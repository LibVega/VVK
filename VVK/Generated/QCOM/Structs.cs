/*
 * MIT License - Copyright(c) 2020 Sean Moss
 * This file is subject to the terms and conditions of the MIT License, the text of which can be found in the 'LICENSE'
 * file at the root of this repository, or online at <https://opensource.org/licenses/MIT>.
 */

/// This file was generated by VVKGen. Edits to this file will be lost on next generation.

using System;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;

namespace Vulkan
{

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkRenderPassTransformBeginInfoQCOM : IEquatable<VkRenderPassTransformBeginInfoQCOM>
{
	public const VkStructureType TYPE = VkStructureType.RenderPassTransformBeginInfoQcom;

	public VkStructureType sType;
	public void* pNext;
	public VkSurfaceTransformFlagsKHR Transform;

	public VkRenderPassTransformBeginInfoQCOM(
		VkSurfaceTransformFlagsKHR transform = default
	) {
		sType = TYPE;
		pNext = null;
		Transform = transform;
	}

	public readonly override bool Equals(object? o) => (o is VkRenderPassTransformBeginInfoQCOM s) && (this == s);
	readonly bool IEquatable<VkRenderPassTransformBeginInfoQCOM>.Equals(VkRenderPassTransformBeginInfoQCOM o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Transform.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkRenderPassTransformBeginInfoQCOM l, in VkRenderPassTransformBeginInfoQCOM r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Transform == r.Transform)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkRenderPassTransformBeginInfoQCOM l, in VkRenderPassTransformBeginInfoQCOM r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Transform != r.Transform)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkRenderPassTransformBeginInfoQCOM s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkCopyCommandTransformInfoQCOM : IEquatable<VkCopyCommandTransformInfoQCOM>
{
	public const VkStructureType TYPE = VkStructureType.CopyCommandTransformInfoQcom;

	public VkStructureType sType;
	public void* pNext;
	public VkSurfaceTransformFlagsKHR Transform;

	public VkCopyCommandTransformInfoQCOM(
		VkSurfaceTransformFlagsKHR transform = default
	) {
		sType = TYPE;
		pNext = null;
		Transform = transform;
	}

	public readonly override bool Equals(object? o) => (o is VkCopyCommandTransformInfoQCOM s) && (this == s);
	readonly bool IEquatable<VkCopyCommandTransformInfoQCOM>.Equals(VkCopyCommandTransformInfoQCOM o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Transform.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkCopyCommandTransformInfoQCOM l, in VkCopyCommandTransformInfoQCOM r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Transform == r.Transform)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkCopyCommandTransformInfoQCOM l, in VkCopyCommandTransformInfoQCOM r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Transform != r.Transform)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkCopyCommandTransformInfoQCOM s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkCommandBufferInheritanceRenderPassTransformInfoQCOM : IEquatable<VkCommandBufferInheritanceRenderPassTransformInfoQCOM>
{
	public const VkStructureType TYPE = VkStructureType.CommandBufferInheritanceRenderPassTransformInfoQcom;

	public VkStructureType sType;
	public void* pNext;
	public VkSurfaceTransformFlagsKHR Transform;
	public VkRect2D RenderArea;

	public VkCommandBufferInheritanceRenderPassTransformInfoQCOM(
		VkSurfaceTransformFlagsKHR transform = default,
		VkRect2D renderArea = default
	) {
		sType = TYPE;
		pNext = null;
		Transform = transform;
		RenderArea = renderArea;
	}

	public readonly override bool Equals(object? o) => (o is VkCommandBufferInheritanceRenderPassTransformInfoQCOM s) && (this == s);
	readonly bool IEquatable<VkCommandBufferInheritanceRenderPassTransformInfoQCOM>.Equals(VkCommandBufferInheritanceRenderPassTransformInfoQCOM o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Transform.GetHashCode() ^ RenderArea.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkCommandBufferInheritanceRenderPassTransformInfoQCOM l, in VkCommandBufferInheritanceRenderPassTransformInfoQCOM r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Transform == r.Transform) && (l.RenderArea == r.RenderArea)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkCommandBufferInheritanceRenderPassTransformInfoQCOM l, in VkCommandBufferInheritanceRenderPassTransformInfoQCOM r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Transform != r.Transform) || (l.RenderArea != r.RenderArea)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkCommandBufferInheritanceRenderPassTransformInfoQCOM s) => s = new() { sType = TYPE };
}


} // namespace Vulkan

