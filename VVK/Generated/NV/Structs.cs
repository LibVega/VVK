/*
 * MIT License - Copyright(c) 2020 Sean Moss
 * This file is subject to the terms and conditions of the MIT License, the text of which can be found in the 'LICENSE'
 * file at the root of this repository, or online at <https://opensource.org/licenses/MIT>.
 */

/// This file was generated by VVKGen. Edits to this file will be lost on next generation.

using System;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;

namespace Vulkan
{

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDedicatedAllocationImageCreateInfoNV : IEquatable<VkDedicatedAllocationImageCreateInfoNV>
{
	public const VkStructureType TYPE = VkStructureType.DedicatedAllocationImageCreateInfoNv;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 DedicatedAllocation;

	public VkDedicatedAllocationImageCreateInfoNV(
		VkBool32 dedicatedAllocation = default
	) {
		sType = TYPE;
		pNext = null;
		DedicatedAllocation = dedicatedAllocation;
	}

	public readonly override bool Equals(object? o) => (o is VkDedicatedAllocationImageCreateInfoNV s) && (this == s);
	readonly bool IEquatable<VkDedicatedAllocationImageCreateInfoNV>.Equals(VkDedicatedAllocationImageCreateInfoNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DedicatedAllocation.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDedicatedAllocationImageCreateInfoNV l, in VkDedicatedAllocationImageCreateInfoNV r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DedicatedAllocation == r.DedicatedAllocation)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDedicatedAllocationImageCreateInfoNV l, in VkDedicatedAllocationImageCreateInfoNV r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DedicatedAllocation != r.DedicatedAllocation)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDedicatedAllocationImageCreateInfoNV s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDedicatedAllocationBufferCreateInfoNV : IEquatable<VkDedicatedAllocationBufferCreateInfoNV>
{
	public const VkStructureType TYPE = VkStructureType.DedicatedAllocationBufferCreateInfoNv;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 DedicatedAllocation;

	public VkDedicatedAllocationBufferCreateInfoNV(
		VkBool32 dedicatedAllocation = default
	) {
		sType = TYPE;
		pNext = null;
		DedicatedAllocation = dedicatedAllocation;
	}

	public readonly override bool Equals(object? o) => (o is VkDedicatedAllocationBufferCreateInfoNV s) && (this == s);
	readonly bool IEquatable<VkDedicatedAllocationBufferCreateInfoNV>.Equals(VkDedicatedAllocationBufferCreateInfoNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DedicatedAllocation.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDedicatedAllocationBufferCreateInfoNV l, in VkDedicatedAllocationBufferCreateInfoNV r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DedicatedAllocation == r.DedicatedAllocation)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDedicatedAllocationBufferCreateInfoNV l, in VkDedicatedAllocationBufferCreateInfoNV r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DedicatedAllocation != r.DedicatedAllocation)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDedicatedAllocationBufferCreateInfoNV s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDedicatedAllocationMemoryAllocateInfoNV : IEquatable<VkDedicatedAllocationMemoryAllocateInfoNV>
{
	public const VkStructureType TYPE = VkStructureType.DedicatedAllocationMemoryAllocateInfoNv;

	public VkStructureType sType;
	public void* pNext;
	public VulkanHandle<VkImage> Image;
	public VulkanHandle<VkBuffer> Buffer;

	public VkDedicatedAllocationMemoryAllocateInfoNV(
		VulkanHandle<VkImage> image = default,
		VulkanHandle<VkBuffer> buffer = default
	) {
		sType = TYPE;
		pNext = null;
		Image = image;
		Buffer = buffer;
	}

	public readonly override bool Equals(object? o) => (o is VkDedicatedAllocationMemoryAllocateInfoNV s) && (this == s);
	readonly bool IEquatable<VkDedicatedAllocationMemoryAllocateInfoNV>.Equals(VkDedicatedAllocationMemoryAllocateInfoNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Image.GetHashCode() ^ Buffer.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDedicatedAllocationMemoryAllocateInfoNV l, in VkDedicatedAllocationMemoryAllocateInfoNV r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Image == r.Image) && (l.Buffer == r.Buffer)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDedicatedAllocationMemoryAllocateInfoNV l, in VkDedicatedAllocationMemoryAllocateInfoNV r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Image != r.Image) || (l.Buffer != r.Buffer)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDedicatedAllocationMemoryAllocateInfoNV s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkExternalImageFormatPropertiesNV : IEquatable<VkExternalImageFormatPropertiesNV>
{
	public VkImageFormatProperties ImageFormatProperties;
	public VkExternalMemoryFeatureFlagsNV ExternalMemoryFeatures;
	public VkExternalMemoryHandleTypeFlagsNV ExportFromImportedHandleTypes;
	public VkExternalMemoryHandleTypeFlagsNV CompatibleHandleTypes;

	public VkExternalImageFormatPropertiesNV(
		VkImageFormatProperties imageFormatProperties = default,
		VkExternalMemoryFeatureFlagsNV externalMemoryFeatures = default,
		VkExternalMemoryHandleTypeFlagsNV exportFromImportedHandleTypes = default,
		VkExternalMemoryHandleTypeFlagsNV compatibleHandleTypes = default
	) {
		ImageFormatProperties = imageFormatProperties;
		ExternalMemoryFeatures = externalMemoryFeatures;
		ExportFromImportedHandleTypes = exportFromImportedHandleTypes;
		CompatibleHandleTypes = compatibleHandleTypes;
	}

	public readonly override bool Equals(object? o) => (o is VkExternalImageFormatPropertiesNV s) && (this == s);
	readonly bool IEquatable<VkExternalImageFormatPropertiesNV>.Equals(VkExternalImageFormatPropertiesNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			ImageFormatProperties.GetHashCode() ^ ExternalMemoryFeatures.GetHashCode() ^ ExportFromImportedHandleTypes.GetHashCode() ^ CompatibleHandleTypes.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkExternalImageFormatPropertiesNV l, in VkExternalImageFormatPropertiesNV r)
	{
		return
			(l.ImageFormatProperties == r.ImageFormatProperties) && (l.ExternalMemoryFeatures == r.ExternalMemoryFeatures) && (l.ExportFromImportedHandleTypes == r.ExportFromImportedHandleTypes) && (l.CompatibleHandleTypes == r.CompatibleHandleTypes)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkExternalImageFormatPropertiesNV l, in VkExternalImageFormatPropertiesNV r)
	{
		return
			(l.ImageFormatProperties != r.ImageFormatProperties) || (l.ExternalMemoryFeatures != r.ExternalMemoryFeatures) || (l.ExportFromImportedHandleTypes != r.ExportFromImportedHandleTypes) || (l.CompatibleHandleTypes != r.CompatibleHandleTypes)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkExternalImageFormatPropertiesNV s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkExternalMemoryImageCreateInfoNV : IEquatable<VkExternalMemoryImageCreateInfoNV>
{
	public const VkStructureType TYPE = VkStructureType.ExternalMemoryImageCreateInfoNv;

	public VkStructureType sType;
	public void* pNext;
	public VkExternalMemoryHandleTypeFlagsNV HandleTypes;

	public VkExternalMemoryImageCreateInfoNV(
		VkExternalMemoryHandleTypeFlagsNV handleTypes = default
	) {
		sType = TYPE;
		pNext = null;
		HandleTypes = handleTypes;
	}

	public readonly override bool Equals(object? o) => (o is VkExternalMemoryImageCreateInfoNV s) && (this == s);
	readonly bool IEquatable<VkExternalMemoryImageCreateInfoNV>.Equals(VkExternalMemoryImageCreateInfoNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ HandleTypes.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkExternalMemoryImageCreateInfoNV l, in VkExternalMemoryImageCreateInfoNV r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.HandleTypes == r.HandleTypes)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkExternalMemoryImageCreateInfoNV l, in VkExternalMemoryImageCreateInfoNV r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.HandleTypes != r.HandleTypes)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkExternalMemoryImageCreateInfoNV s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkExportMemoryAllocateInfoNV : IEquatable<VkExportMemoryAllocateInfoNV>
{
	public const VkStructureType TYPE = VkStructureType.ExportMemoryAllocateInfoNv;

	public VkStructureType sType;
	public void* pNext;
	public VkExternalMemoryHandleTypeFlagsNV HandleTypes;

	public VkExportMemoryAllocateInfoNV(
		VkExternalMemoryHandleTypeFlagsNV handleTypes = default
	) {
		sType = TYPE;
		pNext = null;
		HandleTypes = handleTypes;
	}

	public readonly override bool Equals(object? o) => (o is VkExportMemoryAllocateInfoNV s) && (this == s);
	readonly bool IEquatable<VkExportMemoryAllocateInfoNV>.Equals(VkExportMemoryAllocateInfoNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ HandleTypes.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkExportMemoryAllocateInfoNV l, in VkExportMemoryAllocateInfoNV r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.HandleTypes == r.HandleTypes)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkExportMemoryAllocateInfoNV l, in VkExportMemoryAllocateInfoNV r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.HandleTypes != r.HandleTypes)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkExportMemoryAllocateInfoNV s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkImportMemoryWin32HandleInfoNV : IEquatable<VkImportMemoryWin32HandleInfoNV>
{
	public const VkStructureType TYPE = VkStructureType.ImportMemoryWin32HandleInfoNv;

	public VkStructureType sType;
	public void* pNext;
	public VkExternalMemoryHandleTypeFlagsNV HandleType;
	public void* Handle;

	public VkImportMemoryWin32HandleInfoNV(
		VkExternalMemoryHandleTypeFlagsNV handleType = default,
		void* handle = default
	) {
		sType = TYPE;
		pNext = null;
		HandleType = handleType;
		Handle = handle;
	}

	public readonly override bool Equals(object? o) => (o is VkImportMemoryWin32HandleInfoNV s) && (this == s);
	readonly bool IEquatable<VkImportMemoryWin32HandleInfoNV>.Equals(VkImportMemoryWin32HandleInfoNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ HandleType.GetHashCode() ^ ((ulong)Handle).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkImportMemoryWin32HandleInfoNV l, in VkImportMemoryWin32HandleInfoNV r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.HandleType == r.HandleType) && (l.Handle == r.Handle)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkImportMemoryWin32HandleInfoNV l, in VkImportMemoryWin32HandleInfoNV r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.HandleType != r.HandleType) || (l.Handle != r.Handle)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkImportMemoryWin32HandleInfoNV s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkExportMemoryWin32HandleInfoNV : IEquatable<VkExportMemoryWin32HandleInfoNV>
{
	public const VkStructureType TYPE = VkStructureType.ExportMemoryWin32HandleInfoNv;

	public VkStructureType sType;
	public void* pNext;
	public void* Attributes;
	public uint DwAccess;

	public VkExportMemoryWin32HandleInfoNV(
		void* attributes = default,
		uint dwAccess = default
	) {
		sType = TYPE;
		pNext = null;
		Attributes = attributes;
		DwAccess = dwAccess;
	}

	public readonly override bool Equals(object? o) => (o is VkExportMemoryWin32HandleInfoNV s) && (this == s);
	readonly bool IEquatable<VkExportMemoryWin32HandleInfoNV>.Equals(VkExportMemoryWin32HandleInfoNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ((ulong)Attributes).GetHashCode() ^ DwAccess.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkExportMemoryWin32HandleInfoNV l, in VkExportMemoryWin32HandleInfoNV r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Attributes == r.Attributes) && (l.DwAccess == r.DwAccess)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkExportMemoryWin32HandleInfoNV l, in VkExportMemoryWin32HandleInfoNV r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Attributes != r.Attributes) || (l.DwAccess != r.DwAccess)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkExportMemoryWin32HandleInfoNV s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkWin32KeyedMutexAcquireReleaseInfoNV : IEquatable<VkWin32KeyedMutexAcquireReleaseInfoNV>
{
	public const VkStructureType TYPE = VkStructureType.Win32KeyedMutexAcquireReleaseInfoNv;

	public VkStructureType sType;
	public void* pNext;
	public uint AcquireCount;
	public VulkanHandle<VkDeviceMemory>* AcquireSyncs;
	public ulong* AcquireKeys;
	public uint* AcquireTimeoutMilliseconds;
	public uint ReleaseCount;
	public VulkanHandle<VkDeviceMemory>* ReleaseSyncs;
	public ulong* ReleaseKeys;

	public VkWin32KeyedMutexAcquireReleaseInfoNV(
		uint acquireCount = default,
		VulkanHandle<VkDeviceMemory>* acquireSyncs = default,
		ulong* acquireKeys = default,
		uint* acquireTimeoutMilliseconds = default,
		uint releaseCount = default,
		VulkanHandle<VkDeviceMemory>* releaseSyncs = default,
		ulong* releaseKeys = default
	) {
		sType = TYPE;
		pNext = null;
		AcquireCount = acquireCount;
		AcquireSyncs = acquireSyncs;
		AcquireKeys = acquireKeys;
		AcquireTimeoutMilliseconds = acquireTimeoutMilliseconds;
		ReleaseCount = releaseCount;
		ReleaseSyncs = releaseSyncs;
		ReleaseKeys = releaseKeys;
	}

	public readonly override bool Equals(object? o) => (o is VkWin32KeyedMutexAcquireReleaseInfoNV s) && (this == s);
	readonly bool IEquatable<VkWin32KeyedMutexAcquireReleaseInfoNV>.Equals(VkWin32KeyedMutexAcquireReleaseInfoNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ AcquireCount.GetHashCode() ^ ((ulong)AcquireSyncs).GetHashCode()
			^ ((ulong)AcquireKeys).GetHashCode() ^ ((ulong)AcquireTimeoutMilliseconds).GetHashCode() ^ ReleaseCount.GetHashCode() ^ ((ulong)ReleaseSyncs).GetHashCode()
			^ ((ulong)ReleaseKeys).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkWin32KeyedMutexAcquireReleaseInfoNV l, in VkWin32KeyedMutexAcquireReleaseInfoNV r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.AcquireCount == r.AcquireCount) && (l.AcquireSyncs == r.AcquireSyncs)
			&& (l.AcquireKeys == r.AcquireKeys) && (l.AcquireTimeoutMilliseconds == r.AcquireTimeoutMilliseconds) && (l.ReleaseCount == r.ReleaseCount) && (l.ReleaseSyncs == r.ReleaseSyncs)
			&& (l.ReleaseKeys == r.ReleaseKeys)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkWin32KeyedMutexAcquireReleaseInfoNV l, in VkWin32KeyedMutexAcquireReleaseInfoNV r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.AcquireCount != r.AcquireCount) || (l.AcquireSyncs != r.AcquireSyncs)
			|| (l.AcquireKeys != r.AcquireKeys) || (l.AcquireTimeoutMilliseconds != r.AcquireTimeoutMilliseconds) || (l.ReleaseCount != r.ReleaseCount) || (l.ReleaseSyncs != r.ReleaseSyncs)
			|| (l.ReleaseKeys != r.ReleaseKeys)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkWin32KeyedMutexAcquireReleaseInfoNV s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV : IEquatable<VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceDeviceGeneratedCommandsFeaturesNv;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 DeviceGeneratedCommands;

	public VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV(
		VkBool32 deviceGeneratedCommands = default
	) {
		sType = TYPE;
		pNext = null;
		DeviceGeneratedCommands = deviceGeneratedCommands;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV>.Equals(VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DeviceGeneratedCommands.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV l, in VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DeviceGeneratedCommands == r.DeviceGeneratedCommands)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV l, in VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DeviceGeneratedCommands != r.DeviceGeneratedCommands)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV : IEquatable<VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceDeviceGeneratedCommandsPropertiesNv;

	public VkStructureType sType;
	public void* pNext;
	public uint MaxGraphicsShaderGroupCount;
	public uint MaxIndirectSequenceCount;
	public uint MaxIndirectCommandsTokenCount;
	public uint MaxIndirectCommandsStreamCount;
	public uint MaxIndirectCommandsTokenOffset;
	public uint MaxIndirectCommandsStreamStride;
	public uint MinSequencesCountBufferOffsetAlignment;
	public uint MinSequencesIndexBufferOffsetAlignment;
	public uint MinIndirectCommandsBufferOffsetAlignment;

	public VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV(
		uint maxGraphicsShaderGroupCount = default,
		uint maxIndirectSequenceCount = default,
		uint maxIndirectCommandsTokenCount = default,
		uint maxIndirectCommandsStreamCount = default,
		uint maxIndirectCommandsTokenOffset = default,
		uint maxIndirectCommandsStreamStride = default,
		uint minSequencesCountBufferOffsetAlignment = default,
		uint minSequencesIndexBufferOffsetAlignment = default,
		uint minIndirectCommandsBufferOffsetAlignment = default
	) {
		sType = TYPE;
		pNext = null;
		MaxGraphicsShaderGroupCount = maxGraphicsShaderGroupCount;
		MaxIndirectSequenceCount = maxIndirectSequenceCount;
		MaxIndirectCommandsTokenCount = maxIndirectCommandsTokenCount;
		MaxIndirectCommandsStreamCount = maxIndirectCommandsStreamCount;
		MaxIndirectCommandsTokenOffset = maxIndirectCommandsTokenOffset;
		MaxIndirectCommandsStreamStride = maxIndirectCommandsStreamStride;
		MinSequencesCountBufferOffsetAlignment = minSequencesCountBufferOffsetAlignment;
		MinSequencesIndexBufferOffsetAlignment = minSequencesIndexBufferOffsetAlignment;
		MinIndirectCommandsBufferOffsetAlignment = minIndirectCommandsBufferOffsetAlignment;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV>.Equals(VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MaxGraphicsShaderGroupCount.GetHashCode() ^ MaxIndirectSequenceCount.GetHashCode()
			^ MaxIndirectCommandsTokenCount.GetHashCode() ^ MaxIndirectCommandsStreamCount.GetHashCode() ^ MaxIndirectCommandsTokenOffset.GetHashCode() ^ MaxIndirectCommandsStreamStride.GetHashCode()
			^ MinSequencesCountBufferOffsetAlignment.GetHashCode() ^ MinSequencesIndexBufferOffsetAlignment.GetHashCode() ^ MinIndirectCommandsBufferOffsetAlignment.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV l, in VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MaxGraphicsShaderGroupCount == r.MaxGraphicsShaderGroupCount) && (l.MaxIndirectSequenceCount == r.MaxIndirectSequenceCount)
			&& (l.MaxIndirectCommandsTokenCount == r.MaxIndirectCommandsTokenCount) && (l.MaxIndirectCommandsStreamCount == r.MaxIndirectCommandsStreamCount) && (l.MaxIndirectCommandsTokenOffset == r.MaxIndirectCommandsTokenOffset) && (l.MaxIndirectCommandsStreamStride == r.MaxIndirectCommandsStreamStride)
			&& (l.MinSequencesCountBufferOffsetAlignment == r.MinSequencesCountBufferOffsetAlignment) && (l.MinSequencesIndexBufferOffsetAlignment == r.MinSequencesIndexBufferOffsetAlignment) && (l.MinIndirectCommandsBufferOffsetAlignment == r.MinIndirectCommandsBufferOffsetAlignment)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV l, in VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MaxGraphicsShaderGroupCount != r.MaxGraphicsShaderGroupCount) || (l.MaxIndirectSequenceCount != r.MaxIndirectSequenceCount)
			|| (l.MaxIndirectCommandsTokenCount != r.MaxIndirectCommandsTokenCount) || (l.MaxIndirectCommandsStreamCount != r.MaxIndirectCommandsStreamCount) || (l.MaxIndirectCommandsTokenOffset != r.MaxIndirectCommandsTokenOffset) || (l.MaxIndirectCommandsStreamStride != r.MaxIndirectCommandsStreamStride)
			|| (l.MinSequencesCountBufferOffsetAlignment != r.MinSequencesCountBufferOffsetAlignment) || (l.MinSequencesIndexBufferOffsetAlignment != r.MinSequencesIndexBufferOffsetAlignment) || (l.MinIndirectCommandsBufferOffsetAlignment != r.MinIndirectCommandsBufferOffsetAlignment)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkGraphicsShaderGroupCreateInfoNV : IEquatable<VkGraphicsShaderGroupCreateInfoNV>
{
	public const VkStructureType TYPE = VkStructureType.GraphicsShaderGroupCreateInfoNv;

	public VkStructureType sType;
	public void* pNext;
	public uint StageCount;
	public VkPipelineShaderStageCreateInfo* Stages;
	public VkPipelineVertexInputStateCreateInfo* VertexInputState;
	public VkPipelineTessellationStateCreateInfo* TessellationState;

	public VkGraphicsShaderGroupCreateInfoNV(
		uint stageCount = default,
		VkPipelineShaderStageCreateInfo* stages = default,
		VkPipelineVertexInputStateCreateInfo* vertexInputState = default,
		VkPipelineTessellationStateCreateInfo* tessellationState = default
	) {
		sType = TYPE;
		pNext = null;
		StageCount = stageCount;
		Stages = stages;
		VertexInputState = vertexInputState;
		TessellationState = tessellationState;
	}

	public readonly override bool Equals(object? o) => (o is VkGraphicsShaderGroupCreateInfoNV s) && (this == s);
	readonly bool IEquatable<VkGraphicsShaderGroupCreateInfoNV>.Equals(VkGraphicsShaderGroupCreateInfoNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ StageCount.GetHashCode() ^ ((ulong)Stages).GetHashCode()
			^ ((ulong)VertexInputState).GetHashCode() ^ ((ulong)TessellationState).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkGraphicsShaderGroupCreateInfoNV l, in VkGraphicsShaderGroupCreateInfoNV r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.StageCount == r.StageCount) && (l.Stages == r.Stages)
			&& (l.VertexInputState == r.VertexInputState) && (l.TessellationState == r.TessellationState)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkGraphicsShaderGroupCreateInfoNV l, in VkGraphicsShaderGroupCreateInfoNV r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.StageCount != r.StageCount) || (l.Stages != r.Stages)
			|| (l.VertexInputState != r.VertexInputState) || (l.TessellationState != r.TessellationState)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkGraphicsShaderGroupCreateInfoNV s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkGraphicsPipelineShaderGroupsCreateInfoNV : IEquatable<VkGraphicsPipelineShaderGroupsCreateInfoNV>
{
	public const VkStructureType TYPE = VkStructureType.GraphicsPipelineShaderGroupsCreateInfoNv;

	public VkStructureType sType;
	public void* pNext;
	public uint GroupCount;
	public VkGraphicsShaderGroupCreateInfoNV* Groups;
	public uint PipelineCount;
	public VulkanHandle<VkPipeline>* Pipelines;

	public VkGraphicsPipelineShaderGroupsCreateInfoNV(
		uint groupCount = default,
		VkGraphicsShaderGroupCreateInfoNV* groups = default,
		uint pipelineCount = default,
		VulkanHandle<VkPipeline>* pipelines = default
	) {
		sType = TYPE;
		pNext = null;
		GroupCount = groupCount;
		Groups = groups;
		PipelineCount = pipelineCount;
		Pipelines = pipelines;
	}

	public readonly override bool Equals(object? o) => (o is VkGraphicsPipelineShaderGroupsCreateInfoNV s) && (this == s);
	readonly bool IEquatable<VkGraphicsPipelineShaderGroupsCreateInfoNV>.Equals(VkGraphicsPipelineShaderGroupsCreateInfoNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ GroupCount.GetHashCode() ^ ((ulong)Groups).GetHashCode()
			^ PipelineCount.GetHashCode() ^ ((ulong)Pipelines).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkGraphicsPipelineShaderGroupsCreateInfoNV l, in VkGraphicsPipelineShaderGroupsCreateInfoNV r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.GroupCount == r.GroupCount) && (l.Groups == r.Groups)
			&& (l.PipelineCount == r.PipelineCount) && (l.Pipelines == r.Pipelines)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkGraphicsPipelineShaderGroupsCreateInfoNV l, in VkGraphicsPipelineShaderGroupsCreateInfoNV r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.GroupCount != r.GroupCount) || (l.Groups != r.Groups)
			|| (l.PipelineCount != r.PipelineCount) || (l.Pipelines != r.Pipelines)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkGraphicsPipelineShaderGroupsCreateInfoNV s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkBindShaderGroupIndirectCommandNV : IEquatable<VkBindShaderGroupIndirectCommandNV>
{
	public uint GroupIndex;

	public VkBindShaderGroupIndirectCommandNV(
		uint groupIndex = default
	) {
		GroupIndex = groupIndex;
	}

	public readonly override bool Equals(object? o) => (o is VkBindShaderGroupIndirectCommandNV s) && (this == s);
	readonly bool IEquatable<VkBindShaderGroupIndirectCommandNV>.Equals(VkBindShaderGroupIndirectCommandNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			GroupIndex.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkBindShaderGroupIndirectCommandNV l, in VkBindShaderGroupIndirectCommandNV r)
	{
		return
			(l.GroupIndex == r.GroupIndex)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkBindShaderGroupIndirectCommandNV l, in VkBindShaderGroupIndirectCommandNV r)
	{
		return
			(l.GroupIndex != r.GroupIndex)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkBindShaderGroupIndirectCommandNV s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkBindIndexBufferIndirectCommandNV : IEquatable<VkBindIndexBufferIndirectCommandNV>
{
	public ulong BufferAddress;
	public uint Size;
	public VkIndexType IndexType;

	public VkBindIndexBufferIndirectCommandNV(
		ulong bufferAddress = default,
		uint size = default,
		VkIndexType indexType = default
	) {
		BufferAddress = bufferAddress;
		Size = size;
		IndexType = indexType;
	}

	public readonly override bool Equals(object? o) => (o is VkBindIndexBufferIndirectCommandNV s) && (this == s);
	readonly bool IEquatable<VkBindIndexBufferIndirectCommandNV>.Equals(VkBindIndexBufferIndirectCommandNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			BufferAddress.GetHashCode() ^ Size.GetHashCode() ^ IndexType.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkBindIndexBufferIndirectCommandNV l, in VkBindIndexBufferIndirectCommandNV r)
	{
		return
			(l.BufferAddress == r.BufferAddress) && (l.Size == r.Size) && (l.IndexType == r.IndexType)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkBindIndexBufferIndirectCommandNV l, in VkBindIndexBufferIndirectCommandNV r)
	{
		return
			(l.BufferAddress != r.BufferAddress) || (l.Size != r.Size) || (l.IndexType != r.IndexType)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkBindIndexBufferIndirectCommandNV s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkBindVertexBufferIndirectCommandNV : IEquatable<VkBindVertexBufferIndirectCommandNV>
{
	public ulong BufferAddress;
	public uint Size;
	public uint Stride;

	public VkBindVertexBufferIndirectCommandNV(
		ulong bufferAddress = default,
		uint size = default,
		uint stride = default
	) {
		BufferAddress = bufferAddress;
		Size = size;
		Stride = stride;
	}

	public readonly override bool Equals(object? o) => (o is VkBindVertexBufferIndirectCommandNV s) && (this == s);
	readonly bool IEquatable<VkBindVertexBufferIndirectCommandNV>.Equals(VkBindVertexBufferIndirectCommandNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			BufferAddress.GetHashCode() ^ Size.GetHashCode() ^ Stride.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkBindVertexBufferIndirectCommandNV l, in VkBindVertexBufferIndirectCommandNV r)
	{
		return
			(l.BufferAddress == r.BufferAddress) && (l.Size == r.Size) && (l.Stride == r.Stride)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkBindVertexBufferIndirectCommandNV l, in VkBindVertexBufferIndirectCommandNV r)
	{
		return
			(l.BufferAddress != r.BufferAddress) || (l.Size != r.Size) || (l.Stride != r.Stride)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkBindVertexBufferIndirectCommandNV s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkSetStateFlagsIndirectCommandNV : IEquatable<VkSetStateFlagsIndirectCommandNV>
{
	public uint Data;

	public VkSetStateFlagsIndirectCommandNV(
		uint data = default
	) {
		Data = data;
	}

	public readonly override bool Equals(object? o) => (o is VkSetStateFlagsIndirectCommandNV s) && (this == s);
	readonly bool IEquatable<VkSetStateFlagsIndirectCommandNV>.Equals(VkSetStateFlagsIndirectCommandNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Data.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkSetStateFlagsIndirectCommandNV l, in VkSetStateFlagsIndirectCommandNV r)
	{
		return
			(l.Data == r.Data)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkSetStateFlagsIndirectCommandNV l, in VkSetStateFlagsIndirectCommandNV r)
	{
		return
			(l.Data != r.Data)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkSetStateFlagsIndirectCommandNV s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkIndirectCommandsStreamNV : IEquatable<VkIndirectCommandsStreamNV>
{
	public VulkanHandle<VkBuffer> Buffer;
	public ulong Offset;

	public VkIndirectCommandsStreamNV(
		VulkanHandle<VkBuffer> buffer = default,
		ulong offset = default
	) {
		Buffer = buffer;
		Offset = offset;
	}

	public readonly override bool Equals(object? o) => (o is VkIndirectCommandsStreamNV s) && (this == s);
	readonly bool IEquatable<VkIndirectCommandsStreamNV>.Equals(VkIndirectCommandsStreamNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Buffer.GetHashCode() ^ Offset.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkIndirectCommandsStreamNV l, in VkIndirectCommandsStreamNV r)
	{
		return
			(l.Buffer == r.Buffer) && (l.Offset == r.Offset)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkIndirectCommandsStreamNV l, in VkIndirectCommandsStreamNV r)
	{
		return
			(l.Buffer != r.Buffer) || (l.Offset != r.Offset)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkIndirectCommandsStreamNV s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkIndirectCommandsLayoutTokenNV : IEquatable<VkIndirectCommandsLayoutTokenNV>
{
	public const VkStructureType TYPE = VkStructureType.IndirectCommandsLayoutTokenNv;

	public VkStructureType sType;
	public void* pNext;
	public VkIndirectCommandsTokenTypeNV TokenType;
	public uint Stream;
	public uint Offset;
	public uint VertexBindingUnit;
	public VkBool32 VertexDynamicStride;
	public VulkanHandle<VkPipelineLayout> PushconstantPipelineLayout;
	public VkShaderStageFlags PushconstantShaderStageFlags;
	public uint PushconstantOffset;
	public uint PushconstantSize;
	public VkIndirectStateFlagsNV IndirectStateFlags;
	public uint IndexTypeCount;
	public VkIndexType* IndexTypes;
	public uint* IndexTypeValues;

	public VkIndirectCommandsLayoutTokenNV(
		VkIndirectCommandsTokenTypeNV tokenType = default,
		uint stream = default,
		uint offset = default,
		uint vertexBindingUnit = default,
		VkBool32 vertexDynamicStride = default,
		VulkanHandle<VkPipelineLayout> pushconstantPipelineLayout = default,
		VkShaderStageFlags pushconstantShaderStageFlags = default,
		uint pushconstantOffset = default,
		uint pushconstantSize = default,
		VkIndirectStateFlagsNV indirectStateFlags = default,
		uint indexTypeCount = default,
		VkIndexType* indexTypes = default,
		uint* indexTypeValues = default
	) {
		sType = TYPE;
		pNext = null;
		TokenType = tokenType;
		Stream = stream;
		Offset = offset;
		VertexBindingUnit = vertexBindingUnit;
		VertexDynamicStride = vertexDynamicStride;
		PushconstantPipelineLayout = pushconstantPipelineLayout;
		PushconstantShaderStageFlags = pushconstantShaderStageFlags;
		PushconstantOffset = pushconstantOffset;
		PushconstantSize = pushconstantSize;
		IndirectStateFlags = indirectStateFlags;
		IndexTypeCount = indexTypeCount;
		IndexTypes = indexTypes;
		IndexTypeValues = indexTypeValues;
	}

	public readonly override bool Equals(object? o) => (o is VkIndirectCommandsLayoutTokenNV s) && (this == s);
	readonly bool IEquatable<VkIndirectCommandsLayoutTokenNV>.Equals(VkIndirectCommandsLayoutTokenNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ TokenType.GetHashCode() ^ Stream.GetHashCode()
			^ Offset.GetHashCode() ^ VertexBindingUnit.GetHashCode() ^ VertexDynamicStride.GetHashCode() ^ PushconstantPipelineLayout.GetHashCode()
			^ PushconstantShaderStageFlags.GetHashCode() ^ PushconstantOffset.GetHashCode() ^ PushconstantSize.GetHashCode() ^ IndirectStateFlags.GetHashCode()
			^ IndexTypeCount.GetHashCode() ^ ((ulong)IndexTypes).GetHashCode() ^ ((ulong)IndexTypeValues).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkIndirectCommandsLayoutTokenNV l, in VkIndirectCommandsLayoutTokenNV r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.TokenType == r.TokenType) && (l.Stream == r.Stream)
			&& (l.Offset == r.Offset) && (l.VertexBindingUnit == r.VertexBindingUnit) && (l.VertexDynamicStride == r.VertexDynamicStride) && (l.PushconstantPipelineLayout == r.PushconstantPipelineLayout)
			&& (l.PushconstantShaderStageFlags == r.PushconstantShaderStageFlags) && (l.PushconstantOffset == r.PushconstantOffset) && (l.PushconstantSize == r.PushconstantSize) && (l.IndirectStateFlags == r.IndirectStateFlags)
			&& (l.IndexTypeCount == r.IndexTypeCount) && (l.IndexTypes == r.IndexTypes) && (l.IndexTypeValues == r.IndexTypeValues)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkIndirectCommandsLayoutTokenNV l, in VkIndirectCommandsLayoutTokenNV r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.TokenType != r.TokenType) || (l.Stream != r.Stream)
			|| (l.Offset != r.Offset) || (l.VertexBindingUnit != r.VertexBindingUnit) || (l.VertexDynamicStride != r.VertexDynamicStride) || (l.PushconstantPipelineLayout != r.PushconstantPipelineLayout)
			|| (l.PushconstantShaderStageFlags != r.PushconstantShaderStageFlags) || (l.PushconstantOffset != r.PushconstantOffset) || (l.PushconstantSize != r.PushconstantSize) || (l.IndirectStateFlags != r.IndirectStateFlags)
			|| (l.IndexTypeCount != r.IndexTypeCount) || (l.IndexTypes != r.IndexTypes) || (l.IndexTypeValues != r.IndexTypeValues)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkIndirectCommandsLayoutTokenNV s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkIndirectCommandsLayoutCreateInfoNV : IEquatable<VkIndirectCommandsLayoutCreateInfoNV>
{
	public const VkStructureType TYPE = VkStructureType.IndirectCommandsLayoutCreateInfoNv;

	public VkStructureType sType;
	public void* pNext;
	public VkIndirectCommandsLayoutUsageFlagsNV Flags;
	public VkPipelineBindPoint PipelineBindPoint;
	public uint TokenCount;
	public VkIndirectCommandsLayoutTokenNV* Tokens;
	public uint StreamCount;
	public uint* StreamStrides;

	public VkIndirectCommandsLayoutCreateInfoNV(
		VkIndirectCommandsLayoutUsageFlagsNV flags = default,
		VkPipelineBindPoint pipelineBindPoint = default,
		uint tokenCount = default,
		VkIndirectCommandsLayoutTokenNV* tokens = default,
		uint streamCount = default,
		uint* streamStrides = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		PipelineBindPoint = pipelineBindPoint;
		TokenCount = tokenCount;
		Tokens = tokens;
		StreamCount = streamCount;
		StreamStrides = streamStrides;
	}

	public readonly override bool Equals(object? o) => (o is VkIndirectCommandsLayoutCreateInfoNV s) && (this == s);
	readonly bool IEquatable<VkIndirectCommandsLayoutCreateInfoNV>.Equals(VkIndirectCommandsLayoutCreateInfoNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ PipelineBindPoint.GetHashCode()
			^ TokenCount.GetHashCode() ^ ((ulong)Tokens).GetHashCode() ^ StreamCount.GetHashCode() ^ ((ulong)StreamStrides).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkIndirectCommandsLayoutCreateInfoNV l, in VkIndirectCommandsLayoutCreateInfoNV r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.PipelineBindPoint == r.PipelineBindPoint)
			&& (l.TokenCount == r.TokenCount) && (l.Tokens == r.Tokens) && (l.StreamCount == r.StreamCount) && (l.StreamStrides == r.StreamStrides)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkIndirectCommandsLayoutCreateInfoNV l, in VkIndirectCommandsLayoutCreateInfoNV r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.PipelineBindPoint != r.PipelineBindPoint)
			|| (l.TokenCount != r.TokenCount) || (l.Tokens != r.Tokens) || (l.StreamCount != r.StreamCount) || (l.StreamStrides != r.StreamStrides)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkIndirectCommandsLayoutCreateInfoNV s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkGeneratedCommandsInfoNV : IEquatable<VkGeneratedCommandsInfoNV>
{
	public const VkStructureType TYPE = VkStructureType.GeneratedCommandsInfoNv;

	public VkStructureType sType;
	public void* pNext;
	public VkPipelineBindPoint PipelineBindPoint;
	public VulkanHandle<VkPipeline> Pipeline;
	public VulkanHandle<VkIndirectCommandsLayoutNV> IndirectCommandsLayout;
	public uint StreamCount;
	public VkIndirectCommandsStreamNV* Streams;
	public uint SequencesCount;
	public VulkanHandle<VkBuffer> PreprocessBuffer;
	public ulong PreprocessOffset;
	public ulong PreprocessSize;
	public VulkanHandle<VkBuffer> SequencesCountBuffer;
	public ulong SequencesCountOffset;
	public VulkanHandle<VkBuffer> SequencesIndexBuffer;
	public ulong SequencesIndexOffset;

	public VkGeneratedCommandsInfoNV(
		VkPipelineBindPoint pipelineBindPoint = default,
		VulkanHandle<VkPipeline> pipeline = default,
		VulkanHandle<VkIndirectCommandsLayoutNV> indirectCommandsLayout = default,
		uint streamCount = default,
		VkIndirectCommandsStreamNV* streams = default,
		uint sequencesCount = default,
		VulkanHandle<VkBuffer> preprocessBuffer = default,
		ulong preprocessOffset = default,
		ulong preprocessSize = default,
		VulkanHandle<VkBuffer> sequencesCountBuffer = default,
		ulong sequencesCountOffset = default,
		VulkanHandle<VkBuffer> sequencesIndexBuffer = default,
		ulong sequencesIndexOffset = default
	) {
		sType = TYPE;
		pNext = null;
		PipelineBindPoint = pipelineBindPoint;
		Pipeline = pipeline;
		IndirectCommandsLayout = indirectCommandsLayout;
		StreamCount = streamCount;
		Streams = streams;
		SequencesCount = sequencesCount;
		PreprocessBuffer = preprocessBuffer;
		PreprocessOffset = preprocessOffset;
		PreprocessSize = preprocessSize;
		SequencesCountBuffer = sequencesCountBuffer;
		SequencesCountOffset = sequencesCountOffset;
		SequencesIndexBuffer = sequencesIndexBuffer;
		SequencesIndexOffset = sequencesIndexOffset;
	}

	public readonly override bool Equals(object? o) => (o is VkGeneratedCommandsInfoNV s) && (this == s);
	readonly bool IEquatable<VkGeneratedCommandsInfoNV>.Equals(VkGeneratedCommandsInfoNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ PipelineBindPoint.GetHashCode() ^ Pipeline.GetHashCode()
			^ IndirectCommandsLayout.GetHashCode() ^ StreamCount.GetHashCode() ^ ((ulong)Streams).GetHashCode() ^ SequencesCount.GetHashCode()
			^ PreprocessBuffer.GetHashCode() ^ PreprocessOffset.GetHashCode() ^ PreprocessSize.GetHashCode() ^ SequencesCountBuffer.GetHashCode()
			^ SequencesCountOffset.GetHashCode() ^ SequencesIndexBuffer.GetHashCode() ^ SequencesIndexOffset.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkGeneratedCommandsInfoNV l, in VkGeneratedCommandsInfoNV r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.PipelineBindPoint == r.PipelineBindPoint) && (l.Pipeline == r.Pipeline)
			&& (l.IndirectCommandsLayout == r.IndirectCommandsLayout) && (l.StreamCount == r.StreamCount) && (l.Streams == r.Streams) && (l.SequencesCount == r.SequencesCount)
			&& (l.PreprocessBuffer == r.PreprocessBuffer) && (l.PreprocessOffset == r.PreprocessOffset) && (l.PreprocessSize == r.PreprocessSize) && (l.SequencesCountBuffer == r.SequencesCountBuffer)
			&& (l.SequencesCountOffset == r.SequencesCountOffset) && (l.SequencesIndexBuffer == r.SequencesIndexBuffer) && (l.SequencesIndexOffset == r.SequencesIndexOffset)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkGeneratedCommandsInfoNV l, in VkGeneratedCommandsInfoNV r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.PipelineBindPoint != r.PipelineBindPoint) || (l.Pipeline != r.Pipeline)
			|| (l.IndirectCommandsLayout != r.IndirectCommandsLayout) || (l.StreamCount != r.StreamCount) || (l.Streams != r.Streams) || (l.SequencesCount != r.SequencesCount)
			|| (l.PreprocessBuffer != r.PreprocessBuffer) || (l.PreprocessOffset != r.PreprocessOffset) || (l.PreprocessSize != r.PreprocessSize) || (l.SequencesCountBuffer != r.SequencesCountBuffer)
			|| (l.SequencesCountOffset != r.SequencesCountOffset) || (l.SequencesIndexBuffer != r.SequencesIndexBuffer) || (l.SequencesIndexOffset != r.SequencesIndexOffset)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkGeneratedCommandsInfoNV s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkGeneratedCommandsMemoryRequirementsInfoNV : IEquatable<VkGeneratedCommandsMemoryRequirementsInfoNV>
{
	public const VkStructureType TYPE = VkStructureType.GeneratedCommandsMemoryRequirementsInfoNv;

	public VkStructureType sType;
	public void* pNext;
	public VkPipelineBindPoint PipelineBindPoint;
	public VulkanHandle<VkPipeline> Pipeline;
	public VulkanHandle<VkIndirectCommandsLayoutNV> IndirectCommandsLayout;
	public uint MaxSequencesCount;

	public VkGeneratedCommandsMemoryRequirementsInfoNV(
		VkPipelineBindPoint pipelineBindPoint = default,
		VulkanHandle<VkPipeline> pipeline = default,
		VulkanHandle<VkIndirectCommandsLayoutNV> indirectCommandsLayout = default,
		uint maxSequencesCount = default
	) {
		sType = TYPE;
		pNext = null;
		PipelineBindPoint = pipelineBindPoint;
		Pipeline = pipeline;
		IndirectCommandsLayout = indirectCommandsLayout;
		MaxSequencesCount = maxSequencesCount;
	}

	public readonly override bool Equals(object? o) => (o is VkGeneratedCommandsMemoryRequirementsInfoNV s) && (this == s);
	readonly bool IEquatable<VkGeneratedCommandsMemoryRequirementsInfoNV>.Equals(VkGeneratedCommandsMemoryRequirementsInfoNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ PipelineBindPoint.GetHashCode() ^ Pipeline.GetHashCode()
			^ IndirectCommandsLayout.GetHashCode() ^ MaxSequencesCount.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkGeneratedCommandsMemoryRequirementsInfoNV l, in VkGeneratedCommandsMemoryRequirementsInfoNV r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.PipelineBindPoint == r.PipelineBindPoint) && (l.Pipeline == r.Pipeline)
			&& (l.IndirectCommandsLayout == r.IndirectCommandsLayout) && (l.MaxSequencesCount == r.MaxSequencesCount)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkGeneratedCommandsMemoryRequirementsInfoNV l, in VkGeneratedCommandsMemoryRequirementsInfoNV r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.PipelineBindPoint != r.PipelineBindPoint) || (l.Pipeline != r.Pipeline)
			|| (l.IndirectCommandsLayout != r.IndirectCommandsLayout) || (l.MaxSequencesCount != r.MaxSequencesCount)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkGeneratedCommandsMemoryRequirementsInfoNV s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkViewportWScalingNV : IEquatable<VkViewportWScalingNV>
{
	public float Xcoeff;
	public float Ycoeff;

	public VkViewportWScalingNV(
		float xcoeff = default,
		float ycoeff = default
	) {
		Xcoeff = xcoeff;
		Ycoeff = ycoeff;
	}

	public readonly override bool Equals(object? o) => (o is VkViewportWScalingNV s) && (this == s);
	readonly bool IEquatable<VkViewportWScalingNV>.Equals(VkViewportWScalingNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Xcoeff.GetHashCode() ^ Ycoeff.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkViewportWScalingNV l, in VkViewportWScalingNV r)
	{
		return
			(l.Xcoeff == r.Xcoeff) && (l.Ycoeff == r.Ycoeff)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkViewportWScalingNV l, in VkViewportWScalingNV r)
	{
		return
			(l.Xcoeff != r.Xcoeff) || (l.Ycoeff != r.Ycoeff)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkViewportWScalingNV s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPipelineViewportWScalingStateCreateInfoNV : IEquatable<VkPipelineViewportWScalingStateCreateInfoNV>
{
	public const VkStructureType TYPE = VkStructureType.PipelineViewportWScalingStateCreateInfoNv;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 ViewportWScalingEnable;
	public uint ViewportCount;
	public VkViewportWScalingNV* ViewportWScalings;

	public VkPipelineViewportWScalingStateCreateInfoNV(
		VkBool32 viewportWScalingEnable = default,
		uint viewportCount = default,
		VkViewportWScalingNV* viewportWScalings = default
	) {
		sType = TYPE;
		pNext = null;
		ViewportWScalingEnable = viewportWScalingEnable;
		ViewportCount = viewportCount;
		ViewportWScalings = viewportWScalings;
	}

	public readonly override bool Equals(object? o) => (o is VkPipelineViewportWScalingStateCreateInfoNV s) && (this == s);
	readonly bool IEquatable<VkPipelineViewportWScalingStateCreateInfoNV>.Equals(VkPipelineViewportWScalingStateCreateInfoNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ViewportWScalingEnable.GetHashCode() ^ ViewportCount.GetHashCode()
			^ ((ulong)ViewportWScalings).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPipelineViewportWScalingStateCreateInfoNV l, in VkPipelineViewportWScalingStateCreateInfoNV r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ViewportWScalingEnable == r.ViewportWScalingEnable) && (l.ViewportCount == r.ViewportCount)
			&& (l.ViewportWScalings == r.ViewportWScalings)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPipelineViewportWScalingStateCreateInfoNV l, in VkPipelineViewportWScalingStateCreateInfoNV r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ViewportWScalingEnable != r.ViewportWScalingEnable) || (l.ViewportCount != r.ViewportCount)
			|| (l.ViewportWScalings != r.ViewportWScalings)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPipelineViewportWScalingStateCreateInfoNV s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkViewportSwizzleNV : IEquatable<VkViewportSwizzleNV>
{
	public VkViewportCoordinateSwizzleNV X;
	public VkViewportCoordinateSwizzleNV Y;
	public VkViewportCoordinateSwizzleNV Z;
	public VkViewportCoordinateSwizzleNV W;

	public VkViewportSwizzleNV(
		VkViewportCoordinateSwizzleNV x = default,
		VkViewportCoordinateSwizzleNV y = default,
		VkViewportCoordinateSwizzleNV z = default,
		VkViewportCoordinateSwizzleNV w = default
	) {
		X = x;
		Y = y;
		Z = z;
		W = w;
	}

	public readonly override bool Equals(object? o) => (o is VkViewportSwizzleNV s) && (this == s);
	readonly bool IEquatable<VkViewportSwizzleNV>.Equals(VkViewportSwizzleNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			X.GetHashCode() ^ Y.GetHashCode() ^ Z.GetHashCode() ^ W.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkViewportSwizzleNV l, in VkViewportSwizzleNV r)
	{
		return
			(l.X == r.X) && (l.Y == r.Y) && (l.Z == r.Z) && (l.W == r.W)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkViewportSwizzleNV l, in VkViewportSwizzleNV r)
	{
		return
			(l.X != r.X) || (l.Y != r.Y) || (l.Z != r.Z) || (l.W != r.W)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkViewportSwizzleNV s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPipelineViewportSwizzleStateCreateInfoNV : IEquatable<VkPipelineViewportSwizzleStateCreateInfoNV>
{
	public const VkStructureType TYPE = VkStructureType.PipelineViewportSwizzleStateCreateInfoNv;

	public VkStructureType sType;
	public void* pNext;
	public VkPipelineViewportSwizzleStateCreateFlagsNV Flags;
	public uint ViewportCount;
	public VkViewportSwizzleNV* ViewportSwizzles;

	public VkPipelineViewportSwizzleStateCreateInfoNV(
		VkPipelineViewportSwizzleStateCreateFlagsNV flags = default,
		uint viewportCount = default,
		VkViewportSwizzleNV* viewportSwizzles = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		ViewportCount = viewportCount;
		ViewportSwizzles = viewportSwizzles;
	}

	public readonly override bool Equals(object? o) => (o is VkPipelineViewportSwizzleStateCreateInfoNV s) && (this == s);
	readonly bool IEquatable<VkPipelineViewportSwizzleStateCreateInfoNV>.Equals(VkPipelineViewportSwizzleStateCreateInfoNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ ViewportCount.GetHashCode()
			^ ((ulong)ViewportSwizzles).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPipelineViewportSwizzleStateCreateInfoNV l, in VkPipelineViewportSwizzleStateCreateInfoNV r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.ViewportCount == r.ViewportCount)
			&& (l.ViewportSwizzles == r.ViewportSwizzles)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPipelineViewportSwizzleStateCreateInfoNV l, in VkPipelineViewportSwizzleStateCreateInfoNV r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.ViewportCount != r.ViewportCount)
			|| (l.ViewportSwizzles != r.ViewportSwizzles)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPipelineViewportSwizzleStateCreateInfoNV s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPipelineCoverageToColorStateCreateInfoNV : IEquatable<VkPipelineCoverageToColorStateCreateInfoNV>
{
	public const VkStructureType TYPE = VkStructureType.PipelineCoverageToColorStateCreateInfoNv;

	public VkStructureType sType;
	public void* pNext;
	public VkPipelineCoverageToColorStateCreateFlagsNV Flags;
	public VkBool32 CoverageToColorEnable;
	public uint CoverageToColorLocation;

	public VkPipelineCoverageToColorStateCreateInfoNV(
		VkPipelineCoverageToColorStateCreateFlagsNV flags = default,
		VkBool32 coverageToColorEnable = default,
		uint coverageToColorLocation = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		CoverageToColorEnable = coverageToColorEnable;
		CoverageToColorLocation = coverageToColorLocation;
	}

	public readonly override bool Equals(object? o) => (o is VkPipelineCoverageToColorStateCreateInfoNV s) && (this == s);
	readonly bool IEquatable<VkPipelineCoverageToColorStateCreateInfoNV>.Equals(VkPipelineCoverageToColorStateCreateInfoNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ CoverageToColorEnable.GetHashCode()
			^ CoverageToColorLocation.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPipelineCoverageToColorStateCreateInfoNV l, in VkPipelineCoverageToColorStateCreateInfoNV r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.CoverageToColorEnable == r.CoverageToColorEnable)
			&& (l.CoverageToColorLocation == r.CoverageToColorLocation)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPipelineCoverageToColorStateCreateInfoNV l, in VkPipelineCoverageToColorStateCreateInfoNV r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.CoverageToColorEnable != r.CoverageToColorEnable)
			|| (l.CoverageToColorLocation != r.CoverageToColorLocation)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPipelineCoverageToColorStateCreateInfoNV s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPipelineCoverageModulationStateCreateInfoNV : IEquatable<VkPipelineCoverageModulationStateCreateInfoNV>
{
	public const VkStructureType TYPE = VkStructureType.PipelineCoverageModulationStateCreateInfoNv;

	public VkStructureType sType;
	public void* pNext;
	public VkPipelineCoverageModulationStateCreateFlagsNV Flags;
	public VkCoverageModulationModeNV CoverageModulationMode;
	public VkBool32 CoverageModulationTableEnable;
	public uint CoverageModulationTableCount;
	public float* CoverageModulationTable;

	public VkPipelineCoverageModulationStateCreateInfoNV(
		VkPipelineCoverageModulationStateCreateFlagsNV flags = default,
		VkCoverageModulationModeNV coverageModulationMode = default,
		VkBool32 coverageModulationTableEnable = default,
		uint coverageModulationTableCount = default,
		float* coverageModulationTable = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		CoverageModulationMode = coverageModulationMode;
		CoverageModulationTableEnable = coverageModulationTableEnable;
		CoverageModulationTableCount = coverageModulationTableCount;
		CoverageModulationTable = coverageModulationTable;
	}

	public readonly override bool Equals(object? o) => (o is VkPipelineCoverageModulationStateCreateInfoNV s) && (this == s);
	readonly bool IEquatable<VkPipelineCoverageModulationStateCreateInfoNV>.Equals(VkPipelineCoverageModulationStateCreateInfoNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ CoverageModulationMode.GetHashCode()
			^ CoverageModulationTableEnable.GetHashCode() ^ CoverageModulationTableCount.GetHashCode() ^ ((ulong)CoverageModulationTable).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPipelineCoverageModulationStateCreateInfoNV l, in VkPipelineCoverageModulationStateCreateInfoNV r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.CoverageModulationMode == r.CoverageModulationMode)
			&& (l.CoverageModulationTableEnable == r.CoverageModulationTableEnable) && (l.CoverageModulationTableCount == r.CoverageModulationTableCount) && (l.CoverageModulationTable == r.CoverageModulationTable)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPipelineCoverageModulationStateCreateInfoNV l, in VkPipelineCoverageModulationStateCreateInfoNV r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.CoverageModulationMode != r.CoverageModulationMode)
			|| (l.CoverageModulationTableEnable != r.CoverageModulationTableEnable) || (l.CoverageModulationTableCount != r.CoverageModulationTableCount) || (l.CoverageModulationTable != r.CoverageModulationTable)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPipelineCoverageModulationStateCreateInfoNV s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkQueueFamilyCheckpointPropertiesNV : IEquatable<VkQueueFamilyCheckpointPropertiesNV>
{
	public const VkStructureType TYPE = VkStructureType.QueueFamilyCheckpointPropertiesNv;

	public VkStructureType sType;
	public void* pNext;
	public VkPipelineStageFlags CheckpointExecutionStageMask;

	public VkQueueFamilyCheckpointPropertiesNV(
		VkPipelineStageFlags checkpointExecutionStageMask = default
	) {
		sType = TYPE;
		pNext = null;
		CheckpointExecutionStageMask = checkpointExecutionStageMask;
	}

	public readonly override bool Equals(object? o) => (o is VkQueueFamilyCheckpointPropertiesNV s) && (this == s);
	readonly bool IEquatable<VkQueueFamilyCheckpointPropertiesNV>.Equals(VkQueueFamilyCheckpointPropertiesNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ CheckpointExecutionStageMask.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkQueueFamilyCheckpointPropertiesNV l, in VkQueueFamilyCheckpointPropertiesNV r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.CheckpointExecutionStageMask == r.CheckpointExecutionStageMask)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkQueueFamilyCheckpointPropertiesNV l, in VkQueueFamilyCheckpointPropertiesNV r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.CheckpointExecutionStageMask != r.CheckpointExecutionStageMask)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkQueueFamilyCheckpointPropertiesNV s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkCheckpointDataNV : IEquatable<VkCheckpointDataNV>
{
	public const VkStructureType TYPE = VkStructureType.CheckpointDataNv;

	public VkStructureType sType;
	public void* pNext;
	public VkPipelineStageFlags Stage;
	public void* CheckpointMarker;

	public VkCheckpointDataNV(
		VkPipelineStageFlags stage = default,
		void* checkpointMarker = default
	) {
		sType = TYPE;
		pNext = null;
		Stage = stage;
		CheckpointMarker = checkpointMarker;
	}

	public readonly override bool Equals(object? o) => (o is VkCheckpointDataNV s) && (this == s);
	readonly bool IEquatable<VkCheckpointDataNV>.Equals(VkCheckpointDataNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Stage.GetHashCode() ^ ((ulong)CheckpointMarker).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkCheckpointDataNV l, in VkCheckpointDataNV r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Stage == r.Stage) && (l.CheckpointMarker == r.CheckpointMarker)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkCheckpointDataNV l, in VkCheckpointDataNV r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Stage != r.Stage) || (l.CheckpointMarker != r.CheckpointMarker)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkCheckpointDataNV s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV : IEquatable<VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceRepresentativeFragmentTestFeaturesNv;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 RepresentativeFragmentTest;

	public VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV(
		VkBool32 representativeFragmentTest = default
	) {
		sType = TYPE;
		pNext = null;
		RepresentativeFragmentTest = representativeFragmentTest;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV>.Equals(VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ RepresentativeFragmentTest.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV l, in VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.RepresentativeFragmentTest == r.RepresentativeFragmentTest)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV l, in VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.RepresentativeFragmentTest != r.RepresentativeFragmentTest)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPipelineRepresentativeFragmentTestStateCreateInfoNV : IEquatable<VkPipelineRepresentativeFragmentTestStateCreateInfoNV>
{
	public const VkStructureType TYPE = VkStructureType.PipelineRepresentativeFragmentTestStateCreateInfoNv;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 RepresentativeFragmentTestEnable;

	public VkPipelineRepresentativeFragmentTestStateCreateInfoNV(
		VkBool32 representativeFragmentTestEnable = default
	) {
		sType = TYPE;
		pNext = null;
		RepresentativeFragmentTestEnable = representativeFragmentTestEnable;
	}

	public readonly override bool Equals(object? o) => (o is VkPipelineRepresentativeFragmentTestStateCreateInfoNV s) && (this == s);
	readonly bool IEquatable<VkPipelineRepresentativeFragmentTestStateCreateInfoNV>.Equals(VkPipelineRepresentativeFragmentTestStateCreateInfoNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ RepresentativeFragmentTestEnable.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPipelineRepresentativeFragmentTestStateCreateInfoNV l, in VkPipelineRepresentativeFragmentTestStateCreateInfoNV r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.RepresentativeFragmentTestEnable == r.RepresentativeFragmentTestEnable)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPipelineRepresentativeFragmentTestStateCreateInfoNV l, in VkPipelineRepresentativeFragmentTestStateCreateInfoNV r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.RepresentativeFragmentTestEnable != r.RepresentativeFragmentTestEnable)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPipelineRepresentativeFragmentTestStateCreateInfoNV s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceExclusiveScissorFeaturesNV : IEquatable<VkPhysicalDeviceExclusiveScissorFeaturesNV>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceExclusiveScissorFeaturesNv;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 ExclusiveScissor;

	public VkPhysicalDeviceExclusiveScissorFeaturesNV(
		VkBool32 exclusiveScissor = default
	) {
		sType = TYPE;
		pNext = null;
		ExclusiveScissor = exclusiveScissor;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceExclusiveScissorFeaturesNV s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceExclusiveScissorFeaturesNV>.Equals(VkPhysicalDeviceExclusiveScissorFeaturesNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ExclusiveScissor.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceExclusiveScissorFeaturesNV l, in VkPhysicalDeviceExclusiveScissorFeaturesNV r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ExclusiveScissor == r.ExclusiveScissor)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceExclusiveScissorFeaturesNV l, in VkPhysicalDeviceExclusiveScissorFeaturesNV r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ExclusiveScissor != r.ExclusiveScissor)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceExclusiveScissorFeaturesNV s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPipelineViewportExclusiveScissorStateCreateInfoNV : IEquatable<VkPipelineViewportExclusiveScissorStateCreateInfoNV>
{
	public const VkStructureType TYPE = VkStructureType.PipelineViewportExclusiveScissorStateCreateInfoNv;

	public VkStructureType sType;
	public void* pNext;
	public uint ExclusiveScissorCount;
	public VkRect2D* ExclusiveScissors;

	public VkPipelineViewportExclusiveScissorStateCreateInfoNV(
		uint exclusiveScissorCount = default,
		VkRect2D* exclusiveScissors = default
	) {
		sType = TYPE;
		pNext = null;
		ExclusiveScissorCount = exclusiveScissorCount;
		ExclusiveScissors = exclusiveScissors;
	}

	public readonly override bool Equals(object? o) => (o is VkPipelineViewportExclusiveScissorStateCreateInfoNV s) && (this == s);
	readonly bool IEquatable<VkPipelineViewportExclusiveScissorStateCreateInfoNV>.Equals(VkPipelineViewportExclusiveScissorStateCreateInfoNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ExclusiveScissorCount.GetHashCode() ^ ((ulong)ExclusiveScissors).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPipelineViewportExclusiveScissorStateCreateInfoNV l, in VkPipelineViewportExclusiveScissorStateCreateInfoNV r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ExclusiveScissorCount == r.ExclusiveScissorCount) && (l.ExclusiveScissors == r.ExclusiveScissors)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPipelineViewportExclusiveScissorStateCreateInfoNV l, in VkPipelineViewportExclusiveScissorStateCreateInfoNV r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ExclusiveScissorCount != r.ExclusiveScissorCount) || (l.ExclusiveScissors != r.ExclusiveScissors)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPipelineViewportExclusiveScissorStateCreateInfoNV s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceCornerSampledImageFeaturesNV : IEquatable<VkPhysicalDeviceCornerSampledImageFeaturesNV>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceCornerSampledImageFeaturesNv;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 CornerSampledImage;

	public VkPhysicalDeviceCornerSampledImageFeaturesNV(
		VkBool32 cornerSampledImage = default
	) {
		sType = TYPE;
		pNext = null;
		CornerSampledImage = cornerSampledImage;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceCornerSampledImageFeaturesNV s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceCornerSampledImageFeaturesNV>.Equals(VkPhysicalDeviceCornerSampledImageFeaturesNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ CornerSampledImage.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceCornerSampledImageFeaturesNV l, in VkPhysicalDeviceCornerSampledImageFeaturesNV r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.CornerSampledImage == r.CornerSampledImage)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceCornerSampledImageFeaturesNV l, in VkPhysicalDeviceCornerSampledImageFeaturesNV r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.CornerSampledImage != r.CornerSampledImage)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceCornerSampledImageFeaturesNV s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceComputeShaderDerivativesFeaturesNV : IEquatable<VkPhysicalDeviceComputeShaderDerivativesFeaturesNV>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceComputeShaderDerivativesFeaturesNv;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 ComputeDerivativeGroupQuads;
	public VkBool32 ComputeDerivativeGroupLinear;

	public VkPhysicalDeviceComputeShaderDerivativesFeaturesNV(
		VkBool32 computeDerivativeGroupQuads = default,
		VkBool32 computeDerivativeGroupLinear = default
	) {
		sType = TYPE;
		pNext = null;
		ComputeDerivativeGroupQuads = computeDerivativeGroupQuads;
		ComputeDerivativeGroupLinear = computeDerivativeGroupLinear;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceComputeShaderDerivativesFeaturesNV s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceComputeShaderDerivativesFeaturesNV>.Equals(VkPhysicalDeviceComputeShaderDerivativesFeaturesNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ComputeDerivativeGroupQuads.GetHashCode() ^ ComputeDerivativeGroupLinear.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceComputeShaderDerivativesFeaturesNV l, in VkPhysicalDeviceComputeShaderDerivativesFeaturesNV r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ComputeDerivativeGroupQuads == r.ComputeDerivativeGroupQuads) && (l.ComputeDerivativeGroupLinear == r.ComputeDerivativeGroupLinear)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceComputeShaderDerivativesFeaturesNV l, in VkPhysicalDeviceComputeShaderDerivativesFeaturesNV r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ComputeDerivativeGroupQuads != r.ComputeDerivativeGroupQuads) || (l.ComputeDerivativeGroupLinear != r.ComputeDerivativeGroupLinear)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceComputeShaderDerivativesFeaturesNV s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV : IEquatable<VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceFragmentShaderBarycentricFeaturesNv;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 FragmentShaderBarycentric;

	public VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV(
		VkBool32 fragmentShaderBarycentric = default
	) {
		sType = TYPE;
		pNext = null;
		FragmentShaderBarycentric = fragmentShaderBarycentric;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV>.Equals(VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ FragmentShaderBarycentric.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV l, in VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.FragmentShaderBarycentric == r.FragmentShaderBarycentric)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV l, in VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.FragmentShaderBarycentric != r.FragmentShaderBarycentric)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceShaderImageFootprintFeaturesNV : IEquatable<VkPhysicalDeviceShaderImageFootprintFeaturesNV>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceShaderImageFootprintFeaturesNv;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 ImageFootprint;

	public VkPhysicalDeviceShaderImageFootprintFeaturesNV(
		VkBool32 imageFootprint = default
	) {
		sType = TYPE;
		pNext = null;
		ImageFootprint = imageFootprint;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceShaderImageFootprintFeaturesNV s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceShaderImageFootprintFeaturesNV>.Equals(VkPhysicalDeviceShaderImageFootprintFeaturesNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ImageFootprint.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceShaderImageFootprintFeaturesNV l, in VkPhysicalDeviceShaderImageFootprintFeaturesNV r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ImageFootprint == r.ImageFootprint)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceShaderImageFootprintFeaturesNV l, in VkPhysicalDeviceShaderImageFootprintFeaturesNV r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ImageFootprint != r.ImageFootprint)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceShaderImageFootprintFeaturesNV s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV : IEquatable<VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNv;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 DedicatedAllocationImageAliasing;

	public VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV(
		VkBool32 dedicatedAllocationImageAliasing = default
	) {
		sType = TYPE;
		pNext = null;
		DedicatedAllocationImageAliasing = dedicatedAllocationImageAliasing;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV>.Equals(VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DedicatedAllocationImageAliasing.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV l, in VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DedicatedAllocationImageAliasing == r.DedicatedAllocationImageAliasing)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV l, in VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DedicatedAllocationImageAliasing != r.DedicatedAllocationImageAliasing)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkShadingRatePaletteNV : IEquatable<VkShadingRatePaletteNV>
{
	public uint ShadingRatePaletteEntryCount;
	public VkShadingRatePaletteEntryNV* ShadingRatePaletteEntries;

	public VkShadingRatePaletteNV(
		uint shadingRatePaletteEntryCount = default,
		VkShadingRatePaletteEntryNV* shadingRatePaletteEntries = default
	) {
		ShadingRatePaletteEntryCount = shadingRatePaletteEntryCount;
		ShadingRatePaletteEntries = shadingRatePaletteEntries;
	}

	public readonly override bool Equals(object? o) => (o is VkShadingRatePaletteNV s) && (this == s);
	readonly bool IEquatable<VkShadingRatePaletteNV>.Equals(VkShadingRatePaletteNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			ShadingRatePaletteEntryCount.GetHashCode() ^ ((ulong)ShadingRatePaletteEntries).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkShadingRatePaletteNV l, in VkShadingRatePaletteNV r)
	{
		return
			(l.ShadingRatePaletteEntryCount == r.ShadingRatePaletteEntryCount) && (l.ShadingRatePaletteEntries == r.ShadingRatePaletteEntries)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkShadingRatePaletteNV l, in VkShadingRatePaletteNV r)
	{
		return
			(l.ShadingRatePaletteEntryCount != r.ShadingRatePaletteEntryCount) || (l.ShadingRatePaletteEntries != r.ShadingRatePaletteEntries)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkShadingRatePaletteNV s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPipelineViewportShadingRateImageStateCreateInfoNV : IEquatable<VkPipelineViewportShadingRateImageStateCreateInfoNV>
{
	public const VkStructureType TYPE = VkStructureType.PipelineViewportShadingRateImageStateCreateInfoNv;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 ShadingRateImageEnable;
	public uint ViewportCount;
	public VkShadingRatePaletteNV* ShadingRatePalettes;

	public VkPipelineViewportShadingRateImageStateCreateInfoNV(
		VkBool32 shadingRateImageEnable = default,
		uint viewportCount = default,
		VkShadingRatePaletteNV* shadingRatePalettes = default
	) {
		sType = TYPE;
		pNext = null;
		ShadingRateImageEnable = shadingRateImageEnable;
		ViewportCount = viewportCount;
		ShadingRatePalettes = shadingRatePalettes;
	}

	public readonly override bool Equals(object? o) => (o is VkPipelineViewportShadingRateImageStateCreateInfoNV s) && (this == s);
	readonly bool IEquatable<VkPipelineViewportShadingRateImageStateCreateInfoNV>.Equals(VkPipelineViewportShadingRateImageStateCreateInfoNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ShadingRateImageEnable.GetHashCode() ^ ViewportCount.GetHashCode()
			^ ((ulong)ShadingRatePalettes).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPipelineViewportShadingRateImageStateCreateInfoNV l, in VkPipelineViewportShadingRateImageStateCreateInfoNV r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ShadingRateImageEnable == r.ShadingRateImageEnable) && (l.ViewportCount == r.ViewportCount)
			&& (l.ShadingRatePalettes == r.ShadingRatePalettes)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPipelineViewportShadingRateImageStateCreateInfoNV l, in VkPipelineViewportShadingRateImageStateCreateInfoNV r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ShadingRateImageEnable != r.ShadingRateImageEnable) || (l.ViewportCount != r.ViewportCount)
			|| (l.ShadingRatePalettes != r.ShadingRatePalettes)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPipelineViewportShadingRateImageStateCreateInfoNV s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceShadingRateImageFeaturesNV : IEquatable<VkPhysicalDeviceShadingRateImageFeaturesNV>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceShadingRateImageFeaturesNv;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 ShadingRateImage;
	public VkBool32 ShadingRateCoarseSampleOrder;

	public VkPhysicalDeviceShadingRateImageFeaturesNV(
		VkBool32 shadingRateImage = default,
		VkBool32 shadingRateCoarseSampleOrder = default
	) {
		sType = TYPE;
		pNext = null;
		ShadingRateImage = shadingRateImage;
		ShadingRateCoarseSampleOrder = shadingRateCoarseSampleOrder;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceShadingRateImageFeaturesNV s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceShadingRateImageFeaturesNV>.Equals(VkPhysicalDeviceShadingRateImageFeaturesNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ShadingRateImage.GetHashCode() ^ ShadingRateCoarseSampleOrder.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceShadingRateImageFeaturesNV l, in VkPhysicalDeviceShadingRateImageFeaturesNV r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ShadingRateImage == r.ShadingRateImage) && (l.ShadingRateCoarseSampleOrder == r.ShadingRateCoarseSampleOrder)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceShadingRateImageFeaturesNV l, in VkPhysicalDeviceShadingRateImageFeaturesNV r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ShadingRateImage != r.ShadingRateImage) || (l.ShadingRateCoarseSampleOrder != r.ShadingRateCoarseSampleOrder)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceShadingRateImageFeaturesNV s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceShadingRateImagePropertiesNV : IEquatable<VkPhysicalDeviceShadingRateImagePropertiesNV>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceShadingRateImagePropertiesNv;

	public VkStructureType sType;
	public void* pNext;
	public VkExtent2D ShadingRateTexelSize;
	public uint ShadingRatePaletteSize;
	public uint ShadingRateMaxCoarseSamples;

	public VkPhysicalDeviceShadingRateImagePropertiesNV(
		VkExtent2D shadingRateTexelSize = default,
		uint shadingRatePaletteSize = default,
		uint shadingRateMaxCoarseSamples = default
	) {
		sType = TYPE;
		pNext = null;
		ShadingRateTexelSize = shadingRateTexelSize;
		ShadingRatePaletteSize = shadingRatePaletteSize;
		ShadingRateMaxCoarseSamples = shadingRateMaxCoarseSamples;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceShadingRateImagePropertiesNV s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceShadingRateImagePropertiesNV>.Equals(VkPhysicalDeviceShadingRateImagePropertiesNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ShadingRateTexelSize.GetHashCode() ^ ShadingRatePaletteSize.GetHashCode()
			^ ShadingRateMaxCoarseSamples.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceShadingRateImagePropertiesNV l, in VkPhysicalDeviceShadingRateImagePropertiesNV r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ShadingRateTexelSize == r.ShadingRateTexelSize) && (l.ShadingRatePaletteSize == r.ShadingRatePaletteSize)
			&& (l.ShadingRateMaxCoarseSamples == r.ShadingRateMaxCoarseSamples)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceShadingRateImagePropertiesNV l, in VkPhysicalDeviceShadingRateImagePropertiesNV r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ShadingRateTexelSize != r.ShadingRateTexelSize) || (l.ShadingRatePaletteSize != r.ShadingRatePaletteSize)
			|| (l.ShadingRateMaxCoarseSamples != r.ShadingRateMaxCoarseSamples)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceShadingRateImagePropertiesNV s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkCoarseSampleLocationNV : IEquatable<VkCoarseSampleLocationNV>
{
	public uint PixelX;
	public uint PixelY;
	public uint Sample;

	public VkCoarseSampleLocationNV(
		uint pixelX = default,
		uint pixelY = default,
		uint sample = default
	) {
		PixelX = pixelX;
		PixelY = pixelY;
		Sample = sample;
	}

	public readonly override bool Equals(object? o) => (o is VkCoarseSampleLocationNV s) && (this == s);
	readonly bool IEquatable<VkCoarseSampleLocationNV>.Equals(VkCoarseSampleLocationNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			PixelX.GetHashCode() ^ PixelY.GetHashCode() ^ Sample.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkCoarseSampleLocationNV l, in VkCoarseSampleLocationNV r)
	{
		return
			(l.PixelX == r.PixelX) && (l.PixelY == r.PixelY) && (l.Sample == r.Sample)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkCoarseSampleLocationNV l, in VkCoarseSampleLocationNV r)
	{
		return
			(l.PixelX != r.PixelX) || (l.PixelY != r.PixelY) || (l.Sample != r.Sample)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkCoarseSampleLocationNV s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkCoarseSampleOrderCustomNV : IEquatable<VkCoarseSampleOrderCustomNV>
{
	public VkShadingRatePaletteEntryNV ShadingRate;
	public uint SampleCount;
	public uint SampleLocationCount;
	public VkCoarseSampleLocationNV* SampleLocations;

	public VkCoarseSampleOrderCustomNV(
		VkShadingRatePaletteEntryNV shadingRate = default,
		uint sampleCount = default,
		uint sampleLocationCount = default,
		VkCoarseSampleLocationNV* sampleLocations = default
	) {
		ShadingRate = shadingRate;
		SampleCount = sampleCount;
		SampleLocationCount = sampleLocationCount;
		SampleLocations = sampleLocations;
	}

	public readonly override bool Equals(object? o) => (o is VkCoarseSampleOrderCustomNV s) && (this == s);
	readonly bool IEquatable<VkCoarseSampleOrderCustomNV>.Equals(VkCoarseSampleOrderCustomNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			ShadingRate.GetHashCode() ^ SampleCount.GetHashCode() ^ SampleLocationCount.GetHashCode() ^ ((ulong)SampleLocations).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkCoarseSampleOrderCustomNV l, in VkCoarseSampleOrderCustomNV r)
	{
		return
			(l.ShadingRate == r.ShadingRate) && (l.SampleCount == r.SampleCount) && (l.SampleLocationCount == r.SampleLocationCount) && (l.SampleLocations == r.SampleLocations)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkCoarseSampleOrderCustomNV l, in VkCoarseSampleOrderCustomNV r)
	{
		return
			(l.ShadingRate != r.ShadingRate) || (l.SampleCount != r.SampleCount) || (l.SampleLocationCount != r.SampleLocationCount) || (l.SampleLocations != r.SampleLocations)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkCoarseSampleOrderCustomNV s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPipelineViewportCoarseSampleOrderStateCreateInfoNV : IEquatable<VkPipelineViewportCoarseSampleOrderStateCreateInfoNV>
{
	public const VkStructureType TYPE = VkStructureType.PipelineViewportCoarseSampleOrderStateCreateInfoNv;

	public VkStructureType sType;
	public void* pNext;
	public VkCoarseSampleOrderTypeNV SampleOrderType;
	public uint CustomSampleOrderCount;
	public VkCoarseSampleOrderCustomNV* CustomSampleOrders;

	public VkPipelineViewportCoarseSampleOrderStateCreateInfoNV(
		VkCoarseSampleOrderTypeNV sampleOrderType = default,
		uint customSampleOrderCount = default,
		VkCoarseSampleOrderCustomNV* customSampleOrders = default
	) {
		sType = TYPE;
		pNext = null;
		SampleOrderType = sampleOrderType;
		CustomSampleOrderCount = customSampleOrderCount;
		CustomSampleOrders = customSampleOrders;
	}

	public readonly override bool Equals(object? o) => (o is VkPipelineViewportCoarseSampleOrderStateCreateInfoNV s) && (this == s);
	readonly bool IEquatable<VkPipelineViewportCoarseSampleOrderStateCreateInfoNV>.Equals(VkPipelineViewportCoarseSampleOrderStateCreateInfoNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SampleOrderType.GetHashCode() ^ CustomSampleOrderCount.GetHashCode()
			^ ((ulong)CustomSampleOrders).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPipelineViewportCoarseSampleOrderStateCreateInfoNV l, in VkPipelineViewportCoarseSampleOrderStateCreateInfoNV r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SampleOrderType == r.SampleOrderType) && (l.CustomSampleOrderCount == r.CustomSampleOrderCount)
			&& (l.CustomSampleOrders == r.CustomSampleOrders)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPipelineViewportCoarseSampleOrderStateCreateInfoNV l, in VkPipelineViewportCoarseSampleOrderStateCreateInfoNV r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SampleOrderType != r.SampleOrderType) || (l.CustomSampleOrderCount != r.CustomSampleOrderCount)
			|| (l.CustomSampleOrders != r.CustomSampleOrders)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPipelineViewportCoarseSampleOrderStateCreateInfoNV s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceMeshShaderFeaturesNV : IEquatable<VkPhysicalDeviceMeshShaderFeaturesNV>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceMeshShaderFeaturesNv;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 TaskShader;
	public VkBool32 MeshShader;

	public VkPhysicalDeviceMeshShaderFeaturesNV(
		VkBool32 taskShader = default,
		VkBool32 meshShader = default
	) {
		sType = TYPE;
		pNext = null;
		TaskShader = taskShader;
		MeshShader = meshShader;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceMeshShaderFeaturesNV s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceMeshShaderFeaturesNV>.Equals(VkPhysicalDeviceMeshShaderFeaturesNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ TaskShader.GetHashCode() ^ MeshShader.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceMeshShaderFeaturesNV l, in VkPhysicalDeviceMeshShaderFeaturesNV r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.TaskShader == r.TaskShader) && (l.MeshShader == r.MeshShader)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceMeshShaderFeaturesNV l, in VkPhysicalDeviceMeshShaderFeaturesNV r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.TaskShader != r.TaskShader) || (l.MeshShader != r.MeshShader)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceMeshShaderFeaturesNV s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceMeshShaderPropertiesNV : IEquatable<VkPhysicalDeviceMeshShaderPropertiesNV>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceMeshShaderPropertiesNv;

	public VkStructureType sType;
	public void* pNext;
	public uint MaxDrawMeshTasksCount;
	public uint MaxTaskWorkGroupInvocations;
	public fixed uint MaxTaskWorkGroupSize[3];
	public uint MaxTaskTotalMemorySize;
	public uint MaxTaskOutputCount;
	public uint MaxMeshWorkGroupInvocations;
	public fixed uint MaxMeshWorkGroupSize[3];
	public uint MaxMeshTotalMemorySize;
	public uint MaxMeshOutputVertices;
	public uint MaxMeshOutputPrimitives;
	public uint MaxMeshMultiviewViewCount;
	public uint MeshOutputPerVertexGranularity;
	public uint MeshOutputPerPrimitiveGranularity;

	public VkPhysicalDeviceMeshShaderPropertiesNV(
		uint maxDrawMeshTasksCount = default,
		uint maxTaskWorkGroupInvocations = default,
		uint maxTaskWorkGroupSize_0 = default,
		uint maxTaskWorkGroupSize_1 = default,
		uint maxTaskWorkGroupSize_2 = default,
		uint maxTaskTotalMemorySize = default,
		uint maxTaskOutputCount = default,
		uint maxMeshWorkGroupInvocations = default,
		uint maxMeshWorkGroupSize_0 = default,
		uint maxMeshWorkGroupSize_1 = default,
		uint maxMeshWorkGroupSize_2 = default,
		uint maxMeshTotalMemorySize = default,
		uint maxMeshOutputVertices = default,
		uint maxMeshOutputPrimitives = default,
		uint maxMeshMultiviewViewCount = default,
		uint meshOutputPerVertexGranularity = default,
		uint meshOutputPerPrimitiveGranularity = default
	) {
		sType = TYPE;
		pNext = null;
		MaxDrawMeshTasksCount = maxDrawMeshTasksCount;
		MaxTaskWorkGroupInvocations = maxTaskWorkGroupInvocations;
		MaxTaskWorkGroupSize[0] = maxTaskWorkGroupSize_0;
		MaxTaskWorkGroupSize[1] = maxTaskWorkGroupSize_1;
		MaxTaskWorkGroupSize[2] = maxTaskWorkGroupSize_2;
		MaxTaskTotalMemorySize = maxTaskTotalMemorySize;
		MaxTaskOutputCount = maxTaskOutputCount;
		MaxMeshWorkGroupInvocations = maxMeshWorkGroupInvocations;
		MaxMeshWorkGroupSize[0] = maxMeshWorkGroupSize_0;
		MaxMeshWorkGroupSize[1] = maxMeshWorkGroupSize_1;
		MaxMeshWorkGroupSize[2] = maxMeshWorkGroupSize_2;
		MaxMeshTotalMemorySize = maxMeshTotalMemorySize;
		MaxMeshOutputVertices = maxMeshOutputVertices;
		MaxMeshOutputPrimitives = maxMeshOutputPrimitives;
		MaxMeshMultiviewViewCount = maxMeshMultiviewViewCount;
		MeshOutputPerVertexGranularity = meshOutputPerVertexGranularity;
		MeshOutputPerPrimitiveGranularity = meshOutputPerPrimitiveGranularity;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceMeshShaderPropertiesNV s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceMeshShaderPropertiesNV>.Equals(VkPhysicalDeviceMeshShaderPropertiesNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MaxDrawMeshTasksCount.GetHashCode() ^ MaxTaskWorkGroupInvocations.GetHashCode()
			^ MaxTaskWorkGroupSize[0].GetHashCode() ^ MaxTaskWorkGroupSize[1].GetHashCode() ^ MaxTaskWorkGroupSize[2].GetHashCode() ^ MaxTaskTotalMemorySize.GetHashCode()
			^ MaxTaskOutputCount.GetHashCode() ^ MaxMeshWorkGroupInvocations.GetHashCode() ^ MaxMeshWorkGroupSize[0].GetHashCode() ^ MaxMeshWorkGroupSize[1].GetHashCode()
			^ MaxMeshWorkGroupSize[2].GetHashCode() ^ MaxMeshTotalMemorySize.GetHashCode() ^ MaxMeshOutputVertices.GetHashCode() ^ MaxMeshOutputPrimitives.GetHashCode()
			^ MaxMeshMultiviewViewCount.GetHashCode() ^ MeshOutputPerVertexGranularity.GetHashCode() ^ MeshOutputPerPrimitiveGranularity.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceMeshShaderPropertiesNV l, in VkPhysicalDeviceMeshShaderPropertiesNV r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MaxDrawMeshTasksCount == r.MaxDrawMeshTasksCount) && (l.MaxTaskWorkGroupInvocations == r.MaxTaskWorkGroupInvocations)
			&& (l.MaxTaskWorkGroupSize[0] == r.MaxTaskWorkGroupSize[0]) && (l.MaxTaskWorkGroupSize[1] == r.MaxTaskWorkGroupSize[1]) && (l.MaxTaskWorkGroupSize[2] == r.MaxTaskWorkGroupSize[2]) && (l.MaxTaskTotalMemorySize == r.MaxTaskTotalMemorySize)
			&& (l.MaxTaskOutputCount == r.MaxTaskOutputCount) && (l.MaxMeshWorkGroupInvocations == r.MaxMeshWorkGroupInvocations) && (l.MaxMeshWorkGroupSize[0] == r.MaxMeshWorkGroupSize[0]) && (l.MaxMeshWorkGroupSize[1] == r.MaxMeshWorkGroupSize[1])
			&& (l.MaxMeshWorkGroupSize[2] == r.MaxMeshWorkGroupSize[2]) && (l.MaxMeshTotalMemorySize == r.MaxMeshTotalMemorySize) && (l.MaxMeshOutputVertices == r.MaxMeshOutputVertices) && (l.MaxMeshOutputPrimitives == r.MaxMeshOutputPrimitives)
			&& (l.MaxMeshMultiviewViewCount == r.MaxMeshMultiviewViewCount) && (l.MeshOutputPerVertexGranularity == r.MeshOutputPerVertexGranularity) && (l.MeshOutputPerPrimitiveGranularity == r.MeshOutputPerPrimitiveGranularity)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceMeshShaderPropertiesNV l, in VkPhysicalDeviceMeshShaderPropertiesNV r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MaxDrawMeshTasksCount != r.MaxDrawMeshTasksCount) || (l.MaxTaskWorkGroupInvocations != r.MaxTaskWorkGroupInvocations)
			|| (l.MaxTaskWorkGroupSize[0] != r.MaxTaskWorkGroupSize[0]) || (l.MaxTaskWorkGroupSize[1] != r.MaxTaskWorkGroupSize[1]) || (l.MaxTaskWorkGroupSize[2] != r.MaxTaskWorkGroupSize[2]) || (l.MaxTaskTotalMemorySize != r.MaxTaskTotalMemorySize)
			|| (l.MaxTaskOutputCount != r.MaxTaskOutputCount) || (l.MaxMeshWorkGroupInvocations != r.MaxMeshWorkGroupInvocations) || (l.MaxMeshWorkGroupSize[0] != r.MaxMeshWorkGroupSize[0]) || (l.MaxMeshWorkGroupSize[1] != r.MaxMeshWorkGroupSize[1])
			|| (l.MaxMeshWorkGroupSize[2] != r.MaxMeshWorkGroupSize[2]) || (l.MaxMeshTotalMemorySize != r.MaxMeshTotalMemorySize) || (l.MaxMeshOutputVertices != r.MaxMeshOutputVertices) || (l.MaxMeshOutputPrimitives != r.MaxMeshOutputPrimitives)
			|| (l.MaxMeshMultiviewViewCount != r.MaxMeshMultiviewViewCount) || (l.MeshOutputPerVertexGranularity != r.MeshOutputPerVertexGranularity) || (l.MeshOutputPerPrimitiveGranularity != r.MeshOutputPerPrimitiveGranularity)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceMeshShaderPropertiesNV s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDrawMeshTasksIndirectCommandNV : IEquatable<VkDrawMeshTasksIndirectCommandNV>
{
	public uint TaskCount;
	public uint FirstTask;

	public VkDrawMeshTasksIndirectCommandNV(
		uint taskCount = default,
		uint firstTask = default
	) {
		TaskCount = taskCount;
		FirstTask = firstTask;
	}

	public readonly override bool Equals(object? o) => (o is VkDrawMeshTasksIndirectCommandNV s) && (this == s);
	readonly bool IEquatable<VkDrawMeshTasksIndirectCommandNV>.Equals(VkDrawMeshTasksIndirectCommandNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			TaskCount.GetHashCode() ^ FirstTask.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDrawMeshTasksIndirectCommandNV l, in VkDrawMeshTasksIndirectCommandNV r)
	{
		return
			(l.TaskCount == r.TaskCount) && (l.FirstTask == r.FirstTask)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDrawMeshTasksIndirectCommandNV l, in VkDrawMeshTasksIndirectCommandNV r)
	{
		return
			(l.TaskCount != r.TaskCount) || (l.FirstTask != r.FirstTask)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDrawMeshTasksIndirectCommandNV s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkRayTracingShaderGroupCreateInfoNV : IEquatable<VkRayTracingShaderGroupCreateInfoNV>
{
	public const VkStructureType TYPE = VkStructureType.RayTracingShaderGroupCreateInfoNv;

	public VkStructureType sType;
	public void* pNext;
	public VkRayTracingShaderGroupTypeKHR Type;
	public uint GeneralShader;
	public uint ClosestHitShader;
	public uint AnyHitShader;
	public uint IntersectionShader;

	public VkRayTracingShaderGroupCreateInfoNV(
		VkRayTracingShaderGroupTypeKHR type = default,
		uint generalShader = default,
		uint closestHitShader = default,
		uint anyHitShader = default,
		uint intersectionShader = default
	) {
		sType = TYPE;
		pNext = null;
		Type = type;
		GeneralShader = generalShader;
		ClosestHitShader = closestHitShader;
		AnyHitShader = anyHitShader;
		IntersectionShader = intersectionShader;
	}

	public readonly override bool Equals(object? o) => (o is VkRayTracingShaderGroupCreateInfoNV s) && (this == s);
	readonly bool IEquatable<VkRayTracingShaderGroupCreateInfoNV>.Equals(VkRayTracingShaderGroupCreateInfoNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Type.GetHashCode() ^ GeneralShader.GetHashCode()
			^ ClosestHitShader.GetHashCode() ^ AnyHitShader.GetHashCode() ^ IntersectionShader.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkRayTracingShaderGroupCreateInfoNV l, in VkRayTracingShaderGroupCreateInfoNV r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Type == r.Type) && (l.GeneralShader == r.GeneralShader)
			&& (l.ClosestHitShader == r.ClosestHitShader) && (l.AnyHitShader == r.AnyHitShader) && (l.IntersectionShader == r.IntersectionShader)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkRayTracingShaderGroupCreateInfoNV l, in VkRayTracingShaderGroupCreateInfoNV r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Type != r.Type) || (l.GeneralShader != r.GeneralShader)
			|| (l.ClosestHitShader != r.ClosestHitShader) || (l.AnyHitShader != r.AnyHitShader) || (l.IntersectionShader != r.IntersectionShader)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkRayTracingShaderGroupCreateInfoNV s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkRayTracingPipelineCreateInfoNV : IEquatable<VkRayTracingPipelineCreateInfoNV>
{
	public const VkStructureType TYPE = VkStructureType.RayTracingPipelineCreateInfoNv;

	public VkStructureType sType;
	public void* pNext;
	public VkPipelineCreateFlags Flags;
	public uint StageCount;
	public VkPipelineShaderStageCreateInfo* Stages;
	public uint GroupCount;
	public VkRayTracingShaderGroupCreateInfoNV* Groups;
	public uint MaxRecursionDepth;
	public VulkanHandle<VkPipelineLayout> Layout;
	public VulkanHandle<VkPipeline> BasePipelineHandle;
	public int BasePipelineIndex;

	public VkRayTracingPipelineCreateInfoNV(
		VkPipelineCreateFlags flags = default,
		uint stageCount = default,
		VkPipelineShaderStageCreateInfo* stages = default,
		uint groupCount = default,
		VkRayTracingShaderGroupCreateInfoNV* groups = default,
		uint maxRecursionDepth = default,
		VulkanHandle<VkPipelineLayout> layout = default,
		VulkanHandle<VkPipeline> basePipelineHandle = default,
		int basePipelineIndex = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		StageCount = stageCount;
		Stages = stages;
		GroupCount = groupCount;
		Groups = groups;
		MaxRecursionDepth = maxRecursionDepth;
		Layout = layout;
		BasePipelineHandle = basePipelineHandle;
		BasePipelineIndex = basePipelineIndex;
	}

	public readonly override bool Equals(object? o) => (o is VkRayTracingPipelineCreateInfoNV s) && (this == s);
	readonly bool IEquatable<VkRayTracingPipelineCreateInfoNV>.Equals(VkRayTracingPipelineCreateInfoNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ StageCount.GetHashCode()
			^ ((ulong)Stages).GetHashCode() ^ GroupCount.GetHashCode() ^ ((ulong)Groups).GetHashCode() ^ MaxRecursionDepth.GetHashCode()
			^ Layout.GetHashCode() ^ BasePipelineHandle.GetHashCode() ^ BasePipelineIndex.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkRayTracingPipelineCreateInfoNV l, in VkRayTracingPipelineCreateInfoNV r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.StageCount == r.StageCount)
			&& (l.Stages == r.Stages) && (l.GroupCount == r.GroupCount) && (l.Groups == r.Groups) && (l.MaxRecursionDepth == r.MaxRecursionDepth)
			&& (l.Layout == r.Layout) && (l.BasePipelineHandle == r.BasePipelineHandle) && (l.BasePipelineIndex == r.BasePipelineIndex)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkRayTracingPipelineCreateInfoNV l, in VkRayTracingPipelineCreateInfoNV r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.StageCount != r.StageCount)
			|| (l.Stages != r.Stages) || (l.GroupCount != r.GroupCount) || (l.Groups != r.Groups) || (l.MaxRecursionDepth != r.MaxRecursionDepth)
			|| (l.Layout != r.Layout) || (l.BasePipelineHandle != r.BasePipelineHandle) || (l.BasePipelineIndex != r.BasePipelineIndex)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkRayTracingPipelineCreateInfoNV s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkGeometryTrianglesNV : IEquatable<VkGeometryTrianglesNV>
{
	public const VkStructureType TYPE = VkStructureType.GeometryTrianglesNv;

	public VkStructureType sType;
	public void* pNext;
	public VulkanHandle<VkBuffer> VertexData;
	public ulong VertexOffset;
	public uint VertexCount;
	public ulong VertexStride;
	public VkFormat VertexFormat;
	public VulkanHandle<VkBuffer> IndexData;
	public ulong IndexOffset;
	public uint IndexCount;
	public VkIndexType IndexType;
	public VulkanHandle<VkBuffer> TransformData;
	public ulong TransformOffset;

	public VkGeometryTrianglesNV(
		VulkanHandle<VkBuffer> vertexData = default,
		ulong vertexOffset = default,
		uint vertexCount = default,
		ulong vertexStride = default,
		VkFormat vertexFormat = default,
		VulkanHandle<VkBuffer> indexData = default,
		ulong indexOffset = default,
		uint indexCount = default,
		VkIndexType indexType = default,
		VulkanHandle<VkBuffer> transformData = default,
		ulong transformOffset = default
	) {
		sType = TYPE;
		pNext = null;
		VertexData = vertexData;
		VertexOffset = vertexOffset;
		VertexCount = vertexCount;
		VertexStride = vertexStride;
		VertexFormat = vertexFormat;
		IndexData = indexData;
		IndexOffset = indexOffset;
		IndexCount = indexCount;
		IndexType = indexType;
		TransformData = transformData;
		TransformOffset = transformOffset;
	}

	public readonly override bool Equals(object? o) => (o is VkGeometryTrianglesNV s) && (this == s);
	readonly bool IEquatable<VkGeometryTrianglesNV>.Equals(VkGeometryTrianglesNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ VertexData.GetHashCode() ^ VertexOffset.GetHashCode()
			^ VertexCount.GetHashCode() ^ VertexStride.GetHashCode() ^ VertexFormat.GetHashCode() ^ IndexData.GetHashCode()
			^ IndexOffset.GetHashCode() ^ IndexCount.GetHashCode() ^ IndexType.GetHashCode() ^ TransformData.GetHashCode()
			^ TransformOffset.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkGeometryTrianglesNV l, in VkGeometryTrianglesNV r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.VertexData == r.VertexData) && (l.VertexOffset == r.VertexOffset)
			&& (l.VertexCount == r.VertexCount) && (l.VertexStride == r.VertexStride) && (l.VertexFormat == r.VertexFormat) && (l.IndexData == r.IndexData)
			&& (l.IndexOffset == r.IndexOffset) && (l.IndexCount == r.IndexCount) && (l.IndexType == r.IndexType) && (l.TransformData == r.TransformData)
			&& (l.TransformOffset == r.TransformOffset)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkGeometryTrianglesNV l, in VkGeometryTrianglesNV r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.VertexData != r.VertexData) || (l.VertexOffset != r.VertexOffset)
			|| (l.VertexCount != r.VertexCount) || (l.VertexStride != r.VertexStride) || (l.VertexFormat != r.VertexFormat) || (l.IndexData != r.IndexData)
			|| (l.IndexOffset != r.IndexOffset) || (l.IndexCount != r.IndexCount) || (l.IndexType != r.IndexType) || (l.TransformData != r.TransformData)
			|| (l.TransformOffset != r.TransformOffset)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkGeometryTrianglesNV s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkGeometryAABBNV : IEquatable<VkGeometryAABBNV>
{
	public const VkStructureType TYPE = VkStructureType.GeometryAabbNv;

	public VkStructureType sType;
	public void* pNext;
	public VulkanHandle<VkBuffer> AabbData;
	public uint NumAABBs;
	public uint Stride;
	public ulong Offset;

	public VkGeometryAABBNV(
		VulkanHandle<VkBuffer> aabbData = default,
		uint numAABBs = default,
		uint stride = default,
		ulong offset = default
	) {
		sType = TYPE;
		pNext = null;
		AabbData = aabbData;
		NumAABBs = numAABBs;
		Stride = stride;
		Offset = offset;
	}

	public readonly override bool Equals(object? o) => (o is VkGeometryAABBNV s) && (this == s);
	readonly bool IEquatable<VkGeometryAABBNV>.Equals(VkGeometryAABBNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ AabbData.GetHashCode() ^ NumAABBs.GetHashCode()
			^ Stride.GetHashCode() ^ Offset.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkGeometryAABBNV l, in VkGeometryAABBNV r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.AabbData == r.AabbData) && (l.NumAABBs == r.NumAABBs)
			&& (l.Stride == r.Stride) && (l.Offset == r.Offset)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkGeometryAABBNV l, in VkGeometryAABBNV r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.AabbData != r.AabbData) || (l.NumAABBs != r.NumAABBs)
			|| (l.Stride != r.Stride) || (l.Offset != r.Offset)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkGeometryAABBNV s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkGeometryDataNV : IEquatable<VkGeometryDataNV>
{
	public VkGeometryTrianglesNV Triangles;
	public VkGeometryAABBNV Aabbs;

	public VkGeometryDataNV(
		VkGeometryTrianglesNV triangles = default,
		VkGeometryAABBNV aabbs = default
	) {
		Triangles = triangles;
		Aabbs = aabbs;
	}

	public readonly override bool Equals(object? o) => (o is VkGeometryDataNV s) && (this == s);
	readonly bool IEquatable<VkGeometryDataNV>.Equals(VkGeometryDataNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Triangles.GetHashCode() ^ Aabbs.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkGeometryDataNV l, in VkGeometryDataNV r)
	{
		return
			(l.Triangles == r.Triangles) && (l.Aabbs == r.Aabbs)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkGeometryDataNV l, in VkGeometryDataNV r)
	{
		return
			(l.Triangles != r.Triangles) || (l.Aabbs != r.Aabbs)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkGeometryDataNV s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkGeometryNV : IEquatable<VkGeometryNV>
{
	public const VkStructureType TYPE = VkStructureType.GeometryNv;

	public VkStructureType sType;
	public void* pNext;
	public VkGeometryTypeKHR GeometryType;
	public VkGeometryDataNV Geometry;
	public VkGeometryFlagsKHR Flags;

	public VkGeometryNV(
		VkGeometryTypeKHR geometryType = default,
		VkGeometryDataNV geometry = default,
		VkGeometryFlagsKHR flags = default
	) {
		sType = TYPE;
		pNext = null;
		GeometryType = geometryType;
		Geometry = geometry;
		Flags = flags;
	}

	public readonly override bool Equals(object? o) => (o is VkGeometryNV s) && (this == s);
	readonly bool IEquatable<VkGeometryNV>.Equals(VkGeometryNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ GeometryType.GetHashCode() ^ Geometry.GetHashCode()
			^ Flags.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkGeometryNV l, in VkGeometryNV r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.GeometryType == r.GeometryType) && (l.Geometry == r.Geometry)
			&& (l.Flags == r.Flags)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkGeometryNV l, in VkGeometryNV r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.GeometryType != r.GeometryType) || (l.Geometry != r.Geometry)
			|| (l.Flags != r.Flags)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkGeometryNV s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkAccelerationStructureInfoNV : IEquatable<VkAccelerationStructureInfoNV>
{
	public const VkStructureType TYPE = VkStructureType.AccelerationStructureInfoNv;

	public VkStructureType sType;
	public void* pNext;
	public VkAccelerationStructureTypeNV Type;
	public VkBuildAccelerationStructureFlagsNV Flags;
	public uint InstanceCount;
	public uint GeometryCount;
	public VkGeometryNV* Geometries;

	public VkAccelerationStructureInfoNV(
		VkAccelerationStructureTypeNV type = default,
		VkBuildAccelerationStructureFlagsNV flags = default,
		uint instanceCount = default,
		uint geometryCount = default,
		VkGeometryNV* geometries = default
	) {
		sType = TYPE;
		pNext = null;
		Type = type;
		Flags = flags;
		InstanceCount = instanceCount;
		GeometryCount = geometryCount;
		Geometries = geometries;
	}

	public readonly override bool Equals(object? o) => (o is VkAccelerationStructureInfoNV s) && (this == s);
	readonly bool IEquatable<VkAccelerationStructureInfoNV>.Equals(VkAccelerationStructureInfoNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Type.GetHashCode() ^ Flags.GetHashCode()
			^ InstanceCount.GetHashCode() ^ GeometryCount.GetHashCode() ^ ((ulong)Geometries).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkAccelerationStructureInfoNV l, in VkAccelerationStructureInfoNV r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Type == r.Type) && (l.Flags == r.Flags)
			&& (l.InstanceCount == r.InstanceCount) && (l.GeometryCount == r.GeometryCount) && (l.Geometries == r.Geometries)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkAccelerationStructureInfoNV l, in VkAccelerationStructureInfoNV r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Type != r.Type) || (l.Flags != r.Flags)
			|| (l.InstanceCount != r.InstanceCount) || (l.GeometryCount != r.GeometryCount) || (l.Geometries != r.Geometries)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkAccelerationStructureInfoNV s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkAccelerationStructureCreateInfoNV : IEquatable<VkAccelerationStructureCreateInfoNV>
{
	public const VkStructureType TYPE = VkStructureType.AccelerationStructureCreateInfoNv;

	public VkStructureType sType;
	public void* pNext;
	public ulong CompactedSize;
	public VkAccelerationStructureInfoNV Info;

	public VkAccelerationStructureCreateInfoNV(
		ulong compactedSize = default,
		VkAccelerationStructureInfoNV info = default
	) {
		sType = TYPE;
		pNext = null;
		CompactedSize = compactedSize;
		Info = info;
	}

	public readonly override bool Equals(object? o) => (o is VkAccelerationStructureCreateInfoNV s) && (this == s);
	readonly bool IEquatable<VkAccelerationStructureCreateInfoNV>.Equals(VkAccelerationStructureCreateInfoNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ CompactedSize.GetHashCode() ^ Info.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkAccelerationStructureCreateInfoNV l, in VkAccelerationStructureCreateInfoNV r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.CompactedSize == r.CompactedSize) && (l.Info == r.Info)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkAccelerationStructureCreateInfoNV l, in VkAccelerationStructureCreateInfoNV r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.CompactedSize != r.CompactedSize) || (l.Info != r.Info)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkAccelerationStructureCreateInfoNV s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkBindAccelerationStructureMemoryInfoNV : IEquatable<VkBindAccelerationStructureMemoryInfoNV>
{
	public const VkStructureType TYPE = VkStructureType.BindAccelerationStructureMemoryInfoKhr;

	public VkStructureType sType;
	public void* pNext;
	public VulkanHandle<VkAccelerationStructureKHR> AccelerationStructure;
	public VulkanHandle<VkDeviceMemory> Memory;
	public ulong MemoryOffset;
	public uint DeviceIndexCount;
	public uint* DeviceIndices;

	public VkBindAccelerationStructureMemoryInfoNV(
		VulkanHandle<VkAccelerationStructureKHR> accelerationStructure = default,
		VulkanHandle<VkDeviceMemory> memory = default,
		ulong memoryOffset = default,
		uint deviceIndexCount = default,
		uint* deviceIndices = default
	) {
		sType = TYPE;
		pNext = null;
		AccelerationStructure = accelerationStructure;
		Memory = memory;
		MemoryOffset = memoryOffset;
		DeviceIndexCount = deviceIndexCount;
		DeviceIndices = deviceIndices;
	}

	public readonly override bool Equals(object? o) => (o is VkBindAccelerationStructureMemoryInfoNV s) && (this == s);
	readonly bool IEquatable<VkBindAccelerationStructureMemoryInfoNV>.Equals(VkBindAccelerationStructureMemoryInfoNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ AccelerationStructure.GetHashCode() ^ Memory.GetHashCode()
			^ MemoryOffset.GetHashCode() ^ DeviceIndexCount.GetHashCode() ^ ((ulong)DeviceIndices).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkBindAccelerationStructureMemoryInfoNV l, in VkBindAccelerationStructureMemoryInfoNV r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.AccelerationStructure == r.AccelerationStructure) && (l.Memory == r.Memory)
			&& (l.MemoryOffset == r.MemoryOffset) && (l.DeviceIndexCount == r.DeviceIndexCount) && (l.DeviceIndices == r.DeviceIndices)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkBindAccelerationStructureMemoryInfoNV l, in VkBindAccelerationStructureMemoryInfoNV r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.AccelerationStructure != r.AccelerationStructure) || (l.Memory != r.Memory)
			|| (l.MemoryOffset != r.MemoryOffset) || (l.DeviceIndexCount != r.DeviceIndexCount) || (l.DeviceIndices != r.DeviceIndices)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkBindAccelerationStructureMemoryInfoNV s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkWriteDescriptorSetAccelerationStructureNV : IEquatable<VkWriteDescriptorSetAccelerationStructureNV>
{
	public const VkStructureType TYPE = VkStructureType.WriteDescriptorSetAccelerationStructureKhr;

	public VkStructureType sType;
	public void* pNext;
	public uint AccelerationStructureCount;
	public VulkanHandle<VkAccelerationStructureKHR>* AccelerationStructures;

	public VkWriteDescriptorSetAccelerationStructureNV(
		uint accelerationStructureCount = default,
		VulkanHandle<VkAccelerationStructureKHR>* accelerationStructures = default
	) {
		sType = TYPE;
		pNext = null;
		AccelerationStructureCount = accelerationStructureCount;
		AccelerationStructures = accelerationStructures;
	}

	public readonly override bool Equals(object? o) => (o is VkWriteDescriptorSetAccelerationStructureNV s) && (this == s);
	readonly bool IEquatable<VkWriteDescriptorSetAccelerationStructureNV>.Equals(VkWriteDescriptorSetAccelerationStructureNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ AccelerationStructureCount.GetHashCode() ^ ((ulong)AccelerationStructures).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkWriteDescriptorSetAccelerationStructureNV l, in VkWriteDescriptorSetAccelerationStructureNV r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.AccelerationStructureCount == r.AccelerationStructureCount) && (l.AccelerationStructures == r.AccelerationStructures)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkWriteDescriptorSetAccelerationStructureNV l, in VkWriteDescriptorSetAccelerationStructureNV r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.AccelerationStructureCount != r.AccelerationStructureCount) || (l.AccelerationStructures != r.AccelerationStructures)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkWriteDescriptorSetAccelerationStructureNV s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkAccelerationStructureMemoryRequirementsInfoNV : IEquatable<VkAccelerationStructureMemoryRequirementsInfoNV>
{
	public const VkStructureType TYPE = VkStructureType.AccelerationStructureMemoryRequirementsInfoNv;

	public VkStructureType sType;
	public void* pNext;
	public VkAccelerationStructureMemoryRequirementsTypeNV Type;
	public VulkanHandle<VkAccelerationStructureNV> AccelerationStructure;

	public VkAccelerationStructureMemoryRequirementsInfoNV(
		VkAccelerationStructureMemoryRequirementsTypeNV type = default,
		VulkanHandle<VkAccelerationStructureNV> accelerationStructure = default
	) {
		sType = TYPE;
		pNext = null;
		Type = type;
		AccelerationStructure = accelerationStructure;
	}

	public readonly override bool Equals(object? o) => (o is VkAccelerationStructureMemoryRequirementsInfoNV s) && (this == s);
	readonly bool IEquatable<VkAccelerationStructureMemoryRequirementsInfoNV>.Equals(VkAccelerationStructureMemoryRequirementsInfoNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Type.GetHashCode() ^ AccelerationStructure.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkAccelerationStructureMemoryRequirementsInfoNV l, in VkAccelerationStructureMemoryRequirementsInfoNV r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Type == r.Type) && (l.AccelerationStructure == r.AccelerationStructure)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkAccelerationStructureMemoryRequirementsInfoNV l, in VkAccelerationStructureMemoryRequirementsInfoNV r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Type != r.Type) || (l.AccelerationStructure != r.AccelerationStructure)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkAccelerationStructureMemoryRequirementsInfoNV s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceRayTracingPropertiesNV : IEquatable<VkPhysicalDeviceRayTracingPropertiesNV>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceRayTracingPropertiesNv;

	public VkStructureType sType;
	public void* pNext;
	public uint ShaderGroupHandleSize;
	public uint MaxRecursionDepth;
	public uint MaxShaderGroupStride;
	public uint ShaderGroupBaseAlignment;
	public ulong MaxGeometryCount;
	public ulong MaxInstanceCount;
	public ulong MaxTriangleCount;
	public uint MaxDescriptorSetAccelerationStructures;

	public VkPhysicalDeviceRayTracingPropertiesNV(
		uint shaderGroupHandleSize = default,
		uint maxRecursionDepth = default,
		uint maxShaderGroupStride = default,
		uint shaderGroupBaseAlignment = default,
		ulong maxGeometryCount = default,
		ulong maxInstanceCount = default,
		ulong maxTriangleCount = default,
		uint maxDescriptorSetAccelerationStructures = default
	) {
		sType = TYPE;
		pNext = null;
		ShaderGroupHandleSize = shaderGroupHandleSize;
		MaxRecursionDepth = maxRecursionDepth;
		MaxShaderGroupStride = maxShaderGroupStride;
		ShaderGroupBaseAlignment = shaderGroupBaseAlignment;
		MaxGeometryCount = maxGeometryCount;
		MaxInstanceCount = maxInstanceCount;
		MaxTriangleCount = maxTriangleCount;
		MaxDescriptorSetAccelerationStructures = maxDescriptorSetAccelerationStructures;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceRayTracingPropertiesNV s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceRayTracingPropertiesNV>.Equals(VkPhysicalDeviceRayTracingPropertiesNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ShaderGroupHandleSize.GetHashCode() ^ MaxRecursionDepth.GetHashCode()
			^ MaxShaderGroupStride.GetHashCode() ^ ShaderGroupBaseAlignment.GetHashCode() ^ MaxGeometryCount.GetHashCode() ^ MaxInstanceCount.GetHashCode()
			^ MaxTriangleCount.GetHashCode() ^ MaxDescriptorSetAccelerationStructures.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceRayTracingPropertiesNV l, in VkPhysicalDeviceRayTracingPropertiesNV r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ShaderGroupHandleSize == r.ShaderGroupHandleSize) && (l.MaxRecursionDepth == r.MaxRecursionDepth)
			&& (l.MaxShaderGroupStride == r.MaxShaderGroupStride) && (l.ShaderGroupBaseAlignment == r.ShaderGroupBaseAlignment) && (l.MaxGeometryCount == r.MaxGeometryCount) && (l.MaxInstanceCount == r.MaxInstanceCount)
			&& (l.MaxTriangleCount == r.MaxTriangleCount) && (l.MaxDescriptorSetAccelerationStructures == r.MaxDescriptorSetAccelerationStructures)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceRayTracingPropertiesNV l, in VkPhysicalDeviceRayTracingPropertiesNV r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ShaderGroupHandleSize != r.ShaderGroupHandleSize) || (l.MaxRecursionDepth != r.MaxRecursionDepth)
			|| (l.MaxShaderGroupStride != r.MaxShaderGroupStride) || (l.ShaderGroupBaseAlignment != r.ShaderGroupBaseAlignment) || (l.MaxGeometryCount != r.MaxGeometryCount) || (l.MaxInstanceCount != r.MaxInstanceCount)
			|| (l.MaxTriangleCount != r.MaxTriangleCount) || (l.MaxDescriptorSetAccelerationStructures != r.MaxDescriptorSetAccelerationStructures)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceRayTracingPropertiesNV s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceCooperativeMatrixFeaturesNV : IEquatable<VkPhysicalDeviceCooperativeMatrixFeaturesNV>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceCooperativeMatrixFeaturesNv;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 CooperativeMatrix;
	public VkBool32 CooperativeMatrixRobustBufferAccess;

	public VkPhysicalDeviceCooperativeMatrixFeaturesNV(
		VkBool32 cooperativeMatrix = default,
		VkBool32 cooperativeMatrixRobustBufferAccess = default
	) {
		sType = TYPE;
		pNext = null;
		CooperativeMatrix = cooperativeMatrix;
		CooperativeMatrixRobustBufferAccess = cooperativeMatrixRobustBufferAccess;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceCooperativeMatrixFeaturesNV s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceCooperativeMatrixFeaturesNV>.Equals(VkPhysicalDeviceCooperativeMatrixFeaturesNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ CooperativeMatrix.GetHashCode() ^ CooperativeMatrixRobustBufferAccess.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceCooperativeMatrixFeaturesNV l, in VkPhysicalDeviceCooperativeMatrixFeaturesNV r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.CooperativeMatrix == r.CooperativeMatrix) && (l.CooperativeMatrixRobustBufferAccess == r.CooperativeMatrixRobustBufferAccess)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceCooperativeMatrixFeaturesNV l, in VkPhysicalDeviceCooperativeMatrixFeaturesNV r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.CooperativeMatrix != r.CooperativeMatrix) || (l.CooperativeMatrixRobustBufferAccess != r.CooperativeMatrixRobustBufferAccess)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceCooperativeMatrixFeaturesNV s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceCooperativeMatrixPropertiesNV : IEquatable<VkPhysicalDeviceCooperativeMatrixPropertiesNV>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceCooperativeMatrixPropertiesNv;

	public VkStructureType sType;
	public void* pNext;
	public VkShaderStageFlags CooperativeMatrixSupportedStages;

	public VkPhysicalDeviceCooperativeMatrixPropertiesNV(
		VkShaderStageFlags cooperativeMatrixSupportedStages = default
	) {
		sType = TYPE;
		pNext = null;
		CooperativeMatrixSupportedStages = cooperativeMatrixSupportedStages;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceCooperativeMatrixPropertiesNV s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceCooperativeMatrixPropertiesNV>.Equals(VkPhysicalDeviceCooperativeMatrixPropertiesNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ CooperativeMatrixSupportedStages.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceCooperativeMatrixPropertiesNV l, in VkPhysicalDeviceCooperativeMatrixPropertiesNV r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.CooperativeMatrixSupportedStages == r.CooperativeMatrixSupportedStages)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceCooperativeMatrixPropertiesNV l, in VkPhysicalDeviceCooperativeMatrixPropertiesNV r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.CooperativeMatrixSupportedStages != r.CooperativeMatrixSupportedStages)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceCooperativeMatrixPropertiesNV s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkCooperativeMatrixPropertiesNV : IEquatable<VkCooperativeMatrixPropertiesNV>
{
	public const VkStructureType TYPE = VkStructureType.CooperativeMatrixPropertiesNv;

	public VkStructureType sType;
	public void* pNext;
	public uint MSize;
	public uint NSize;
	public uint KSize;
	public VkComponentTypeNV AType;
	public VkComponentTypeNV BType;
	public VkComponentTypeNV CType;
	public VkComponentTypeNV DType;
	public VkScopeNV Scope;

	public VkCooperativeMatrixPropertiesNV(
		uint mSize = default,
		uint nSize = default,
		uint kSize = default,
		VkComponentTypeNV aType = default,
		VkComponentTypeNV bType = default,
		VkComponentTypeNV cType = default,
		VkComponentTypeNV dType = default,
		VkScopeNV scope = default
	) {
		sType = TYPE;
		pNext = null;
		MSize = mSize;
		NSize = nSize;
		KSize = kSize;
		AType = aType;
		BType = bType;
		CType = cType;
		DType = dType;
		Scope = scope;
	}

	public readonly override bool Equals(object? o) => (o is VkCooperativeMatrixPropertiesNV s) && (this == s);
	readonly bool IEquatable<VkCooperativeMatrixPropertiesNV>.Equals(VkCooperativeMatrixPropertiesNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MSize.GetHashCode() ^ NSize.GetHashCode()
			^ KSize.GetHashCode() ^ AType.GetHashCode() ^ BType.GetHashCode() ^ CType.GetHashCode()
			^ DType.GetHashCode() ^ Scope.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkCooperativeMatrixPropertiesNV l, in VkCooperativeMatrixPropertiesNV r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MSize == r.MSize) && (l.NSize == r.NSize)
			&& (l.KSize == r.KSize) && (l.AType == r.AType) && (l.BType == r.BType) && (l.CType == r.CType)
			&& (l.DType == r.DType) && (l.Scope == r.Scope)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkCooperativeMatrixPropertiesNV l, in VkCooperativeMatrixPropertiesNV r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MSize != r.MSize) || (l.NSize != r.NSize)
			|| (l.KSize != r.KSize) || (l.AType != r.AType) || (l.BType != r.BType) || (l.CType != r.CType)
			|| (l.DType != r.DType) || (l.Scope != r.Scope)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkCooperativeMatrixPropertiesNV s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceCoverageReductionModeFeaturesNV : IEquatable<VkPhysicalDeviceCoverageReductionModeFeaturesNV>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceCoverageReductionModeFeaturesNv;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 CoverageReductionMode;

	public VkPhysicalDeviceCoverageReductionModeFeaturesNV(
		VkBool32 coverageReductionMode = default
	) {
		sType = TYPE;
		pNext = null;
		CoverageReductionMode = coverageReductionMode;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceCoverageReductionModeFeaturesNV s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceCoverageReductionModeFeaturesNV>.Equals(VkPhysicalDeviceCoverageReductionModeFeaturesNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ CoverageReductionMode.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceCoverageReductionModeFeaturesNV l, in VkPhysicalDeviceCoverageReductionModeFeaturesNV r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.CoverageReductionMode == r.CoverageReductionMode)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceCoverageReductionModeFeaturesNV l, in VkPhysicalDeviceCoverageReductionModeFeaturesNV r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.CoverageReductionMode != r.CoverageReductionMode)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceCoverageReductionModeFeaturesNV s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPipelineCoverageReductionStateCreateInfoNV : IEquatable<VkPipelineCoverageReductionStateCreateInfoNV>
{
	public const VkStructureType TYPE = VkStructureType.PipelineCoverageReductionStateCreateInfoNv;

	public VkStructureType sType;
	public void* pNext;
	public VkPipelineCoverageReductionStateCreateFlagsNV Flags;
	public VkCoverageReductionModeNV CoverageReductionMode;

	public VkPipelineCoverageReductionStateCreateInfoNV(
		VkPipelineCoverageReductionStateCreateFlagsNV flags = default,
		VkCoverageReductionModeNV coverageReductionMode = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		CoverageReductionMode = coverageReductionMode;
	}

	public readonly override bool Equals(object? o) => (o is VkPipelineCoverageReductionStateCreateInfoNV s) && (this == s);
	readonly bool IEquatable<VkPipelineCoverageReductionStateCreateInfoNV>.Equals(VkPipelineCoverageReductionStateCreateInfoNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ CoverageReductionMode.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPipelineCoverageReductionStateCreateInfoNV l, in VkPipelineCoverageReductionStateCreateInfoNV r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.CoverageReductionMode == r.CoverageReductionMode)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPipelineCoverageReductionStateCreateInfoNV l, in VkPipelineCoverageReductionStateCreateInfoNV r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.CoverageReductionMode != r.CoverageReductionMode)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPipelineCoverageReductionStateCreateInfoNV s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkFramebufferMixedSamplesCombinationNV : IEquatable<VkFramebufferMixedSamplesCombinationNV>
{
	public const VkStructureType TYPE = VkStructureType.FramebufferMixedSamplesCombinationNv;

	public VkStructureType sType;
	public void* pNext;
	public VkCoverageReductionModeNV CoverageReductionMode;
	public VkSampleCountFlags RasterizationSamples;
	public VkSampleCountFlags DepthStencilSamples;
	public VkSampleCountFlags ColorSamples;

	public VkFramebufferMixedSamplesCombinationNV(
		VkCoverageReductionModeNV coverageReductionMode = default,
		VkSampleCountFlags rasterizationSamples = default,
		VkSampleCountFlags depthStencilSamples = default,
		VkSampleCountFlags colorSamples = default
	) {
		sType = TYPE;
		pNext = null;
		CoverageReductionMode = coverageReductionMode;
		RasterizationSamples = rasterizationSamples;
		DepthStencilSamples = depthStencilSamples;
		ColorSamples = colorSamples;
	}

	public readonly override bool Equals(object? o) => (o is VkFramebufferMixedSamplesCombinationNV s) && (this == s);
	readonly bool IEquatable<VkFramebufferMixedSamplesCombinationNV>.Equals(VkFramebufferMixedSamplesCombinationNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ CoverageReductionMode.GetHashCode() ^ RasterizationSamples.GetHashCode()
			^ DepthStencilSamples.GetHashCode() ^ ColorSamples.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkFramebufferMixedSamplesCombinationNV l, in VkFramebufferMixedSamplesCombinationNV r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.CoverageReductionMode == r.CoverageReductionMode) && (l.RasterizationSamples == r.RasterizationSamples)
			&& (l.DepthStencilSamples == r.DepthStencilSamples) && (l.ColorSamples == r.ColorSamples)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkFramebufferMixedSamplesCombinationNV l, in VkFramebufferMixedSamplesCombinationNV r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.CoverageReductionMode != r.CoverageReductionMode) || (l.RasterizationSamples != r.RasterizationSamples)
			|| (l.DepthStencilSamples != r.DepthStencilSamples) || (l.ColorSamples != r.ColorSamples)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkFramebufferMixedSamplesCombinationNV s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceShaderSMBuiltinsPropertiesNV : IEquatable<VkPhysicalDeviceShaderSMBuiltinsPropertiesNV>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceShaderSmBuiltinsPropertiesNv;

	public VkStructureType sType;
	public void* pNext;
	public uint ShaderSMCount;
	public uint ShaderWarpsPerSM;

	public VkPhysicalDeviceShaderSMBuiltinsPropertiesNV(
		uint shaderSMCount = default,
		uint shaderWarpsPerSM = default
	) {
		sType = TYPE;
		pNext = null;
		ShaderSMCount = shaderSMCount;
		ShaderWarpsPerSM = shaderWarpsPerSM;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceShaderSMBuiltinsPropertiesNV s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceShaderSMBuiltinsPropertiesNV>.Equals(VkPhysicalDeviceShaderSMBuiltinsPropertiesNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ShaderSMCount.GetHashCode() ^ ShaderWarpsPerSM.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceShaderSMBuiltinsPropertiesNV l, in VkPhysicalDeviceShaderSMBuiltinsPropertiesNV r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ShaderSMCount == r.ShaderSMCount) && (l.ShaderWarpsPerSM == r.ShaderWarpsPerSM)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceShaderSMBuiltinsPropertiesNV l, in VkPhysicalDeviceShaderSMBuiltinsPropertiesNV r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ShaderSMCount != r.ShaderSMCount) || (l.ShaderWarpsPerSM != r.ShaderWarpsPerSM)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceShaderSMBuiltinsPropertiesNV s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceShaderSMBuiltinsFeaturesNV : IEquatable<VkPhysicalDeviceShaderSMBuiltinsFeaturesNV>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceShaderSmBuiltinsFeaturesNv;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 ShaderSMBuiltins;

	public VkPhysicalDeviceShaderSMBuiltinsFeaturesNV(
		VkBool32 shaderSMBuiltins = default
	) {
		sType = TYPE;
		pNext = null;
		ShaderSMBuiltins = shaderSMBuiltins;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceShaderSMBuiltinsFeaturesNV s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceShaderSMBuiltinsFeaturesNV>.Equals(VkPhysicalDeviceShaderSMBuiltinsFeaturesNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ShaderSMBuiltins.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceShaderSMBuiltinsFeaturesNV l, in VkPhysicalDeviceShaderSMBuiltinsFeaturesNV r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ShaderSMBuiltins == r.ShaderSMBuiltins)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceShaderSMBuiltinsFeaturesNV l, in VkPhysicalDeviceShaderSMBuiltinsFeaturesNV r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ShaderSMBuiltins != r.ShaderSMBuiltins)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceShaderSMBuiltinsFeaturesNV s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkAabbPositionsNV : IEquatable<VkAabbPositionsNV>
{
	public float MinX;
	public float MinY;
	public float MinZ;
	public float MaxX;
	public float MaxY;
	public float MaxZ;

	public VkAabbPositionsNV(
		float minX = default,
		float minY = default,
		float minZ = default,
		float maxX = default,
		float maxY = default,
		float maxZ = default
	) {
		MinX = minX;
		MinY = minY;
		MinZ = minZ;
		MaxX = maxX;
		MaxY = maxY;
		MaxZ = maxZ;
	}

	public readonly override bool Equals(object? o) => (o is VkAabbPositionsNV s) && (this == s);
	readonly bool IEquatable<VkAabbPositionsNV>.Equals(VkAabbPositionsNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			MinX.GetHashCode() ^ MinY.GetHashCode() ^ MinZ.GetHashCode() ^ MaxX.GetHashCode()
			^ MaxY.GetHashCode() ^ MaxZ.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkAabbPositionsNV l, in VkAabbPositionsNV r)
	{
		return
			(l.MinX == r.MinX) && (l.MinY == r.MinY) && (l.MinZ == r.MinZ) && (l.MaxX == r.MaxX)
			&& (l.MaxY == r.MaxY) && (l.MaxZ == r.MaxZ)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkAabbPositionsNV l, in VkAabbPositionsNV r)
	{
		return
			(l.MinX != r.MinX) || (l.MinY != r.MinY) || (l.MinZ != r.MinZ) || (l.MaxX != r.MaxX)
			|| (l.MaxY != r.MaxY) || (l.MaxZ != r.MaxZ)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkAabbPositionsNV s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkTransformMatrixNV : IEquatable<VkTransformMatrixNV>
{
	public fixed float Matrix[12];

	public VkTransformMatrixNV(
		float matrix_0 = default,
		float matrix_1 = default,
		float matrix_2 = default,
		float matrix_3 = default,
		float matrix_4 = default,
		float matrix_5 = default,
		float matrix_6 = default,
		float matrix_7 = default,
		float matrix_8 = default,
		float matrix_9 = default,
		float matrix_10 = default,
		float matrix_11 = default
	) {
		Matrix[0] = matrix_0;
		Matrix[1] = matrix_1;
		Matrix[2] = matrix_2;
		Matrix[3] = matrix_3;
		Matrix[4] = matrix_4;
		Matrix[5] = matrix_5;
		Matrix[6] = matrix_6;
		Matrix[7] = matrix_7;
		Matrix[8] = matrix_8;
		Matrix[9] = matrix_9;
		Matrix[10] = matrix_10;
		Matrix[11] = matrix_11;
	}

	public readonly override bool Equals(object? o) => (o is VkTransformMatrixNV s) && (this == s);
	readonly bool IEquatable<VkTransformMatrixNV>.Equals(VkTransformMatrixNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Matrix[0].GetHashCode() ^ Matrix[1].GetHashCode() ^ Matrix[2].GetHashCode() ^ Matrix[3].GetHashCode()
			^ Matrix[4].GetHashCode() ^ Matrix[5].GetHashCode() ^ Matrix[6].GetHashCode() ^ Matrix[7].GetHashCode()
			^ Matrix[8].GetHashCode() ^ Matrix[9].GetHashCode() ^ Matrix[10].GetHashCode() ^ Matrix[11].GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkTransformMatrixNV l, in VkTransformMatrixNV r)
	{
		return
			(l.Matrix[0] == r.Matrix[0]) && (l.Matrix[1] == r.Matrix[1]) && (l.Matrix[2] == r.Matrix[2]) && (l.Matrix[3] == r.Matrix[3])
			&& (l.Matrix[4] == r.Matrix[4]) && (l.Matrix[5] == r.Matrix[5]) && (l.Matrix[6] == r.Matrix[6]) && (l.Matrix[7] == r.Matrix[7])
			&& (l.Matrix[8] == r.Matrix[8]) && (l.Matrix[9] == r.Matrix[9]) && (l.Matrix[10] == r.Matrix[10]) && (l.Matrix[11] == r.Matrix[11])
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkTransformMatrixNV l, in VkTransformMatrixNV r)
	{
		return
			(l.Matrix[0] != r.Matrix[0]) || (l.Matrix[1] != r.Matrix[1]) || (l.Matrix[2] != r.Matrix[2]) || (l.Matrix[3] != r.Matrix[3])
			|| (l.Matrix[4] != r.Matrix[4]) || (l.Matrix[5] != r.Matrix[5]) || (l.Matrix[6] != r.Matrix[6]) || (l.Matrix[7] != r.Matrix[7])
			|| (l.Matrix[8] != r.Matrix[8]) || (l.Matrix[9] != r.Matrix[9]) || (l.Matrix[10] != r.Matrix[10]) || (l.Matrix[11] != r.Matrix[11])
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkTransformMatrixNV s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkAccelerationStructureInstanceNV : IEquatable<VkAccelerationStructureInstanceNV>
{
	public VkTransformMatrixKHR Transform;
	public uint InstanceCustomIndex;
	public uint Mask;
	public uint InstanceShaderBindingTableRecordOffset;
	public VkGeometryInstanceFlagsKHR Flags;
	public ulong AccelerationStructureReference;

	public VkAccelerationStructureInstanceNV(
		VkTransformMatrixKHR transform = default,
		uint instanceCustomIndex = default,
		uint mask = default,
		uint instanceShaderBindingTableRecordOffset = default,
		VkGeometryInstanceFlagsKHR flags = default,
		ulong accelerationStructureReference = default
	) {
		Transform = transform;
		InstanceCustomIndex = instanceCustomIndex;
		Mask = mask;
		InstanceShaderBindingTableRecordOffset = instanceShaderBindingTableRecordOffset;
		Flags = flags;
		AccelerationStructureReference = accelerationStructureReference;
	}

	public readonly override bool Equals(object? o) => (o is VkAccelerationStructureInstanceNV s) && (this == s);
	readonly bool IEquatable<VkAccelerationStructureInstanceNV>.Equals(VkAccelerationStructureInstanceNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Transform.GetHashCode() ^ InstanceCustomIndex.GetHashCode() ^ Mask.GetHashCode() ^ InstanceShaderBindingTableRecordOffset.GetHashCode()
			^ Flags.GetHashCode() ^ AccelerationStructureReference.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkAccelerationStructureInstanceNV l, in VkAccelerationStructureInstanceNV r)
	{
		return
			(l.Transform == r.Transform) && (l.InstanceCustomIndex == r.InstanceCustomIndex) && (l.Mask == r.Mask) && (l.InstanceShaderBindingTableRecordOffset == r.InstanceShaderBindingTableRecordOffset)
			&& (l.Flags == r.Flags) && (l.AccelerationStructureReference == r.AccelerationStructureReference)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkAccelerationStructureInstanceNV l, in VkAccelerationStructureInstanceNV r)
	{
		return
			(l.Transform != r.Transform) || (l.InstanceCustomIndex != r.InstanceCustomIndex) || (l.Mask != r.Mask) || (l.InstanceShaderBindingTableRecordOffset != r.InstanceShaderBindingTableRecordOffset)
			|| (l.Flags != r.Flags) || (l.AccelerationStructureReference != r.AccelerationStructureReference)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkAccelerationStructureInstanceNV s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceDiagnosticsConfigFeaturesNV : IEquatable<VkPhysicalDeviceDiagnosticsConfigFeaturesNV>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceDiagnosticsConfigFeaturesNv;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 DiagnosticsConfig;

	public VkPhysicalDeviceDiagnosticsConfigFeaturesNV(
		VkBool32 diagnosticsConfig = default
	) {
		sType = TYPE;
		pNext = null;
		DiagnosticsConfig = diagnosticsConfig;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceDiagnosticsConfigFeaturesNV s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceDiagnosticsConfigFeaturesNV>.Equals(VkPhysicalDeviceDiagnosticsConfigFeaturesNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DiagnosticsConfig.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceDiagnosticsConfigFeaturesNV l, in VkPhysicalDeviceDiagnosticsConfigFeaturesNV r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DiagnosticsConfig == r.DiagnosticsConfig)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceDiagnosticsConfigFeaturesNV l, in VkPhysicalDeviceDiagnosticsConfigFeaturesNV r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DiagnosticsConfig != r.DiagnosticsConfig)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceDiagnosticsConfigFeaturesNV s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDeviceDiagnosticsConfigCreateInfoNV : IEquatable<VkDeviceDiagnosticsConfigCreateInfoNV>
{
	public const VkStructureType TYPE = VkStructureType.DeviceDiagnosticsConfigCreateInfoNv;

	public VkStructureType sType;
	public void* pNext;
	public VkDeviceDiagnosticsConfigFlagsNV Flags;

	public VkDeviceDiagnosticsConfigCreateInfoNV(
		VkDeviceDiagnosticsConfigFlagsNV flags = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
	}

	public readonly override bool Equals(object? o) => (o is VkDeviceDiagnosticsConfigCreateInfoNV s) && (this == s);
	readonly bool IEquatable<VkDeviceDiagnosticsConfigCreateInfoNV>.Equals(VkDeviceDiagnosticsConfigCreateInfoNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDeviceDiagnosticsConfigCreateInfoNV l, in VkDeviceDiagnosticsConfigCreateInfoNV r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDeviceDiagnosticsConfigCreateInfoNV l, in VkDeviceDiagnosticsConfigCreateInfoNV r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDeviceDiagnosticsConfigCreateInfoNV s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV : IEquatable<VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceFragmentShadingRateEnumsFeaturesNv;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 FragmentShadingRateEnums;
	public VkBool32 SupersampleFragmentShadingRates;
	public VkBool32 NoInvocationFragmentShadingRates;

	public VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV(
		VkBool32 fragmentShadingRateEnums = default,
		VkBool32 supersampleFragmentShadingRates = default,
		VkBool32 noInvocationFragmentShadingRates = default
	) {
		sType = TYPE;
		pNext = null;
		FragmentShadingRateEnums = fragmentShadingRateEnums;
		SupersampleFragmentShadingRates = supersampleFragmentShadingRates;
		NoInvocationFragmentShadingRates = noInvocationFragmentShadingRates;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV>.Equals(VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ FragmentShadingRateEnums.GetHashCode() ^ SupersampleFragmentShadingRates.GetHashCode()
			^ NoInvocationFragmentShadingRates.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV l, in VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.FragmentShadingRateEnums == r.FragmentShadingRateEnums) && (l.SupersampleFragmentShadingRates == r.SupersampleFragmentShadingRates)
			&& (l.NoInvocationFragmentShadingRates == r.NoInvocationFragmentShadingRates)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV l, in VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.FragmentShadingRateEnums != r.FragmentShadingRateEnums) || (l.SupersampleFragmentShadingRates != r.SupersampleFragmentShadingRates)
			|| (l.NoInvocationFragmentShadingRates != r.NoInvocationFragmentShadingRates)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV : IEquatable<VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceFragmentShadingRateEnumsPropertiesNv;

	public VkStructureType sType;
	public void* pNext;
	public VkSampleCountFlags MaxFragmentShadingRateInvocationCount;

	public VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV(
		VkSampleCountFlags maxFragmentShadingRateInvocationCount = default
	) {
		sType = TYPE;
		pNext = null;
		MaxFragmentShadingRateInvocationCount = maxFragmentShadingRateInvocationCount;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV>.Equals(VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MaxFragmentShadingRateInvocationCount.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV l, in VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MaxFragmentShadingRateInvocationCount == r.MaxFragmentShadingRateInvocationCount)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV l, in VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MaxFragmentShadingRateInvocationCount != r.MaxFragmentShadingRateInvocationCount)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPipelineFragmentShadingRateEnumStateCreateInfoNV : IEquatable<VkPipelineFragmentShadingRateEnumStateCreateInfoNV>
{
	public const VkStructureType TYPE = VkStructureType.PipelineFragmentShadingRateEnumStateCreateInfoNv;

	public VkStructureType sType;
	public void* pNext;
	public VkFragmentShadingRateTypeNV ShadingRateType;
	public VkFragmentShadingRateNV ShadingRate;
	public VkFragmentShadingRateCombinerOpKHR CombinerOps_0;
	public VkFragmentShadingRateCombinerOpKHR CombinerOps_1;

	public VkPipelineFragmentShadingRateEnumStateCreateInfoNV(
		VkFragmentShadingRateTypeNV shadingRateType = default,
		VkFragmentShadingRateNV shadingRate = default,
		VkFragmentShadingRateCombinerOpKHR combinerOps_0 = default,
		VkFragmentShadingRateCombinerOpKHR combinerOps_1 = default
	) {
		sType = TYPE;
		pNext = null;
		ShadingRateType = shadingRateType;
		ShadingRate = shadingRate;
		CombinerOps_0 = combinerOps_0;
		CombinerOps_1 = combinerOps_1;
	}

	public readonly override bool Equals(object? o) => (o is VkPipelineFragmentShadingRateEnumStateCreateInfoNV s) && (this == s);
	readonly bool IEquatable<VkPipelineFragmentShadingRateEnumStateCreateInfoNV>.Equals(VkPipelineFragmentShadingRateEnumStateCreateInfoNV o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ShadingRateType.GetHashCode() ^ ShadingRate.GetHashCode()
			^ CombinerOps_0.GetHashCode() ^ CombinerOps_1.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPipelineFragmentShadingRateEnumStateCreateInfoNV l, in VkPipelineFragmentShadingRateEnumStateCreateInfoNV r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ShadingRateType == r.ShadingRateType) && (l.ShadingRate == r.ShadingRate)
			&& (l.CombinerOps_0 == r.CombinerOps_0) && (l.CombinerOps_1 == r.CombinerOps_1)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPipelineFragmentShadingRateEnumStateCreateInfoNV l, in VkPipelineFragmentShadingRateEnumStateCreateInfoNV r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ShadingRateType != r.ShadingRateType) || (l.ShadingRate != r.ShadingRate)
			|| (l.CombinerOps_0 != r.CombinerOps_0) || (l.CombinerOps_1 != r.CombinerOps_1)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPipelineFragmentShadingRateEnumStateCreateInfoNV s) => s = new() { sType = TYPE };
}


} // namespace Vulkan

