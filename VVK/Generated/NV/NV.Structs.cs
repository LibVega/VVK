/*
 * MIT License - Copyright(c) 2020 Sean Moss
 * This file is subject to the terms and conditions of the MIT License, the text of which can be found in the 'LICENSE'
 * file at the root of this repository, or online at<https://opensource.org/licenses/MIT>.
 */

/// This file was generated by VVKGen. Edits to this file will be lost on next generation.

using System;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;


namespace Vk.NV
{

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DedicatedAllocationImageCreateInfo : IEquatable<DedicatedAllocationImageCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DedicatedAllocationImageCreateInfoNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 DedicatedAllocation;

	public readonly override bool Equals(object? obj) => (obj is DedicatedAllocationImageCreateInfo o) && (this == o);
	readonly bool IEquatable<DedicatedAllocationImageCreateInfo>.Equals(DedicatedAllocationImageCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DedicatedAllocation.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DedicatedAllocationImageCreateInfo l, in DedicatedAllocationImageCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DedicatedAllocation == r.DedicatedAllocation)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DedicatedAllocationImageCreateInfo l, in DedicatedAllocationImageCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DedicatedAllocation != r.DedicatedAllocation)
			;
	}


	/// <summary>Creates a new DedicatedAllocationImageCreateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DedicatedAllocationImageCreateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref DedicatedAllocationImageCreateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DedicatedAllocationBufferCreateInfo : IEquatable<DedicatedAllocationBufferCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DedicatedAllocationBufferCreateInfoNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 DedicatedAllocation;

	public readonly override bool Equals(object? obj) => (obj is DedicatedAllocationBufferCreateInfo o) && (this == o);
	readonly bool IEquatable<DedicatedAllocationBufferCreateInfo>.Equals(DedicatedAllocationBufferCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DedicatedAllocation.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DedicatedAllocationBufferCreateInfo l, in DedicatedAllocationBufferCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DedicatedAllocation == r.DedicatedAllocation)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DedicatedAllocationBufferCreateInfo l, in DedicatedAllocationBufferCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DedicatedAllocation != r.DedicatedAllocation)
			;
	}


	/// <summary>Creates a new DedicatedAllocationBufferCreateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DedicatedAllocationBufferCreateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref DedicatedAllocationBufferCreateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DedicatedAllocationMemoryAllocateInfo : IEquatable<DedicatedAllocationMemoryAllocateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DedicatedAllocationMemoryAllocateInfoNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Handle<Vk.Image> Image;
	public Vk.Handle<Vk.Buffer> Buffer;

	public readonly override bool Equals(object? obj) => (obj is DedicatedAllocationMemoryAllocateInfo o) && (this == o);
	readonly bool IEquatable<DedicatedAllocationMemoryAllocateInfo>.Equals(DedicatedAllocationMemoryAllocateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Image.GetHashCode() ^ Buffer.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DedicatedAllocationMemoryAllocateInfo l, in DedicatedAllocationMemoryAllocateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Image == r.Image) && (l.Buffer == r.Buffer)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DedicatedAllocationMemoryAllocateInfo l, in DedicatedAllocationMemoryAllocateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Image != r.Image) || (l.Buffer != r.Buffer)
			;
	}


	/// <summary>Creates a new DedicatedAllocationMemoryAllocateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DedicatedAllocationMemoryAllocateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref DedicatedAllocationMemoryAllocateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ExternalImageFormatProperties : IEquatable<ExternalImageFormatProperties>
{
	public Vk.ImageFormatProperties ImageFormatProperties;
	public Vk.NV.ExternalMemoryFeatureFlags ExternalMemoryFeatures;
	public Vk.NV.ExternalMemoryHandleTypeFlags ExportFromImportedHandleTypes;
	public Vk.NV.ExternalMemoryHandleTypeFlags CompatibleHandleTypes;

	public readonly override bool Equals(object? obj) => (obj is ExternalImageFormatProperties o) && (this == o);
	readonly bool IEquatable<ExternalImageFormatProperties>.Equals(ExternalImageFormatProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			ImageFormatProperties.GetHashCode() ^ ExternalMemoryFeatures.GetHashCode() ^ ExportFromImportedHandleTypes.GetHashCode() ^ CompatibleHandleTypes.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ExternalImageFormatProperties l, in ExternalImageFormatProperties r)
	{
		return
			(l.ImageFormatProperties == r.ImageFormatProperties) && (l.ExternalMemoryFeatures == r.ExternalMemoryFeatures) && (l.ExportFromImportedHandleTypes == r.ExportFromImportedHandleTypes) && (l.CompatibleHandleTypes == r.CompatibleHandleTypes)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ExternalImageFormatProperties l, in ExternalImageFormatProperties r)
	{
		return
			(l.ImageFormatProperties != r.ImageFormatProperties) || (l.ExternalMemoryFeatures != r.ExternalMemoryFeatures) || (l.ExportFromImportedHandleTypes != r.ExportFromImportedHandleTypes) || (l.CompatibleHandleTypes != r.CompatibleHandleTypes)
			;
	}

}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ExternalMemoryImageCreateInfo : IEquatable<ExternalMemoryImageCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ExternalMemoryImageCreateInfoNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.NV.ExternalMemoryHandleTypeFlags HandleTypes;

	public readonly override bool Equals(object? obj) => (obj is ExternalMemoryImageCreateInfo o) && (this == o);
	readonly bool IEquatable<ExternalMemoryImageCreateInfo>.Equals(ExternalMemoryImageCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ HandleTypes.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ExternalMemoryImageCreateInfo l, in ExternalMemoryImageCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.HandleTypes == r.HandleTypes)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ExternalMemoryImageCreateInfo l, in ExternalMemoryImageCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.HandleTypes != r.HandleTypes)
			;
	}


	/// <summary>Creates a new ExternalMemoryImageCreateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ExternalMemoryImageCreateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref ExternalMemoryImageCreateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ExportMemoryAllocateInfo : IEquatable<ExportMemoryAllocateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ExportMemoryAllocateInfoNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.NV.ExternalMemoryHandleTypeFlags HandleTypes;

	public readonly override bool Equals(object? obj) => (obj is ExportMemoryAllocateInfo o) && (this == o);
	readonly bool IEquatable<ExportMemoryAllocateInfo>.Equals(ExportMemoryAllocateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ HandleTypes.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ExportMemoryAllocateInfo l, in ExportMemoryAllocateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.HandleTypes == r.HandleTypes)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ExportMemoryAllocateInfo l, in ExportMemoryAllocateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.HandleTypes != r.HandleTypes)
			;
	}


	/// <summary>Creates a new ExportMemoryAllocateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ExportMemoryAllocateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref ExportMemoryAllocateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ImportMemoryWin32HandleInfo : IEquatable<ImportMemoryWin32HandleInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ImportMemoryWin32HandleInfoNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.NV.ExternalMemoryHandleTypeFlags HandleType;
	public void* Handle;

	public readonly override bool Equals(object? obj) => (obj is ImportMemoryWin32HandleInfo o) && (this == o);
	readonly bool IEquatable<ImportMemoryWin32HandleInfo>.Equals(ImportMemoryWin32HandleInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ HandleType.GetHashCode() ^ ((ulong)Handle).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ImportMemoryWin32HandleInfo l, in ImportMemoryWin32HandleInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.HandleType == r.HandleType) && (l.Handle == r.Handle)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ImportMemoryWin32HandleInfo l, in ImportMemoryWin32HandleInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.HandleType != r.HandleType) || (l.Handle != r.Handle)
			;
	}


	/// <summary>Creates a new ImportMemoryWin32HandleInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ImportMemoryWin32HandleInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref ImportMemoryWin32HandleInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ExportMemoryWin32HandleInfo : IEquatable<ExportMemoryWin32HandleInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ExportMemoryWin32HandleInfoNV;

	public Vk.StructureType sType;
	public void* pNext;
	public void* Attributes;
	public uint DwAccess;

	public readonly override bool Equals(object? obj) => (obj is ExportMemoryWin32HandleInfo o) && (this == o);
	readonly bool IEquatable<ExportMemoryWin32HandleInfo>.Equals(ExportMemoryWin32HandleInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ((ulong)Attributes).GetHashCode() ^ DwAccess.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ExportMemoryWin32HandleInfo l, in ExportMemoryWin32HandleInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Attributes == r.Attributes) && (l.DwAccess == r.DwAccess)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ExportMemoryWin32HandleInfo l, in ExportMemoryWin32HandleInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Attributes != r.Attributes) || (l.DwAccess != r.DwAccess)
			;
	}


	/// <summary>Creates a new ExportMemoryWin32HandleInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ExportMemoryWin32HandleInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref ExportMemoryWin32HandleInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct Win32KeyedMutexAcquireReleaseInfo : IEquatable<Win32KeyedMutexAcquireReleaseInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.Win32KeyedMutexAcquireReleaseInfoNV;

	public Vk.StructureType sType;
	public void* pNext;
	public uint AcquireCount;
	public Vk.Handle<Vk.DeviceMemory>* AcquireSyncs;
	public ulong* AcquireKeys;
	public uint* AcquireTimeoutMilliseconds;
	public uint ReleaseCount;
	public Vk.Handle<Vk.DeviceMemory>* ReleaseSyncs;
	public ulong* ReleaseKeys;

	public readonly override bool Equals(object? obj) => (obj is Win32KeyedMutexAcquireReleaseInfo o) && (this == o);
	readonly bool IEquatable<Win32KeyedMutexAcquireReleaseInfo>.Equals(Win32KeyedMutexAcquireReleaseInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ AcquireCount.GetHashCode() ^ ((ulong)AcquireSyncs).GetHashCode()
			^ ((ulong)AcquireKeys).GetHashCode() ^ ((ulong)AcquireTimeoutMilliseconds).GetHashCode() ^ ReleaseCount.GetHashCode() ^ ((ulong)ReleaseSyncs).GetHashCode()
			^ ((ulong)ReleaseKeys).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in Win32KeyedMutexAcquireReleaseInfo l, in Win32KeyedMutexAcquireReleaseInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.AcquireCount == r.AcquireCount) && (l.AcquireSyncs == r.AcquireSyncs)
			&& (l.AcquireKeys == r.AcquireKeys) && (l.AcquireTimeoutMilliseconds == r.AcquireTimeoutMilliseconds) && (l.ReleaseCount == r.ReleaseCount) && (l.ReleaseSyncs == r.ReleaseSyncs)
			&& (l.ReleaseKeys == r.ReleaseKeys)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in Win32KeyedMutexAcquireReleaseInfo l, in Win32KeyedMutexAcquireReleaseInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.AcquireCount != r.AcquireCount) || (l.AcquireSyncs != r.AcquireSyncs)
			|| (l.AcquireKeys != r.AcquireKeys) || (l.AcquireTimeoutMilliseconds != r.AcquireTimeoutMilliseconds) || (l.ReleaseCount != r.ReleaseCount) || (l.ReleaseSyncs != r.ReleaseSyncs)
			|| (l.ReleaseKeys != r.ReleaseKeys)
			;
	}


	/// <summary>Creates a new Win32KeyedMutexAcquireReleaseInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out Win32KeyedMutexAcquireReleaseInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref Win32KeyedMutexAcquireReleaseInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceDeviceGeneratedCommandsFeatures : IEquatable<PhysicalDeviceDeviceGeneratedCommandsFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceDeviceGeneratedCommandsFeaturesNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 DeviceGeneratedCommands;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceDeviceGeneratedCommandsFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceDeviceGeneratedCommandsFeatures>.Equals(PhysicalDeviceDeviceGeneratedCommandsFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DeviceGeneratedCommands.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceDeviceGeneratedCommandsFeatures l, in PhysicalDeviceDeviceGeneratedCommandsFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DeviceGeneratedCommands == r.DeviceGeneratedCommands)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceDeviceGeneratedCommandsFeatures l, in PhysicalDeviceDeviceGeneratedCommandsFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DeviceGeneratedCommands != r.DeviceGeneratedCommands)
			;
	}


	/// <summary>Creates a new PhysicalDeviceDeviceGeneratedCommandsFeatures value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceDeviceGeneratedCommandsFeatures value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceDeviceGeneratedCommandsFeatures value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceDeviceGeneratedCommandsProperties : IEquatable<PhysicalDeviceDeviceGeneratedCommandsProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceDeviceGeneratedCommandsPropertiesNV;

	public Vk.StructureType sType;
	public void* pNext;
	public uint MaxGraphicsShaderGroupCount;
	public uint MaxIndirectSequenceCount;
	public uint MaxIndirectCommandsTokenCount;
	public uint MaxIndirectCommandsStreamCount;
	public uint MaxIndirectCommandsTokenOffset;
	public uint MaxIndirectCommandsStreamStride;
	public uint MinSequencesCountBufferOffsetAlignment;
	public uint MinSequencesIndexBufferOffsetAlignment;
	public uint MinIndirectCommandsBufferOffsetAlignment;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceDeviceGeneratedCommandsProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceDeviceGeneratedCommandsProperties>.Equals(PhysicalDeviceDeviceGeneratedCommandsProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MaxGraphicsShaderGroupCount.GetHashCode() ^ MaxIndirectSequenceCount.GetHashCode()
			^ MaxIndirectCommandsTokenCount.GetHashCode() ^ MaxIndirectCommandsStreamCount.GetHashCode() ^ MaxIndirectCommandsTokenOffset.GetHashCode() ^ MaxIndirectCommandsStreamStride.GetHashCode()
			^ MinSequencesCountBufferOffsetAlignment.GetHashCode() ^ MinSequencesIndexBufferOffsetAlignment.GetHashCode() ^ MinIndirectCommandsBufferOffsetAlignment.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceDeviceGeneratedCommandsProperties l, in PhysicalDeviceDeviceGeneratedCommandsProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MaxGraphicsShaderGroupCount == r.MaxGraphicsShaderGroupCount) && (l.MaxIndirectSequenceCount == r.MaxIndirectSequenceCount)
			&& (l.MaxIndirectCommandsTokenCount == r.MaxIndirectCommandsTokenCount) && (l.MaxIndirectCommandsStreamCount == r.MaxIndirectCommandsStreamCount) && (l.MaxIndirectCommandsTokenOffset == r.MaxIndirectCommandsTokenOffset) && (l.MaxIndirectCommandsStreamStride == r.MaxIndirectCommandsStreamStride)
			&& (l.MinSequencesCountBufferOffsetAlignment == r.MinSequencesCountBufferOffsetAlignment) && (l.MinSequencesIndexBufferOffsetAlignment == r.MinSequencesIndexBufferOffsetAlignment) && (l.MinIndirectCommandsBufferOffsetAlignment == r.MinIndirectCommandsBufferOffsetAlignment)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceDeviceGeneratedCommandsProperties l, in PhysicalDeviceDeviceGeneratedCommandsProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MaxGraphicsShaderGroupCount != r.MaxGraphicsShaderGroupCount) || (l.MaxIndirectSequenceCount != r.MaxIndirectSequenceCount)
			|| (l.MaxIndirectCommandsTokenCount != r.MaxIndirectCommandsTokenCount) || (l.MaxIndirectCommandsStreamCount != r.MaxIndirectCommandsStreamCount) || (l.MaxIndirectCommandsTokenOffset != r.MaxIndirectCommandsTokenOffset) || (l.MaxIndirectCommandsStreamStride != r.MaxIndirectCommandsStreamStride)
			|| (l.MinSequencesCountBufferOffsetAlignment != r.MinSequencesCountBufferOffsetAlignment) || (l.MinSequencesIndexBufferOffsetAlignment != r.MinSequencesIndexBufferOffsetAlignment) || (l.MinIndirectCommandsBufferOffsetAlignment != r.MinIndirectCommandsBufferOffsetAlignment)
			;
	}


	/// <summary>Creates a new PhysicalDeviceDeviceGeneratedCommandsProperties value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceDeviceGeneratedCommandsProperties value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceDeviceGeneratedCommandsProperties value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct GraphicsShaderGroupCreateInfo : IEquatable<GraphicsShaderGroupCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.GraphicsShaderGroupCreateInfoNV;

	public Vk.StructureType sType;
	public void* pNext;
	public uint StageCount;
	public Vk.PipelineShaderStageCreateInfo* Stages;
	public Vk.PipelineVertexInputStateCreateInfo* VertexInputState;
	public Vk.PipelineTessellationStateCreateInfo* TessellationState;

	public readonly override bool Equals(object? obj) => (obj is GraphicsShaderGroupCreateInfo o) && (this == o);
	readonly bool IEquatable<GraphicsShaderGroupCreateInfo>.Equals(GraphicsShaderGroupCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ StageCount.GetHashCode() ^ ((ulong)Stages).GetHashCode()
			^ ((ulong)VertexInputState).GetHashCode() ^ ((ulong)TessellationState).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in GraphicsShaderGroupCreateInfo l, in GraphicsShaderGroupCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.StageCount == r.StageCount) && (l.Stages == r.Stages)
			&& (l.VertexInputState == r.VertexInputState) && (l.TessellationState == r.TessellationState)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in GraphicsShaderGroupCreateInfo l, in GraphicsShaderGroupCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.StageCount != r.StageCount) || (l.Stages != r.Stages)
			|| (l.VertexInputState != r.VertexInputState) || (l.TessellationState != r.TessellationState)
			;
	}


	/// <summary>Creates a new GraphicsShaderGroupCreateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out GraphicsShaderGroupCreateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref GraphicsShaderGroupCreateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct GraphicsPipelineShaderGroupsCreateInfo : IEquatable<GraphicsPipelineShaderGroupsCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.GraphicsPipelineShaderGroupsCreateInfoNV;

	public Vk.StructureType sType;
	public void* pNext;
	public uint GroupCount;
	public Vk.NV.GraphicsShaderGroupCreateInfo* Groups;
	public uint PipelineCount;
	public Vk.Handle<Vk.Pipeline>* Pipelines;

	public readonly override bool Equals(object? obj) => (obj is GraphicsPipelineShaderGroupsCreateInfo o) && (this == o);
	readonly bool IEquatable<GraphicsPipelineShaderGroupsCreateInfo>.Equals(GraphicsPipelineShaderGroupsCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ GroupCount.GetHashCode() ^ ((ulong)Groups).GetHashCode()
			^ PipelineCount.GetHashCode() ^ ((ulong)Pipelines).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in GraphicsPipelineShaderGroupsCreateInfo l, in GraphicsPipelineShaderGroupsCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.GroupCount == r.GroupCount) && (l.Groups == r.Groups)
			&& (l.PipelineCount == r.PipelineCount) && (l.Pipelines == r.Pipelines)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in GraphicsPipelineShaderGroupsCreateInfo l, in GraphicsPipelineShaderGroupsCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.GroupCount != r.GroupCount) || (l.Groups != r.Groups)
			|| (l.PipelineCount != r.PipelineCount) || (l.Pipelines != r.Pipelines)
			;
	}


	/// <summary>Creates a new GraphicsPipelineShaderGroupsCreateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out GraphicsPipelineShaderGroupsCreateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref GraphicsPipelineShaderGroupsCreateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct BindShaderGroupIndirectCommand : IEquatable<BindShaderGroupIndirectCommand>
{
	public uint GroupIndex;

	public readonly override bool Equals(object? obj) => (obj is BindShaderGroupIndirectCommand o) && (this == o);
	readonly bool IEquatable<BindShaderGroupIndirectCommand>.Equals(BindShaderGroupIndirectCommand obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			GroupIndex.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in BindShaderGroupIndirectCommand l, in BindShaderGroupIndirectCommand r)
	{
		return
			(l.GroupIndex == r.GroupIndex)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in BindShaderGroupIndirectCommand l, in BindShaderGroupIndirectCommand r)
	{
		return
			(l.GroupIndex != r.GroupIndex)
			;
	}

}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct BindIndexBufferIndirectCommand : IEquatable<BindIndexBufferIndirectCommand>
{
	public ulong BufferAddress;
	public uint Size;
	public Vk.IndexType IndexType;

	public readonly override bool Equals(object? obj) => (obj is BindIndexBufferIndirectCommand o) && (this == o);
	readonly bool IEquatable<BindIndexBufferIndirectCommand>.Equals(BindIndexBufferIndirectCommand obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			BufferAddress.GetHashCode() ^ Size.GetHashCode() ^ IndexType.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in BindIndexBufferIndirectCommand l, in BindIndexBufferIndirectCommand r)
	{
		return
			(l.BufferAddress == r.BufferAddress) && (l.Size == r.Size) && (l.IndexType == r.IndexType)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in BindIndexBufferIndirectCommand l, in BindIndexBufferIndirectCommand r)
	{
		return
			(l.BufferAddress != r.BufferAddress) || (l.Size != r.Size) || (l.IndexType != r.IndexType)
			;
	}

}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct BindVertexBufferIndirectCommand : IEquatable<BindVertexBufferIndirectCommand>
{
	public ulong BufferAddress;
	public uint Size;
	public uint Stride;

	public readonly override bool Equals(object? obj) => (obj is BindVertexBufferIndirectCommand o) && (this == o);
	readonly bool IEquatable<BindVertexBufferIndirectCommand>.Equals(BindVertexBufferIndirectCommand obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			BufferAddress.GetHashCode() ^ Size.GetHashCode() ^ Stride.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in BindVertexBufferIndirectCommand l, in BindVertexBufferIndirectCommand r)
	{
		return
			(l.BufferAddress == r.BufferAddress) && (l.Size == r.Size) && (l.Stride == r.Stride)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in BindVertexBufferIndirectCommand l, in BindVertexBufferIndirectCommand r)
	{
		return
			(l.BufferAddress != r.BufferAddress) || (l.Size != r.Size) || (l.Stride != r.Stride)
			;
	}

}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SetStateFlagsIndirectCommand : IEquatable<SetStateFlagsIndirectCommand>
{
	public uint Data;

	public readonly override bool Equals(object? obj) => (obj is SetStateFlagsIndirectCommand o) && (this == o);
	readonly bool IEquatable<SetStateFlagsIndirectCommand>.Equals(SetStateFlagsIndirectCommand obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Data.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SetStateFlagsIndirectCommand l, in SetStateFlagsIndirectCommand r)
	{
		return
			(l.Data == r.Data)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SetStateFlagsIndirectCommand l, in SetStateFlagsIndirectCommand r)
	{
		return
			(l.Data != r.Data)
			;
	}

}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct IndirectCommandsStream : IEquatable<IndirectCommandsStream>
{
	public Vk.Handle<Vk.Buffer> Buffer;
	public Vk.DeviceSize Offset;

	public readonly override bool Equals(object? obj) => (obj is IndirectCommandsStream o) && (this == o);
	readonly bool IEquatable<IndirectCommandsStream>.Equals(IndirectCommandsStream obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Buffer.GetHashCode() ^ Offset.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in IndirectCommandsStream l, in IndirectCommandsStream r)
	{
		return
			(l.Buffer == r.Buffer) && (l.Offset == r.Offset)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in IndirectCommandsStream l, in IndirectCommandsStream r)
	{
		return
			(l.Buffer != r.Buffer) || (l.Offset != r.Offset)
			;
	}

}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct IndirectCommandsLayoutToken : IEquatable<IndirectCommandsLayoutToken>
{
	public const Vk.StructureType TYPE = Vk.StructureType.IndirectCommandsLayoutTokenNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.NV.IndirectCommandsTokenType TokenType;
	public uint Stream;
	public uint Offset;
	public uint VertexBindingUnit;
	public Vk.Bool32 VertexDynamicStride;
	public Vk.Handle<Vk.PipelineLayout> PushconstantPipelineLayout;
	public Vk.ShaderStageFlags PushconstantShaderStageFlags;
	public uint PushconstantOffset;
	public uint PushconstantSize;
	public Vk.NV.IndirectStateFlags IndirectStateFlags;
	public uint IndexTypeCount;
	public Vk.IndexType* IndexTypes;
	public uint* IndexTypeValues;

	public readonly override bool Equals(object? obj) => (obj is IndirectCommandsLayoutToken o) && (this == o);
	readonly bool IEquatable<IndirectCommandsLayoutToken>.Equals(IndirectCommandsLayoutToken obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ TokenType.GetHashCode() ^ Stream.GetHashCode()
			^ Offset.GetHashCode() ^ VertexBindingUnit.GetHashCode() ^ VertexDynamicStride.GetHashCode() ^ PushconstantPipelineLayout.GetHashCode()
			^ PushconstantShaderStageFlags.GetHashCode() ^ PushconstantOffset.GetHashCode() ^ PushconstantSize.GetHashCode() ^ IndirectStateFlags.GetHashCode()
			^ IndexTypeCount.GetHashCode() ^ ((ulong)IndexTypes).GetHashCode() ^ ((ulong)IndexTypeValues).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in IndirectCommandsLayoutToken l, in IndirectCommandsLayoutToken r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.TokenType == r.TokenType) && (l.Stream == r.Stream)
			&& (l.Offset == r.Offset) && (l.VertexBindingUnit == r.VertexBindingUnit) && (l.VertexDynamicStride == r.VertexDynamicStride) && (l.PushconstantPipelineLayout == r.PushconstantPipelineLayout)
			&& (l.PushconstantShaderStageFlags == r.PushconstantShaderStageFlags) && (l.PushconstantOffset == r.PushconstantOffset) && (l.PushconstantSize == r.PushconstantSize) && (l.IndirectStateFlags == r.IndirectStateFlags)
			&& (l.IndexTypeCount == r.IndexTypeCount) && (l.IndexTypes == r.IndexTypes) && (l.IndexTypeValues == r.IndexTypeValues)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in IndirectCommandsLayoutToken l, in IndirectCommandsLayoutToken r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.TokenType != r.TokenType) || (l.Stream != r.Stream)
			|| (l.Offset != r.Offset) || (l.VertexBindingUnit != r.VertexBindingUnit) || (l.VertexDynamicStride != r.VertexDynamicStride) || (l.PushconstantPipelineLayout != r.PushconstantPipelineLayout)
			|| (l.PushconstantShaderStageFlags != r.PushconstantShaderStageFlags) || (l.PushconstantOffset != r.PushconstantOffset) || (l.PushconstantSize != r.PushconstantSize) || (l.IndirectStateFlags != r.IndirectStateFlags)
			|| (l.IndexTypeCount != r.IndexTypeCount) || (l.IndexTypes != r.IndexTypes) || (l.IndexTypeValues != r.IndexTypeValues)
			;
	}


	/// <summary>Creates a new IndirectCommandsLayoutToken value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out IndirectCommandsLayoutToken value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref IndirectCommandsLayoutToken value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct IndirectCommandsLayoutCreateInfo : IEquatable<IndirectCommandsLayoutCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.IndirectCommandsLayoutCreateInfoNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.NV.IndirectCommandsLayoutUsageFlags Flags;
	public Vk.PipelineBindPoint PipelineBindPoint;
	public uint TokenCount;
	public Vk.NV.IndirectCommandsLayoutToken* Tokens;
	public uint StreamCount;
	public uint* StreamStrides;

	public readonly override bool Equals(object? obj) => (obj is IndirectCommandsLayoutCreateInfo o) && (this == o);
	readonly bool IEquatable<IndirectCommandsLayoutCreateInfo>.Equals(IndirectCommandsLayoutCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ PipelineBindPoint.GetHashCode()
			^ TokenCount.GetHashCode() ^ ((ulong)Tokens).GetHashCode() ^ StreamCount.GetHashCode() ^ ((ulong)StreamStrides).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in IndirectCommandsLayoutCreateInfo l, in IndirectCommandsLayoutCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.PipelineBindPoint == r.PipelineBindPoint)
			&& (l.TokenCount == r.TokenCount) && (l.Tokens == r.Tokens) && (l.StreamCount == r.StreamCount) && (l.StreamStrides == r.StreamStrides)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in IndirectCommandsLayoutCreateInfo l, in IndirectCommandsLayoutCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.PipelineBindPoint != r.PipelineBindPoint)
			|| (l.TokenCount != r.TokenCount) || (l.Tokens != r.Tokens) || (l.StreamCount != r.StreamCount) || (l.StreamStrides != r.StreamStrides)
			;
	}


	/// <summary>Creates a new IndirectCommandsLayoutCreateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out IndirectCommandsLayoutCreateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref IndirectCommandsLayoutCreateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct GeneratedCommandsInfo : IEquatable<GeneratedCommandsInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.GeneratedCommandsInfoNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.PipelineBindPoint PipelineBindPoint;
	public Vk.Handle<Vk.Pipeline> Pipeline;
	public Vk.Handle<Vk.NV.IndirectCommandsLayout> IndirectCommandsLayout;
	public uint StreamCount;
	public Vk.NV.IndirectCommandsStream* Streams;
	public uint SequencesCount;
	public Vk.Handle<Vk.Buffer> PreprocessBuffer;
	public Vk.DeviceSize PreprocessOffset;
	public Vk.DeviceSize PreprocessSize;
	public Vk.Handle<Vk.Buffer> SequencesCountBuffer;
	public Vk.DeviceSize SequencesCountOffset;
	public Vk.Handle<Vk.Buffer> SequencesIndexBuffer;
	public Vk.DeviceSize SequencesIndexOffset;

	public readonly override bool Equals(object? obj) => (obj is GeneratedCommandsInfo o) && (this == o);
	readonly bool IEquatable<GeneratedCommandsInfo>.Equals(GeneratedCommandsInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ PipelineBindPoint.GetHashCode() ^ Pipeline.GetHashCode()
			^ IndirectCommandsLayout.GetHashCode() ^ StreamCount.GetHashCode() ^ ((ulong)Streams).GetHashCode() ^ SequencesCount.GetHashCode()
			^ PreprocessBuffer.GetHashCode() ^ PreprocessOffset.GetHashCode() ^ PreprocessSize.GetHashCode() ^ SequencesCountBuffer.GetHashCode()
			^ SequencesCountOffset.GetHashCode() ^ SequencesIndexBuffer.GetHashCode() ^ SequencesIndexOffset.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in GeneratedCommandsInfo l, in GeneratedCommandsInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.PipelineBindPoint == r.PipelineBindPoint) && (l.Pipeline == r.Pipeline)
			&& (l.IndirectCommandsLayout == r.IndirectCommandsLayout) && (l.StreamCount == r.StreamCount) && (l.Streams == r.Streams) && (l.SequencesCount == r.SequencesCount)
			&& (l.PreprocessBuffer == r.PreprocessBuffer) && (l.PreprocessOffset == r.PreprocessOffset) && (l.PreprocessSize == r.PreprocessSize) && (l.SequencesCountBuffer == r.SequencesCountBuffer)
			&& (l.SequencesCountOffset == r.SequencesCountOffset) && (l.SequencesIndexBuffer == r.SequencesIndexBuffer) && (l.SequencesIndexOffset == r.SequencesIndexOffset)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in GeneratedCommandsInfo l, in GeneratedCommandsInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.PipelineBindPoint != r.PipelineBindPoint) || (l.Pipeline != r.Pipeline)
			|| (l.IndirectCommandsLayout != r.IndirectCommandsLayout) || (l.StreamCount != r.StreamCount) || (l.Streams != r.Streams) || (l.SequencesCount != r.SequencesCount)
			|| (l.PreprocessBuffer != r.PreprocessBuffer) || (l.PreprocessOffset != r.PreprocessOffset) || (l.PreprocessSize != r.PreprocessSize) || (l.SequencesCountBuffer != r.SequencesCountBuffer)
			|| (l.SequencesCountOffset != r.SequencesCountOffset) || (l.SequencesIndexBuffer != r.SequencesIndexBuffer) || (l.SequencesIndexOffset != r.SequencesIndexOffset)
			;
	}


	/// <summary>Creates a new GeneratedCommandsInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out GeneratedCommandsInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref GeneratedCommandsInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct GeneratedCommandsMemoryRequirementsInfo : IEquatable<GeneratedCommandsMemoryRequirementsInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.GeneratedCommandsMemoryRequirementsInfoNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.PipelineBindPoint PipelineBindPoint;
	public Vk.Handle<Vk.Pipeline> Pipeline;
	public Vk.Handle<Vk.NV.IndirectCommandsLayout> IndirectCommandsLayout;
	public uint MaxSequencesCount;

	public readonly override bool Equals(object? obj) => (obj is GeneratedCommandsMemoryRequirementsInfo o) && (this == o);
	readonly bool IEquatable<GeneratedCommandsMemoryRequirementsInfo>.Equals(GeneratedCommandsMemoryRequirementsInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ PipelineBindPoint.GetHashCode() ^ Pipeline.GetHashCode()
			^ IndirectCommandsLayout.GetHashCode() ^ MaxSequencesCount.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in GeneratedCommandsMemoryRequirementsInfo l, in GeneratedCommandsMemoryRequirementsInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.PipelineBindPoint == r.PipelineBindPoint) && (l.Pipeline == r.Pipeline)
			&& (l.IndirectCommandsLayout == r.IndirectCommandsLayout) && (l.MaxSequencesCount == r.MaxSequencesCount)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in GeneratedCommandsMemoryRequirementsInfo l, in GeneratedCommandsMemoryRequirementsInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.PipelineBindPoint != r.PipelineBindPoint) || (l.Pipeline != r.Pipeline)
			|| (l.IndirectCommandsLayout != r.IndirectCommandsLayout) || (l.MaxSequencesCount != r.MaxSequencesCount)
			;
	}


	/// <summary>Creates a new GeneratedCommandsMemoryRequirementsInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out GeneratedCommandsMemoryRequirementsInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref GeneratedCommandsMemoryRequirementsInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ViewportWScaling : IEquatable<ViewportWScaling>
{
	public float Xcoeff;
	public float Ycoeff;

	public readonly override bool Equals(object? obj) => (obj is ViewportWScaling o) && (this == o);
	readonly bool IEquatable<ViewportWScaling>.Equals(ViewportWScaling obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Xcoeff.GetHashCode() ^ Ycoeff.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ViewportWScaling l, in ViewportWScaling r)
	{
		return
			(l.Xcoeff == r.Xcoeff) && (l.Ycoeff == r.Ycoeff)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ViewportWScaling l, in ViewportWScaling r)
	{
		return
			(l.Xcoeff != r.Xcoeff) || (l.Ycoeff != r.Ycoeff)
			;
	}

}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PipelineViewportWScalingStateCreateInfo : IEquatable<PipelineViewportWScalingStateCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PipelineViewportWScalingStateCreateInfoNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 ViewportWScalingEnable;
	public uint ViewportCount;
	public Vk.NV.ViewportWScaling* ViewportWScalings;

	public readonly override bool Equals(object? obj) => (obj is PipelineViewportWScalingStateCreateInfo o) && (this == o);
	readonly bool IEquatable<PipelineViewportWScalingStateCreateInfo>.Equals(PipelineViewportWScalingStateCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ViewportWScalingEnable.GetHashCode() ^ ViewportCount.GetHashCode()
			^ ((ulong)ViewportWScalings).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PipelineViewportWScalingStateCreateInfo l, in PipelineViewportWScalingStateCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ViewportWScalingEnable == r.ViewportWScalingEnable) && (l.ViewportCount == r.ViewportCount)
			&& (l.ViewportWScalings == r.ViewportWScalings)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PipelineViewportWScalingStateCreateInfo l, in PipelineViewportWScalingStateCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ViewportWScalingEnable != r.ViewportWScalingEnable) || (l.ViewportCount != r.ViewportCount)
			|| (l.ViewportWScalings != r.ViewportWScalings)
			;
	}


	/// <summary>Creates a new PipelineViewportWScalingStateCreateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PipelineViewportWScalingStateCreateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PipelineViewportWScalingStateCreateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ViewportSwizzle : IEquatable<ViewportSwizzle>
{
	public Vk.NV.ViewportCoordinateSwizzle X;
	public Vk.NV.ViewportCoordinateSwizzle Y;
	public Vk.NV.ViewportCoordinateSwizzle Z;
	public Vk.NV.ViewportCoordinateSwizzle W;

	public readonly override bool Equals(object? obj) => (obj is ViewportSwizzle o) && (this == o);
	readonly bool IEquatable<ViewportSwizzle>.Equals(ViewportSwizzle obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			X.GetHashCode() ^ Y.GetHashCode() ^ Z.GetHashCode() ^ W.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ViewportSwizzle l, in ViewportSwizzle r)
	{
		return
			(l.X == r.X) && (l.Y == r.Y) && (l.Z == r.Z) && (l.W == r.W)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ViewportSwizzle l, in ViewportSwizzle r)
	{
		return
			(l.X != r.X) || (l.Y != r.Y) || (l.Z != r.Z) || (l.W != r.W)
			;
	}

}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PipelineViewportSwizzleStateCreateInfo : IEquatable<PipelineViewportSwizzleStateCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PipelineViewportSwizzleStateCreateInfoNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.NV.PipelineViewportSwizzleStateCreateFlags Flags;
	public uint ViewportCount;
	public Vk.NV.ViewportSwizzle* ViewportSwizzles;

	public readonly override bool Equals(object? obj) => (obj is PipelineViewportSwizzleStateCreateInfo o) && (this == o);
	readonly bool IEquatable<PipelineViewportSwizzleStateCreateInfo>.Equals(PipelineViewportSwizzleStateCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ ViewportCount.GetHashCode()
			^ ((ulong)ViewportSwizzles).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PipelineViewportSwizzleStateCreateInfo l, in PipelineViewportSwizzleStateCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.ViewportCount == r.ViewportCount)
			&& (l.ViewportSwizzles == r.ViewportSwizzles)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PipelineViewportSwizzleStateCreateInfo l, in PipelineViewportSwizzleStateCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.ViewportCount != r.ViewportCount)
			|| (l.ViewportSwizzles != r.ViewportSwizzles)
			;
	}


	/// <summary>Creates a new PipelineViewportSwizzleStateCreateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PipelineViewportSwizzleStateCreateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PipelineViewportSwizzleStateCreateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PipelineCoverageToColorStateCreateInfo : IEquatable<PipelineCoverageToColorStateCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PipelineCoverageToColorStateCreateInfoNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.NV.PipelineCoverageToColorStateCreateFlags Flags;
	public Vk.Bool32 CoverageToColorEnable;
	public uint CoverageToColorLocation;

	public readonly override bool Equals(object? obj) => (obj is PipelineCoverageToColorStateCreateInfo o) && (this == o);
	readonly bool IEquatable<PipelineCoverageToColorStateCreateInfo>.Equals(PipelineCoverageToColorStateCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ CoverageToColorEnable.GetHashCode()
			^ CoverageToColorLocation.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PipelineCoverageToColorStateCreateInfo l, in PipelineCoverageToColorStateCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.CoverageToColorEnable == r.CoverageToColorEnable)
			&& (l.CoverageToColorLocation == r.CoverageToColorLocation)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PipelineCoverageToColorStateCreateInfo l, in PipelineCoverageToColorStateCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.CoverageToColorEnable != r.CoverageToColorEnable)
			|| (l.CoverageToColorLocation != r.CoverageToColorLocation)
			;
	}


	/// <summary>Creates a new PipelineCoverageToColorStateCreateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PipelineCoverageToColorStateCreateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PipelineCoverageToColorStateCreateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PipelineCoverageModulationStateCreateInfo : IEquatable<PipelineCoverageModulationStateCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PipelineCoverageModulationStateCreateInfoNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.NV.PipelineCoverageModulationStateCreateFlags Flags;
	public Vk.NV.CoverageModulationMode CoverageModulationMode;
	public Vk.Bool32 CoverageModulationTableEnable;
	public uint CoverageModulationTableCount;
	public float* CoverageModulationTable;

	public readonly override bool Equals(object? obj) => (obj is PipelineCoverageModulationStateCreateInfo o) && (this == o);
	readonly bool IEquatable<PipelineCoverageModulationStateCreateInfo>.Equals(PipelineCoverageModulationStateCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ CoverageModulationMode.GetHashCode()
			^ CoverageModulationTableEnable.GetHashCode() ^ CoverageModulationTableCount.GetHashCode() ^ ((ulong)CoverageModulationTable).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PipelineCoverageModulationStateCreateInfo l, in PipelineCoverageModulationStateCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.CoverageModulationMode == r.CoverageModulationMode)
			&& (l.CoverageModulationTableEnable == r.CoverageModulationTableEnable) && (l.CoverageModulationTableCount == r.CoverageModulationTableCount) && (l.CoverageModulationTable == r.CoverageModulationTable)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PipelineCoverageModulationStateCreateInfo l, in PipelineCoverageModulationStateCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.CoverageModulationMode != r.CoverageModulationMode)
			|| (l.CoverageModulationTableEnable != r.CoverageModulationTableEnable) || (l.CoverageModulationTableCount != r.CoverageModulationTableCount) || (l.CoverageModulationTable != r.CoverageModulationTable)
			;
	}


	/// <summary>Creates a new PipelineCoverageModulationStateCreateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PipelineCoverageModulationStateCreateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PipelineCoverageModulationStateCreateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct QueueFamilyCheckpointProperties : IEquatable<QueueFamilyCheckpointProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.QueueFamilyCheckpointPropertiesNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.PipelineStageFlags CheckpointExecutionStageMask;

	public readonly override bool Equals(object? obj) => (obj is QueueFamilyCheckpointProperties o) && (this == o);
	readonly bool IEquatable<QueueFamilyCheckpointProperties>.Equals(QueueFamilyCheckpointProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ CheckpointExecutionStageMask.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in QueueFamilyCheckpointProperties l, in QueueFamilyCheckpointProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.CheckpointExecutionStageMask == r.CheckpointExecutionStageMask)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in QueueFamilyCheckpointProperties l, in QueueFamilyCheckpointProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.CheckpointExecutionStageMask != r.CheckpointExecutionStageMask)
			;
	}


	/// <summary>Creates a new QueueFamilyCheckpointProperties value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out QueueFamilyCheckpointProperties value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref QueueFamilyCheckpointProperties value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct CheckpointData : IEquatable<CheckpointData>
{
	public const Vk.StructureType TYPE = Vk.StructureType.CheckpointDataNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.PipelineStageFlags Stage;
	public void* CheckpointMarker;

	public readonly override bool Equals(object? obj) => (obj is CheckpointData o) && (this == o);
	readonly bool IEquatable<CheckpointData>.Equals(CheckpointData obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Stage.GetHashCode() ^ ((ulong)CheckpointMarker).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in CheckpointData l, in CheckpointData r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Stage == r.Stage) && (l.CheckpointMarker == r.CheckpointMarker)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in CheckpointData l, in CheckpointData r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Stage != r.Stage) || (l.CheckpointMarker != r.CheckpointMarker)
			;
	}


	/// <summary>Creates a new CheckpointData value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out CheckpointData value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref CheckpointData value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceRepresentativeFragmentTestFeatures : IEquatable<PhysicalDeviceRepresentativeFragmentTestFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceRepresentativeFragmentTestFeaturesNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 RepresentativeFragmentTest;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceRepresentativeFragmentTestFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceRepresentativeFragmentTestFeatures>.Equals(PhysicalDeviceRepresentativeFragmentTestFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ RepresentativeFragmentTest.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceRepresentativeFragmentTestFeatures l, in PhysicalDeviceRepresentativeFragmentTestFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.RepresentativeFragmentTest == r.RepresentativeFragmentTest)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceRepresentativeFragmentTestFeatures l, in PhysicalDeviceRepresentativeFragmentTestFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.RepresentativeFragmentTest != r.RepresentativeFragmentTest)
			;
	}


	/// <summary>Creates a new PhysicalDeviceRepresentativeFragmentTestFeatures value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceRepresentativeFragmentTestFeatures value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceRepresentativeFragmentTestFeatures value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PipelineRepresentativeFragmentTestStateCreateInfo : IEquatable<PipelineRepresentativeFragmentTestStateCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PipelineRepresentativeFragmentTestStateCreateInfoNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 RepresentativeFragmentTestEnable;

	public readonly override bool Equals(object? obj) => (obj is PipelineRepresentativeFragmentTestStateCreateInfo o) && (this == o);
	readonly bool IEquatable<PipelineRepresentativeFragmentTestStateCreateInfo>.Equals(PipelineRepresentativeFragmentTestStateCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ RepresentativeFragmentTestEnable.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PipelineRepresentativeFragmentTestStateCreateInfo l, in PipelineRepresentativeFragmentTestStateCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.RepresentativeFragmentTestEnable == r.RepresentativeFragmentTestEnable)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PipelineRepresentativeFragmentTestStateCreateInfo l, in PipelineRepresentativeFragmentTestStateCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.RepresentativeFragmentTestEnable != r.RepresentativeFragmentTestEnable)
			;
	}


	/// <summary>Creates a new PipelineRepresentativeFragmentTestStateCreateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PipelineRepresentativeFragmentTestStateCreateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PipelineRepresentativeFragmentTestStateCreateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceExclusiveScissorFeatures : IEquatable<PhysicalDeviceExclusiveScissorFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceExclusiveScissorFeaturesNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 ExclusiveScissor;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceExclusiveScissorFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceExclusiveScissorFeatures>.Equals(PhysicalDeviceExclusiveScissorFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ExclusiveScissor.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceExclusiveScissorFeatures l, in PhysicalDeviceExclusiveScissorFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ExclusiveScissor == r.ExclusiveScissor)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceExclusiveScissorFeatures l, in PhysicalDeviceExclusiveScissorFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ExclusiveScissor != r.ExclusiveScissor)
			;
	}


	/// <summary>Creates a new PhysicalDeviceExclusiveScissorFeatures value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceExclusiveScissorFeatures value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceExclusiveScissorFeatures value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PipelineViewportExclusiveScissorStateCreateInfo : IEquatable<PipelineViewportExclusiveScissorStateCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PipelineViewportExclusiveScissorStateCreateInfoNV;

	public Vk.StructureType sType;
	public void* pNext;
	public uint ExclusiveScissorCount;
	public Vk.Rect2D* ExclusiveScissors;

	public readonly override bool Equals(object? obj) => (obj is PipelineViewportExclusiveScissorStateCreateInfo o) && (this == o);
	readonly bool IEquatable<PipelineViewportExclusiveScissorStateCreateInfo>.Equals(PipelineViewportExclusiveScissorStateCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ExclusiveScissorCount.GetHashCode() ^ ((ulong)ExclusiveScissors).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PipelineViewportExclusiveScissorStateCreateInfo l, in PipelineViewportExclusiveScissorStateCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ExclusiveScissorCount == r.ExclusiveScissorCount) && (l.ExclusiveScissors == r.ExclusiveScissors)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PipelineViewportExclusiveScissorStateCreateInfo l, in PipelineViewportExclusiveScissorStateCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ExclusiveScissorCount != r.ExclusiveScissorCount) || (l.ExclusiveScissors != r.ExclusiveScissors)
			;
	}


	/// <summary>Creates a new PipelineViewportExclusiveScissorStateCreateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PipelineViewportExclusiveScissorStateCreateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PipelineViewportExclusiveScissorStateCreateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceCornerSampledImageFeatures : IEquatable<PhysicalDeviceCornerSampledImageFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceCornerSampledImageFeaturesNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 CornerSampledImage;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceCornerSampledImageFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceCornerSampledImageFeatures>.Equals(PhysicalDeviceCornerSampledImageFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ CornerSampledImage.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceCornerSampledImageFeatures l, in PhysicalDeviceCornerSampledImageFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.CornerSampledImage == r.CornerSampledImage)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceCornerSampledImageFeatures l, in PhysicalDeviceCornerSampledImageFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.CornerSampledImage != r.CornerSampledImage)
			;
	}


	/// <summary>Creates a new PhysicalDeviceCornerSampledImageFeatures value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceCornerSampledImageFeatures value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceCornerSampledImageFeatures value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceComputeShaderDerivativesFeatures : IEquatable<PhysicalDeviceComputeShaderDerivativesFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceComputeShaderDerivativesFeaturesNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 ComputeDerivativeGroupQuads;
	public Vk.Bool32 ComputeDerivativeGroupLinear;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceComputeShaderDerivativesFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceComputeShaderDerivativesFeatures>.Equals(PhysicalDeviceComputeShaderDerivativesFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ComputeDerivativeGroupQuads.GetHashCode() ^ ComputeDerivativeGroupLinear.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceComputeShaderDerivativesFeatures l, in PhysicalDeviceComputeShaderDerivativesFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ComputeDerivativeGroupQuads == r.ComputeDerivativeGroupQuads) && (l.ComputeDerivativeGroupLinear == r.ComputeDerivativeGroupLinear)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceComputeShaderDerivativesFeatures l, in PhysicalDeviceComputeShaderDerivativesFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ComputeDerivativeGroupQuads != r.ComputeDerivativeGroupQuads) || (l.ComputeDerivativeGroupLinear != r.ComputeDerivativeGroupLinear)
			;
	}


	/// <summary>Creates a new PhysicalDeviceComputeShaderDerivativesFeatures value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceComputeShaderDerivativesFeatures value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceComputeShaderDerivativesFeatures value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceFragmentShaderBarycentricFeatures : IEquatable<PhysicalDeviceFragmentShaderBarycentricFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceFragmentShaderBarycentricFeaturesNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 FragmentShaderBarycentric;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceFragmentShaderBarycentricFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceFragmentShaderBarycentricFeatures>.Equals(PhysicalDeviceFragmentShaderBarycentricFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ FragmentShaderBarycentric.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceFragmentShaderBarycentricFeatures l, in PhysicalDeviceFragmentShaderBarycentricFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.FragmentShaderBarycentric == r.FragmentShaderBarycentric)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceFragmentShaderBarycentricFeatures l, in PhysicalDeviceFragmentShaderBarycentricFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.FragmentShaderBarycentric != r.FragmentShaderBarycentric)
			;
	}


	/// <summary>Creates a new PhysicalDeviceFragmentShaderBarycentricFeatures value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceFragmentShaderBarycentricFeatures value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceFragmentShaderBarycentricFeatures value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceShaderImageFootprintFeatures : IEquatable<PhysicalDeviceShaderImageFootprintFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceShaderImageFootprintFeaturesNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 ImageFootprint;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceShaderImageFootprintFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceShaderImageFootprintFeatures>.Equals(PhysicalDeviceShaderImageFootprintFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ImageFootprint.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceShaderImageFootprintFeatures l, in PhysicalDeviceShaderImageFootprintFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ImageFootprint == r.ImageFootprint)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceShaderImageFootprintFeatures l, in PhysicalDeviceShaderImageFootprintFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ImageFootprint != r.ImageFootprint)
			;
	}


	/// <summary>Creates a new PhysicalDeviceShaderImageFootprintFeatures value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceShaderImageFootprintFeatures value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceShaderImageFootprintFeatures value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceDedicatedAllocationImageAliasingFeatures : IEquatable<PhysicalDeviceDedicatedAllocationImageAliasingFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 DedicatedAllocationImageAliasing;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceDedicatedAllocationImageAliasingFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceDedicatedAllocationImageAliasingFeatures>.Equals(PhysicalDeviceDedicatedAllocationImageAliasingFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DedicatedAllocationImageAliasing.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceDedicatedAllocationImageAliasingFeatures l, in PhysicalDeviceDedicatedAllocationImageAliasingFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DedicatedAllocationImageAliasing == r.DedicatedAllocationImageAliasing)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceDedicatedAllocationImageAliasingFeatures l, in PhysicalDeviceDedicatedAllocationImageAliasingFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DedicatedAllocationImageAliasing != r.DedicatedAllocationImageAliasing)
			;
	}


	/// <summary>Creates a new PhysicalDeviceDedicatedAllocationImageAliasingFeatures value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceDedicatedAllocationImageAliasingFeatures value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceDedicatedAllocationImageAliasingFeatures value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ShadingRatePalette : IEquatable<ShadingRatePalette>
{
	public uint ShadingRatePaletteEntryCount;
	public Vk.NV.ShadingRatePaletteEntry* ShadingRatePaletteEntries;

	public readonly override bool Equals(object? obj) => (obj is ShadingRatePalette o) && (this == o);
	readonly bool IEquatable<ShadingRatePalette>.Equals(ShadingRatePalette obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			ShadingRatePaletteEntryCount.GetHashCode() ^ ((ulong)ShadingRatePaletteEntries).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ShadingRatePalette l, in ShadingRatePalette r)
	{
		return
			(l.ShadingRatePaletteEntryCount == r.ShadingRatePaletteEntryCount) && (l.ShadingRatePaletteEntries == r.ShadingRatePaletteEntries)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ShadingRatePalette l, in ShadingRatePalette r)
	{
		return
			(l.ShadingRatePaletteEntryCount != r.ShadingRatePaletteEntryCount) || (l.ShadingRatePaletteEntries != r.ShadingRatePaletteEntries)
			;
	}

}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PipelineViewportShadingRateImageStateCreateInfo : IEquatable<PipelineViewportShadingRateImageStateCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PipelineViewportShadingRateImageStateCreateInfoNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 ShadingRateImageEnable;
	public uint ViewportCount;
	public Vk.NV.ShadingRatePalette* ShadingRatePalettes;

	public readonly override bool Equals(object? obj) => (obj is PipelineViewportShadingRateImageStateCreateInfo o) && (this == o);
	readonly bool IEquatable<PipelineViewportShadingRateImageStateCreateInfo>.Equals(PipelineViewportShadingRateImageStateCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ShadingRateImageEnable.GetHashCode() ^ ViewportCount.GetHashCode()
			^ ((ulong)ShadingRatePalettes).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PipelineViewportShadingRateImageStateCreateInfo l, in PipelineViewportShadingRateImageStateCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ShadingRateImageEnable == r.ShadingRateImageEnable) && (l.ViewportCount == r.ViewportCount)
			&& (l.ShadingRatePalettes == r.ShadingRatePalettes)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PipelineViewportShadingRateImageStateCreateInfo l, in PipelineViewportShadingRateImageStateCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ShadingRateImageEnable != r.ShadingRateImageEnable) || (l.ViewportCount != r.ViewportCount)
			|| (l.ShadingRatePalettes != r.ShadingRatePalettes)
			;
	}


	/// <summary>Creates a new PipelineViewportShadingRateImageStateCreateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PipelineViewportShadingRateImageStateCreateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PipelineViewportShadingRateImageStateCreateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceShadingRateImageFeatures : IEquatable<PhysicalDeviceShadingRateImageFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceShadingRateImageFeaturesNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 ShadingRateImage;
	public Vk.Bool32 ShadingRateCoarseSampleOrder;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceShadingRateImageFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceShadingRateImageFeatures>.Equals(PhysicalDeviceShadingRateImageFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ShadingRateImage.GetHashCode() ^ ShadingRateCoarseSampleOrder.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceShadingRateImageFeatures l, in PhysicalDeviceShadingRateImageFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ShadingRateImage == r.ShadingRateImage) && (l.ShadingRateCoarseSampleOrder == r.ShadingRateCoarseSampleOrder)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceShadingRateImageFeatures l, in PhysicalDeviceShadingRateImageFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ShadingRateImage != r.ShadingRateImage) || (l.ShadingRateCoarseSampleOrder != r.ShadingRateCoarseSampleOrder)
			;
	}


	/// <summary>Creates a new PhysicalDeviceShadingRateImageFeatures value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceShadingRateImageFeatures value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceShadingRateImageFeatures value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceShadingRateImageProperties : IEquatable<PhysicalDeviceShadingRateImageProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceShadingRateImagePropertiesNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Extent2D ShadingRateTexelSize;
	public uint ShadingRatePaletteSize;
	public uint ShadingRateMaxCoarseSamples;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceShadingRateImageProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceShadingRateImageProperties>.Equals(PhysicalDeviceShadingRateImageProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ShadingRateTexelSize.GetHashCode() ^ ShadingRatePaletteSize.GetHashCode()
			^ ShadingRateMaxCoarseSamples.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceShadingRateImageProperties l, in PhysicalDeviceShadingRateImageProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ShadingRateTexelSize == r.ShadingRateTexelSize) && (l.ShadingRatePaletteSize == r.ShadingRatePaletteSize)
			&& (l.ShadingRateMaxCoarseSamples == r.ShadingRateMaxCoarseSamples)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceShadingRateImageProperties l, in PhysicalDeviceShadingRateImageProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ShadingRateTexelSize != r.ShadingRateTexelSize) || (l.ShadingRatePaletteSize != r.ShadingRatePaletteSize)
			|| (l.ShadingRateMaxCoarseSamples != r.ShadingRateMaxCoarseSamples)
			;
	}


	/// <summary>Creates a new PhysicalDeviceShadingRateImageProperties value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceShadingRateImageProperties value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceShadingRateImageProperties value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct CoarseSampleLocation : IEquatable<CoarseSampleLocation>
{
	public uint PixelX;
	public uint PixelY;
	public uint Sample;

	public readonly override bool Equals(object? obj) => (obj is CoarseSampleLocation o) && (this == o);
	readonly bool IEquatable<CoarseSampleLocation>.Equals(CoarseSampleLocation obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			PixelX.GetHashCode() ^ PixelY.GetHashCode() ^ Sample.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in CoarseSampleLocation l, in CoarseSampleLocation r)
	{
		return
			(l.PixelX == r.PixelX) && (l.PixelY == r.PixelY) && (l.Sample == r.Sample)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in CoarseSampleLocation l, in CoarseSampleLocation r)
	{
		return
			(l.PixelX != r.PixelX) || (l.PixelY != r.PixelY) || (l.Sample != r.Sample)
			;
	}

}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct CoarseSampleOrderCustom : IEquatable<CoarseSampleOrderCustom>
{
	public Vk.NV.ShadingRatePaletteEntry ShadingRate;
	public uint SampleCount;
	public uint SampleLocationCount;
	public Vk.NV.CoarseSampleLocation* SampleLocations;

	public readonly override bool Equals(object? obj) => (obj is CoarseSampleOrderCustom o) && (this == o);
	readonly bool IEquatable<CoarseSampleOrderCustom>.Equals(CoarseSampleOrderCustom obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			ShadingRate.GetHashCode() ^ SampleCount.GetHashCode() ^ SampleLocationCount.GetHashCode() ^ ((ulong)SampleLocations).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in CoarseSampleOrderCustom l, in CoarseSampleOrderCustom r)
	{
		return
			(l.ShadingRate == r.ShadingRate) && (l.SampleCount == r.SampleCount) && (l.SampleLocationCount == r.SampleLocationCount) && (l.SampleLocations == r.SampleLocations)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in CoarseSampleOrderCustom l, in CoarseSampleOrderCustom r)
	{
		return
			(l.ShadingRate != r.ShadingRate) || (l.SampleCount != r.SampleCount) || (l.SampleLocationCount != r.SampleLocationCount) || (l.SampleLocations != r.SampleLocations)
			;
	}

}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PipelineViewportCoarseSampleOrderStateCreateInfo : IEquatable<PipelineViewportCoarseSampleOrderStateCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PipelineViewportCoarseSampleOrderStateCreateInfoNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.NV.CoarseSampleOrderType SampleOrderType;
	public uint CustomSampleOrderCount;
	public Vk.NV.CoarseSampleOrderCustom* CustomSampleOrders;

	public readonly override bool Equals(object? obj) => (obj is PipelineViewportCoarseSampleOrderStateCreateInfo o) && (this == o);
	readonly bool IEquatable<PipelineViewportCoarseSampleOrderStateCreateInfo>.Equals(PipelineViewportCoarseSampleOrderStateCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SampleOrderType.GetHashCode() ^ CustomSampleOrderCount.GetHashCode()
			^ ((ulong)CustomSampleOrders).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PipelineViewportCoarseSampleOrderStateCreateInfo l, in PipelineViewportCoarseSampleOrderStateCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SampleOrderType == r.SampleOrderType) && (l.CustomSampleOrderCount == r.CustomSampleOrderCount)
			&& (l.CustomSampleOrders == r.CustomSampleOrders)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PipelineViewportCoarseSampleOrderStateCreateInfo l, in PipelineViewportCoarseSampleOrderStateCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SampleOrderType != r.SampleOrderType) || (l.CustomSampleOrderCount != r.CustomSampleOrderCount)
			|| (l.CustomSampleOrders != r.CustomSampleOrders)
			;
	}


	/// <summary>Creates a new PipelineViewportCoarseSampleOrderStateCreateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PipelineViewportCoarseSampleOrderStateCreateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PipelineViewportCoarseSampleOrderStateCreateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceMeshShaderFeatures : IEquatable<PhysicalDeviceMeshShaderFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceMeshShaderFeaturesNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 TaskShader;
	public Vk.Bool32 MeshShader;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceMeshShaderFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceMeshShaderFeatures>.Equals(PhysicalDeviceMeshShaderFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ TaskShader.GetHashCode() ^ MeshShader.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceMeshShaderFeatures l, in PhysicalDeviceMeshShaderFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.TaskShader == r.TaskShader) && (l.MeshShader == r.MeshShader)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceMeshShaderFeatures l, in PhysicalDeviceMeshShaderFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.TaskShader != r.TaskShader) || (l.MeshShader != r.MeshShader)
			;
	}


	/// <summary>Creates a new PhysicalDeviceMeshShaderFeatures value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceMeshShaderFeatures value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceMeshShaderFeatures value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceMeshShaderProperties : IEquatable<PhysicalDeviceMeshShaderProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceMeshShaderPropertiesNV;

	public Vk.StructureType sType;
	public void* pNext;
	public uint MaxDrawMeshTasksCount;
	public uint MaxTaskWorkGroupInvocations;
	public fixed uint MaxTaskWorkGroupSize[3];
	public uint MaxTaskTotalMemorySize;
	public uint MaxTaskOutputCount;
	public uint MaxMeshWorkGroupInvocations;
	public fixed uint MaxMeshWorkGroupSize[3];
	public uint MaxMeshTotalMemorySize;
	public uint MaxMeshOutputVertices;
	public uint MaxMeshOutputPrimitives;
	public uint MaxMeshMultiviewViewCount;
	public uint MeshOutputPerVertexGranularity;
	public uint MeshOutputPerPrimitiveGranularity;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceMeshShaderProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceMeshShaderProperties>.Equals(PhysicalDeviceMeshShaderProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MaxDrawMeshTasksCount.GetHashCode() ^ MaxTaskWorkGroupInvocations.GetHashCode()
			^ MaxTaskWorkGroupSize[0].GetHashCode() ^ MaxTaskWorkGroupSize[1].GetHashCode() ^ MaxTaskWorkGroupSize[2].GetHashCode() ^ MaxTaskTotalMemorySize.GetHashCode()
			^ MaxTaskOutputCount.GetHashCode() ^ MaxMeshWorkGroupInvocations.GetHashCode() ^ MaxMeshWorkGroupSize[0].GetHashCode() ^ MaxMeshWorkGroupSize[1].GetHashCode()
			^ MaxMeshWorkGroupSize[2].GetHashCode() ^ MaxMeshTotalMemorySize.GetHashCode() ^ MaxMeshOutputVertices.GetHashCode() ^ MaxMeshOutputPrimitives.GetHashCode()
			^ MaxMeshMultiviewViewCount.GetHashCode() ^ MeshOutputPerVertexGranularity.GetHashCode() ^ MeshOutputPerPrimitiveGranularity.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceMeshShaderProperties l, in PhysicalDeviceMeshShaderProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MaxDrawMeshTasksCount == r.MaxDrawMeshTasksCount) && (l.MaxTaskWorkGroupInvocations == r.MaxTaskWorkGroupInvocations)
			&& (l.MaxTaskWorkGroupSize[0] == r.MaxTaskWorkGroupSize[0]) && (l.MaxTaskWorkGroupSize[1] == r.MaxTaskWorkGroupSize[1]) && (l.MaxTaskWorkGroupSize[2] == r.MaxTaskWorkGroupSize[2]) && (l.MaxTaskTotalMemorySize == r.MaxTaskTotalMemorySize)
			&& (l.MaxTaskOutputCount == r.MaxTaskOutputCount) && (l.MaxMeshWorkGroupInvocations == r.MaxMeshWorkGroupInvocations) && (l.MaxMeshWorkGroupSize[0] == r.MaxMeshWorkGroupSize[0]) && (l.MaxMeshWorkGroupSize[1] == r.MaxMeshWorkGroupSize[1])
			&& (l.MaxMeshWorkGroupSize[2] == r.MaxMeshWorkGroupSize[2]) && (l.MaxMeshTotalMemorySize == r.MaxMeshTotalMemorySize) && (l.MaxMeshOutputVertices == r.MaxMeshOutputVertices) && (l.MaxMeshOutputPrimitives == r.MaxMeshOutputPrimitives)
			&& (l.MaxMeshMultiviewViewCount == r.MaxMeshMultiviewViewCount) && (l.MeshOutputPerVertexGranularity == r.MeshOutputPerVertexGranularity) && (l.MeshOutputPerPrimitiveGranularity == r.MeshOutputPerPrimitiveGranularity)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceMeshShaderProperties l, in PhysicalDeviceMeshShaderProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MaxDrawMeshTasksCount != r.MaxDrawMeshTasksCount) || (l.MaxTaskWorkGroupInvocations != r.MaxTaskWorkGroupInvocations)
			|| (l.MaxTaskWorkGroupSize[0] != r.MaxTaskWorkGroupSize[0]) || (l.MaxTaskWorkGroupSize[1] != r.MaxTaskWorkGroupSize[1]) || (l.MaxTaskWorkGroupSize[2] != r.MaxTaskWorkGroupSize[2]) || (l.MaxTaskTotalMemorySize != r.MaxTaskTotalMemorySize)
			|| (l.MaxTaskOutputCount != r.MaxTaskOutputCount) || (l.MaxMeshWorkGroupInvocations != r.MaxMeshWorkGroupInvocations) || (l.MaxMeshWorkGroupSize[0] != r.MaxMeshWorkGroupSize[0]) || (l.MaxMeshWorkGroupSize[1] != r.MaxMeshWorkGroupSize[1])
			|| (l.MaxMeshWorkGroupSize[2] != r.MaxMeshWorkGroupSize[2]) || (l.MaxMeshTotalMemorySize != r.MaxMeshTotalMemorySize) || (l.MaxMeshOutputVertices != r.MaxMeshOutputVertices) || (l.MaxMeshOutputPrimitives != r.MaxMeshOutputPrimitives)
			|| (l.MaxMeshMultiviewViewCount != r.MaxMeshMultiviewViewCount) || (l.MeshOutputPerVertexGranularity != r.MeshOutputPerVertexGranularity) || (l.MeshOutputPerPrimitiveGranularity != r.MeshOutputPerPrimitiveGranularity)
			;
	}


	/// <summary>Creates a new PhysicalDeviceMeshShaderProperties value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceMeshShaderProperties value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceMeshShaderProperties value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DrawMeshTasksIndirectCommand : IEquatable<DrawMeshTasksIndirectCommand>
{
	public uint TaskCount;
	public uint FirstTask;

	public readonly override bool Equals(object? obj) => (obj is DrawMeshTasksIndirectCommand o) && (this == o);
	readonly bool IEquatable<DrawMeshTasksIndirectCommand>.Equals(DrawMeshTasksIndirectCommand obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			TaskCount.GetHashCode() ^ FirstTask.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DrawMeshTasksIndirectCommand l, in DrawMeshTasksIndirectCommand r)
	{
		return
			(l.TaskCount == r.TaskCount) && (l.FirstTask == r.FirstTask)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DrawMeshTasksIndirectCommand l, in DrawMeshTasksIndirectCommand r)
	{
		return
			(l.TaskCount != r.TaskCount) || (l.FirstTask != r.FirstTask)
			;
	}

}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct RayTracingShaderGroupCreateInfo : IEquatable<RayTracingShaderGroupCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.RayTracingShaderGroupCreateInfoNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.KHR.RayTracingShaderGroupType Type;
	public uint GeneralShader;
	public uint ClosestHitShader;
	public uint AnyHitShader;
	public uint IntersectionShader;

	public readonly override bool Equals(object? obj) => (obj is RayTracingShaderGroupCreateInfo o) && (this == o);
	readonly bool IEquatable<RayTracingShaderGroupCreateInfo>.Equals(RayTracingShaderGroupCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Type.GetHashCode() ^ GeneralShader.GetHashCode()
			^ ClosestHitShader.GetHashCode() ^ AnyHitShader.GetHashCode() ^ IntersectionShader.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in RayTracingShaderGroupCreateInfo l, in RayTracingShaderGroupCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Type == r.Type) && (l.GeneralShader == r.GeneralShader)
			&& (l.ClosestHitShader == r.ClosestHitShader) && (l.AnyHitShader == r.AnyHitShader) && (l.IntersectionShader == r.IntersectionShader)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in RayTracingShaderGroupCreateInfo l, in RayTracingShaderGroupCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Type != r.Type) || (l.GeneralShader != r.GeneralShader)
			|| (l.ClosestHitShader != r.ClosestHitShader) || (l.AnyHitShader != r.AnyHitShader) || (l.IntersectionShader != r.IntersectionShader)
			;
	}


	/// <summary>Creates a new RayTracingShaderGroupCreateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out RayTracingShaderGroupCreateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref RayTracingShaderGroupCreateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct RayTracingPipelineCreateInfo : IEquatable<RayTracingPipelineCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.RayTracingPipelineCreateInfoNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.PipelineCreateFlags Flags;
	public uint StageCount;
	public Vk.PipelineShaderStageCreateInfo* Stages;
	public uint GroupCount;
	public Vk.NV.RayTracingShaderGroupCreateInfo* Groups;
	public uint MaxRecursionDepth;
	public Vk.Handle<Vk.PipelineLayout> Layout;
	public Vk.Handle<Vk.Pipeline> BasePipelineHandle;
	public int BasePipelineIndex;

	public readonly override bool Equals(object? obj) => (obj is RayTracingPipelineCreateInfo o) && (this == o);
	readonly bool IEquatable<RayTracingPipelineCreateInfo>.Equals(RayTracingPipelineCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ StageCount.GetHashCode()
			^ ((ulong)Stages).GetHashCode() ^ GroupCount.GetHashCode() ^ ((ulong)Groups).GetHashCode() ^ MaxRecursionDepth.GetHashCode()
			^ Layout.GetHashCode() ^ BasePipelineHandle.GetHashCode() ^ BasePipelineIndex.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in RayTracingPipelineCreateInfo l, in RayTracingPipelineCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.StageCount == r.StageCount)
			&& (l.Stages == r.Stages) && (l.GroupCount == r.GroupCount) && (l.Groups == r.Groups) && (l.MaxRecursionDepth == r.MaxRecursionDepth)
			&& (l.Layout == r.Layout) && (l.BasePipelineHandle == r.BasePipelineHandle) && (l.BasePipelineIndex == r.BasePipelineIndex)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in RayTracingPipelineCreateInfo l, in RayTracingPipelineCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.StageCount != r.StageCount)
			|| (l.Stages != r.Stages) || (l.GroupCount != r.GroupCount) || (l.Groups != r.Groups) || (l.MaxRecursionDepth != r.MaxRecursionDepth)
			|| (l.Layout != r.Layout) || (l.BasePipelineHandle != r.BasePipelineHandle) || (l.BasePipelineIndex != r.BasePipelineIndex)
			;
	}


	/// <summary>Creates a new RayTracingPipelineCreateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out RayTracingPipelineCreateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref RayTracingPipelineCreateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct GeometryTriangles : IEquatable<GeometryTriangles>
{
	public const Vk.StructureType TYPE = Vk.StructureType.GeometryTrianglesNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Handle<Vk.Buffer> VertexData;
	public Vk.DeviceSize VertexOffset;
	public uint VertexCount;
	public Vk.DeviceSize VertexStride;
	public Vk.Format VertexFormat;
	public Vk.Handle<Vk.Buffer> IndexData;
	public Vk.DeviceSize IndexOffset;
	public uint IndexCount;
	public Vk.IndexType IndexType;
	public Vk.Handle<Vk.Buffer> TransformData;
	public Vk.DeviceSize TransformOffset;

	public readonly override bool Equals(object? obj) => (obj is GeometryTriangles o) && (this == o);
	readonly bool IEquatable<GeometryTriangles>.Equals(GeometryTriangles obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ VertexData.GetHashCode() ^ VertexOffset.GetHashCode()
			^ VertexCount.GetHashCode() ^ VertexStride.GetHashCode() ^ VertexFormat.GetHashCode() ^ IndexData.GetHashCode()
			^ IndexOffset.GetHashCode() ^ IndexCount.GetHashCode() ^ IndexType.GetHashCode() ^ TransformData.GetHashCode()
			^ TransformOffset.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in GeometryTriangles l, in GeometryTriangles r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.VertexData == r.VertexData) && (l.VertexOffset == r.VertexOffset)
			&& (l.VertexCount == r.VertexCount) && (l.VertexStride == r.VertexStride) && (l.VertexFormat == r.VertexFormat) && (l.IndexData == r.IndexData)
			&& (l.IndexOffset == r.IndexOffset) && (l.IndexCount == r.IndexCount) && (l.IndexType == r.IndexType) && (l.TransformData == r.TransformData)
			&& (l.TransformOffset == r.TransformOffset)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in GeometryTriangles l, in GeometryTriangles r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.VertexData != r.VertexData) || (l.VertexOffset != r.VertexOffset)
			|| (l.VertexCount != r.VertexCount) || (l.VertexStride != r.VertexStride) || (l.VertexFormat != r.VertexFormat) || (l.IndexData != r.IndexData)
			|| (l.IndexOffset != r.IndexOffset) || (l.IndexCount != r.IndexCount) || (l.IndexType != r.IndexType) || (l.TransformData != r.TransformData)
			|| (l.TransformOffset != r.TransformOffset)
			;
	}


	/// <summary>Creates a new GeometryTriangles value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out GeometryTriangles value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref GeometryTriangles value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct GeometryAABB : IEquatable<GeometryAABB>
{
	public const Vk.StructureType TYPE = Vk.StructureType.GeometryAabbNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Handle<Vk.Buffer> AabbData;
	public uint NumAABBs;
	public uint Stride;
	public Vk.DeviceSize Offset;

	public readonly override bool Equals(object? obj) => (obj is GeometryAABB o) && (this == o);
	readonly bool IEquatable<GeometryAABB>.Equals(GeometryAABB obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ AabbData.GetHashCode() ^ NumAABBs.GetHashCode()
			^ Stride.GetHashCode() ^ Offset.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in GeometryAABB l, in GeometryAABB r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.AabbData == r.AabbData) && (l.NumAABBs == r.NumAABBs)
			&& (l.Stride == r.Stride) && (l.Offset == r.Offset)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in GeometryAABB l, in GeometryAABB r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.AabbData != r.AabbData) || (l.NumAABBs != r.NumAABBs)
			|| (l.Stride != r.Stride) || (l.Offset != r.Offset)
			;
	}


	/// <summary>Creates a new GeometryAABB value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out GeometryAABB value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref GeometryAABB value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct GeometryData : IEquatable<GeometryData>
{
	public Vk.NV.GeometryTriangles Triangles;
	public Vk.NV.GeometryAABB Aabbs;

	public readonly override bool Equals(object? obj) => (obj is GeometryData o) && (this == o);
	readonly bool IEquatable<GeometryData>.Equals(GeometryData obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Triangles.GetHashCode() ^ Aabbs.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in GeometryData l, in GeometryData r)
	{
		return
			(l.Triangles == r.Triangles) && (l.Aabbs == r.Aabbs)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in GeometryData l, in GeometryData r)
	{
		return
			(l.Triangles != r.Triangles) || (l.Aabbs != r.Aabbs)
			;
	}

}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct Geometry : IEquatable<Geometry>
{
	public const Vk.StructureType TYPE = Vk.StructureType.GeometryNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.KHR.GeometryType GeometryType;
	public Vk.NV.GeometryData Geometry_;
	public Vk.KHR.GeometryFlags Flags;

	public readonly override bool Equals(object? obj) => (obj is Geometry o) && (this == o);
	readonly bool IEquatable<Geometry>.Equals(Geometry obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ GeometryType.GetHashCode() ^ Geometry_.GetHashCode()
			^ Flags.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in Geometry l, in Geometry r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.GeometryType == r.GeometryType) && (l.Geometry_ == r.Geometry_)
			&& (l.Flags == r.Flags)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in Geometry l, in Geometry r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.GeometryType != r.GeometryType) || (l.Geometry_ != r.Geometry_)
			|| (l.Flags != r.Flags)
			;
	}


	/// <summary>Creates a new Geometry value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out Geometry value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref Geometry value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct AccelerationStructureInfo : IEquatable<AccelerationStructureInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.AccelerationStructureInfoNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.NV.AccelerationStructureType Type;
	public Vk.NV.BuildAccelerationStructureFlags Flags;
	public uint InstanceCount;
	public uint GeometryCount;
	public Vk.NV.Geometry* Geometries;

	public readonly override bool Equals(object? obj) => (obj is AccelerationStructureInfo o) && (this == o);
	readonly bool IEquatable<AccelerationStructureInfo>.Equals(AccelerationStructureInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Type.GetHashCode() ^ Flags.GetHashCode()
			^ InstanceCount.GetHashCode() ^ GeometryCount.GetHashCode() ^ ((ulong)Geometries).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in AccelerationStructureInfo l, in AccelerationStructureInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Type == r.Type) && (l.Flags == r.Flags)
			&& (l.InstanceCount == r.InstanceCount) && (l.GeometryCount == r.GeometryCount) && (l.Geometries == r.Geometries)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in AccelerationStructureInfo l, in AccelerationStructureInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Type != r.Type) || (l.Flags != r.Flags)
			|| (l.InstanceCount != r.InstanceCount) || (l.GeometryCount != r.GeometryCount) || (l.Geometries != r.Geometries)
			;
	}


	/// <summary>Creates a new AccelerationStructureInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out AccelerationStructureInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref AccelerationStructureInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct AccelerationStructureCreateInfo : IEquatable<AccelerationStructureCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.AccelerationStructureCreateInfoNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.DeviceSize CompactedSize;
	public Vk.NV.AccelerationStructureInfo Info;

	public readonly override bool Equals(object? obj) => (obj is AccelerationStructureCreateInfo o) && (this == o);
	readonly bool IEquatable<AccelerationStructureCreateInfo>.Equals(AccelerationStructureCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ CompactedSize.GetHashCode() ^ Info.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in AccelerationStructureCreateInfo l, in AccelerationStructureCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.CompactedSize == r.CompactedSize) && (l.Info == r.Info)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in AccelerationStructureCreateInfo l, in AccelerationStructureCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.CompactedSize != r.CompactedSize) || (l.Info != r.Info)
			;
	}


	/// <summary>Creates a new AccelerationStructureCreateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out AccelerationStructureCreateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref AccelerationStructureCreateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct BindAccelerationStructureMemoryInfo : IEquatable<BindAccelerationStructureMemoryInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.BindAccelerationStructureMemoryInfoKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Handle<Vk.KHR.AccelerationStructure> AccelerationStructure;
	public Vk.Handle<Vk.DeviceMemory> Memory;
	public Vk.DeviceSize MemoryOffset;
	public uint DeviceIndexCount;
	public uint* DeviceIndices;

	public readonly override bool Equals(object? obj) => (obj is BindAccelerationStructureMemoryInfo o) && (this == o);
	readonly bool IEquatable<BindAccelerationStructureMemoryInfo>.Equals(BindAccelerationStructureMemoryInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ AccelerationStructure.GetHashCode() ^ Memory.GetHashCode()
			^ MemoryOffset.GetHashCode() ^ DeviceIndexCount.GetHashCode() ^ ((ulong)DeviceIndices).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in BindAccelerationStructureMemoryInfo l, in BindAccelerationStructureMemoryInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.AccelerationStructure == r.AccelerationStructure) && (l.Memory == r.Memory)
			&& (l.MemoryOffset == r.MemoryOffset) && (l.DeviceIndexCount == r.DeviceIndexCount) && (l.DeviceIndices == r.DeviceIndices)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in BindAccelerationStructureMemoryInfo l, in BindAccelerationStructureMemoryInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.AccelerationStructure != r.AccelerationStructure) || (l.Memory != r.Memory)
			|| (l.MemoryOffset != r.MemoryOffset) || (l.DeviceIndexCount != r.DeviceIndexCount) || (l.DeviceIndices != r.DeviceIndices)
			;
	}


	/// <summary>Creates a new BindAccelerationStructureMemoryInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out BindAccelerationStructureMemoryInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref BindAccelerationStructureMemoryInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct WriteDescriptorSetAccelerationStructure : IEquatable<WriteDescriptorSetAccelerationStructure>
{
	public const Vk.StructureType TYPE = Vk.StructureType.WriteDescriptorSetAccelerationStructureKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public uint AccelerationStructureCount;
	public Vk.Handle<Vk.KHR.AccelerationStructure>* AccelerationStructures;

	public readonly override bool Equals(object? obj) => (obj is WriteDescriptorSetAccelerationStructure o) && (this == o);
	readonly bool IEquatable<WriteDescriptorSetAccelerationStructure>.Equals(WriteDescriptorSetAccelerationStructure obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ AccelerationStructureCount.GetHashCode() ^ ((ulong)AccelerationStructures).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in WriteDescriptorSetAccelerationStructure l, in WriteDescriptorSetAccelerationStructure r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.AccelerationStructureCount == r.AccelerationStructureCount) && (l.AccelerationStructures == r.AccelerationStructures)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in WriteDescriptorSetAccelerationStructure l, in WriteDescriptorSetAccelerationStructure r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.AccelerationStructureCount != r.AccelerationStructureCount) || (l.AccelerationStructures != r.AccelerationStructures)
			;
	}


	/// <summary>Creates a new WriteDescriptorSetAccelerationStructure value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out WriteDescriptorSetAccelerationStructure value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref WriteDescriptorSetAccelerationStructure value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct AccelerationStructureMemoryRequirementsInfo : IEquatable<AccelerationStructureMemoryRequirementsInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.AccelerationStructureMemoryRequirementsInfoNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.NV.AccelerationStructureMemoryRequirementsType Type;
	public Vk.Handle<Vk.NV.AccelerationStructure> AccelerationStructure;

	public readonly override bool Equals(object? obj) => (obj is AccelerationStructureMemoryRequirementsInfo o) && (this == o);
	readonly bool IEquatable<AccelerationStructureMemoryRequirementsInfo>.Equals(AccelerationStructureMemoryRequirementsInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Type.GetHashCode() ^ AccelerationStructure.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in AccelerationStructureMemoryRequirementsInfo l, in AccelerationStructureMemoryRequirementsInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Type == r.Type) && (l.AccelerationStructure == r.AccelerationStructure)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in AccelerationStructureMemoryRequirementsInfo l, in AccelerationStructureMemoryRequirementsInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Type != r.Type) || (l.AccelerationStructure != r.AccelerationStructure)
			;
	}


	/// <summary>Creates a new AccelerationStructureMemoryRequirementsInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out AccelerationStructureMemoryRequirementsInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref AccelerationStructureMemoryRequirementsInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceRayTracingProperties : IEquatable<PhysicalDeviceRayTracingProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceRayTracingPropertiesNV;

	public Vk.StructureType sType;
	public void* pNext;
	public uint ShaderGroupHandleSize;
	public uint MaxRecursionDepth;
	public uint MaxShaderGroupStride;
	public uint ShaderGroupBaseAlignment;
	public ulong MaxGeometryCount;
	public ulong MaxInstanceCount;
	public ulong MaxTriangleCount;
	public uint MaxDescriptorSetAccelerationStructures;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceRayTracingProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceRayTracingProperties>.Equals(PhysicalDeviceRayTracingProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ShaderGroupHandleSize.GetHashCode() ^ MaxRecursionDepth.GetHashCode()
			^ MaxShaderGroupStride.GetHashCode() ^ ShaderGroupBaseAlignment.GetHashCode() ^ MaxGeometryCount.GetHashCode() ^ MaxInstanceCount.GetHashCode()
			^ MaxTriangleCount.GetHashCode() ^ MaxDescriptorSetAccelerationStructures.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceRayTracingProperties l, in PhysicalDeviceRayTracingProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ShaderGroupHandleSize == r.ShaderGroupHandleSize) && (l.MaxRecursionDepth == r.MaxRecursionDepth)
			&& (l.MaxShaderGroupStride == r.MaxShaderGroupStride) && (l.ShaderGroupBaseAlignment == r.ShaderGroupBaseAlignment) && (l.MaxGeometryCount == r.MaxGeometryCount) && (l.MaxInstanceCount == r.MaxInstanceCount)
			&& (l.MaxTriangleCount == r.MaxTriangleCount) && (l.MaxDescriptorSetAccelerationStructures == r.MaxDescriptorSetAccelerationStructures)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceRayTracingProperties l, in PhysicalDeviceRayTracingProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ShaderGroupHandleSize != r.ShaderGroupHandleSize) || (l.MaxRecursionDepth != r.MaxRecursionDepth)
			|| (l.MaxShaderGroupStride != r.MaxShaderGroupStride) || (l.ShaderGroupBaseAlignment != r.ShaderGroupBaseAlignment) || (l.MaxGeometryCount != r.MaxGeometryCount) || (l.MaxInstanceCount != r.MaxInstanceCount)
			|| (l.MaxTriangleCount != r.MaxTriangleCount) || (l.MaxDescriptorSetAccelerationStructures != r.MaxDescriptorSetAccelerationStructures)
			;
	}


	/// <summary>Creates a new PhysicalDeviceRayTracingProperties value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceRayTracingProperties value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceRayTracingProperties value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceCooperativeMatrixFeatures : IEquatable<PhysicalDeviceCooperativeMatrixFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceCooperativeMatrixFeaturesNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 CooperativeMatrix;
	public Vk.Bool32 CooperativeMatrixRobustBufferAccess;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceCooperativeMatrixFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceCooperativeMatrixFeatures>.Equals(PhysicalDeviceCooperativeMatrixFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ CooperativeMatrix.GetHashCode() ^ CooperativeMatrixRobustBufferAccess.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceCooperativeMatrixFeatures l, in PhysicalDeviceCooperativeMatrixFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.CooperativeMatrix == r.CooperativeMatrix) && (l.CooperativeMatrixRobustBufferAccess == r.CooperativeMatrixRobustBufferAccess)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceCooperativeMatrixFeatures l, in PhysicalDeviceCooperativeMatrixFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.CooperativeMatrix != r.CooperativeMatrix) || (l.CooperativeMatrixRobustBufferAccess != r.CooperativeMatrixRobustBufferAccess)
			;
	}


	/// <summary>Creates a new PhysicalDeviceCooperativeMatrixFeatures value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceCooperativeMatrixFeatures value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceCooperativeMatrixFeatures value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceCooperativeMatrixProperties : IEquatable<PhysicalDeviceCooperativeMatrixProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceCooperativeMatrixPropertiesNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.ShaderStageFlags CooperativeMatrixSupportedStages;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceCooperativeMatrixProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceCooperativeMatrixProperties>.Equals(PhysicalDeviceCooperativeMatrixProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ CooperativeMatrixSupportedStages.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceCooperativeMatrixProperties l, in PhysicalDeviceCooperativeMatrixProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.CooperativeMatrixSupportedStages == r.CooperativeMatrixSupportedStages)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceCooperativeMatrixProperties l, in PhysicalDeviceCooperativeMatrixProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.CooperativeMatrixSupportedStages != r.CooperativeMatrixSupportedStages)
			;
	}


	/// <summary>Creates a new PhysicalDeviceCooperativeMatrixProperties value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceCooperativeMatrixProperties value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceCooperativeMatrixProperties value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct CooperativeMatrixProperties : IEquatable<CooperativeMatrixProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.CooperativeMatrixPropertiesNV;

	public Vk.StructureType sType;
	public void* pNext;
	public uint MSize;
	public uint NSize;
	public uint KSize;
	public Vk.NV.ComponentType AType;
	public Vk.NV.ComponentType BType;
	public Vk.NV.ComponentType CType;
	public Vk.NV.ComponentType DType;
	public Vk.NV.Scope Scope;

	public readonly override bool Equals(object? obj) => (obj is CooperativeMatrixProperties o) && (this == o);
	readonly bool IEquatable<CooperativeMatrixProperties>.Equals(CooperativeMatrixProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MSize.GetHashCode() ^ NSize.GetHashCode()
			^ KSize.GetHashCode() ^ AType.GetHashCode() ^ BType.GetHashCode() ^ CType.GetHashCode()
			^ DType.GetHashCode() ^ Scope.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in CooperativeMatrixProperties l, in CooperativeMatrixProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MSize == r.MSize) && (l.NSize == r.NSize)
			&& (l.KSize == r.KSize) && (l.AType == r.AType) && (l.BType == r.BType) && (l.CType == r.CType)
			&& (l.DType == r.DType) && (l.Scope == r.Scope)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in CooperativeMatrixProperties l, in CooperativeMatrixProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MSize != r.MSize) || (l.NSize != r.NSize)
			|| (l.KSize != r.KSize) || (l.AType != r.AType) || (l.BType != r.BType) || (l.CType != r.CType)
			|| (l.DType != r.DType) || (l.Scope != r.Scope)
			;
	}


	/// <summary>Creates a new CooperativeMatrixProperties value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out CooperativeMatrixProperties value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref CooperativeMatrixProperties value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceCoverageReductionModeFeatures : IEquatable<PhysicalDeviceCoverageReductionModeFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceCoverageReductionModeFeaturesNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 CoverageReductionMode;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceCoverageReductionModeFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceCoverageReductionModeFeatures>.Equals(PhysicalDeviceCoverageReductionModeFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ CoverageReductionMode.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceCoverageReductionModeFeatures l, in PhysicalDeviceCoverageReductionModeFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.CoverageReductionMode == r.CoverageReductionMode)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceCoverageReductionModeFeatures l, in PhysicalDeviceCoverageReductionModeFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.CoverageReductionMode != r.CoverageReductionMode)
			;
	}


	/// <summary>Creates a new PhysicalDeviceCoverageReductionModeFeatures value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceCoverageReductionModeFeatures value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceCoverageReductionModeFeatures value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PipelineCoverageReductionStateCreateInfo : IEquatable<PipelineCoverageReductionStateCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PipelineCoverageReductionStateCreateInfoNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.NV.PipelineCoverageReductionStateCreateFlags Flags;
	public Vk.NV.CoverageReductionMode CoverageReductionMode;

	public readonly override bool Equals(object? obj) => (obj is PipelineCoverageReductionStateCreateInfo o) && (this == o);
	readonly bool IEquatable<PipelineCoverageReductionStateCreateInfo>.Equals(PipelineCoverageReductionStateCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ CoverageReductionMode.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PipelineCoverageReductionStateCreateInfo l, in PipelineCoverageReductionStateCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.CoverageReductionMode == r.CoverageReductionMode)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PipelineCoverageReductionStateCreateInfo l, in PipelineCoverageReductionStateCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.CoverageReductionMode != r.CoverageReductionMode)
			;
	}


	/// <summary>Creates a new PipelineCoverageReductionStateCreateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PipelineCoverageReductionStateCreateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PipelineCoverageReductionStateCreateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct FramebufferMixedSamplesCombination : IEquatable<FramebufferMixedSamplesCombination>
{
	public const Vk.StructureType TYPE = Vk.StructureType.FramebufferMixedSamplesCombinationNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.NV.CoverageReductionMode CoverageReductionMode;
	public Vk.SampleCountFlags RasterizationSamples;
	public Vk.SampleCountFlags DepthStencilSamples;
	public Vk.SampleCountFlags ColorSamples;

	public readonly override bool Equals(object? obj) => (obj is FramebufferMixedSamplesCombination o) && (this == o);
	readonly bool IEquatable<FramebufferMixedSamplesCombination>.Equals(FramebufferMixedSamplesCombination obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ CoverageReductionMode.GetHashCode() ^ RasterizationSamples.GetHashCode()
			^ DepthStencilSamples.GetHashCode() ^ ColorSamples.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in FramebufferMixedSamplesCombination l, in FramebufferMixedSamplesCombination r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.CoverageReductionMode == r.CoverageReductionMode) && (l.RasterizationSamples == r.RasterizationSamples)
			&& (l.DepthStencilSamples == r.DepthStencilSamples) && (l.ColorSamples == r.ColorSamples)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in FramebufferMixedSamplesCombination l, in FramebufferMixedSamplesCombination r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.CoverageReductionMode != r.CoverageReductionMode) || (l.RasterizationSamples != r.RasterizationSamples)
			|| (l.DepthStencilSamples != r.DepthStencilSamples) || (l.ColorSamples != r.ColorSamples)
			;
	}


	/// <summary>Creates a new FramebufferMixedSamplesCombination value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out FramebufferMixedSamplesCombination value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref FramebufferMixedSamplesCombination value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceShaderSMBuiltinsProperties : IEquatable<PhysicalDeviceShaderSMBuiltinsProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceShaderSmBuiltinsPropertiesNV;

	public Vk.StructureType sType;
	public void* pNext;
	public uint ShaderSMCount;
	public uint ShaderWarpsPerSM;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceShaderSMBuiltinsProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceShaderSMBuiltinsProperties>.Equals(PhysicalDeviceShaderSMBuiltinsProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ShaderSMCount.GetHashCode() ^ ShaderWarpsPerSM.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceShaderSMBuiltinsProperties l, in PhysicalDeviceShaderSMBuiltinsProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ShaderSMCount == r.ShaderSMCount) && (l.ShaderWarpsPerSM == r.ShaderWarpsPerSM)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceShaderSMBuiltinsProperties l, in PhysicalDeviceShaderSMBuiltinsProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ShaderSMCount != r.ShaderSMCount) || (l.ShaderWarpsPerSM != r.ShaderWarpsPerSM)
			;
	}


	/// <summary>Creates a new PhysicalDeviceShaderSMBuiltinsProperties value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceShaderSMBuiltinsProperties value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceShaderSMBuiltinsProperties value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceShaderSMBuiltinsFeatures : IEquatable<PhysicalDeviceShaderSMBuiltinsFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceShaderSmBuiltinsFeaturesNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 ShaderSMBuiltins;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceShaderSMBuiltinsFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceShaderSMBuiltinsFeatures>.Equals(PhysicalDeviceShaderSMBuiltinsFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ShaderSMBuiltins.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceShaderSMBuiltinsFeatures l, in PhysicalDeviceShaderSMBuiltinsFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ShaderSMBuiltins == r.ShaderSMBuiltins)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceShaderSMBuiltinsFeatures l, in PhysicalDeviceShaderSMBuiltinsFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ShaderSMBuiltins != r.ShaderSMBuiltins)
			;
	}


	/// <summary>Creates a new PhysicalDeviceShaderSMBuiltinsFeatures value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceShaderSMBuiltinsFeatures value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceShaderSMBuiltinsFeatures value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct AabbPositions : IEquatable<AabbPositions>
{
	public float MinX;
	public float MinY;
	public float MinZ;
	public float MaxX;
	public float MaxY;
	public float MaxZ;

	public readonly override bool Equals(object? obj) => (obj is AabbPositions o) && (this == o);
	readonly bool IEquatable<AabbPositions>.Equals(AabbPositions obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			MinX.GetHashCode() ^ MinY.GetHashCode() ^ MinZ.GetHashCode() ^ MaxX.GetHashCode()
			^ MaxY.GetHashCode() ^ MaxZ.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in AabbPositions l, in AabbPositions r)
	{
		return
			(l.MinX == r.MinX) && (l.MinY == r.MinY) && (l.MinZ == r.MinZ) && (l.MaxX == r.MaxX)
			&& (l.MaxY == r.MaxY) && (l.MaxZ == r.MaxZ)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in AabbPositions l, in AabbPositions r)
	{
		return
			(l.MinX != r.MinX) || (l.MinY != r.MinY) || (l.MinZ != r.MinZ) || (l.MaxX != r.MaxX)
			|| (l.MaxY != r.MaxY) || (l.MaxZ != r.MaxZ)
			;
	}

}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct TransformMatrix : IEquatable<TransformMatrix>
{
	public fixed float Matrix[12];

	public readonly override bool Equals(object? obj) => (obj is TransformMatrix o) && (this == o);
	readonly bool IEquatable<TransformMatrix>.Equals(TransformMatrix obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Matrix[0].GetHashCode() ^ Matrix[1].GetHashCode() ^ Matrix[2].GetHashCode() ^ Matrix[3].GetHashCode()
			^ Matrix[4].GetHashCode() ^ Matrix[5].GetHashCode() ^ Matrix[6].GetHashCode() ^ Matrix[7].GetHashCode()
			^ Matrix[8].GetHashCode() ^ Matrix[9].GetHashCode() ^ Matrix[10].GetHashCode() ^ Matrix[11].GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in TransformMatrix l, in TransformMatrix r)
	{
		return
			(l.Matrix[0] == r.Matrix[0]) && (l.Matrix[1] == r.Matrix[1]) && (l.Matrix[2] == r.Matrix[2]) && (l.Matrix[3] == r.Matrix[3])
			&& (l.Matrix[4] == r.Matrix[4]) && (l.Matrix[5] == r.Matrix[5]) && (l.Matrix[6] == r.Matrix[6]) && (l.Matrix[7] == r.Matrix[7])
			&& (l.Matrix[8] == r.Matrix[8]) && (l.Matrix[9] == r.Matrix[9]) && (l.Matrix[10] == r.Matrix[10]) && (l.Matrix[11] == r.Matrix[11])
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in TransformMatrix l, in TransformMatrix r)
	{
		return
			(l.Matrix[0] != r.Matrix[0]) || (l.Matrix[1] != r.Matrix[1]) || (l.Matrix[2] != r.Matrix[2]) || (l.Matrix[3] != r.Matrix[3])
			|| (l.Matrix[4] != r.Matrix[4]) || (l.Matrix[5] != r.Matrix[5]) || (l.Matrix[6] != r.Matrix[6]) || (l.Matrix[7] != r.Matrix[7])
			|| (l.Matrix[8] != r.Matrix[8]) || (l.Matrix[9] != r.Matrix[9]) || (l.Matrix[10] != r.Matrix[10]) || (l.Matrix[11] != r.Matrix[11])
			;
	}

}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct AccelerationStructureInstance : IEquatable<AccelerationStructureInstance>
{
	public Vk.KHR.TransformMatrix Transform;
	public uint InstanceCustomIndex;
	public uint Mask;
	public uint InstanceShaderBindingTableRecordOffset;
	public Vk.KHR.GeometryInstanceFlags Flags;
	public ulong AccelerationStructureReference;

	public readonly override bool Equals(object? obj) => (obj is AccelerationStructureInstance o) && (this == o);
	readonly bool IEquatable<AccelerationStructureInstance>.Equals(AccelerationStructureInstance obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Transform.GetHashCode() ^ InstanceCustomIndex.GetHashCode() ^ Mask.GetHashCode() ^ InstanceShaderBindingTableRecordOffset.GetHashCode()
			^ Flags.GetHashCode() ^ AccelerationStructureReference.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in AccelerationStructureInstance l, in AccelerationStructureInstance r)
	{
		return
			(l.Transform == r.Transform) && (l.InstanceCustomIndex == r.InstanceCustomIndex) && (l.Mask == r.Mask) && (l.InstanceShaderBindingTableRecordOffset == r.InstanceShaderBindingTableRecordOffset)
			&& (l.Flags == r.Flags) && (l.AccelerationStructureReference == r.AccelerationStructureReference)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in AccelerationStructureInstance l, in AccelerationStructureInstance r)
	{
		return
			(l.Transform != r.Transform) || (l.InstanceCustomIndex != r.InstanceCustomIndex) || (l.Mask != r.Mask) || (l.InstanceShaderBindingTableRecordOffset != r.InstanceShaderBindingTableRecordOffset)
			|| (l.Flags != r.Flags) || (l.AccelerationStructureReference != r.AccelerationStructureReference)
			;
	}

}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceDiagnosticsConfigFeatures : IEquatable<PhysicalDeviceDiagnosticsConfigFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceDiagnosticsConfigFeaturesNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 DiagnosticsConfig;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceDiagnosticsConfigFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceDiagnosticsConfigFeatures>.Equals(PhysicalDeviceDiagnosticsConfigFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DiagnosticsConfig.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceDiagnosticsConfigFeatures l, in PhysicalDeviceDiagnosticsConfigFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DiagnosticsConfig == r.DiagnosticsConfig)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceDiagnosticsConfigFeatures l, in PhysicalDeviceDiagnosticsConfigFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DiagnosticsConfig != r.DiagnosticsConfig)
			;
	}


	/// <summary>Creates a new PhysicalDeviceDiagnosticsConfigFeatures value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceDiagnosticsConfigFeatures value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceDiagnosticsConfigFeatures value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DeviceDiagnosticsConfigCreateInfo : IEquatable<DeviceDiagnosticsConfigCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DeviceDiagnosticsConfigCreateInfoNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.NV.DeviceDiagnosticsConfigFlags Flags;

	public readonly override bool Equals(object? obj) => (obj is DeviceDiagnosticsConfigCreateInfo o) && (this == o);
	readonly bool IEquatable<DeviceDiagnosticsConfigCreateInfo>.Equals(DeviceDiagnosticsConfigCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DeviceDiagnosticsConfigCreateInfo l, in DeviceDiagnosticsConfigCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DeviceDiagnosticsConfigCreateInfo l, in DeviceDiagnosticsConfigCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags)
			;
	}


	/// <summary>Creates a new DeviceDiagnosticsConfigCreateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DeviceDiagnosticsConfigCreateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref DeviceDiagnosticsConfigCreateInfo value) { value.sType = TYPE; value.pNext = null; }
}

} // namespace Vk.NV
