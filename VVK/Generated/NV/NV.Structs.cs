/*
 * MIT License - Copyright(c) 2020 Sean Moss
 * This file is subject to the terms and conditions of the MIT License, the text of which can be found in the 'LICENSE'
 * file at the root of this repository, or online at<https://opensource.org/licenses/MIT>.
 */

/// This file was generated by VVKGen. Edits to this file will be lost on next generation.

using System;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;


namespace Vk.NV
{

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DedicatedAllocationImageCreateInfo : IEquatable<DedicatedAllocationImageCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DedicatedAllocationImageCreateInfoNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 DedicatedAllocation;

	public readonly override bool Equals(object? obj) => (obj is DedicatedAllocationImageCreateInfo o) && (this == o);
	readonly bool IEquatable<DedicatedAllocationImageCreateInfo>.Equals(DedicatedAllocationImageCreateInfo obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (Vk.StructureType* ptr = &sType) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<DedicatedAllocationImageCreateInfo>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in DedicatedAllocationImageCreateInfo l, in DedicatedAllocationImageCreateInfo r)
	{
		fixed (DedicatedAllocationImageCreateInfo* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<DedicatedAllocationImageCreateInfo>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<DedicatedAllocationImageCreateInfo>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in DedicatedAllocationImageCreateInfo l, in DedicatedAllocationImageCreateInfo r)
	{
		fixed (DedicatedAllocationImageCreateInfo* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<DedicatedAllocationImageCreateInfo>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<DedicatedAllocationImageCreateInfo>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}


	/// <summary>Creates a new DedicatedAllocationImageCreateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DedicatedAllocationImageCreateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref DedicatedAllocationImageCreateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DedicatedAllocationBufferCreateInfo : IEquatable<DedicatedAllocationBufferCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DedicatedAllocationBufferCreateInfoNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 DedicatedAllocation;

	public readonly override bool Equals(object? obj) => (obj is DedicatedAllocationBufferCreateInfo o) && (this == o);
	readonly bool IEquatable<DedicatedAllocationBufferCreateInfo>.Equals(DedicatedAllocationBufferCreateInfo obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (Vk.StructureType* ptr = &sType) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<DedicatedAllocationBufferCreateInfo>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in DedicatedAllocationBufferCreateInfo l, in DedicatedAllocationBufferCreateInfo r)
	{
		fixed (DedicatedAllocationBufferCreateInfo* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<DedicatedAllocationBufferCreateInfo>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<DedicatedAllocationBufferCreateInfo>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in DedicatedAllocationBufferCreateInfo l, in DedicatedAllocationBufferCreateInfo r)
	{
		fixed (DedicatedAllocationBufferCreateInfo* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<DedicatedAllocationBufferCreateInfo>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<DedicatedAllocationBufferCreateInfo>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}


	/// <summary>Creates a new DedicatedAllocationBufferCreateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DedicatedAllocationBufferCreateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref DedicatedAllocationBufferCreateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DedicatedAllocationMemoryAllocateInfo : IEquatable<DedicatedAllocationMemoryAllocateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DedicatedAllocationMemoryAllocateInfoNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Handle<Vk.Image> Image;
	public Vk.Handle<Vk.Buffer> Buffer;

	public readonly override bool Equals(object? obj) => (obj is DedicatedAllocationMemoryAllocateInfo o) && (this == o);
	readonly bool IEquatable<DedicatedAllocationMemoryAllocateInfo>.Equals(DedicatedAllocationMemoryAllocateInfo obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (Vk.StructureType* ptr = &sType) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<DedicatedAllocationMemoryAllocateInfo>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in DedicatedAllocationMemoryAllocateInfo l, in DedicatedAllocationMemoryAllocateInfo r)
	{
		fixed (DedicatedAllocationMemoryAllocateInfo* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<DedicatedAllocationMemoryAllocateInfo>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<DedicatedAllocationMemoryAllocateInfo>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in DedicatedAllocationMemoryAllocateInfo l, in DedicatedAllocationMemoryAllocateInfo r)
	{
		fixed (DedicatedAllocationMemoryAllocateInfo* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<DedicatedAllocationMemoryAllocateInfo>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<DedicatedAllocationMemoryAllocateInfo>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}


	/// <summary>Creates a new DedicatedAllocationMemoryAllocateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DedicatedAllocationMemoryAllocateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref DedicatedAllocationMemoryAllocateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ExternalImageFormatProperties : IEquatable<ExternalImageFormatProperties>
{
	public Vk.ImageFormatProperties ImageFormatProperties;
	public Vk.NV.ExternalMemoryFeatureFlags ExternalMemoryFeatures;
	public Vk.NV.ExternalMemoryHandleTypeFlags ExportFromImportedHandleTypes;
	public Vk.NV.ExternalMemoryHandleTypeFlags CompatibleHandleTypes;

	public readonly override bool Equals(object? obj) => (obj is ExternalImageFormatProperties o) && (this == o);
	readonly bool IEquatable<ExternalImageFormatProperties>.Equals(ExternalImageFormatProperties obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (Vk.ImageFormatProperties* ptr = &ImageFormatProperties) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<ExternalImageFormatProperties>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in ExternalImageFormatProperties l, in ExternalImageFormatProperties r)
	{
		fixed (ExternalImageFormatProperties* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<ExternalImageFormatProperties>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<ExternalImageFormatProperties>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in ExternalImageFormatProperties l, in ExternalImageFormatProperties r)
	{
		fixed (ExternalImageFormatProperties* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<ExternalImageFormatProperties>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<ExternalImageFormatProperties>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}

}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ExternalMemoryImageCreateInfo : IEquatable<ExternalMemoryImageCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ExternalMemoryImageCreateInfoNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.NV.ExternalMemoryHandleTypeFlags HandleTypes;

	public readonly override bool Equals(object? obj) => (obj is ExternalMemoryImageCreateInfo o) && (this == o);
	readonly bool IEquatable<ExternalMemoryImageCreateInfo>.Equals(ExternalMemoryImageCreateInfo obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (Vk.StructureType* ptr = &sType) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<ExternalMemoryImageCreateInfo>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in ExternalMemoryImageCreateInfo l, in ExternalMemoryImageCreateInfo r)
	{
		fixed (ExternalMemoryImageCreateInfo* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<ExternalMemoryImageCreateInfo>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<ExternalMemoryImageCreateInfo>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in ExternalMemoryImageCreateInfo l, in ExternalMemoryImageCreateInfo r)
	{
		fixed (ExternalMemoryImageCreateInfo* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<ExternalMemoryImageCreateInfo>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<ExternalMemoryImageCreateInfo>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}


	/// <summary>Creates a new ExternalMemoryImageCreateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ExternalMemoryImageCreateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref ExternalMemoryImageCreateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ExportMemoryAllocateInfo : IEquatable<ExportMemoryAllocateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ExportMemoryAllocateInfoNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.NV.ExternalMemoryHandleTypeFlags HandleTypes;

	public readonly override bool Equals(object? obj) => (obj is ExportMemoryAllocateInfo o) && (this == o);
	readonly bool IEquatable<ExportMemoryAllocateInfo>.Equals(ExportMemoryAllocateInfo obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (Vk.StructureType* ptr = &sType) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<ExportMemoryAllocateInfo>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in ExportMemoryAllocateInfo l, in ExportMemoryAllocateInfo r)
	{
		fixed (ExportMemoryAllocateInfo* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<ExportMemoryAllocateInfo>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<ExportMemoryAllocateInfo>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in ExportMemoryAllocateInfo l, in ExportMemoryAllocateInfo r)
	{
		fixed (ExportMemoryAllocateInfo* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<ExportMemoryAllocateInfo>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<ExportMemoryAllocateInfo>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}


	/// <summary>Creates a new ExportMemoryAllocateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ExportMemoryAllocateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref ExportMemoryAllocateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ImportMemoryWin32HandleInfo : IEquatable<ImportMemoryWin32HandleInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ImportMemoryWin32HandleInfoNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.NV.ExternalMemoryHandleTypeFlags HandleType;
	public void* Handle;

	public readonly override bool Equals(object? obj) => (obj is ImportMemoryWin32HandleInfo o) && (this == o);
	readonly bool IEquatable<ImportMemoryWin32HandleInfo>.Equals(ImportMemoryWin32HandleInfo obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (Vk.StructureType* ptr = &sType) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<ImportMemoryWin32HandleInfo>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in ImportMemoryWin32HandleInfo l, in ImportMemoryWin32HandleInfo r)
	{
		fixed (ImportMemoryWin32HandleInfo* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<ImportMemoryWin32HandleInfo>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<ImportMemoryWin32HandleInfo>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in ImportMemoryWin32HandleInfo l, in ImportMemoryWin32HandleInfo r)
	{
		fixed (ImportMemoryWin32HandleInfo* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<ImportMemoryWin32HandleInfo>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<ImportMemoryWin32HandleInfo>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}


	/// <summary>Creates a new ImportMemoryWin32HandleInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ImportMemoryWin32HandleInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref ImportMemoryWin32HandleInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ExportMemoryWin32HandleInfo : IEquatable<ExportMemoryWin32HandleInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ExportMemoryWin32HandleInfoNV;

	public Vk.StructureType sType;
	public void* pNext;
	public void* Attributes;
	public uint DwAccess;

	public readonly override bool Equals(object? obj) => (obj is ExportMemoryWin32HandleInfo o) && (this == o);
	readonly bool IEquatable<ExportMemoryWin32HandleInfo>.Equals(ExportMemoryWin32HandleInfo obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (Vk.StructureType* ptr = &sType) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<ExportMemoryWin32HandleInfo>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in ExportMemoryWin32HandleInfo l, in ExportMemoryWin32HandleInfo r)
	{
		fixed (ExportMemoryWin32HandleInfo* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<ExportMemoryWin32HandleInfo>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<ExportMemoryWin32HandleInfo>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in ExportMemoryWin32HandleInfo l, in ExportMemoryWin32HandleInfo r)
	{
		fixed (ExportMemoryWin32HandleInfo* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<ExportMemoryWin32HandleInfo>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<ExportMemoryWin32HandleInfo>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}


	/// <summary>Creates a new ExportMemoryWin32HandleInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ExportMemoryWin32HandleInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref ExportMemoryWin32HandleInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct Win32KeyedMutexAcquireReleaseInfo : IEquatable<Win32KeyedMutexAcquireReleaseInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.Win32KeyedMutexAcquireReleaseInfoNV;

	public Vk.StructureType sType;
	public void* pNext;
	public uint AcquireCount;
	public Vk.Handle<Vk.DeviceMemory>* AcquireSyncs;
	public ulong* AcquireKeys;
	public uint* AcquireTimeoutMilliseconds;
	public uint ReleaseCount;
	public Vk.Handle<Vk.DeviceMemory>* ReleaseSyncs;
	public ulong* ReleaseKeys;

	public readonly override bool Equals(object? obj) => (obj is Win32KeyedMutexAcquireReleaseInfo o) && (this == o);
	readonly bool IEquatable<Win32KeyedMutexAcquireReleaseInfo>.Equals(Win32KeyedMutexAcquireReleaseInfo obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (Vk.StructureType* ptr = &sType) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<Win32KeyedMutexAcquireReleaseInfo>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in Win32KeyedMutexAcquireReleaseInfo l, in Win32KeyedMutexAcquireReleaseInfo r)
	{
		fixed (Win32KeyedMutexAcquireReleaseInfo* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<Win32KeyedMutexAcquireReleaseInfo>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<Win32KeyedMutexAcquireReleaseInfo>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in Win32KeyedMutexAcquireReleaseInfo l, in Win32KeyedMutexAcquireReleaseInfo r)
	{
		fixed (Win32KeyedMutexAcquireReleaseInfo* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<Win32KeyedMutexAcquireReleaseInfo>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<Win32KeyedMutexAcquireReleaseInfo>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}


	/// <summary>Creates a new Win32KeyedMutexAcquireReleaseInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out Win32KeyedMutexAcquireReleaseInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref Win32KeyedMutexAcquireReleaseInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceDeviceGeneratedCommandsFeatures : IEquatable<PhysicalDeviceDeviceGeneratedCommandsFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceDeviceGeneratedCommandsFeaturesNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 DeviceGeneratedCommands;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceDeviceGeneratedCommandsFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceDeviceGeneratedCommandsFeatures>.Equals(PhysicalDeviceDeviceGeneratedCommandsFeatures obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (Vk.StructureType* ptr = &sType) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<PhysicalDeviceDeviceGeneratedCommandsFeatures>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in PhysicalDeviceDeviceGeneratedCommandsFeatures l, in PhysicalDeviceDeviceGeneratedCommandsFeatures r)
	{
		fixed (PhysicalDeviceDeviceGeneratedCommandsFeatures* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<PhysicalDeviceDeviceGeneratedCommandsFeatures>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<PhysicalDeviceDeviceGeneratedCommandsFeatures>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in PhysicalDeviceDeviceGeneratedCommandsFeatures l, in PhysicalDeviceDeviceGeneratedCommandsFeatures r)
	{
		fixed (PhysicalDeviceDeviceGeneratedCommandsFeatures* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<PhysicalDeviceDeviceGeneratedCommandsFeatures>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<PhysicalDeviceDeviceGeneratedCommandsFeatures>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}


	/// <summary>Creates a new PhysicalDeviceDeviceGeneratedCommandsFeatures value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceDeviceGeneratedCommandsFeatures value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceDeviceGeneratedCommandsFeatures value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceDeviceGeneratedCommandsProperties : IEquatable<PhysicalDeviceDeviceGeneratedCommandsProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceDeviceGeneratedCommandsPropertiesNV;

	public Vk.StructureType sType;
	public void* pNext;
	public uint MaxGraphicsShaderGroupCount;
	public uint MaxIndirectSequenceCount;
	public uint MaxIndirectCommandsTokenCount;
	public uint MaxIndirectCommandsStreamCount;
	public uint MaxIndirectCommandsTokenOffset;
	public uint MaxIndirectCommandsStreamStride;
	public uint MinSequencesCountBufferOffsetAlignment;
	public uint MinSequencesIndexBufferOffsetAlignment;
	public uint MinIndirectCommandsBufferOffsetAlignment;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceDeviceGeneratedCommandsProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceDeviceGeneratedCommandsProperties>.Equals(PhysicalDeviceDeviceGeneratedCommandsProperties obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (Vk.StructureType* ptr = &sType) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<PhysicalDeviceDeviceGeneratedCommandsProperties>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in PhysicalDeviceDeviceGeneratedCommandsProperties l, in PhysicalDeviceDeviceGeneratedCommandsProperties r)
	{
		fixed (PhysicalDeviceDeviceGeneratedCommandsProperties* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<PhysicalDeviceDeviceGeneratedCommandsProperties>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<PhysicalDeviceDeviceGeneratedCommandsProperties>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in PhysicalDeviceDeviceGeneratedCommandsProperties l, in PhysicalDeviceDeviceGeneratedCommandsProperties r)
	{
		fixed (PhysicalDeviceDeviceGeneratedCommandsProperties* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<PhysicalDeviceDeviceGeneratedCommandsProperties>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<PhysicalDeviceDeviceGeneratedCommandsProperties>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}


	/// <summary>Creates a new PhysicalDeviceDeviceGeneratedCommandsProperties value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceDeviceGeneratedCommandsProperties value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceDeviceGeneratedCommandsProperties value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct GraphicsShaderGroupCreateInfo : IEquatable<GraphicsShaderGroupCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.GraphicsShaderGroupCreateInfoNV;

	public Vk.StructureType sType;
	public void* pNext;
	public uint StageCount;
	public Vk.PipelineShaderStageCreateInfo* Stages;
	public Vk.PipelineVertexInputStateCreateInfo* VertexInputState;
	public Vk.PipelineTessellationStateCreateInfo* TessellationState;

	public readonly override bool Equals(object? obj) => (obj is GraphicsShaderGroupCreateInfo o) && (this == o);
	readonly bool IEquatable<GraphicsShaderGroupCreateInfo>.Equals(GraphicsShaderGroupCreateInfo obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (Vk.StructureType* ptr = &sType) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<GraphicsShaderGroupCreateInfo>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in GraphicsShaderGroupCreateInfo l, in GraphicsShaderGroupCreateInfo r)
	{
		fixed (GraphicsShaderGroupCreateInfo* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<GraphicsShaderGroupCreateInfo>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<GraphicsShaderGroupCreateInfo>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in GraphicsShaderGroupCreateInfo l, in GraphicsShaderGroupCreateInfo r)
	{
		fixed (GraphicsShaderGroupCreateInfo* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<GraphicsShaderGroupCreateInfo>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<GraphicsShaderGroupCreateInfo>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}


	/// <summary>Creates a new GraphicsShaderGroupCreateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out GraphicsShaderGroupCreateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref GraphicsShaderGroupCreateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct GraphicsPipelineShaderGroupsCreateInfo : IEquatable<GraphicsPipelineShaderGroupsCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.GraphicsPipelineShaderGroupsCreateInfoNV;

	public Vk.StructureType sType;
	public void* pNext;
	public uint GroupCount;
	public Vk.NV.GraphicsShaderGroupCreateInfo* Groups;
	public uint PipelineCount;
	public Vk.Handle<Vk.Pipeline>* Pipelines;

	public readonly override bool Equals(object? obj) => (obj is GraphicsPipelineShaderGroupsCreateInfo o) && (this == o);
	readonly bool IEquatable<GraphicsPipelineShaderGroupsCreateInfo>.Equals(GraphicsPipelineShaderGroupsCreateInfo obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (Vk.StructureType* ptr = &sType) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<GraphicsPipelineShaderGroupsCreateInfo>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in GraphicsPipelineShaderGroupsCreateInfo l, in GraphicsPipelineShaderGroupsCreateInfo r)
	{
		fixed (GraphicsPipelineShaderGroupsCreateInfo* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<GraphicsPipelineShaderGroupsCreateInfo>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<GraphicsPipelineShaderGroupsCreateInfo>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in GraphicsPipelineShaderGroupsCreateInfo l, in GraphicsPipelineShaderGroupsCreateInfo r)
	{
		fixed (GraphicsPipelineShaderGroupsCreateInfo* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<GraphicsPipelineShaderGroupsCreateInfo>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<GraphicsPipelineShaderGroupsCreateInfo>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}


	/// <summary>Creates a new GraphicsPipelineShaderGroupsCreateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out GraphicsPipelineShaderGroupsCreateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref GraphicsPipelineShaderGroupsCreateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct BindShaderGroupIndirectCommand : IEquatable<BindShaderGroupIndirectCommand>
{
	public uint GroupIndex;

	public readonly override bool Equals(object? obj) => (obj is BindShaderGroupIndirectCommand o) && (this == o);
	readonly bool IEquatable<BindShaderGroupIndirectCommand>.Equals(BindShaderGroupIndirectCommand obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (uint* ptr = &GroupIndex) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<BindShaderGroupIndirectCommand>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in BindShaderGroupIndirectCommand l, in BindShaderGroupIndirectCommand r)
	{
		fixed (BindShaderGroupIndirectCommand* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<BindShaderGroupIndirectCommand>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<BindShaderGroupIndirectCommand>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in BindShaderGroupIndirectCommand l, in BindShaderGroupIndirectCommand r)
	{
		fixed (BindShaderGroupIndirectCommand* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<BindShaderGroupIndirectCommand>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<BindShaderGroupIndirectCommand>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}

}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct BindIndexBufferIndirectCommand : IEquatable<BindIndexBufferIndirectCommand>
{
	public ulong BufferAddress;
	public uint Size;
	public Vk.IndexType IndexType;

	public readonly override bool Equals(object? obj) => (obj is BindIndexBufferIndirectCommand o) && (this == o);
	readonly bool IEquatable<BindIndexBufferIndirectCommand>.Equals(BindIndexBufferIndirectCommand obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (ulong* ptr = &BufferAddress) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<BindIndexBufferIndirectCommand>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in BindIndexBufferIndirectCommand l, in BindIndexBufferIndirectCommand r)
	{
		fixed (BindIndexBufferIndirectCommand* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<BindIndexBufferIndirectCommand>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<BindIndexBufferIndirectCommand>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in BindIndexBufferIndirectCommand l, in BindIndexBufferIndirectCommand r)
	{
		fixed (BindIndexBufferIndirectCommand* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<BindIndexBufferIndirectCommand>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<BindIndexBufferIndirectCommand>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}

}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct BindVertexBufferIndirectCommand : IEquatable<BindVertexBufferIndirectCommand>
{
	public ulong BufferAddress;
	public uint Size;
	public uint Stride;

	public readonly override bool Equals(object? obj) => (obj is BindVertexBufferIndirectCommand o) && (this == o);
	readonly bool IEquatable<BindVertexBufferIndirectCommand>.Equals(BindVertexBufferIndirectCommand obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (ulong* ptr = &BufferAddress) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<BindVertexBufferIndirectCommand>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in BindVertexBufferIndirectCommand l, in BindVertexBufferIndirectCommand r)
	{
		fixed (BindVertexBufferIndirectCommand* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<BindVertexBufferIndirectCommand>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<BindVertexBufferIndirectCommand>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in BindVertexBufferIndirectCommand l, in BindVertexBufferIndirectCommand r)
	{
		fixed (BindVertexBufferIndirectCommand* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<BindVertexBufferIndirectCommand>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<BindVertexBufferIndirectCommand>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}

}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SetStateFlagsIndirectCommand : IEquatable<SetStateFlagsIndirectCommand>
{
	public uint Data;

	public readonly override bool Equals(object? obj) => (obj is SetStateFlagsIndirectCommand o) && (this == o);
	readonly bool IEquatable<SetStateFlagsIndirectCommand>.Equals(SetStateFlagsIndirectCommand obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (uint* ptr = &Data) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<SetStateFlagsIndirectCommand>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in SetStateFlagsIndirectCommand l, in SetStateFlagsIndirectCommand r)
	{
		fixed (SetStateFlagsIndirectCommand* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<SetStateFlagsIndirectCommand>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<SetStateFlagsIndirectCommand>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in SetStateFlagsIndirectCommand l, in SetStateFlagsIndirectCommand r)
	{
		fixed (SetStateFlagsIndirectCommand* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<SetStateFlagsIndirectCommand>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<SetStateFlagsIndirectCommand>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}

}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct IndirectCommandsStream : IEquatable<IndirectCommandsStream>
{
	public Vk.Handle<Vk.Buffer> Buffer;
	public Vk.DeviceSize Offset;

	public readonly override bool Equals(object? obj) => (obj is IndirectCommandsStream o) && (this == o);
	readonly bool IEquatable<IndirectCommandsStream>.Equals(IndirectCommandsStream obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (Vk.Handle<Vk.Buffer>* ptr = &Buffer) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<IndirectCommandsStream>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in IndirectCommandsStream l, in IndirectCommandsStream r)
	{
		fixed (IndirectCommandsStream* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<IndirectCommandsStream>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<IndirectCommandsStream>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in IndirectCommandsStream l, in IndirectCommandsStream r)
	{
		fixed (IndirectCommandsStream* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<IndirectCommandsStream>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<IndirectCommandsStream>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}

}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct IndirectCommandsLayoutToken : IEquatable<IndirectCommandsLayoutToken>
{
	public const Vk.StructureType TYPE = Vk.StructureType.IndirectCommandsLayoutTokenNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.NV.IndirectCommandsTokenType TokenType;
	public uint Stream;
	public uint Offset;
	public uint VertexBindingUnit;
	public Vk.Bool32 VertexDynamicStride;
	public Vk.Handle<Vk.PipelineLayout> PushconstantPipelineLayout;
	public Vk.ShaderStageFlags PushconstantShaderStageFlags;
	public uint PushconstantOffset;
	public uint PushconstantSize;
	public Vk.NV.IndirectStateFlags IndirectStateFlags;
	public uint IndexTypeCount;
	public Vk.IndexType* IndexTypes;
	public uint* IndexTypeValues;

	public readonly override bool Equals(object? obj) => (obj is IndirectCommandsLayoutToken o) && (this == o);
	readonly bool IEquatable<IndirectCommandsLayoutToken>.Equals(IndirectCommandsLayoutToken obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (Vk.StructureType* ptr = &sType) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<IndirectCommandsLayoutToken>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in IndirectCommandsLayoutToken l, in IndirectCommandsLayoutToken r)
	{
		fixed (IndirectCommandsLayoutToken* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<IndirectCommandsLayoutToken>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<IndirectCommandsLayoutToken>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in IndirectCommandsLayoutToken l, in IndirectCommandsLayoutToken r)
	{
		fixed (IndirectCommandsLayoutToken* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<IndirectCommandsLayoutToken>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<IndirectCommandsLayoutToken>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}


	/// <summary>Creates a new IndirectCommandsLayoutToken value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out IndirectCommandsLayoutToken value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref IndirectCommandsLayoutToken value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct IndirectCommandsLayoutCreateInfo : IEquatable<IndirectCommandsLayoutCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.IndirectCommandsLayoutCreateInfoNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.NV.IndirectCommandsLayoutUsageFlags Flags;
	public Vk.PipelineBindPoint PipelineBindPoint;
	public uint TokenCount;
	public Vk.NV.IndirectCommandsLayoutToken* Tokens;
	public uint StreamCount;
	public uint* StreamStrides;

	public readonly override bool Equals(object? obj) => (obj is IndirectCommandsLayoutCreateInfo o) && (this == o);
	readonly bool IEquatable<IndirectCommandsLayoutCreateInfo>.Equals(IndirectCommandsLayoutCreateInfo obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (Vk.StructureType* ptr = &sType) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<IndirectCommandsLayoutCreateInfo>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in IndirectCommandsLayoutCreateInfo l, in IndirectCommandsLayoutCreateInfo r)
	{
		fixed (IndirectCommandsLayoutCreateInfo* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<IndirectCommandsLayoutCreateInfo>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<IndirectCommandsLayoutCreateInfo>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in IndirectCommandsLayoutCreateInfo l, in IndirectCommandsLayoutCreateInfo r)
	{
		fixed (IndirectCommandsLayoutCreateInfo* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<IndirectCommandsLayoutCreateInfo>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<IndirectCommandsLayoutCreateInfo>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}


	/// <summary>Creates a new IndirectCommandsLayoutCreateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out IndirectCommandsLayoutCreateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref IndirectCommandsLayoutCreateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct GeneratedCommandsInfo : IEquatable<GeneratedCommandsInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.GeneratedCommandsInfoNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.PipelineBindPoint PipelineBindPoint;
	public Vk.Handle<Vk.Pipeline> Pipeline;
	public Vk.Handle<Vk.NV.IndirectCommandsLayout> IndirectCommandsLayout;
	public uint StreamCount;
	public Vk.NV.IndirectCommandsStream* Streams;
	public uint SequencesCount;
	public Vk.Handle<Vk.Buffer> PreprocessBuffer;
	public Vk.DeviceSize PreprocessOffset;
	public Vk.DeviceSize PreprocessSize;
	public Vk.Handle<Vk.Buffer> SequencesCountBuffer;
	public Vk.DeviceSize SequencesCountOffset;
	public Vk.Handle<Vk.Buffer> SequencesIndexBuffer;
	public Vk.DeviceSize SequencesIndexOffset;

	public readonly override bool Equals(object? obj) => (obj is GeneratedCommandsInfo o) && (this == o);
	readonly bool IEquatable<GeneratedCommandsInfo>.Equals(GeneratedCommandsInfo obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (Vk.StructureType* ptr = &sType) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<GeneratedCommandsInfo>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in GeneratedCommandsInfo l, in GeneratedCommandsInfo r)
	{
		fixed (GeneratedCommandsInfo* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<GeneratedCommandsInfo>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<GeneratedCommandsInfo>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in GeneratedCommandsInfo l, in GeneratedCommandsInfo r)
	{
		fixed (GeneratedCommandsInfo* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<GeneratedCommandsInfo>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<GeneratedCommandsInfo>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}


	/// <summary>Creates a new GeneratedCommandsInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out GeneratedCommandsInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref GeneratedCommandsInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct GeneratedCommandsMemoryRequirementsInfo : IEquatable<GeneratedCommandsMemoryRequirementsInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.GeneratedCommandsMemoryRequirementsInfoNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.PipelineBindPoint PipelineBindPoint;
	public Vk.Handle<Vk.Pipeline> Pipeline;
	public Vk.Handle<Vk.NV.IndirectCommandsLayout> IndirectCommandsLayout;
	public uint MaxSequencesCount;

	public readonly override bool Equals(object? obj) => (obj is GeneratedCommandsMemoryRequirementsInfo o) && (this == o);
	readonly bool IEquatable<GeneratedCommandsMemoryRequirementsInfo>.Equals(GeneratedCommandsMemoryRequirementsInfo obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (Vk.StructureType* ptr = &sType) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<GeneratedCommandsMemoryRequirementsInfo>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in GeneratedCommandsMemoryRequirementsInfo l, in GeneratedCommandsMemoryRequirementsInfo r)
	{
		fixed (GeneratedCommandsMemoryRequirementsInfo* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<GeneratedCommandsMemoryRequirementsInfo>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<GeneratedCommandsMemoryRequirementsInfo>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in GeneratedCommandsMemoryRequirementsInfo l, in GeneratedCommandsMemoryRequirementsInfo r)
	{
		fixed (GeneratedCommandsMemoryRequirementsInfo* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<GeneratedCommandsMemoryRequirementsInfo>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<GeneratedCommandsMemoryRequirementsInfo>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}


	/// <summary>Creates a new GeneratedCommandsMemoryRequirementsInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out GeneratedCommandsMemoryRequirementsInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref GeneratedCommandsMemoryRequirementsInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ViewportWScaling : IEquatable<ViewportWScaling>
{
	public float Xcoeff;
	public float Ycoeff;

	public readonly override bool Equals(object? obj) => (obj is ViewportWScaling o) && (this == o);
	readonly bool IEquatable<ViewportWScaling>.Equals(ViewportWScaling obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (float* ptr = &Xcoeff) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<ViewportWScaling>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in ViewportWScaling l, in ViewportWScaling r)
	{
		fixed (ViewportWScaling* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<ViewportWScaling>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<ViewportWScaling>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in ViewportWScaling l, in ViewportWScaling r)
	{
		fixed (ViewportWScaling* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<ViewportWScaling>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<ViewportWScaling>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}

}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PipelineViewportWScalingStateCreateInfo : IEquatable<PipelineViewportWScalingStateCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PipelineViewportWScalingStateCreateInfoNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 ViewportWScalingEnable;
	public uint ViewportCount;
	public Vk.NV.ViewportWScaling* ViewportWScalings;

	public readonly override bool Equals(object? obj) => (obj is PipelineViewportWScalingStateCreateInfo o) && (this == o);
	readonly bool IEquatable<PipelineViewportWScalingStateCreateInfo>.Equals(PipelineViewportWScalingStateCreateInfo obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (Vk.StructureType* ptr = &sType) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<PipelineViewportWScalingStateCreateInfo>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in PipelineViewportWScalingStateCreateInfo l, in PipelineViewportWScalingStateCreateInfo r)
	{
		fixed (PipelineViewportWScalingStateCreateInfo* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<PipelineViewportWScalingStateCreateInfo>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<PipelineViewportWScalingStateCreateInfo>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in PipelineViewportWScalingStateCreateInfo l, in PipelineViewportWScalingStateCreateInfo r)
	{
		fixed (PipelineViewportWScalingStateCreateInfo* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<PipelineViewportWScalingStateCreateInfo>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<PipelineViewportWScalingStateCreateInfo>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}


	/// <summary>Creates a new PipelineViewportWScalingStateCreateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PipelineViewportWScalingStateCreateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PipelineViewportWScalingStateCreateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ViewportSwizzle : IEquatable<ViewportSwizzle>
{
	public Vk.NV.ViewportCoordinateSwizzle X;
	public Vk.NV.ViewportCoordinateSwizzle Y;
	public Vk.NV.ViewportCoordinateSwizzle Z;
	public Vk.NV.ViewportCoordinateSwizzle W;

	public readonly override bool Equals(object? obj) => (obj is ViewportSwizzle o) && (this == o);
	readonly bool IEquatable<ViewportSwizzle>.Equals(ViewportSwizzle obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (Vk.NV.ViewportCoordinateSwizzle* ptr = &X) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<ViewportSwizzle>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in ViewportSwizzle l, in ViewportSwizzle r)
	{
		fixed (ViewportSwizzle* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<ViewportSwizzle>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<ViewportSwizzle>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in ViewportSwizzle l, in ViewportSwizzle r)
	{
		fixed (ViewportSwizzle* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<ViewportSwizzle>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<ViewportSwizzle>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}

}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PipelineViewportSwizzleStateCreateInfo : IEquatable<PipelineViewportSwizzleStateCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PipelineViewportSwizzleStateCreateInfoNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.NV.PipelineViewportSwizzleStateCreateFlags Flags;
	public uint ViewportCount;
	public Vk.NV.ViewportSwizzle* ViewportSwizzles;

	public readonly override bool Equals(object? obj) => (obj is PipelineViewportSwizzleStateCreateInfo o) && (this == o);
	readonly bool IEquatable<PipelineViewportSwizzleStateCreateInfo>.Equals(PipelineViewportSwizzleStateCreateInfo obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (Vk.StructureType* ptr = &sType) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<PipelineViewportSwizzleStateCreateInfo>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in PipelineViewportSwizzleStateCreateInfo l, in PipelineViewportSwizzleStateCreateInfo r)
	{
		fixed (PipelineViewportSwizzleStateCreateInfo* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<PipelineViewportSwizzleStateCreateInfo>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<PipelineViewportSwizzleStateCreateInfo>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in PipelineViewportSwizzleStateCreateInfo l, in PipelineViewportSwizzleStateCreateInfo r)
	{
		fixed (PipelineViewportSwizzleStateCreateInfo* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<PipelineViewportSwizzleStateCreateInfo>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<PipelineViewportSwizzleStateCreateInfo>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}


	/// <summary>Creates a new PipelineViewportSwizzleStateCreateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PipelineViewportSwizzleStateCreateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PipelineViewportSwizzleStateCreateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PipelineCoverageToColorStateCreateInfo : IEquatable<PipelineCoverageToColorStateCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PipelineCoverageToColorStateCreateInfoNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.NV.PipelineCoverageToColorStateCreateFlags Flags;
	public Vk.Bool32 CoverageToColorEnable;
	public uint CoverageToColorLocation;

	public readonly override bool Equals(object? obj) => (obj is PipelineCoverageToColorStateCreateInfo o) && (this == o);
	readonly bool IEquatable<PipelineCoverageToColorStateCreateInfo>.Equals(PipelineCoverageToColorStateCreateInfo obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (Vk.StructureType* ptr = &sType) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<PipelineCoverageToColorStateCreateInfo>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in PipelineCoverageToColorStateCreateInfo l, in PipelineCoverageToColorStateCreateInfo r)
	{
		fixed (PipelineCoverageToColorStateCreateInfo* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<PipelineCoverageToColorStateCreateInfo>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<PipelineCoverageToColorStateCreateInfo>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in PipelineCoverageToColorStateCreateInfo l, in PipelineCoverageToColorStateCreateInfo r)
	{
		fixed (PipelineCoverageToColorStateCreateInfo* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<PipelineCoverageToColorStateCreateInfo>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<PipelineCoverageToColorStateCreateInfo>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}


	/// <summary>Creates a new PipelineCoverageToColorStateCreateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PipelineCoverageToColorStateCreateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PipelineCoverageToColorStateCreateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PipelineCoverageModulationStateCreateInfo : IEquatable<PipelineCoverageModulationStateCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PipelineCoverageModulationStateCreateInfoNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.NV.PipelineCoverageModulationStateCreateFlags Flags;
	public Vk.NV.CoverageModulationMode CoverageModulationMode;
	public Vk.Bool32 CoverageModulationTableEnable;
	public uint CoverageModulationTableCount;
	public float* CoverageModulationTable;

	public readonly override bool Equals(object? obj) => (obj is PipelineCoverageModulationStateCreateInfo o) && (this == o);
	readonly bool IEquatable<PipelineCoverageModulationStateCreateInfo>.Equals(PipelineCoverageModulationStateCreateInfo obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (Vk.StructureType* ptr = &sType) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<PipelineCoverageModulationStateCreateInfo>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in PipelineCoverageModulationStateCreateInfo l, in PipelineCoverageModulationStateCreateInfo r)
	{
		fixed (PipelineCoverageModulationStateCreateInfo* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<PipelineCoverageModulationStateCreateInfo>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<PipelineCoverageModulationStateCreateInfo>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in PipelineCoverageModulationStateCreateInfo l, in PipelineCoverageModulationStateCreateInfo r)
	{
		fixed (PipelineCoverageModulationStateCreateInfo* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<PipelineCoverageModulationStateCreateInfo>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<PipelineCoverageModulationStateCreateInfo>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}


	/// <summary>Creates a new PipelineCoverageModulationStateCreateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PipelineCoverageModulationStateCreateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PipelineCoverageModulationStateCreateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct QueueFamilyCheckpointProperties : IEquatable<QueueFamilyCheckpointProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.QueueFamilyCheckpointPropertiesNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.PipelineStageFlags CheckpointExecutionStageMask;

	public readonly override bool Equals(object? obj) => (obj is QueueFamilyCheckpointProperties o) && (this == o);
	readonly bool IEquatable<QueueFamilyCheckpointProperties>.Equals(QueueFamilyCheckpointProperties obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (Vk.StructureType* ptr = &sType) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<QueueFamilyCheckpointProperties>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in QueueFamilyCheckpointProperties l, in QueueFamilyCheckpointProperties r)
	{
		fixed (QueueFamilyCheckpointProperties* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<QueueFamilyCheckpointProperties>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<QueueFamilyCheckpointProperties>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in QueueFamilyCheckpointProperties l, in QueueFamilyCheckpointProperties r)
	{
		fixed (QueueFamilyCheckpointProperties* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<QueueFamilyCheckpointProperties>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<QueueFamilyCheckpointProperties>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}


	/// <summary>Creates a new QueueFamilyCheckpointProperties value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out QueueFamilyCheckpointProperties value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref QueueFamilyCheckpointProperties value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct CheckpointData : IEquatable<CheckpointData>
{
	public const Vk.StructureType TYPE = Vk.StructureType.CheckpointDataNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.PipelineStageFlags Stage;
	public void* CheckpointMarker;

	public readonly override bool Equals(object? obj) => (obj is CheckpointData o) && (this == o);
	readonly bool IEquatable<CheckpointData>.Equals(CheckpointData obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (Vk.StructureType* ptr = &sType) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<CheckpointData>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in CheckpointData l, in CheckpointData r)
	{
		fixed (CheckpointData* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<CheckpointData>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<CheckpointData>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in CheckpointData l, in CheckpointData r)
	{
		fixed (CheckpointData* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<CheckpointData>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<CheckpointData>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}


	/// <summary>Creates a new CheckpointData value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out CheckpointData value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref CheckpointData value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceRepresentativeFragmentTestFeatures : IEquatable<PhysicalDeviceRepresentativeFragmentTestFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceRepresentativeFragmentTestFeaturesNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 RepresentativeFragmentTest;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceRepresentativeFragmentTestFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceRepresentativeFragmentTestFeatures>.Equals(PhysicalDeviceRepresentativeFragmentTestFeatures obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (Vk.StructureType* ptr = &sType) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<PhysicalDeviceRepresentativeFragmentTestFeatures>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in PhysicalDeviceRepresentativeFragmentTestFeatures l, in PhysicalDeviceRepresentativeFragmentTestFeatures r)
	{
		fixed (PhysicalDeviceRepresentativeFragmentTestFeatures* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<PhysicalDeviceRepresentativeFragmentTestFeatures>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<PhysicalDeviceRepresentativeFragmentTestFeatures>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in PhysicalDeviceRepresentativeFragmentTestFeatures l, in PhysicalDeviceRepresentativeFragmentTestFeatures r)
	{
		fixed (PhysicalDeviceRepresentativeFragmentTestFeatures* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<PhysicalDeviceRepresentativeFragmentTestFeatures>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<PhysicalDeviceRepresentativeFragmentTestFeatures>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}


	/// <summary>Creates a new PhysicalDeviceRepresentativeFragmentTestFeatures value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceRepresentativeFragmentTestFeatures value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceRepresentativeFragmentTestFeatures value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PipelineRepresentativeFragmentTestStateCreateInfo : IEquatable<PipelineRepresentativeFragmentTestStateCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PipelineRepresentativeFragmentTestStateCreateInfoNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 RepresentativeFragmentTestEnable;

	public readonly override bool Equals(object? obj) => (obj is PipelineRepresentativeFragmentTestStateCreateInfo o) && (this == o);
	readonly bool IEquatable<PipelineRepresentativeFragmentTestStateCreateInfo>.Equals(PipelineRepresentativeFragmentTestStateCreateInfo obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (Vk.StructureType* ptr = &sType) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<PipelineRepresentativeFragmentTestStateCreateInfo>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in PipelineRepresentativeFragmentTestStateCreateInfo l, in PipelineRepresentativeFragmentTestStateCreateInfo r)
	{
		fixed (PipelineRepresentativeFragmentTestStateCreateInfo* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<PipelineRepresentativeFragmentTestStateCreateInfo>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<PipelineRepresentativeFragmentTestStateCreateInfo>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in PipelineRepresentativeFragmentTestStateCreateInfo l, in PipelineRepresentativeFragmentTestStateCreateInfo r)
	{
		fixed (PipelineRepresentativeFragmentTestStateCreateInfo* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<PipelineRepresentativeFragmentTestStateCreateInfo>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<PipelineRepresentativeFragmentTestStateCreateInfo>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}


	/// <summary>Creates a new PipelineRepresentativeFragmentTestStateCreateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PipelineRepresentativeFragmentTestStateCreateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PipelineRepresentativeFragmentTestStateCreateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceExclusiveScissorFeatures : IEquatable<PhysicalDeviceExclusiveScissorFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceExclusiveScissorFeaturesNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 ExclusiveScissor;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceExclusiveScissorFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceExclusiveScissorFeatures>.Equals(PhysicalDeviceExclusiveScissorFeatures obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (Vk.StructureType* ptr = &sType) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<PhysicalDeviceExclusiveScissorFeatures>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in PhysicalDeviceExclusiveScissorFeatures l, in PhysicalDeviceExclusiveScissorFeatures r)
	{
		fixed (PhysicalDeviceExclusiveScissorFeatures* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<PhysicalDeviceExclusiveScissorFeatures>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<PhysicalDeviceExclusiveScissorFeatures>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in PhysicalDeviceExclusiveScissorFeatures l, in PhysicalDeviceExclusiveScissorFeatures r)
	{
		fixed (PhysicalDeviceExclusiveScissorFeatures* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<PhysicalDeviceExclusiveScissorFeatures>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<PhysicalDeviceExclusiveScissorFeatures>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}


	/// <summary>Creates a new PhysicalDeviceExclusiveScissorFeatures value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceExclusiveScissorFeatures value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceExclusiveScissorFeatures value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PipelineViewportExclusiveScissorStateCreateInfo : IEquatable<PipelineViewportExclusiveScissorStateCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PipelineViewportExclusiveScissorStateCreateInfoNV;

	public Vk.StructureType sType;
	public void* pNext;
	public uint ExclusiveScissorCount;
	public Vk.Rect2D* ExclusiveScissors;

	public readonly override bool Equals(object? obj) => (obj is PipelineViewportExclusiveScissorStateCreateInfo o) && (this == o);
	readonly bool IEquatable<PipelineViewportExclusiveScissorStateCreateInfo>.Equals(PipelineViewportExclusiveScissorStateCreateInfo obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (Vk.StructureType* ptr = &sType) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<PipelineViewportExclusiveScissorStateCreateInfo>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in PipelineViewportExclusiveScissorStateCreateInfo l, in PipelineViewportExclusiveScissorStateCreateInfo r)
	{
		fixed (PipelineViewportExclusiveScissorStateCreateInfo* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<PipelineViewportExclusiveScissorStateCreateInfo>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<PipelineViewportExclusiveScissorStateCreateInfo>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in PipelineViewportExclusiveScissorStateCreateInfo l, in PipelineViewportExclusiveScissorStateCreateInfo r)
	{
		fixed (PipelineViewportExclusiveScissorStateCreateInfo* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<PipelineViewportExclusiveScissorStateCreateInfo>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<PipelineViewportExclusiveScissorStateCreateInfo>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}


	/// <summary>Creates a new PipelineViewportExclusiveScissorStateCreateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PipelineViewportExclusiveScissorStateCreateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PipelineViewportExclusiveScissorStateCreateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceCornerSampledImageFeatures : IEquatable<PhysicalDeviceCornerSampledImageFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceCornerSampledImageFeaturesNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 CornerSampledImage;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceCornerSampledImageFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceCornerSampledImageFeatures>.Equals(PhysicalDeviceCornerSampledImageFeatures obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (Vk.StructureType* ptr = &sType) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<PhysicalDeviceCornerSampledImageFeatures>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in PhysicalDeviceCornerSampledImageFeatures l, in PhysicalDeviceCornerSampledImageFeatures r)
	{
		fixed (PhysicalDeviceCornerSampledImageFeatures* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<PhysicalDeviceCornerSampledImageFeatures>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<PhysicalDeviceCornerSampledImageFeatures>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in PhysicalDeviceCornerSampledImageFeatures l, in PhysicalDeviceCornerSampledImageFeatures r)
	{
		fixed (PhysicalDeviceCornerSampledImageFeatures* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<PhysicalDeviceCornerSampledImageFeatures>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<PhysicalDeviceCornerSampledImageFeatures>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}


	/// <summary>Creates a new PhysicalDeviceCornerSampledImageFeatures value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceCornerSampledImageFeatures value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceCornerSampledImageFeatures value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceComputeShaderDerivativesFeatures : IEquatable<PhysicalDeviceComputeShaderDerivativesFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceComputeShaderDerivativesFeaturesNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 ComputeDerivativeGroupQuads;
	public Vk.Bool32 ComputeDerivativeGroupLinear;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceComputeShaderDerivativesFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceComputeShaderDerivativesFeatures>.Equals(PhysicalDeviceComputeShaderDerivativesFeatures obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (Vk.StructureType* ptr = &sType) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<PhysicalDeviceComputeShaderDerivativesFeatures>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in PhysicalDeviceComputeShaderDerivativesFeatures l, in PhysicalDeviceComputeShaderDerivativesFeatures r)
	{
		fixed (PhysicalDeviceComputeShaderDerivativesFeatures* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<PhysicalDeviceComputeShaderDerivativesFeatures>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<PhysicalDeviceComputeShaderDerivativesFeatures>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in PhysicalDeviceComputeShaderDerivativesFeatures l, in PhysicalDeviceComputeShaderDerivativesFeatures r)
	{
		fixed (PhysicalDeviceComputeShaderDerivativesFeatures* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<PhysicalDeviceComputeShaderDerivativesFeatures>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<PhysicalDeviceComputeShaderDerivativesFeatures>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}


	/// <summary>Creates a new PhysicalDeviceComputeShaderDerivativesFeatures value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceComputeShaderDerivativesFeatures value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceComputeShaderDerivativesFeatures value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceFragmentShaderBarycentricFeatures : IEquatable<PhysicalDeviceFragmentShaderBarycentricFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceFragmentShaderBarycentricFeaturesNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 FragmentShaderBarycentric;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceFragmentShaderBarycentricFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceFragmentShaderBarycentricFeatures>.Equals(PhysicalDeviceFragmentShaderBarycentricFeatures obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (Vk.StructureType* ptr = &sType) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<PhysicalDeviceFragmentShaderBarycentricFeatures>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in PhysicalDeviceFragmentShaderBarycentricFeatures l, in PhysicalDeviceFragmentShaderBarycentricFeatures r)
	{
		fixed (PhysicalDeviceFragmentShaderBarycentricFeatures* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<PhysicalDeviceFragmentShaderBarycentricFeatures>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<PhysicalDeviceFragmentShaderBarycentricFeatures>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in PhysicalDeviceFragmentShaderBarycentricFeatures l, in PhysicalDeviceFragmentShaderBarycentricFeatures r)
	{
		fixed (PhysicalDeviceFragmentShaderBarycentricFeatures* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<PhysicalDeviceFragmentShaderBarycentricFeatures>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<PhysicalDeviceFragmentShaderBarycentricFeatures>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}


	/// <summary>Creates a new PhysicalDeviceFragmentShaderBarycentricFeatures value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceFragmentShaderBarycentricFeatures value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceFragmentShaderBarycentricFeatures value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceShaderImageFootprintFeatures : IEquatable<PhysicalDeviceShaderImageFootprintFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceShaderImageFootprintFeaturesNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 ImageFootprint;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceShaderImageFootprintFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceShaderImageFootprintFeatures>.Equals(PhysicalDeviceShaderImageFootprintFeatures obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (Vk.StructureType* ptr = &sType) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<PhysicalDeviceShaderImageFootprintFeatures>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in PhysicalDeviceShaderImageFootprintFeatures l, in PhysicalDeviceShaderImageFootprintFeatures r)
	{
		fixed (PhysicalDeviceShaderImageFootprintFeatures* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<PhysicalDeviceShaderImageFootprintFeatures>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<PhysicalDeviceShaderImageFootprintFeatures>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in PhysicalDeviceShaderImageFootprintFeatures l, in PhysicalDeviceShaderImageFootprintFeatures r)
	{
		fixed (PhysicalDeviceShaderImageFootprintFeatures* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<PhysicalDeviceShaderImageFootprintFeatures>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<PhysicalDeviceShaderImageFootprintFeatures>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}


	/// <summary>Creates a new PhysicalDeviceShaderImageFootprintFeatures value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceShaderImageFootprintFeatures value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceShaderImageFootprintFeatures value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceDedicatedAllocationImageAliasingFeatures : IEquatable<PhysicalDeviceDedicatedAllocationImageAliasingFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 DedicatedAllocationImageAliasing;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceDedicatedAllocationImageAliasingFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceDedicatedAllocationImageAliasingFeatures>.Equals(PhysicalDeviceDedicatedAllocationImageAliasingFeatures obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (Vk.StructureType* ptr = &sType) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<PhysicalDeviceDedicatedAllocationImageAliasingFeatures>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in PhysicalDeviceDedicatedAllocationImageAliasingFeatures l, in PhysicalDeviceDedicatedAllocationImageAliasingFeatures r)
	{
		fixed (PhysicalDeviceDedicatedAllocationImageAliasingFeatures* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<PhysicalDeviceDedicatedAllocationImageAliasingFeatures>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<PhysicalDeviceDedicatedAllocationImageAliasingFeatures>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in PhysicalDeviceDedicatedAllocationImageAliasingFeatures l, in PhysicalDeviceDedicatedAllocationImageAliasingFeatures r)
	{
		fixed (PhysicalDeviceDedicatedAllocationImageAliasingFeatures* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<PhysicalDeviceDedicatedAllocationImageAliasingFeatures>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<PhysicalDeviceDedicatedAllocationImageAliasingFeatures>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}


	/// <summary>Creates a new PhysicalDeviceDedicatedAllocationImageAliasingFeatures value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceDedicatedAllocationImageAliasingFeatures value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceDedicatedAllocationImageAliasingFeatures value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ShadingRatePalette : IEquatable<ShadingRatePalette>
{
	public uint ShadingRatePaletteEntryCount;
	public Vk.NV.ShadingRatePaletteEntry* ShadingRatePaletteEntries;

	public readonly override bool Equals(object? obj) => (obj is ShadingRatePalette o) && (this == o);
	readonly bool IEquatable<ShadingRatePalette>.Equals(ShadingRatePalette obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (uint* ptr = &ShadingRatePaletteEntryCount) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<ShadingRatePalette>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in ShadingRatePalette l, in ShadingRatePalette r)
	{
		fixed (ShadingRatePalette* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<ShadingRatePalette>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<ShadingRatePalette>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in ShadingRatePalette l, in ShadingRatePalette r)
	{
		fixed (ShadingRatePalette* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<ShadingRatePalette>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<ShadingRatePalette>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}

}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PipelineViewportShadingRateImageStateCreateInfo : IEquatable<PipelineViewportShadingRateImageStateCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PipelineViewportShadingRateImageStateCreateInfoNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 ShadingRateImageEnable;
	public uint ViewportCount;
	public Vk.NV.ShadingRatePalette* ShadingRatePalettes;

	public readonly override bool Equals(object? obj) => (obj is PipelineViewportShadingRateImageStateCreateInfo o) && (this == o);
	readonly bool IEquatable<PipelineViewportShadingRateImageStateCreateInfo>.Equals(PipelineViewportShadingRateImageStateCreateInfo obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (Vk.StructureType* ptr = &sType) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<PipelineViewportShadingRateImageStateCreateInfo>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in PipelineViewportShadingRateImageStateCreateInfo l, in PipelineViewportShadingRateImageStateCreateInfo r)
	{
		fixed (PipelineViewportShadingRateImageStateCreateInfo* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<PipelineViewportShadingRateImageStateCreateInfo>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<PipelineViewportShadingRateImageStateCreateInfo>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in PipelineViewportShadingRateImageStateCreateInfo l, in PipelineViewportShadingRateImageStateCreateInfo r)
	{
		fixed (PipelineViewportShadingRateImageStateCreateInfo* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<PipelineViewportShadingRateImageStateCreateInfo>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<PipelineViewportShadingRateImageStateCreateInfo>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}


	/// <summary>Creates a new PipelineViewportShadingRateImageStateCreateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PipelineViewportShadingRateImageStateCreateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PipelineViewportShadingRateImageStateCreateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceShadingRateImageFeatures : IEquatable<PhysicalDeviceShadingRateImageFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceShadingRateImageFeaturesNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 ShadingRateImage;
	public Vk.Bool32 ShadingRateCoarseSampleOrder;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceShadingRateImageFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceShadingRateImageFeatures>.Equals(PhysicalDeviceShadingRateImageFeatures obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (Vk.StructureType* ptr = &sType) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<PhysicalDeviceShadingRateImageFeatures>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in PhysicalDeviceShadingRateImageFeatures l, in PhysicalDeviceShadingRateImageFeatures r)
	{
		fixed (PhysicalDeviceShadingRateImageFeatures* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<PhysicalDeviceShadingRateImageFeatures>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<PhysicalDeviceShadingRateImageFeatures>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in PhysicalDeviceShadingRateImageFeatures l, in PhysicalDeviceShadingRateImageFeatures r)
	{
		fixed (PhysicalDeviceShadingRateImageFeatures* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<PhysicalDeviceShadingRateImageFeatures>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<PhysicalDeviceShadingRateImageFeatures>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}


	/// <summary>Creates a new PhysicalDeviceShadingRateImageFeatures value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceShadingRateImageFeatures value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceShadingRateImageFeatures value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceShadingRateImageProperties : IEquatable<PhysicalDeviceShadingRateImageProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceShadingRateImagePropertiesNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Extent2D ShadingRateTexelSize;
	public uint ShadingRatePaletteSize;
	public uint ShadingRateMaxCoarseSamples;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceShadingRateImageProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceShadingRateImageProperties>.Equals(PhysicalDeviceShadingRateImageProperties obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (Vk.StructureType* ptr = &sType) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<PhysicalDeviceShadingRateImageProperties>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in PhysicalDeviceShadingRateImageProperties l, in PhysicalDeviceShadingRateImageProperties r)
	{
		fixed (PhysicalDeviceShadingRateImageProperties* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<PhysicalDeviceShadingRateImageProperties>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<PhysicalDeviceShadingRateImageProperties>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in PhysicalDeviceShadingRateImageProperties l, in PhysicalDeviceShadingRateImageProperties r)
	{
		fixed (PhysicalDeviceShadingRateImageProperties* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<PhysicalDeviceShadingRateImageProperties>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<PhysicalDeviceShadingRateImageProperties>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}


	/// <summary>Creates a new PhysicalDeviceShadingRateImageProperties value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceShadingRateImageProperties value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceShadingRateImageProperties value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct CoarseSampleLocation : IEquatable<CoarseSampleLocation>
{
	public uint PixelX;
	public uint PixelY;
	public uint Sample;

	public readonly override bool Equals(object? obj) => (obj is CoarseSampleLocation o) && (this == o);
	readonly bool IEquatable<CoarseSampleLocation>.Equals(CoarseSampleLocation obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (uint* ptr = &PixelX) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<CoarseSampleLocation>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in CoarseSampleLocation l, in CoarseSampleLocation r)
	{
		fixed (CoarseSampleLocation* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<CoarseSampleLocation>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<CoarseSampleLocation>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in CoarseSampleLocation l, in CoarseSampleLocation r)
	{
		fixed (CoarseSampleLocation* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<CoarseSampleLocation>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<CoarseSampleLocation>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}

}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct CoarseSampleOrderCustom : IEquatable<CoarseSampleOrderCustom>
{
	public Vk.NV.ShadingRatePaletteEntry ShadingRate;
	public uint SampleCount;
	public uint SampleLocationCount;
	public Vk.NV.CoarseSampleLocation* SampleLocations;

	public readonly override bool Equals(object? obj) => (obj is CoarseSampleOrderCustom o) && (this == o);
	readonly bool IEquatable<CoarseSampleOrderCustom>.Equals(CoarseSampleOrderCustom obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (Vk.NV.ShadingRatePaletteEntry* ptr = &ShadingRate) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<CoarseSampleOrderCustom>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in CoarseSampleOrderCustom l, in CoarseSampleOrderCustom r)
	{
		fixed (CoarseSampleOrderCustom* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<CoarseSampleOrderCustom>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<CoarseSampleOrderCustom>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in CoarseSampleOrderCustom l, in CoarseSampleOrderCustom r)
	{
		fixed (CoarseSampleOrderCustom* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<CoarseSampleOrderCustom>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<CoarseSampleOrderCustom>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}

}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PipelineViewportCoarseSampleOrderStateCreateInfo : IEquatable<PipelineViewportCoarseSampleOrderStateCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PipelineViewportCoarseSampleOrderStateCreateInfoNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.NV.CoarseSampleOrderType SampleOrderType;
	public uint CustomSampleOrderCount;
	public Vk.NV.CoarseSampleOrderCustom* CustomSampleOrders;

	public readonly override bool Equals(object? obj) => (obj is PipelineViewportCoarseSampleOrderStateCreateInfo o) && (this == o);
	readonly bool IEquatable<PipelineViewportCoarseSampleOrderStateCreateInfo>.Equals(PipelineViewportCoarseSampleOrderStateCreateInfo obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (Vk.StructureType* ptr = &sType) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<PipelineViewportCoarseSampleOrderStateCreateInfo>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in PipelineViewportCoarseSampleOrderStateCreateInfo l, in PipelineViewportCoarseSampleOrderStateCreateInfo r)
	{
		fixed (PipelineViewportCoarseSampleOrderStateCreateInfo* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<PipelineViewportCoarseSampleOrderStateCreateInfo>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<PipelineViewportCoarseSampleOrderStateCreateInfo>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in PipelineViewportCoarseSampleOrderStateCreateInfo l, in PipelineViewportCoarseSampleOrderStateCreateInfo r)
	{
		fixed (PipelineViewportCoarseSampleOrderStateCreateInfo* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<PipelineViewportCoarseSampleOrderStateCreateInfo>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<PipelineViewportCoarseSampleOrderStateCreateInfo>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}


	/// <summary>Creates a new PipelineViewportCoarseSampleOrderStateCreateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PipelineViewportCoarseSampleOrderStateCreateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PipelineViewportCoarseSampleOrderStateCreateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceMeshShaderFeatures : IEquatable<PhysicalDeviceMeshShaderFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceMeshShaderFeaturesNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 TaskShader;
	public Vk.Bool32 MeshShader;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceMeshShaderFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceMeshShaderFeatures>.Equals(PhysicalDeviceMeshShaderFeatures obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (Vk.StructureType* ptr = &sType) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<PhysicalDeviceMeshShaderFeatures>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in PhysicalDeviceMeshShaderFeatures l, in PhysicalDeviceMeshShaderFeatures r)
	{
		fixed (PhysicalDeviceMeshShaderFeatures* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<PhysicalDeviceMeshShaderFeatures>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<PhysicalDeviceMeshShaderFeatures>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in PhysicalDeviceMeshShaderFeatures l, in PhysicalDeviceMeshShaderFeatures r)
	{
		fixed (PhysicalDeviceMeshShaderFeatures* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<PhysicalDeviceMeshShaderFeatures>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<PhysicalDeviceMeshShaderFeatures>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}


	/// <summary>Creates a new PhysicalDeviceMeshShaderFeatures value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceMeshShaderFeatures value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceMeshShaderFeatures value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceMeshShaderProperties : IEquatable<PhysicalDeviceMeshShaderProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceMeshShaderPropertiesNV;

	public Vk.StructureType sType;
	public void* pNext;
	public uint MaxDrawMeshTasksCount;
	public uint MaxTaskWorkGroupInvocations;
	public fixed uint MaxTaskWorkGroupSize[3];
	public uint MaxTaskTotalMemorySize;
	public uint MaxTaskOutputCount;
	public uint MaxMeshWorkGroupInvocations;
	public fixed uint MaxMeshWorkGroupSize[3];
	public uint MaxMeshTotalMemorySize;
	public uint MaxMeshOutputVertices;
	public uint MaxMeshOutputPrimitives;
	public uint MaxMeshMultiviewViewCount;
	public uint MeshOutputPerVertexGranularity;
	public uint MeshOutputPerPrimitiveGranularity;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceMeshShaderProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceMeshShaderProperties>.Equals(PhysicalDeviceMeshShaderProperties obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (Vk.StructureType* ptr = &sType) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<PhysicalDeviceMeshShaderProperties>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in PhysicalDeviceMeshShaderProperties l, in PhysicalDeviceMeshShaderProperties r)
	{
		fixed (PhysicalDeviceMeshShaderProperties* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<PhysicalDeviceMeshShaderProperties>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<PhysicalDeviceMeshShaderProperties>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in PhysicalDeviceMeshShaderProperties l, in PhysicalDeviceMeshShaderProperties r)
	{
		fixed (PhysicalDeviceMeshShaderProperties* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<PhysicalDeviceMeshShaderProperties>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<PhysicalDeviceMeshShaderProperties>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}


	/// <summary>Creates a new PhysicalDeviceMeshShaderProperties value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceMeshShaderProperties value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceMeshShaderProperties value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DrawMeshTasksIndirectCommand : IEquatable<DrawMeshTasksIndirectCommand>
{
	public uint TaskCount;
	public uint FirstTask;

	public readonly override bool Equals(object? obj) => (obj is DrawMeshTasksIndirectCommand o) && (this == o);
	readonly bool IEquatable<DrawMeshTasksIndirectCommand>.Equals(DrawMeshTasksIndirectCommand obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (uint* ptr = &TaskCount) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<DrawMeshTasksIndirectCommand>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in DrawMeshTasksIndirectCommand l, in DrawMeshTasksIndirectCommand r)
	{
		fixed (DrawMeshTasksIndirectCommand* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<DrawMeshTasksIndirectCommand>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<DrawMeshTasksIndirectCommand>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in DrawMeshTasksIndirectCommand l, in DrawMeshTasksIndirectCommand r)
	{
		fixed (DrawMeshTasksIndirectCommand* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<DrawMeshTasksIndirectCommand>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<DrawMeshTasksIndirectCommand>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}

}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct RayTracingShaderGroupCreateInfo : IEquatable<RayTracingShaderGroupCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.RayTracingShaderGroupCreateInfoNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.KHR.RayTracingShaderGroupType Type;
	public uint GeneralShader;
	public uint ClosestHitShader;
	public uint AnyHitShader;
	public uint IntersectionShader;

	public readonly override bool Equals(object? obj) => (obj is RayTracingShaderGroupCreateInfo o) && (this == o);
	readonly bool IEquatable<RayTracingShaderGroupCreateInfo>.Equals(RayTracingShaderGroupCreateInfo obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (Vk.StructureType* ptr = &sType) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<RayTracingShaderGroupCreateInfo>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in RayTracingShaderGroupCreateInfo l, in RayTracingShaderGroupCreateInfo r)
	{
		fixed (RayTracingShaderGroupCreateInfo* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<RayTracingShaderGroupCreateInfo>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<RayTracingShaderGroupCreateInfo>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in RayTracingShaderGroupCreateInfo l, in RayTracingShaderGroupCreateInfo r)
	{
		fixed (RayTracingShaderGroupCreateInfo* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<RayTracingShaderGroupCreateInfo>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<RayTracingShaderGroupCreateInfo>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}


	/// <summary>Creates a new RayTracingShaderGroupCreateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out RayTracingShaderGroupCreateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref RayTracingShaderGroupCreateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct RayTracingPipelineCreateInfo : IEquatable<RayTracingPipelineCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.RayTracingPipelineCreateInfoNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.PipelineCreateFlags Flags;
	public uint StageCount;
	public Vk.PipelineShaderStageCreateInfo* Stages;
	public uint GroupCount;
	public Vk.NV.RayTracingShaderGroupCreateInfo* Groups;
	public uint MaxRecursionDepth;
	public Vk.Handle<Vk.PipelineLayout> Layout;
	public Vk.Handle<Vk.Pipeline> BasePipelineHandle;
	public int BasePipelineIndex;

	public readonly override bool Equals(object? obj) => (obj is RayTracingPipelineCreateInfo o) && (this == o);
	readonly bool IEquatable<RayTracingPipelineCreateInfo>.Equals(RayTracingPipelineCreateInfo obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (Vk.StructureType* ptr = &sType) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<RayTracingPipelineCreateInfo>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in RayTracingPipelineCreateInfo l, in RayTracingPipelineCreateInfo r)
	{
		fixed (RayTracingPipelineCreateInfo* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<RayTracingPipelineCreateInfo>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<RayTracingPipelineCreateInfo>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in RayTracingPipelineCreateInfo l, in RayTracingPipelineCreateInfo r)
	{
		fixed (RayTracingPipelineCreateInfo* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<RayTracingPipelineCreateInfo>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<RayTracingPipelineCreateInfo>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}


	/// <summary>Creates a new RayTracingPipelineCreateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out RayTracingPipelineCreateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref RayTracingPipelineCreateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct GeometryTriangles : IEquatable<GeometryTriangles>
{
	public const Vk.StructureType TYPE = Vk.StructureType.GeometryTrianglesNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Handle<Vk.Buffer> VertexData;
	public Vk.DeviceSize VertexOffset;
	public uint VertexCount;
	public Vk.DeviceSize VertexStride;
	public Vk.Format VertexFormat;
	public Vk.Handle<Vk.Buffer> IndexData;
	public Vk.DeviceSize IndexOffset;
	public uint IndexCount;
	public Vk.IndexType IndexType;
	public Vk.Handle<Vk.Buffer> TransformData;
	public Vk.DeviceSize TransformOffset;

	public readonly override bool Equals(object? obj) => (obj is GeometryTriangles o) && (this == o);
	readonly bool IEquatable<GeometryTriangles>.Equals(GeometryTriangles obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (Vk.StructureType* ptr = &sType) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<GeometryTriangles>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in GeometryTriangles l, in GeometryTriangles r)
	{
		fixed (GeometryTriangles* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<GeometryTriangles>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<GeometryTriangles>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in GeometryTriangles l, in GeometryTriangles r)
	{
		fixed (GeometryTriangles* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<GeometryTriangles>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<GeometryTriangles>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}


	/// <summary>Creates a new GeometryTriangles value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out GeometryTriangles value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref GeometryTriangles value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct GeometryAABB : IEquatable<GeometryAABB>
{
	public const Vk.StructureType TYPE = Vk.StructureType.GeometryAabbNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Handle<Vk.Buffer> AabbData;
	public uint NumAABBs;
	public uint Stride;
	public Vk.DeviceSize Offset;

	public readonly override bool Equals(object? obj) => (obj is GeometryAABB o) && (this == o);
	readonly bool IEquatable<GeometryAABB>.Equals(GeometryAABB obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (Vk.StructureType* ptr = &sType) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<GeometryAABB>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in GeometryAABB l, in GeometryAABB r)
	{
		fixed (GeometryAABB* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<GeometryAABB>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<GeometryAABB>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in GeometryAABB l, in GeometryAABB r)
	{
		fixed (GeometryAABB* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<GeometryAABB>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<GeometryAABB>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}


	/// <summary>Creates a new GeometryAABB value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out GeometryAABB value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref GeometryAABB value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct GeometryData : IEquatable<GeometryData>
{
	public Vk.NV.GeometryTriangles Triangles;
	public Vk.NV.GeometryAABB Aabbs;

	public readonly override bool Equals(object? obj) => (obj is GeometryData o) && (this == o);
	readonly bool IEquatable<GeometryData>.Equals(GeometryData obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (Vk.NV.GeometryTriangles* ptr = &Triangles) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<GeometryData>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in GeometryData l, in GeometryData r)
	{
		fixed (GeometryData* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<GeometryData>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<GeometryData>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in GeometryData l, in GeometryData r)
	{
		fixed (GeometryData* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<GeometryData>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<GeometryData>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}

}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct Geometry : IEquatable<Geometry>
{
	public const Vk.StructureType TYPE = Vk.StructureType.GeometryNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.KHR.GeometryType GeometryType;
	public Vk.NV.GeometryData Geometry_;
	public Vk.KHR.GeometryFlags Flags;

	public readonly override bool Equals(object? obj) => (obj is Geometry o) && (this == o);
	readonly bool IEquatable<Geometry>.Equals(Geometry obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (Vk.StructureType* ptr = &sType) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<Geometry>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in Geometry l, in Geometry r)
	{
		fixed (Geometry* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<Geometry>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<Geometry>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in Geometry l, in Geometry r)
	{
		fixed (Geometry* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<Geometry>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<Geometry>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}


	/// <summary>Creates a new Geometry value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out Geometry value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref Geometry value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct AccelerationStructureInfo : IEquatable<AccelerationStructureInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.AccelerationStructureInfoNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.NV.AccelerationStructureType Type;
	public Vk.NV.BuildAccelerationStructureFlags Flags;
	public uint InstanceCount;
	public uint GeometryCount;
	public Vk.NV.Geometry* Geometries;

	public readonly override bool Equals(object? obj) => (obj is AccelerationStructureInfo o) && (this == o);
	readonly bool IEquatable<AccelerationStructureInfo>.Equals(AccelerationStructureInfo obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (Vk.StructureType* ptr = &sType) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<AccelerationStructureInfo>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in AccelerationStructureInfo l, in AccelerationStructureInfo r)
	{
		fixed (AccelerationStructureInfo* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<AccelerationStructureInfo>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<AccelerationStructureInfo>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in AccelerationStructureInfo l, in AccelerationStructureInfo r)
	{
		fixed (AccelerationStructureInfo* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<AccelerationStructureInfo>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<AccelerationStructureInfo>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}


	/// <summary>Creates a new AccelerationStructureInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out AccelerationStructureInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref AccelerationStructureInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct AccelerationStructureCreateInfo : IEquatable<AccelerationStructureCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.AccelerationStructureCreateInfoNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.DeviceSize CompactedSize;
	public Vk.NV.AccelerationStructureInfo Info;

	public readonly override bool Equals(object? obj) => (obj is AccelerationStructureCreateInfo o) && (this == o);
	readonly bool IEquatable<AccelerationStructureCreateInfo>.Equals(AccelerationStructureCreateInfo obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (Vk.StructureType* ptr = &sType) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<AccelerationStructureCreateInfo>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in AccelerationStructureCreateInfo l, in AccelerationStructureCreateInfo r)
	{
		fixed (AccelerationStructureCreateInfo* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<AccelerationStructureCreateInfo>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<AccelerationStructureCreateInfo>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in AccelerationStructureCreateInfo l, in AccelerationStructureCreateInfo r)
	{
		fixed (AccelerationStructureCreateInfo* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<AccelerationStructureCreateInfo>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<AccelerationStructureCreateInfo>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}


	/// <summary>Creates a new AccelerationStructureCreateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out AccelerationStructureCreateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref AccelerationStructureCreateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct BindAccelerationStructureMemoryInfo : IEquatable<BindAccelerationStructureMemoryInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.BindAccelerationStructureMemoryInfoKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Handle<Vk.KHR.AccelerationStructure> AccelerationStructure;
	public Vk.Handle<Vk.DeviceMemory> Memory;
	public Vk.DeviceSize MemoryOffset;
	public uint DeviceIndexCount;
	public uint* DeviceIndices;

	public readonly override bool Equals(object? obj) => (obj is BindAccelerationStructureMemoryInfo o) && (this == o);
	readonly bool IEquatable<BindAccelerationStructureMemoryInfo>.Equals(BindAccelerationStructureMemoryInfo obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (Vk.StructureType* ptr = &sType) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<BindAccelerationStructureMemoryInfo>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in BindAccelerationStructureMemoryInfo l, in BindAccelerationStructureMemoryInfo r)
	{
		fixed (BindAccelerationStructureMemoryInfo* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<BindAccelerationStructureMemoryInfo>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<BindAccelerationStructureMemoryInfo>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in BindAccelerationStructureMemoryInfo l, in BindAccelerationStructureMemoryInfo r)
	{
		fixed (BindAccelerationStructureMemoryInfo* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<BindAccelerationStructureMemoryInfo>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<BindAccelerationStructureMemoryInfo>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}


	/// <summary>Creates a new BindAccelerationStructureMemoryInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out BindAccelerationStructureMemoryInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref BindAccelerationStructureMemoryInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct WriteDescriptorSetAccelerationStructure : IEquatable<WriteDescriptorSetAccelerationStructure>
{
	public const Vk.StructureType TYPE = Vk.StructureType.WriteDescriptorSetAccelerationStructureKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public uint AccelerationStructureCount;
	public Vk.Handle<Vk.KHR.AccelerationStructure>* AccelerationStructures;

	public readonly override bool Equals(object? obj) => (obj is WriteDescriptorSetAccelerationStructure o) && (this == o);
	readonly bool IEquatable<WriteDescriptorSetAccelerationStructure>.Equals(WriteDescriptorSetAccelerationStructure obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (Vk.StructureType* ptr = &sType) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<WriteDescriptorSetAccelerationStructure>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in WriteDescriptorSetAccelerationStructure l, in WriteDescriptorSetAccelerationStructure r)
	{
		fixed (WriteDescriptorSetAccelerationStructure* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<WriteDescriptorSetAccelerationStructure>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<WriteDescriptorSetAccelerationStructure>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in WriteDescriptorSetAccelerationStructure l, in WriteDescriptorSetAccelerationStructure r)
	{
		fixed (WriteDescriptorSetAccelerationStructure* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<WriteDescriptorSetAccelerationStructure>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<WriteDescriptorSetAccelerationStructure>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}


	/// <summary>Creates a new WriteDescriptorSetAccelerationStructure value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out WriteDescriptorSetAccelerationStructure value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref WriteDescriptorSetAccelerationStructure value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct AccelerationStructureMemoryRequirementsInfo : IEquatable<AccelerationStructureMemoryRequirementsInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.AccelerationStructureMemoryRequirementsInfoNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.NV.AccelerationStructureMemoryRequirementsType Type;
	public Vk.Handle<Vk.NV.AccelerationStructure> AccelerationStructure;

	public readonly override bool Equals(object? obj) => (obj is AccelerationStructureMemoryRequirementsInfo o) && (this == o);
	readonly bool IEquatable<AccelerationStructureMemoryRequirementsInfo>.Equals(AccelerationStructureMemoryRequirementsInfo obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (Vk.StructureType* ptr = &sType) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<AccelerationStructureMemoryRequirementsInfo>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in AccelerationStructureMemoryRequirementsInfo l, in AccelerationStructureMemoryRequirementsInfo r)
	{
		fixed (AccelerationStructureMemoryRequirementsInfo* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<AccelerationStructureMemoryRequirementsInfo>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<AccelerationStructureMemoryRequirementsInfo>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in AccelerationStructureMemoryRequirementsInfo l, in AccelerationStructureMemoryRequirementsInfo r)
	{
		fixed (AccelerationStructureMemoryRequirementsInfo* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<AccelerationStructureMemoryRequirementsInfo>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<AccelerationStructureMemoryRequirementsInfo>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}


	/// <summary>Creates a new AccelerationStructureMemoryRequirementsInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out AccelerationStructureMemoryRequirementsInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref AccelerationStructureMemoryRequirementsInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceRayTracingProperties : IEquatable<PhysicalDeviceRayTracingProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceRayTracingPropertiesNV;

	public Vk.StructureType sType;
	public void* pNext;
	public uint ShaderGroupHandleSize;
	public uint MaxRecursionDepth;
	public uint MaxShaderGroupStride;
	public uint ShaderGroupBaseAlignment;
	public ulong MaxGeometryCount;
	public ulong MaxInstanceCount;
	public ulong MaxTriangleCount;
	public uint MaxDescriptorSetAccelerationStructures;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceRayTracingProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceRayTracingProperties>.Equals(PhysicalDeviceRayTracingProperties obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (Vk.StructureType* ptr = &sType) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<PhysicalDeviceRayTracingProperties>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in PhysicalDeviceRayTracingProperties l, in PhysicalDeviceRayTracingProperties r)
	{
		fixed (PhysicalDeviceRayTracingProperties* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<PhysicalDeviceRayTracingProperties>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<PhysicalDeviceRayTracingProperties>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in PhysicalDeviceRayTracingProperties l, in PhysicalDeviceRayTracingProperties r)
	{
		fixed (PhysicalDeviceRayTracingProperties* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<PhysicalDeviceRayTracingProperties>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<PhysicalDeviceRayTracingProperties>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}


	/// <summary>Creates a new PhysicalDeviceRayTracingProperties value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceRayTracingProperties value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceRayTracingProperties value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceCooperativeMatrixFeatures : IEquatable<PhysicalDeviceCooperativeMatrixFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceCooperativeMatrixFeaturesNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 CooperativeMatrix;
	public Vk.Bool32 CooperativeMatrixRobustBufferAccess;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceCooperativeMatrixFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceCooperativeMatrixFeatures>.Equals(PhysicalDeviceCooperativeMatrixFeatures obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (Vk.StructureType* ptr = &sType) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<PhysicalDeviceCooperativeMatrixFeatures>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in PhysicalDeviceCooperativeMatrixFeatures l, in PhysicalDeviceCooperativeMatrixFeatures r)
	{
		fixed (PhysicalDeviceCooperativeMatrixFeatures* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<PhysicalDeviceCooperativeMatrixFeatures>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<PhysicalDeviceCooperativeMatrixFeatures>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in PhysicalDeviceCooperativeMatrixFeatures l, in PhysicalDeviceCooperativeMatrixFeatures r)
	{
		fixed (PhysicalDeviceCooperativeMatrixFeatures* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<PhysicalDeviceCooperativeMatrixFeatures>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<PhysicalDeviceCooperativeMatrixFeatures>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}


	/// <summary>Creates a new PhysicalDeviceCooperativeMatrixFeatures value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceCooperativeMatrixFeatures value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceCooperativeMatrixFeatures value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceCooperativeMatrixProperties : IEquatable<PhysicalDeviceCooperativeMatrixProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceCooperativeMatrixPropertiesNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.ShaderStageFlags CooperativeMatrixSupportedStages;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceCooperativeMatrixProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceCooperativeMatrixProperties>.Equals(PhysicalDeviceCooperativeMatrixProperties obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (Vk.StructureType* ptr = &sType) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<PhysicalDeviceCooperativeMatrixProperties>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in PhysicalDeviceCooperativeMatrixProperties l, in PhysicalDeviceCooperativeMatrixProperties r)
	{
		fixed (PhysicalDeviceCooperativeMatrixProperties* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<PhysicalDeviceCooperativeMatrixProperties>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<PhysicalDeviceCooperativeMatrixProperties>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in PhysicalDeviceCooperativeMatrixProperties l, in PhysicalDeviceCooperativeMatrixProperties r)
	{
		fixed (PhysicalDeviceCooperativeMatrixProperties* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<PhysicalDeviceCooperativeMatrixProperties>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<PhysicalDeviceCooperativeMatrixProperties>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}


	/// <summary>Creates a new PhysicalDeviceCooperativeMatrixProperties value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceCooperativeMatrixProperties value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceCooperativeMatrixProperties value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct CooperativeMatrixProperties : IEquatable<CooperativeMatrixProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.CooperativeMatrixPropertiesNV;

	public Vk.StructureType sType;
	public void* pNext;
	public uint MSize;
	public uint NSize;
	public uint KSize;
	public Vk.NV.ComponentType AType;
	public Vk.NV.ComponentType BType;
	public Vk.NV.ComponentType CType;
	public Vk.NV.ComponentType DType;
	public Vk.NV.Scope Scope;

	public readonly override bool Equals(object? obj) => (obj is CooperativeMatrixProperties o) && (this == o);
	readonly bool IEquatable<CooperativeMatrixProperties>.Equals(CooperativeMatrixProperties obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (Vk.StructureType* ptr = &sType) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<CooperativeMatrixProperties>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in CooperativeMatrixProperties l, in CooperativeMatrixProperties r)
	{
		fixed (CooperativeMatrixProperties* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<CooperativeMatrixProperties>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<CooperativeMatrixProperties>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in CooperativeMatrixProperties l, in CooperativeMatrixProperties r)
	{
		fixed (CooperativeMatrixProperties* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<CooperativeMatrixProperties>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<CooperativeMatrixProperties>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}


	/// <summary>Creates a new CooperativeMatrixProperties value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out CooperativeMatrixProperties value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref CooperativeMatrixProperties value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceCoverageReductionModeFeatures : IEquatable<PhysicalDeviceCoverageReductionModeFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceCoverageReductionModeFeaturesNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 CoverageReductionMode;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceCoverageReductionModeFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceCoverageReductionModeFeatures>.Equals(PhysicalDeviceCoverageReductionModeFeatures obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (Vk.StructureType* ptr = &sType) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<PhysicalDeviceCoverageReductionModeFeatures>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in PhysicalDeviceCoverageReductionModeFeatures l, in PhysicalDeviceCoverageReductionModeFeatures r)
	{
		fixed (PhysicalDeviceCoverageReductionModeFeatures* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<PhysicalDeviceCoverageReductionModeFeatures>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<PhysicalDeviceCoverageReductionModeFeatures>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in PhysicalDeviceCoverageReductionModeFeatures l, in PhysicalDeviceCoverageReductionModeFeatures r)
	{
		fixed (PhysicalDeviceCoverageReductionModeFeatures* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<PhysicalDeviceCoverageReductionModeFeatures>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<PhysicalDeviceCoverageReductionModeFeatures>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}


	/// <summary>Creates a new PhysicalDeviceCoverageReductionModeFeatures value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceCoverageReductionModeFeatures value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceCoverageReductionModeFeatures value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PipelineCoverageReductionStateCreateInfo : IEquatable<PipelineCoverageReductionStateCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PipelineCoverageReductionStateCreateInfoNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.NV.PipelineCoverageReductionStateCreateFlags Flags;
	public Vk.NV.CoverageReductionMode CoverageReductionMode;

	public readonly override bool Equals(object? obj) => (obj is PipelineCoverageReductionStateCreateInfo o) && (this == o);
	readonly bool IEquatable<PipelineCoverageReductionStateCreateInfo>.Equals(PipelineCoverageReductionStateCreateInfo obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (Vk.StructureType* ptr = &sType) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<PipelineCoverageReductionStateCreateInfo>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in PipelineCoverageReductionStateCreateInfo l, in PipelineCoverageReductionStateCreateInfo r)
	{
		fixed (PipelineCoverageReductionStateCreateInfo* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<PipelineCoverageReductionStateCreateInfo>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<PipelineCoverageReductionStateCreateInfo>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in PipelineCoverageReductionStateCreateInfo l, in PipelineCoverageReductionStateCreateInfo r)
	{
		fixed (PipelineCoverageReductionStateCreateInfo* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<PipelineCoverageReductionStateCreateInfo>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<PipelineCoverageReductionStateCreateInfo>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}


	/// <summary>Creates a new PipelineCoverageReductionStateCreateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PipelineCoverageReductionStateCreateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PipelineCoverageReductionStateCreateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct FramebufferMixedSamplesCombination : IEquatable<FramebufferMixedSamplesCombination>
{
	public const Vk.StructureType TYPE = Vk.StructureType.FramebufferMixedSamplesCombinationNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.NV.CoverageReductionMode CoverageReductionMode;
	public Vk.SampleCountFlags RasterizationSamples;
	public Vk.SampleCountFlags DepthStencilSamples;
	public Vk.SampleCountFlags ColorSamples;

	public readonly override bool Equals(object? obj) => (obj is FramebufferMixedSamplesCombination o) && (this == o);
	readonly bool IEquatable<FramebufferMixedSamplesCombination>.Equals(FramebufferMixedSamplesCombination obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (Vk.StructureType* ptr = &sType) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<FramebufferMixedSamplesCombination>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in FramebufferMixedSamplesCombination l, in FramebufferMixedSamplesCombination r)
	{
		fixed (FramebufferMixedSamplesCombination* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<FramebufferMixedSamplesCombination>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<FramebufferMixedSamplesCombination>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in FramebufferMixedSamplesCombination l, in FramebufferMixedSamplesCombination r)
	{
		fixed (FramebufferMixedSamplesCombination* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<FramebufferMixedSamplesCombination>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<FramebufferMixedSamplesCombination>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}


	/// <summary>Creates a new FramebufferMixedSamplesCombination value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out FramebufferMixedSamplesCombination value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref FramebufferMixedSamplesCombination value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceShaderSMBuiltinsProperties : IEquatable<PhysicalDeviceShaderSMBuiltinsProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceShaderSmBuiltinsPropertiesNV;

	public Vk.StructureType sType;
	public void* pNext;
	public uint ShaderSMCount;
	public uint ShaderWarpsPerSM;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceShaderSMBuiltinsProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceShaderSMBuiltinsProperties>.Equals(PhysicalDeviceShaderSMBuiltinsProperties obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (Vk.StructureType* ptr = &sType) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<PhysicalDeviceShaderSMBuiltinsProperties>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in PhysicalDeviceShaderSMBuiltinsProperties l, in PhysicalDeviceShaderSMBuiltinsProperties r)
	{
		fixed (PhysicalDeviceShaderSMBuiltinsProperties* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<PhysicalDeviceShaderSMBuiltinsProperties>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<PhysicalDeviceShaderSMBuiltinsProperties>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in PhysicalDeviceShaderSMBuiltinsProperties l, in PhysicalDeviceShaderSMBuiltinsProperties r)
	{
		fixed (PhysicalDeviceShaderSMBuiltinsProperties* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<PhysicalDeviceShaderSMBuiltinsProperties>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<PhysicalDeviceShaderSMBuiltinsProperties>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}


	/// <summary>Creates a new PhysicalDeviceShaderSMBuiltinsProperties value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceShaderSMBuiltinsProperties value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceShaderSMBuiltinsProperties value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceShaderSMBuiltinsFeatures : IEquatable<PhysicalDeviceShaderSMBuiltinsFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceShaderSmBuiltinsFeaturesNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 ShaderSMBuiltins;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceShaderSMBuiltinsFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceShaderSMBuiltinsFeatures>.Equals(PhysicalDeviceShaderSMBuiltinsFeatures obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (Vk.StructureType* ptr = &sType) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<PhysicalDeviceShaderSMBuiltinsFeatures>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in PhysicalDeviceShaderSMBuiltinsFeatures l, in PhysicalDeviceShaderSMBuiltinsFeatures r)
	{
		fixed (PhysicalDeviceShaderSMBuiltinsFeatures* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<PhysicalDeviceShaderSMBuiltinsFeatures>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<PhysicalDeviceShaderSMBuiltinsFeatures>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in PhysicalDeviceShaderSMBuiltinsFeatures l, in PhysicalDeviceShaderSMBuiltinsFeatures r)
	{
		fixed (PhysicalDeviceShaderSMBuiltinsFeatures* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<PhysicalDeviceShaderSMBuiltinsFeatures>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<PhysicalDeviceShaderSMBuiltinsFeatures>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}


	/// <summary>Creates a new PhysicalDeviceShaderSMBuiltinsFeatures value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceShaderSMBuiltinsFeatures value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceShaderSMBuiltinsFeatures value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct AabbPositions : IEquatable<AabbPositions>
{
	public float MinX;
	public float MinY;
	public float MinZ;
	public float MaxX;
	public float MaxY;
	public float MaxZ;

	public readonly override bool Equals(object? obj) => (obj is AabbPositions o) && (this == o);
	readonly bool IEquatable<AabbPositions>.Equals(AabbPositions obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (float* ptr = &MinX) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<AabbPositions>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in AabbPositions l, in AabbPositions r)
	{
		fixed (AabbPositions* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<AabbPositions>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<AabbPositions>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in AabbPositions l, in AabbPositions r)
	{
		fixed (AabbPositions* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<AabbPositions>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<AabbPositions>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}

}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct TransformMatrix : IEquatable<TransformMatrix>
{
	public fixed float Matrix[12];

	public readonly override bool Equals(object? obj) => (obj is TransformMatrix o) && (this == o);
	readonly bool IEquatable<TransformMatrix>.Equals(TransformMatrix obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (float* ptr = &Matrix[0]) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<TransformMatrix>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in TransformMatrix l, in TransformMatrix r)
	{
		fixed (TransformMatrix* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<TransformMatrix>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<TransformMatrix>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in TransformMatrix l, in TransformMatrix r)
	{
		fixed (TransformMatrix* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<TransformMatrix>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<TransformMatrix>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}

}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct AccelerationStructureInstance : IEquatable<AccelerationStructureInstance>
{
	public Vk.KHR.TransformMatrix Transform;
	public uint InstanceCustomIndex;
	public uint Mask;
	public uint InstanceShaderBindingTableRecordOffset;
	public Vk.KHR.GeometryInstanceFlags Flags;
	public ulong AccelerationStructureReference;

	public readonly override bool Equals(object? obj) => (obj is AccelerationStructureInstance o) && (this == o);
	readonly bool IEquatable<AccelerationStructureInstance>.Equals(AccelerationStructureInstance obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (Vk.KHR.TransformMatrix* ptr = &Transform) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<AccelerationStructureInstance>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in AccelerationStructureInstance l, in AccelerationStructureInstance r)
	{
		fixed (AccelerationStructureInstance* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<AccelerationStructureInstance>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<AccelerationStructureInstance>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in AccelerationStructureInstance l, in AccelerationStructureInstance r)
	{
		fixed (AccelerationStructureInstance* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<AccelerationStructureInstance>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<AccelerationStructureInstance>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}

}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceDiagnosticsConfigFeatures : IEquatable<PhysicalDeviceDiagnosticsConfigFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceDiagnosticsConfigFeaturesNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 DiagnosticsConfig;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceDiagnosticsConfigFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceDiagnosticsConfigFeatures>.Equals(PhysicalDeviceDiagnosticsConfigFeatures obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (Vk.StructureType* ptr = &sType) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<PhysicalDeviceDiagnosticsConfigFeatures>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in PhysicalDeviceDiagnosticsConfigFeatures l, in PhysicalDeviceDiagnosticsConfigFeatures r)
	{
		fixed (PhysicalDeviceDiagnosticsConfigFeatures* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<PhysicalDeviceDiagnosticsConfigFeatures>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<PhysicalDeviceDiagnosticsConfigFeatures>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in PhysicalDeviceDiagnosticsConfigFeatures l, in PhysicalDeviceDiagnosticsConfigFeatures r)
	{
		fixed (PhysicalDeviceDiagnosticsConfigFeatures* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<PhysicalDeviceDiagnosticsConfigFeatures>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<PhysicalDeviceDiagnosticsConfigFeatures>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}


	/// <summary>Creates a new PhysicalDeviceDiagnosticsConfigFeatures value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceDiagnosticsConfigFeatures value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceDiagnosticsConfigFeatures value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DeviceDiagnosticsConfigCreateInfo : IEquatable<DeviceDiagnosticsConfigCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DeviceDiagnosticsConfigCreateInfoNV;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.NV.DeviceDiagnosticsConfigFlags Flags;

	public readonly override bool Equals(object? obj) => (obj is DeviceDiagnosticsConfigCreateInfo o) && (this == o);
	readonly bool IEquatable<DeviceDiagnosticsConfigCreateInfo>.Equals(DeviceDiagnosticsConfigCreateInfo obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (Vk.StructureType* ptr = &sType) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<DeviceDiagnosticsConfigCreateInfo>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in DeviceDiagnosticsConfigCreateInfo l, in DeviceDiagnosticsConfigCreateInfo r)
	{
		fixed (DeviceDiagnosticsConfigCreateInfo* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<DeviceDiagnosticsConfigCreateInfo>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<DeviceDiagnosticsConfigCreateInfo>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in DeviceDiagnosticsConfigCreateInfo l, in DeviceDiagnosticsConfigCreateInfo r)
	{
		fixed (DeviceDiagnosticsConfigCreateInfo* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<DeviceDiagnosticsConfigCreateInfo>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<DeviceDiagnosticsConfigCreateInfo>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}


	/// <summary>Creates a new DeviceDiagnosticsConfigCreateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DeviceDiagnosticsConfigCreateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref DeviceDiagnosticsConfigCreateInfo value) { value.sType = TYPE; value.pNext = null; }
}

} // namespace Vk.NV
