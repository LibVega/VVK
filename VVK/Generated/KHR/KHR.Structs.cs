/*
 * MIT License - Copyright(c) 2020 Sean Moss
 * This file is subject to the terms and conditions of the MIT License, the text of which can be found in the 'LICENSE'
 * file at the root of this repository, or online at<https://opensource.org/licenses/MIT>.
 */

/// This file was generated by VVKGen. Edits to this file will be lost on next generation.

using System;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;


namespace Vk.KHR
{

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DisplayProperties : IEquatable<DisplayProperties>
{
	public Vk.Handle<Vk.KHR.Display> Display;
	public byte* DisplayName;
	public Vk.Extent2D PhysicalDimensions;
	public Vk.Extent2D PhysicalResolution;
	public Vk.KHR.SurfaceTransformFlags SupportedTransforms;
	public Vk.Bool32 PlaneReorderPossible;
	public Vk.Bool32 PersistentContent;
	public DisplayProperties(
		in Vk.Handle<Vk.KHR.Display> display = default,
		byte* displayName = default,
		in Vk.Extent2D physicalDimensions = default,
		in Vk.Extent2D physicalResolution = default,
		in Vk.KHR.SurfaceTransformFlags supportedTransforms = default,
		in Vk.Bool32 planeReorderPossible = default,
		in Vk.Bool32 persistentContent = default
	) {
		Display = display;
		DisplayName = displayName;
		PhysicalDimensions = physicalDimensions;
		PhysicalResolution = physicalResolution;
		SupportedTransforms = supportedTransforms;
		PlaneReorderPossible = planeReorderPossible;
		PersistentContent = persistentContent;
	}


	public readonly override bool Equals(object? obj) => (obj is DisplayProperties o) && (this == o);
	readonly bool IEquatable<DisplayProperties>.Equals(DisplayProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Display.GetHashCode() ^ ((ulong)DisplayName).GetHashCode() ^ PhysicalDimensions.GetHashCode() ^ PhysicalResolution.GetHashCode()
			^ SupportedTransforms.GetHashCode() ^ PlaneReorderPossible.GetHashCode() ^ PersistentContent.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DisplayProperties l, in DisplayProperties r)
	{
		return
			(l.Display == r.Display) && (l.DisplayName == r.DisplayName) && (l.PhysicalDimensions == r.PhysicalDimensions) && (l.PhysicalResolution == r.PhysicalResolution)
			&& (l.SupportedTransforms == r.SupportedTransforms) && (l.PlaneReorderPossible == r.PlaneReorderPossible) && (l.PersistentContent == r.PersistentContent)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DisplayProperties l, in DisplayProperties r)
	{
		return
			(l.Display != r.Display) || (l.DisplayName != r.DisplayName) || (l.PhysicalDimensions != r.PhysicalDimensions) || (l.PhysicalResolution != r.PhysicalResolution)
			|| (l.SupportedTransforms != r.SupportedTransforms) || (l.PlaneReorderPossible != r.PlaneReorderPossible) || (l.PersistentContent != r.PersistentContent)
			;
	}


	/// <summary>Creates a new DisplayProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DisplayProperties value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DisplayPlaneProperties : IEquatable<DisplayPlaneProperties>
{
	public Vk.Handle<Vk.KHR.Display> CurrentDisplay;
	public uint CurrentStackIndex;
	public DisplayPlaneProperties(
		in Vk.Handle<Vk.KHR.Display> currentDisplay = default,
		uint currentStackIndex = default
	) {
		CurrentDisplay = currentDisplay;
		CurrentStackIndex = currentStackIndex;
	}


	public readonly override bool Equals(object? obj) => (obj is DisplayPlaneProperties o) && (this == o);
	readonly bool IEquatable<DisplayPlaneProperties>.Equals(DisplayPlaneProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			CurrentDisplay.GetHashCode() ^ CurrentStackIndex.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DisplayPlaneProperties l, in DisplayPlaneProperties r)
	{
		return
			(l.CurrentDisplay == r.CurrentDisplay) && (l.CurrentStackIndex == r.CurrentStackIndex)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DisplayPlaneProperties l, in DisplayPlaneProperties r)
	{
		return
			(l.CurrentDisplay != r.CurrentDisplay) || (l.CurrentStackIndex != r.CurrentStackIndex)
			;
	}


	/// <summary>Creates a new DisplayPlaneProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DisplayPlaneProperties value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DisplayModeParameters : IEquatable<DisplayModeParameters>
{
	public Vk.Extent2D VisibleRegion;
	public uint RefreshRate;
	public DisplayModeParameters(
		in Vk.Extent2D visibleRegion = default,
		uint refreshRate = default
	) {
		VisibleRegion = visibleRegion;
		RefreshRate = refreshRate;
	}


	public readonly override bool Equals(object? obj) => (obj is DisplayModeParameters o) && (this == o);
	readonly bool IEquatable<DisplayModeParameters>.Equals(DisplayModeParameters obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			VisibleRegion.GetHashCode() ^ RefreshRate.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DisplayModeParameters l, in DisplayModeParameters r)
	{
		return
			(l.VisibleRegion == r.VisibleRegion) && (l.RefreshRate == r.RefreshRate)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DisplayModeParameters l, in DisplayModeParameters r)
	{
		return
			(l.VisibleRegion != r.VisibleRegion) || (l.RefreshRate != r.RefreshRate)
			;
	}


	/// <summary>Creates a new DisplayModeParameters value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DisplayModeParameters value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DisplayModeProperties : IEquatable<DisplayModeProperties>
{
	public Vk.Handle<Vk.KHR.DisplayMode> DisplayMode;
	public Vk.KHR.DisplayModeParameters Parameters;
	public DisplayModeProperties(
		in Vk.Handle<Vk.KHR.DisplayMode> displayMode = default,
		in Vk.KHR.DisplayModeParameters parameters = default
	) {
		DisplayMode = displayMode;
		Parameters = parameters;
	}


	public readonly override bool Equals(object? obj) => (obj is DisplayModeProperties o) && (this == o);
	readonly bool IEquatable<DisplayModeProperties>.Equals(DisplayModeProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			DisplayMode.GetHashCode() ^ Parameters.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DisplayModeProperties l, in DisplayModeProperties r)
	{
		return
			(l.DisplayMode == r.DisplayMode) && (l.Parameters == r.Parameters)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DisplayModeProperties l, in DisplayModeProperties r)
	{
		return
			(l.DisplayMode != r.DisplayMode) || (l.Parameters != r.Parameters)
			;
	}


	/// <summary>Creates a new DisplayModeProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DisplayModeProperties value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DisplayModeCreateInfo : IEquatable<DisplayModeCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DisplayModeCreateInfoKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.KHR.DisplayModeCreateFlags Flags;
	public Vk.KHR.DisplayModeParameters Parameters;
	public DisplayModeCreateInfo(
		in Vk.KHR.DisplayModeCreateFlags flags = default,
		in Vk.KHR.DisplayModeParameters parameters = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		Parameters = parameters;
	}


	public readonly override bool Equals(object? obj) => (obj is DisplayModeCreateInfo o) && (this == o);
	readonly bool IEquatable<DisplayModeCreateInfo>.Equals(DisplayModeCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ Parameters.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DisplayModeCreateInfo l, in DisplayModeCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.Parameters == r.Parameters)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DisplayModeCreateInfo l, in DisplayModeCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.Parameters != r.Parameters)
			;
	}


	/// <summary>Creates a new DisplayModeCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DisplayModeCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DisplayPlaneCapabilities : IEquatable<DisplayPlaneCapabilities>
{
	public Vk.KHR.DisplayPlaneAlphaFlags SupportedAlpha;
	public Vk.Offset2D MinSrcPosition;
	public Vk.Offset2D MaxSrcPosition;
	public Vk.Extent2D MinSrcExtent;
	public Vk.Extent2D MaxSrcExtent;
	public Vk.Offset2D MinDstPosition;
	public Vk.Offset2D MaxDstPosition;
	public Vk.Extent2D MinDstExtent;
	public Vk.Extent2D MaxDstExtent;
	public DisplayPlaneCapabilities(
		in Vk.KHR.DisplayPlaneAlphaFlags supportedAlpha = default,
		in Vk.Offset2D minSrcPosition = default,
		in Vk.Offset2D maxSrcPosition = default,
		in Vk.Extent2D minSrcExtent = default,
		in Vk.Extent2D maxSrcExtent = default,
		in Vk.Offset2D minDstPosition = default,
		in Vk.Offset2D maxDstPosition = default,
		in Vk.Extent2D minDstExtent = default,
		in Vk.Extent2D maxDstExtent = default
	) {
		SupportedAlpha = supportedAlpha;
		MinSrcPosition = minSrcPosition;
		MaxSrcPosition = maxSrcPosition;
		MinSrcExtent = minSrcExtent;
		MaxSrcExtent = maxSrcExtent;
		MinDstPosition = minDstPosition;
		MaxDstPosition = maxDstPosition;
		MinDstExtent = minDstExtent;
		MaxDstExtent = maxDstExtent;
	}


	public readonly override bool Equals(object? obj) => (obj is DisplayPlaneCapabilities o) && (this == o);
	readonly bool IEquatable<DisplayPlaneCapabilities>.Equals(DisplayPlaneCapabilities obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			SupportedAlpha.GetHashCode() ^ MinSrcPosition.GetHashCode() ^ MaxSrcPosition.GetHashCode() ^ MinSrcExtent.GetHashCode()
			^ MaxSrcExtent.GetHashCode() ^ MinDstPosition.GetHashCode() ^ MaxDstPosition.GetHashCode() ^ MinDstExtent.GetHashCode()
			^ MaxDstExtent.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DisplayPlaneCapabilities l, in DisplayPlaneCapabilities r)
	{
		return
			(l.SupportedAlpha == r.SupportedAlpha) && (l.MinSrcPosition == r.MinSrcPosition) && (l.MaxSrcPosition == r.MaxSrcPosition) && (l.MinSrcExtent == r.MinSrcExtent)
			&& (l.MaxSrcExtent == r.MaxSrcExtent) && (l.MinDstPosition == r.MinDstPosition) && (l.MaxDstPosition == r.MaxDstPosition) && (l.MinDstExtent == r.MinDstExtent)
			&& (l.MaxDstExtent == r.MaxDstExtent)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DisplayPlaneCapabilities l, in DisplayPlaneCapabilities r)
	{
		return
			(l.SupportedAlpha != r.SupportedAlpha) || (l.MinSrcPosition != r.MinSrcPosition) || (l.MaxSrcPosition != r.MaxSrcPosition) || (l.MinSrcExtent != r.MinSrcExtent)
			|| (l.MaxSrcExtent != r.MaxSrcExtent) || (l.MinDstPosition != r.MinDstPosition) || (l.MaxDstPosition != r.MaxDstPosition) || (l.MinDstExtent != r.MinDstExtent)
			|| (l.MaxDstExtent != r.MaxDstExtent)
			;
	}


	/// <summary>Creates a new DisplayPlaneCapabilities value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DisplayPlaneCapabilities value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DisplaySurfaceCreateInfo : IEquatable<DisplaySurfaceCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DisplaySurfaceCreateInfoKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.KHR.DisplaySurfaceCreateFlags Flags;
	public Vk.Handle<Vk.KHR.DisplayMode> DisplayMode;
	public uint PlaneIndex;
	public uint PlaneStackIndex;
	public Vk.KHR.SurfaceTransformFlags Transform;
	public float GlobalAlpha;
	public Vk.KHR.DisplayPlaneAlphaFlags AlphaMode;
	public Vk.Extent2D ImageExtent;
	public DisplaySurfaceCreateInfo(
		in Vk.KHR.DisplaySurfaceCreateFlags flags = default,
		in Vk.Handle<Vk.KHR.DisplayMode> displayMode = default,
		uint planeIndex = default,
		uint planeStackIndex = default,
		in Vk.KHR.SurfaceTransformFlags transform = default,
		float globalAlpha = default,
		in Vk.KHR.DisplayPlaneAlphaFlags alphaMode = default,
		in Vk.Extent2D imageExtent = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		DisplayMode = displayMode;
		PlaneIndex = planeIndex;
		PlaneStackIndex = planeStackIndex;
		Transform = transform;
		GlobalAlpha = globalAlpha;
		AlphaMode = alphaMode;
		ImageExtent = imageExtent;
	}


	public readonly override bool Equals(object? obj) => (obj is DisplaySurfaceCreateInfo o) && (this == o);
	readonly bool IEquatable<DisplaySurfaceCreateInfo>.Equals(DisplaySurfaceCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ DisplayMode.GetHashCode()
			^ PlaneIndex.GetHashCode() ^ PlaneStackIndex.GetHashCode() ^ Transform.GetHashCode() ^ GlobalAlpha.GetHashCode()
			^ AlphaMode.GetHashCode() ^ ImageExtent.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DisplaySurfaceCreateInfo l, in DisplaySurfaceCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.DisplayMode == r.DisplayMode)
			&& (l.PlaneIndex == r.PlaneIndex) && (l.PlaneStackIndex == r.PlaneStackIndex) && (l.Transform == r.Transform) && (l.GlobalAlpha == r.GlobalAlpha)
			&& (l.AlphaMode == r.AlphaMode) && (l.ImageExtent == r.ImageExtent)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DisplaySurfaceCreateInfo l, in DisplaySurfaceCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.DisplayMode != r.DisplayMode)
			|| (l.PlaneIndex != r.PlaneIndex) || (l.PlaneStackIndex != r.PlaneStackIndex) || (l.Transform != r.Transform) || (l.GlobalAlpha != r.GlobalAlpha)
			|| (l.AlphaMode != r.AlphaMode) || (l.ImageExtent != r.ImageExtent)
			;
	}


	/// <summary>Creates a new DisplaySurfaceCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DisplaySurfaceCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DisplayPresentInfo : IEquatable<DisplayPresentInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DisplayPresentInfoKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Rect2D SrcRect;
	public Vk.Rect2D DstRect;
	public Vk.Bool32 Persistent;
	public DisplayPresentInfo(
		in Vk.Rect2D srcRect = default,
		in Vk.Rect2D dstRect = default,
		in Vk.Bool32 persistent = default
	) {
		sType = TYPE;
		pNext = null;
		SrcRect = srcRect;
		DstRect = dstRect;
		Persistent = persistent;
	}


	public readonly override bool Equals(object? obj) => (obj is DisplayPresentInfo o) && (this == o);
	readonly bool IEquatable<DisplayPresentInfo>.Equals(DisplayPresentInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SrcRect.GetHashCode() ^ DstRect.GetHashCode()
			^ Persistent.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DisplayPresentInfo l, in DisplayPresentInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SrcRect == r.SrcRect) && (l.DstRect == r.DstRect)
			&& (l.Persistent == r.Persistent)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DisplayPresentInfo l, in DisplayPresentInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SrcRect != r.SrcRect) || (l.DstRect != r.DstRect)
			|| (l.Persistent != r.Persistent)
			;
	}


	/// <summary>Creates a new DisplayPresentInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DisplayPresentInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SurfaceCapabilities : IEquatable<SurfaceCapabilities>
{
	public uint MinImageCount;
	public uint MaxImageCount;
	public Vk.Extent2D CurrentExtent;
	public Vk.Extent2D MinImageExtent;
	public Vk.Extent2D MaxImageExtent;
	public uint MaxImageArrayLayers;
	public Vk.KHR.SurfaceTransformFlags SupportedTransforms;
	public Vk.KHR.SurfaceTransformFlags CurrentTransform;
	public Vk.KHR.CompositeAlphaFlags SupportedCompositeAlpha;
	public Vk.ImageUsageFlags SupportedUsageFlags;
	public SurfaceCapabilities(
		uint minImageCount = default,
		uint maxImageCount = default,
		in Vk.Extent2D currentExtent = default,
		in Vk.Extent2D minImageExtent = default,
		in Vk.Extent2D maxImageExtent = default,
		uint maxImageArrayLayers = default,
		in Vk.KHR.SurfaceTransformFlags supportedTransforms = default,
		in Vk.KHR.SurfaceTransformFlags currentTransform = default,
		in Vk.KHR.CompositeAlphaFlags supportedCompositeAlpha = default,
		in Vk.ImageUsageFlags supportedUsageFlags = default
	) {
		MinImageCount = minImageCount;
		MaxImageCount = maxImageCount;
		CurrentExtent = currentExtent;
		MinImageExtent = minImageExtent;
		MaxImageExtent = maxImageExtent;
		MaxImageArrayLayers = maxImageArrayLayers;
		SupportedTransforms = supportedTransforms;
		CurrentTransform = currentTransform;
		SupportedCompositeAlpha = supportedCompositeAlpha;
		SupportedUsageFlags = supportedUsageFlags;
	}


	public readonly override bool Equals(object? obj) => (obj is SurfaceCapabilities o) && (this == o);
	readonly bool IEquatable<SurfaceCapabilities>.Equals(SurfaceCapabilities obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			MinImageCount.GetHashCode() ^ MaxImageCount.GetHashCode() ^ CurrentExtent.GetHashCode() ^ MinImageExtent.GetHashCode()
			^ MaxImageExtent.GetHashCode() ^ MaxImageArrayLayers.GetHashCode() ^ SupportedTransforms.GetHashCode() ^ CurrentTransform.GetHashCode()
			^ SupportedCompositeAlpha.GetHashCode() ^ SupportedUsageFlags.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SurfaceCapabilities l, in SurfaceCapabilities r)
	{
		return
			(l.MinImageCount == r.MinImageCount) && (l.MaxImageCount == r.MaxImageCount) && (l.CurrentExtent == r.CurrentExtent) && (l.MinImageExtent == r.MinImageExtent)
			&& (l.MaxImageExtent == r.MaxImageExtent) && (l.MaxImageArrayLayers == r.MaxImageArrayLayers) && (l.SupportedTransforms == r.SupportedTransforms) && (l.CurrentTransform == r.CurrentTransform)
			&& (l.SupportedCompositeAlpha == r.SupportedCompositeAlpha) && (l.SupportedUsageFlags == r.SupportedUsageFlags)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SurfaceCapabilities l, in SurfaceCapabilities r)
	{
		return
			(l.MinImageCount != r.MinImageCount) || (l.MaxImageCount != r.MaxImageCount) || (l.CurrentExtent != r.CurrentExtent) || (l.MinImageExtent != r.MinImageExtent)
			|| (l.MaxImageExtent != r.MaxImageExtent) || (l.MaxImageArrayLayers != r.MaxImageArrayLayers) || (l.SupportedTransforms != r.SupportedTransforms) || (l.CurrentTransform != r.CurrentTransform)
			|| (l.SupportedCompositeAlpha != r.SupportedCompositeAlpha) || (l.SupportedUsageFlags != r.SupportedUsageFlags)
			;
	}


	/// <summary>Creates a new SurfaceCapabilities value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SurfaceCapabilities value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct AndroidSurfaceCreateInfo : IEquatable<AndroidSurfaceCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.AndroidSurfaceCreateInfoKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.KHR.AndroidSurfaceCreateFlags Flags;
	public void* Window;
	public AndroidSurfaceCreateInfo(
		in Vk.KHR.AndroidSurfaceCreateFlags flags = default,
		void* window = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		Window = window;
	}


	public readonly override bool Equals(object? obj) => (obj is AndroidSurfaceCreateInfo o) && (this == o);
	readonly bool IEquatable<AndroidSurfaceCreateInfo>.Equals(AndroidSurfaceCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ ((ulong)Window).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in AndroidSurfaceCreateInfo l, in AndroidSurfaceCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.Window == r.Window)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in AndroidSurfaceCreateInfo l, in AndroidSurfaceCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.Window != r.Window)
			;
	}


	/// <summary>Creates a new AndroidSurfaceCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out AndroidSurfaceCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct WaylandSurfaceCreateInfo : IEquatable<WaylandSurfaceCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.WaylandSurfaceCreateInfoKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.KHR.WaylandSurfaceCreateFlags Flags;
	public void* Display;
	public void* Surface;
	public WaylandSurfaceCreateInfo(
		in Vk.KHR.WaylandSurfaceCreateFlags flags = default,
		void* display = default,
		void* surface = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		Display = display;
		Surface = surface;
	}


	public readonly override bool Equals(object? obj) => (obj is WaylandSurfaceCreateInfo o) && (this == o);
	readonly bool IEquatable<WaylandSurfaceCreateInfo>.Equals(WaylandSurfaceCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ ((ulong)Display).GetHashCode()
			^ ((ulong)Surface).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in WaylandSurfaceCreateInfo l, in WaylandSurfaceCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.Display == r.Display)
			&& (l.Surface == r.Surface)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in WaylandSurfaceCreateInfo l, in WaylandSurfaceCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.Display != r.Display)
			|| (l.Surface != r.Surface)
			;
	}


	/// <summary>Creates a new WaylandSurfaceCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out WaylandSurfaceCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct Win32SurfaceCreateInfo : IEquatable<Win32SurfaceCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.Win32SurfaceCreateInfoKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.KHR.Win32SurfaceCreateFlags Flags;
	public void* Hinstance;
	public void* Hwnd;
	public Win32SurfaceCreateInfo(
		in Vk.KHR.Win32SurfaceCreateFlags flags = default,
		void* hinstance = default,
		void* hwnd = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		Hinstance = hinstance;
		Hwnd = hwnd;
	}


	public readonly override bool Equals(object? obj) => (obj is Win32SurfaceCreateInfo o) && (this == o);
	readonly bool IEquatable<Win32SurfaceCreateInfo>.Equals(Win32SurfaceCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ ((ulong)Hinstance).GetHashCode()
			^ ((ulong)Hwnd).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in Win32SurfaceCreateInfo l, in Win32SurfaceCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.Hinstance == r.Hinstance)
			&& (l.Hwnd == r.Hwnd)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in Win32SurfaceCreateInfo l, in Win32SurfaceCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.Hinstance != r.Hinstance)
			|| (l.Hwnd != r.Hwnd)
			;
	}


	/// <summary>Creates a new Win32SurfaceCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out Win32SurfaceCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct XlibSurfaceCreateInfo : IEquatable<XlibSurfaceCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.XlibSurfaceCreateInfoKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.KHR.XlibSurfaceCreateFlags Flags;
	public void* Dpy;
	public ulong Window;
	public XlibSurfaceCreateInfo(
		in Vk.KHR.XlibSurfaceCreateFlags flags = default,
		void* dpy = default,
		ulong window = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		Dpy = dpy;
		Window = window;
	}


	public readonly override bool Equals(object? obj) => (obj is XlibSurfaceCreateInfo o) && (this == o);
	readonly bool IEquatable<XlibSurfaceCreateInfo>.Equals(XlibSurfaceCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ ((ulong)Dpy).GetHashCode()
			^ Window.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in XlibSurfaceCreateInfo l, in XlibSurfaceCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.Dpy == r.Dpy)
			&& (l.Window == r.Window)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in XlibSurfaceCreateInfo l, in XlibSurfaceCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.Dpy != r.Dpy)
			|| (l.Window != r.Window)
			;
	}


	/// <summary>Creates a new XlibSurfaceCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out XlibSurfaceCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct XcbSurfaceCreateInfo : IEquatable<XcbSurfaceCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.XcbSurfaceCreateInfoKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.KHR.XcbSurfaceCreateFlags Flags;
	public void* Connection;
	public uint Window;
	public XcbSurfaceCreateInfo(
		in Vk.KHR.XcbSurfaceCreateFlags flags = default,
		void* connection = default,
		uint window = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		Connection = connection;
		Window = window;
	}


	public readonly override bool Equals(object? obj) => (obj is XcbSurfaceCreateInfo o) && (this == o);
	readonly bool IEquatable<XcbSurfaceCreateInfo>.Equals(XcbSurfaceCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ ((ulong)Connection).GetHashCode()
			^ Window.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in XcbSurfaceCreateInfo l, in XcbSurfaceCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.Connection == r.Connection)
			&& (l.Window == r.Window)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in XcbSurfaceCreateInfo l, in XcbSurfaceCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.Connection != r.Connection)
			|| (l.Window != r.Window)
			;
	}


	/// <summary>Creates a new XcbSurfaceCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out XcbSurfaceCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SurfaceFormat : IEquatable<SurfaceFormat>
{
	public Vk.Format Format;
	public Vk.KHR.ColorSpace ColorSpace;
	public SurfaceFormat(
		in Vk.Format format = default,
		in Vk.KHR.ColorSpace colorSpace = default
	) {
		Format = format;
		ColorSpace = colorSpace;
	}


	public readonly override bool Equals(object? obj) => (obj is SurfaceFormat o) && (this == o);
	readonly bool IEquatable<SurfaceFormat>.Equals(SurfaceFormat obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Format.GetHashCode() ^ ColorSpace.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SurfaceFormat l, in SurfaceFormat r)
	{
		return
			(l.Format == r.Format) && (l.ColorSpace == r.ColorSpace)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SurfaceFormat l, in SurfaceFormat r)
	{
		return
			(l.Format != r.Format) || (l.ColorSpace != r.ColorSpace)
			;
	}


	/// <summary>Creates a new SurfaceFormat value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SurfaceFormat value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SwapchainCreateInfo : IEquatable<SwapchainCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.SwapchainCreateInfoKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.KHR.SwapchainCreateFlags Flags;
	public Vk.Handle<Vk.KHR.Surface> Surface;
	public uint MinImageCount;
	public Vk.Format ImageFormat;
	public Vk.KHR.ColorSpace ImageColorSpace;
	public Vk.Extent2D ImageExtent;
	public uint ImageArrayLayers;
	public Vk.ImageUsageFlags ImageUsage;
	public Vk.SharingMode ImageSharingMode;
	public uint QueueFamilyIndexCount;
	public uint* QueueFamilyIndices;
	public Vk.KHR.SurfaceTransformFlags PreTransform;
	public Vk.KHR.CompositeAlphaFlags CompositeAlpha;
	public Vk.KHR.PresentMode PresentMode;
	public Vk.Bool32 Clipped;
	public Vk.Handle<Vk.KHR.Swapchain> OldSwapchain;
	public SwapchainCreateInfo(
		in Vk.KHR.SwapchainCreateFlags flags = default,
		in Vk.Handle<Vk.KHR.Surface> surface = default,
		uint minImageCount = default,
		in Vk.Format imageFormat = default,
		in Vk.KHR.ColorSpace imageColorSpace = default,
		in Vk.Extent2D imageExtent = default,
		uint imageArrayLayers = default,
		in Vk.ImageUsageFlags imageUsage = default,
		in Vk.SharingMode imageSharingMode = default,
		uint queueFamilyIndexCount = default,
		uint* queueFamilyIndices = default,
		in Vk.KHR.SurfaceTransformFlags preTransform = default,
		in Vk.KHR.CompositeAlphaFlags compositeAlpha = default,
		in Vk.KHR.PresentMode presentMode = default,
		in Vk.Bool32 clipped = default,
		in Vk.Handle<Vk.KHR.Swapchain> oldSwapchain = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		Surface = surface;
		MinImageCount = minImageCount;
		ImageFormat = imageFormat;
		ImageColorSpace = imageColorSpace;
		ImageExtent = imageExtent;
		ImageArrayLayers = imageArrayLayers;
		ImageUsage = imageUsage;
		ImageSharingMode = imageSharingMode;
		QueueFamilyIndexCount = queueFamilyIndexCount;
		QueueFamilyIndices = queueFamilyIndices;
		PreTransform = preTransform;
		CompositeAlpha = compositeAlpha;
		PresentMode = presentMode;
		Clipped = clipped;
		OldSwapchain = oldSwapchain;
	}


	public readonly override bool Equals(object? obj) => (obj is SwapchainCreateInfo o) && (this == o);
	readonly bool IEquatable<SwapchainCreateInfo>.Equals(SwapchainCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ Surface.GetHashCode()
			^ MinImageCount.GetHashCode() ^ ImageFormat.GetHashCode() ^ ImageColorSpace.GetHashCode() ^ ImageExtent.GetHashCode()
			^ ImageArrayLayers.GetHashCode() ^ ImageUsage.GetHashCode() ^ ImageSharingMode.GetHashCode() ^ QueueFamilyIndexCount.GetHashCode()
			^ ((ulong)QueueFamilyIndices).GetHashCode() ^ PreTransform.GetHashCode() ^ CompositeAlpha.GetHashCode() ^ PresentMode.GetHashCode()
			^ Clipped.GetHashCode() ^ OldSwapchain.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SwapchainCreateInfo l, in SwapchainCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.Surface == r.Surface)
			&& (l.MinImageCount == r.MinImageCount) && (l.ImageFormat == r.ImageFormat) && (l.ImageColorSpace == r.ImageColorSpace) && (l.ImageExtent == r.ImageExtent)
			&& (l.ImageArrayLayers == r.ImageArrayLayers) && (l.ImageUsage == r.ImageUsage) && (l.ImageSharingMode == r.ImageSharingMode) && (l.QueueFamilyIndexCount == r.QueueFamilyIndexCount)
			&& (l.QueueFamilyIndices == r.QueueFamilyIndices) && (l.PreTransform == r.PreTransform) && (l.CompositeAlpha == r.CompositeAlpha) && (l.PresentMode == r.PresentMode)
			&& (l.Clipped == r.Clipped) && (l.OldSwapchain == r.OldSwapchain)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SwapchainCreateInfo l, in SwapchainCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.Surface != r.Surface)
			|| (l.MinImageCount != r.MinImageCount) || (l.ImageFormat != r.ImageFormat) || (l.ImageColorSpace != r.ImageColorSpace) || (l.ImageExtent != r.ImageExtent)
			|| (l.ImageArrayLayers != r.ImageArrayLayers) || (l.ImageUsage != r.ImageUsage) || (l.ImageSharingMode != r.ImageSharingMode) || (l.QueueFamilyIndexCount != r.QueueFamilyIndexCount)
			|| (l.QueueFamilyIndices != r.QueueFamilyIndices) || (l.PreTransform != r.PreTransform) || (l.CompositeAlpha != r.CompositeAlpha) || (l.PresentMode != r.PresentMode)
			|| (l.Clipped != r.Clipped) || (l.OldSwapchain != r.OldSwapchain)
			;
	}


	/// <summary>Creates a new SwapchainCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SwapchainCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PresentInfo : IEquatable<PresentInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PresentInfoKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public uint WaitSemaphoreCount;
	public Vk.Handle<Vk.Semaphore>* WaitSemaphores;
	public uint SwapchainCount;
	public Vk.Handle<Vk.KHR.Swapchain>* Swapchains;
	public uint* ImageIndices;
	public Vk.Result* Results;
	public PresentInfo(
		uint waitSemaphoreCount = default,
		in Vk.Handle<Vk.Semaphore>* waitSemaphores = default,
		uint swapchainCount = default,
		in Vk.Handle<Vk.KHR.Swapchain>* swapchains = default,
		uint* imageIndices = default,
		in Vk.Result* results = default
	) {
		sType = TYPE;
		pNext = null;
		WaitSemaphoreCount = waitSemaphoreCount;
		WaitSemaphores = waitSemaphores;
		SwapchainCount = swapchainCount;
		Swapchains = swapchains;
		ImageIndices = imageIndices;
		Results = results;
	}


	public readonly override bool Equals(object? obj) => (obj is PresentInfo o) && (this == o);
	readonly bool IEquatable<PresentInfo>.Equals(PresentInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ WaitSemaphoreCount.GetHashCode() ^ ((ulong)WaitSemaphores).GetHashCode()
			^ SwapchainCount.GetHashCode() ^ ((ulong)Swapchains).GetHashCode() ^ ((ulong)ImageIndices).GetHashCode() ^ ((ulong)Results).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PresentInfo l, in PresentInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.WaitSemaphoreCount == r.WaitSemaphoreCount) && (l.WaitSemaphores == r.WaitSemaphores)
			&& (l.SwapchainCount == r.SwapchainCount) && (l.Swapchains == r.Swapchains) && (l.ImageIndices == r.ImageIndices) && (l.Results == r.Results)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PresentInfo l, in PresentInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.WaitSemaphoreCount != r.WaitSemaphoreCount) || (l.WaitSemaphores != r.WaitSemaphores)
			|| (l.SwapchainCount != r.SwapchainCount) || (l.Swapchains != r.Swapchains) || (l.ImageIndices != r.ImageIndices) || (l.Results != r.Results)
			;
	}


	/// <summary>Creates a new PresentInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PresentInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceFeatures2 : IEquatable<PhysicalDeviceFeatures2>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceFeatures2;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.PhysicalDeviceFeatures Features;
	public PhysicalDeviceFeatures2(
		in Vk.PhysicalDeviceFeatures features = default
	) {
		sType = TYPE;
		pNext = null;
		Features = features;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceFeatures2 o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceFeatures2>.Equals(PhysicalDeviceFeatures2 obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Features.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceFeatures2 l, in PhysicalDeviceFeatures2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Features == r.Features)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceFeatures2 l, in PhysicalDeviceFeatures2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Features != r.Features)
			;
	}


	/// <summary>Creates a new PhysicalDeviceFeatures2 value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceFeatures2 value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceProperties2 : IEquatable<PhysicalDeviceProperties2>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceProperties2;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.PhysicalDeviceProperties Properties;
	public PhysicalDeviceProperties2(
		in Vk.PhysicalDeviceProperties properties = default
	) {
		sType = TYPE;
		pNext = null;
		Properties = properties;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceProperties2 o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceProperties2>.Equals(PhysicalDeviceProperties2 obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Properties.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceProperties2 l, in PhysicalDeviceProperties2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Properties == r.Properties)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceProperties2 l, in PhysicalDeviceProperties2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Properties != r.Properties)
			;
	}


	/// <summary>Creates a new PhysicalDeviceProperties2 value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceProperties2 value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct FormatProperties2 : IEquatable<FormatProperties2>
{
	public const Vk.StructureType TYPE = Vk.StructureType.FormatProperties2;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.FormatProperties FormatProperties;
	public FormatProperties2(
		in Vk.FormatProperties formatProperties = default
	) {
		sType = TYPE;
		pNext = null;
		FormatProperties = formatProperties;
	}


	public readonly override bool Equals(object? obj) => (obj is FormatProperties2 o) && (this == o);
	readonly bool IEquatable<FormatProperties2>.Equals(FormatProperties2 obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ FormatProperties.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in FormatProperties2 l, in FormatProperties2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.FormatProperties == r.FormatProperties)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in FormatProperties2 l, in FormatProperties2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.FormatProperties != r.FormatProperties)
			;
	}


	/// <summary>Creates a new FormatProperties2 value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out FormatProperties2 value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ImageFormatProperties2 : IEquatable<ImageFormatProperties2>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ImageFormatProperties2;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.ImageFormatProperties ImageFormatProperties;
	public ImageFormatProperties2(
		in Vk.ImageFormatProperties imageFormatProperties = default
	) {
		sType = TYPE;
		pNext = null;
		ImageFormatProperties = imageFormatProperties;
	}


	public readonly override bool Equals(object? obj) => (obj is ImageFormatProperties2 o) && (this == o);
	readonly bool IEquatable<ImageFormatProperties2>.Equals(ImageFormatProperties2 obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ImageFormatProperties.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ImageFormatProperties2 l, in ImageFormatProperties2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ImageFormatProperties == r.ImageFormatProperties)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ImageFormatProperties2 l, in ImageFormatProperties2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ImageFormatProperties != r.ImageFormatProperties)
			;
	}


	/// <summary>Creates a new ImageFormatProperties2 value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ImageFormatProperties2 value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceImageFormatInfo2 : IEquatable<PhysicalDeviceImageFormatInfo2>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceImageFormatInfo2;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Format Format;
	public Vk.ImageType Type;
	public Vk.ImageTiling Tiling;
	public Vk.ImageUsageFlags Usage;
	public Vk.ImageCreateFlags Flags;
	public PhysicalDeviceImageFormatInfo2(
		in Vk.Format format = default,
		in Vk.ImageType type = default,
		in Vk.ImageTiling tiling = default,
		in Vk.ImageUsageFlags usage = default,
		in Vk.ImageCreateFlags flags = default
	) {
		sType = TYPE;
		pNext = null;
		Format = format;
		Type = type;
		Tiling = tiling;
		Usage = usage;
		Flags = flags;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceImageFormatInfo2 o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceImageFormatInfo2>.Equals(PhysicalDeviceImageFormatInfo2 obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Format.GetHashCode() ^ Type.GetHashCode()
			^ Tiling.GetHashCode() ^ Usage.GetHashCode() ^ Flags.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceImageFormatInfo2 l, in PhysicalDeviceImageFormatInfo2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Format == r.Format) && (l.Type == r.Type)
			&& (l.Tiling == r.Tiling) && (l.Usage == r.Usage) && (l.Flags == r.Flags)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceImageFormatInfo2 l, in PhysicalDeviceImageFormatInfo2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Format != r.Format) || (l.Type != r.Type)
			|| (l.Tiling != r.Tiling) || (l.Usage != r.Usage) || (l.Flags != r.Flags)
			;
	}


	/// <summary>Creates a new PhysicalDeviceImageFormatInfo2 value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceImageFormatInfo2 value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct QueueFamilyProperties2 : IEquatable<QueueFamilyProperties2>
{
	public const Vk.StructureType TYPE = Vk.StructureType.QueueFamilyProperties2;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.QueueFamilyProperties QueueFamilyProperties;
	public QueueFamilyProperties2(
		in Vk.QueueFamilyProperties queueFamilyProperties = default
	) {
		sType = TYPE;
		pNext = null;
		QueueFamilyProperties = queueFamilyProperties;
	}


	public readonly override bool Equals(object? obj) => (obj is QueueFamilyProperties2 o) && (this == o);
	readonly bool IEquatable<QueueFamilyProperties2>.Equals(QueueFamilyProperties2 obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ QueueFamilyProperties.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in QueueFamilyProperties2 l, in QueueFamilyProperties2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.QueueFamilyProperties == r.QueueFamilyProperties)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in QueueFamilyProperties2 l, in QueueFamilyProperties2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.QueueFamilyProperties != r.QueueFamilyProperties)
			;
	}


	/// <summary>Creates a new QueueFamilyProperties2 value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out QueueFamilyProperties2 value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceMemoryProperties2 : IEquatable<PhysicalDeviceMemoryProperties2>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceMemoryProperties2;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.PhysicalDeviceMemoryProperties MemoryProperties;
	public PhysicalDeviceMemoryProperties2(
		in Vk.PhysicalDeviceMemoryProperties memoryProperties = default
	) {
		sType = TYPE;
		pNext = null;
		MemoryProperties = memoryProperties;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceMemoryProperties2 o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceMemoryProperties2>.Equals(PhysicalDeviceMemoryProperties2 obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MemoryProperties.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceMemoryProperties2 l, in PhysicalDeviceMemoryProperties2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MemoryProperties == r.MemoryProperties)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceMemoryProperties2 l, in PhysicalDeviceMemoryProperties2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MemoryProperties != r.MemoryProperties)
			;
	}


	/// <summary>Creates a new PhysicalDeviceMemoryProperties2 value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceMemoryProperties2 value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SparseImageFormatProperties2 : IEquatable<SparseImageFormatProperties2>
{
	public const Vk.StructureType TYPE = Vk.StructureType.SparseImageFormatProperties2;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.SparseImageFormatProperties Properties;
	public SparseImageFormatProperties2(
		in Vk.SparseImageFormatProperties properties = default
	) {
		sType = TYPE;
		pNext = null;
		Properties = properties;
	}


	public readonly override bool Equals(object? obj) => (obj is SparseImageFormatProperties2 o) && (this == o);
	readonly bool IEquatable<SparseImageFormatProperties2>.Equals(SparseImageFormatProperties2 obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Properties.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SparseImageFormatProperties2 l, in SparseImageFormatProperties2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Properties == r.Properties)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SparseImageFormatProperties2 l, in SparseImageFormatProperties2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Properties != r.Properties)
			;
	}


	/// <summary>Creates a new SparseImageFormatProperties2 value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SparseImageFormatProperties2 value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceSparseImageFormatInfo2 : IEquatable<PhysicalDeviceSparseImageFormatInfo2>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceSparseImageFormatInfo2;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Format Format;
	public Vk.ImageType Type;
	public Vk.SampleCountFlags Samples;
	public Vk.ImageUsageFlags Usage;
	public Vk.ImageTiling Tiling;
	public PhysicalDeviceSparseImageFormatInfo2(
		in Vk.Format format = default,
		in Vk.ImageType type = default,
		in Vk.SampleCountFlags samples = default,
		in Vk.ImageUsageFlags usage = default,
		in Vk.ImageTiling tiling = default
	) {
		sType = TYPE;
		pNext = null;
		Format = format;
		Type = type;
		Samples = samples;
		Usage = usage;
		Tiling = tiling;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceSparseImageFormatInfo2 o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceSparseImageFormatInfo2>.Equals(PhysicalDeviceSparseImageFormatInfo2 obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Format.GetHashCode() ^ Type.GetHashCode()
			^ Samples.GetHashCode() ^ Usage.GetHashCode() ^ Tiling.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceSparseImageFormatInfo2 l, in PhysicalDeviceSparseImageFormatInfo2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Format == r.Format) && (l.Type == r.Type)
			&& (l.Samples == r.Samples) && (l.Usage == r.Usage) && (l.Tiling == r.Tiling)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceSparseImageFormatInfo2 l, in PhysicalDeviceSparseImageFormatInfo2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Format != r.Format) || (l.Type != r.Type)
			|| (l.Samples != r.Samples) || (l.Usage != r.Usage) || (l.Tiling != r.Tiling)
			;
	}


	/// <summary>Creates a new PhysicalDeviceSparseImageFormatInfo2 value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceSparseImageFormatInfo2 value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDevicePushDescriptorProperties : IEquatable<PhysicalDevicePushDescriptorProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDevicePushDescriptorPropertiesKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public uint MaxPushDescriptors;
	public PhysicalDevicePushDescriptorProperties(
		uint maxPushDescriptors = default
	) {
		sType = TYPE;
		pNext = null;
		MaxPushDescriptors = maxPushDescriptors;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDevicePushDescriptorProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDevicePushDescriptorProperties>.Equals(PhysicalDevicePushDescriptorProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MaxPushDescriptors.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDevicePushDescriptorProperties l, in PhysicalDevicePushDescriptorProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MaxPushDescriptors == r.MaxPushDescriptors)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDevicePushDescriptorProperties l, in PhysicalDevicePushDescriptorProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MaxPushDescriptors != r.MaxPushDescriptors)
			;
	}


	/// <summary>Creates a new PhysicalDevicePushDescriptorProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDevicePushDescriptorProperties value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ConformanceVersion : IEquatable<ConformanceVersion>
{
	public byte Major;
	public byte Minor;
	public byte Subminor;
	public byte Patch;
	public ConformanceVersion(
		byte major = default,
		byte minor = default,
		byte subminor = default,
		byte patch = default
	) {
		Major = major;
		Minor = minor;
		Subminor = subminor;
		Patch = patch;
	}


	public readonly override bool Equals(object? obj) => (obj is ConformanceVersion o) && (this == o);
	readonly bool IEquatable<ConformanceVersion>.Equals(ConformanceVersion obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Major.GetHashCode() ^ Minor.GetHashCode() ^ Subminor.GetHashCode() ^ Patch.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ConformanceVersion l, in ConformanceVersion r)
	{
		return
			(l.Major == r.Major) && (l.Minor == r.Minor) && (l.Subminor == r.Subminor) && (l.Patch == r.Patch)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ConformanceVersion l, in ConformanceVersion r)
	{
		return
			(l.Major != r.Major) || (l.Minor != r.Minor) || (l.Subminor != r.Subminor) || (l.Patch != r.Patch)
			;
	}


	/// <summary>Creates a new ConformanceVersion value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ConformanceVersion value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceDriverProperties : IEquatable<PhysicalDeviceDriverProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceDriverProperties;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.DriverId DriverID;
	public Vk.FixedString DriverName;
	public Vk.FixedString DriverInfo;
	public Vk.ConformanceVersion ConformanceVersion;
	public PhysicalDeviceDriverProperties(
		in Vk.DriverId driverID = default,
		in Vk.FixedString driverName = default,
		in Vk.FixedString driverInfo = default,
		in Vk.ConformanceVersion conformanceVersion = default
	) {
		sType = TYPE;
		pNext = null;
		DriverID = driverID;
		DriverName = driverName;
		DriverInfo = driverInfo;
		ConformanceVersion = conformanceVersion;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceDriverProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceDriverProperties>.Equals(PhysicalDeviceDriverProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DriverID.GetHashCode() ^ DriverName.GetHashCode()
			^ DriverInfo.GetHashCode() ^ ConformanceVersion.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceDriverProperties l, in PhysicalDeviceDriverProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DriverID == r.DriverID) && (l.DriverName == r.DriverName)
			&& (l.DriverInfo == r.DriverInfo) && (l.ConformanceVersion == r.ConformanceVersion)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceDriverProperties l, in PhysicalDeviceDriverProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DriverID != r.DriverID) || (l.DriverName != r.DriverName)
			|| (l.DriverInfo != r.DriverInfo) || (l.ConformanceVersion != r.ConformanceVersion)
			;
	}


	/// <summary>Creates a new PhysicalDeviceDriverProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceDriverProperties value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PresentRegions : IEquatable<PresentRegions>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PresentRegionsKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public uint SwapchainCount;
	public Vk.KHR.PresentRegion* Regions;
	public PresentRegions(
		uint swapchainCount = default,
		in Vk.KHR.PresentRegion* regions = default
	) {
		sType = TYPE;
		pNext = null;
		SwapchainCount = swapchainCount;
		Regions = regions;
	}


	public readonly override bool Equals(object? obj) => (obj is PresentRegions o) && (this == o);
	readonly bool IEquatable<PresentRegions>.Equals(PresentRegions obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SwapchainCount.GetHashCode() ^ ((ulong)Regions).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PresentRegions l, in PresentRegions r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SwapchainCount == r.SwapchainCount) && (l.Regions == r.Regions)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PresentRegions l, in PresentRegions r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SwapchainCount != r.SwapchainCount) || (l.Regions != r.Regions)
			;
	}


	/// <summary>Creates a new PresentRegions value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PresentRegions value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PresentRegion : IEquatable<PresentRegion>
{
	public uint RectangleCount;
	public Vk.KHR.RectLayer* Rectangles;
	public PresentRegion(
		uint rectangleCount = default,
		in Vk.KHR.RectLayer* rectangles = default
	) {
		RectangleCount = rectangleCount;
		Rectangles = rectangles;
	}


	public readonly override bool Equals(object? obj) => (obj is PresentRegion o) && (this == o);
	readonly bool IEquatable<PresentRegion>.Equals(PresentRegion obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			RectangleCount.GetHashCode() ^ ((ulong)Rectangles).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PresentRegion l, in PresentRegion r)
	{
		return
			(l.RectangleCount == r.RectangleCount) && (l.Rectangles == r.Rectangles)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PresentRegion l, in PresentRegion r)
	{
		return
			(l.RectangleCount != r.RectangleCount) || (l.Rectangles != r.Rectangles)
			;
	}


	/// <summary>Creates a new PresentRegion value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PresentRegion value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct RectLayer : IEquatable<RectLayer>
{
	public Vk.Offset2D Offset;
	public Vk.Extent2D Extent;
	public uint Layer;
	public RectLayer(
		in Vk.Offset2D offset = default,
		in Vk.Extent2D extent = default,
		uint layer = default
	) {
		Offset = offset;
		Extent = extent;
		Layer = layer;
	}


	public readonly override bool Equals(object? obj) => (obj is RectLayer o) && (this == o);
	readonly bool IEquatable<RectLayer>.Equals(RectLayer obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Offset.GetHashCode() ^ Extent.GetHashCode() ^ Layer.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in RectLayer l, in RectLayer r)
	{
		return
			(l.Offset == r.Offset) && (l.Extent == r.Extent) && (l.Layer == r.Layer)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in RectLayer l, in RectLayer r)
	{
		return
			(l.Offset != r.Offset) || (l.Extent != r.Extent) || (l.Layer != r.Layer)
			;
	}


	/// <summary>Creates a new RectLayer value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out RectLayer value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceVariablePointersFeatures : IEquatable<PhysicalDeviceVariablePointersFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceVariablePointersFeatures;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 VariablePointersStorageBuffer;
	public Vk.Bool32 VariablePointers;
	public PhysicalDeviceVariablePointersFeatures(
		in Vk.Bool32 variablePointersStorageBuffer = default,
		in Vk.Bool32 variablePointers = default
	) {
		sType = TYPE;
		pNext = null;
		VariablePointersStorageBuffer = variablePointersStorageBuffer;
		VariablePointers = variablePointers;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceVariablePointersFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceVariablePointersFeatures>.Equals(PhysicalDeviceVariablePointersFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ VariablePointersStorageBuffer.GetHashCode() ^ VariablePointers.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceVariablePointersFeatures l, in PhysicalDeviceVariablePointersFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.VariablePointersStorageBuffer == r.VariablePointersStorageBuffer) && (l.VariablePointers == r.VariablePointers)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceVariablePointersFeatures l, in PhysicalDeviceVariablePointersFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.VariablePointersStorageBuffer != r.VariablePointersStorageBuffer) || (l.VariablePointers != r.VariablePointers)
			;
	}


	/// <summary>Creates a new PhysicalDeviceVariablePointersFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceVariablePointersFeatures value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceVariablePointerFeatures : IEquatable<PhysicalDeviceVariablePointerFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceVariablePointersFeatures;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 VariablePointersStorageBuffer;
	public Vk.Bool32 VariablePointers;
	public PhysicalDeviceVariablePointerFeatures(
		in Vk.Bool32 variablePointersStorageBuffer = default,
		in Vk.Bool32 variablePointers = default
	) {
		sType = TYPE;
		pNext = null;
		VariablePointersStorageBuffer = variablePointersStorageBuffer;
		VariablePointers = variablePointers;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceVariablePointerFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceVariablePointerFeatures>.Equals(PhysicalDeviceVariablePointerFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ VariablePointersStorageBuffer.GetHashCode() ^ VariablePointers.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceVariablePointerFeatures l, in PhysicalDeviceVariablePointerFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.VariablePointersStorageBuffer == r.VariablePointersStorageBuffer) && (l.VariablePointers == r.VariablePointers)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceVariablePointerFeatures l, in PhysicalDeviceVariablePointerFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.VariablePointersStorageBuffer != r.VariablePointersStorageBuffer) || (l.VariablePointers != r.VariablePointers)
			;
	}


	/// <summary>Creates a new PhysicalDeviceVariablePointerFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceVariablePointerFeatures value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ExternalMemoryProperties : IEquatable<ExternalMemoryProperties>
{
	public Vk.ExternalMemoryFeatureFlags ExternalMemoryFeatures;
	public Vk.ExternalMemoryHandleTypeFlags ExportFromImportedHandleTypes;
	public Vk.ExternalMemoryHandleTypeFlags CompatibleHandleTypes;
	public ExternalMemoryProperties(
		in Vk.ExternalMemoryFeatureFlags externalMemoryFeatures = default,
		in Vk.ExternalMemoryHandleTypeFlags exportFromImportedHandleTypes = default,
		in Vk.ExternalMemoryHandleTypeFlags compatibleHandleTypes = default
	) {
		ExternalMemoryFeatures = externalMemoryFeatures;
		ExportFromImportedHandleTypes = exportFromImportedHandleTypes;
		CompatibleHandleTypes = compatibleHandleTypes;
	}


	public readonly override bool Equals(object? obj) => (obj is ExternalMemoryProperties o) && (this == o);
	readonly bool IEquatable<ExternalMemoryProperties>.Equals(ExternalMemoryProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			ExternalMemoryFeatures.GetHashCode() ^ ExportFromImportedHandleTypes.GetHashCode() ^ CompatibleHandleTypes.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ExternalMemoryProperties l, in ExternalMemoryProperties r)
	{
		return
			(l.ExternalMemoryFeatures == r.ExternalMemoryFeatures) && (l.ExportFromImportedHandleTypes == r.ExportFromImportedHandleTypes) && (l.CompatibleHandleTypes == r.CompatibleHandleTypes)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ExternalMemoryProperties l, in ExternalMemoryProperties r)
	{
		return
			(l.ExternalMemoryFeatures != r.ExternalMemoryFeatures) || (l.ExportFromImportedHandleTypes != r.ExportFromImportedHandleTypes) || (l.CompatibleHandleTypes != r.CompatibleHandleTypes)
			;
	}


	/// <summary>Creates a new ExternalMemoryProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ExternalMemoryProperties value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceExternalImageFormatInfo : IEquatable<PhysicalDeviceExternalImageFormatInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceExternalImageFormatInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.ExternalMemoryHandleTypeFlags HandleType;
	public PhysicalDeviceExternalImageFormatInfo(
		in Vk.ExternalMemoryHandleTypeFlags handleType = default
	) {
		sType = TYPE;
		pNext = null;
		HandleType = handleType;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceExternalImageFormatInfo o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceExternalImageFormatInfo>.Equals(PhysicalDeviceExternalImageFormatInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ HandleType.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceExternalImageFormatInfo l, in PhysicalDeviceExternalImageFormatInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.HandleType == r.HandleType)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceExternalImageFormatInfo l, in PhysicalDeviceExternalImageFormatInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.HandleType != r.HandleType)
			;
	}


	/// <summary>Creates a new PhysicalDeviceExternalImageFormatInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceExternalImageFormatInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ExternalImageFormatProperties : IEquatable<ExternalImageFormatProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ExternalImageFormatProperties;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.ExternalMemoryProperties ExternalMemoryProperties;
	public ExternalImageFormatProperties(
		in Vk.ExternalMemoryProperties externalMemoryProperties = default
	) {
		sType = TYPE;
		pNext = null;
		ExternalMemoryProperties = externalMemoryProperties;
	}


	public readonly override bool Equals(object? obj) => (obj is ExternalImageFormatProperties o) && (this == o);
	readonly bool IEquatable<ExternalImageFormatProperties>.Equals(ExternalImageFormatProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ExternalMemoryProperties.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ExternalImageFormatProperties l, in ExternalImageFormatProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ExternalMemoryProperties == r.ExternalMemoryProperties)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ExternalImageFormatProperties l, in ExternalImageFormatProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ExternalMemoryProperties != r.ExternalMemoryProperties)
			;
	}


	/// <summary>Creates a new ExternalImageFormatProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ExternalImageFormatProperties value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceExternalBufferInfo : IEquatable<PhysicalDeviceExternalBufferInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceExternalBufferInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.BufferCreateFlags Flags;
	public Vk.BufferUsageFlags Usage;
	public Vk.ExternalMemoryHandleTypeFlags HandleType;
	public PhysicalDeviceExternalBufferInfo(
		in Vk.BufferCreateFlags flags = default,
		in Vk.BufferUsageFlags usage = default,
		in Vk.ExternalMemoryHandleTypeFlags handleType = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		Usage = usage;
		HandleType = handleType;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceExternalBufferInfo o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceExternalBufferInfo>.Equals(PhysicalDeviceExternalBufferInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ Usage.GetHashCode()
			^ HandleType.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceExternalBufferInfo l, in PhysicalDeviceExternalBufferInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.Usage == r.Usage)
			&& (l.HandleType == r.HandleType)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceExternalBufferInfo l, in PhysicalDeviceExternalBufferInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.Usage != r.Usage)
			|| (l.HandleType != r.HandleType)
			;
	}


	/// <summary>Creates a new PhysicalDeviceExternalBufferInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceExternalBufferInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ExternalBufferProperties : IEquatable<ExternalBufferProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ExternalBufferProperties;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.ExternalMemoryProperties ExternalMemoryProperties;
	public ExternalBufferProperties(
		in Vk.ExternalMemoryProperties externalMemoryProperties = default
	) {
		sType = TYPE;
		pNext = null;
		ExternalMemoryProperties = externalMemoryProperties;
	}


	public readonly override bool Equals(object? obj) => (obj is ExternalBufferProperties o) && (this == o);
	readonly bool IEquatable<ExternalBufferProperties>.Equals(ExternalBufferProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ExternalMemoryProperties.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ExternalBufferProperties l, in ExternalBufferProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ExternalMemoryProperties == r.ExternalMemoryProperties)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ExternalBufferProperties l, in ExternalBufferProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ExternalMemoryProperties != r.ExternalMemoryProperties)
			;
	}


	/// <summary>Creates a new ExternalBufferProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ExternalBufferProperties value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceIDProperties : IEquatable<PhysicalDeviceIDProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceIdProperties;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.UUID DeviceUUID;
	public Vk.UUID DriverUUID;
	public Vk.LUID DeviceLUID;
	public uint DeviceNodeMask;
	public Vk.Bool32 DeviceLUIDValid;
	public PhysicalDeviceIDProperties(
		in Vk.UUID deviceUUID = default,
		in Vk.UUID driverUUID = default,
		in Vk.LUID deviceLUID = default,
		uint deviceNodeMask = default,
		in Vk.Bool32 deviceLUIDValid = default
	) {
		sType = TYPE;
		pNext = null;
		DeviceUUID = deviceUUID;
		DriverUUID = driverUUID;
		DeviceLUID = deviceLUID;
		DeviceNodeMask = deviceNodeMask;
		DeviceLUIDValid = deviceLUIDValid;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceIDProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceIDProperties>.Equals(PhysicalDeviceIDProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DeviceUUID.GetHashCode() ^ DriverUUID.GetHashCode()
			^ DeviceLUID.GetHashCode() ^ DeviceNodeMask.GetHashCode() ^ DeviceLUIDValid.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceIDProperties l, in PhysicalDeviceIDProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DeviceUUID == r.DeviceUUID) && (l.DriverUUID == r.DriverUUID)
			&& (l.DeviceLUID == r.DeviceLUID) && (l.DeviceNodeMask == r.DeviceNodeMask) && (l.DeviceLUIDValid == r.DeviceLUIDValid)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceIDProperties l, in PhysicalDeviceIDProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DeviceUUID != r.DeviceUUID) || (l.DriverUUID != r.DriverUUID)
			|| (l.DeviceLUID != r.DeviceLUID) || (l.DeviceNodeMask != r.DeviceNodeMask) || (l.DeviceLUIDValid != r.DeviceLUIDValid)
			;
	}


	/// <summary>Creates a new PhysicalDeviceIDProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceIDProperties value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ExternalMemoryImageCreateInfo : IEquatable<ExternalMemoryImageCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ExternalMemoryImageCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.ExternalMemoryHandleTypeFlags HandleTypes;
	public ExternalMemoryImageCreateInfo(
		in Vk.ExternalMemoryHandleTypeFlags handleTypes = default
	) {
		sType = TYPE;
		pNext = null;
		HandleTypes = handleTypes;
	}


	public readonly override bool Equals(object? obj) => (obj is ExternalMemoryImageCreateInfo o) && (this == o);
	readonly bool IEquatable<ExternalMemoryImageCreateInfo>.Equals(ExternalMemoryImageCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ HandleTypes.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ExternalMemoryImageCreateInfo l, in ExternalMemoryImageCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.HandleTypes == r.HandleTypes)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ExternalMemoryImageCreateInfo l, in ExternalMemoryImageCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.HandleTypes != r.HandleTypes)
			;
	}


	/// <summary>Creates a new ExternalMemoryImageCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ExternalMemoryImageCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ExternalMemoryBufferCreateInfo : IEquatable<ExternalMemoryBufferCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ExternalMemoryBufferCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.ExternalMemoryHandleTypeFlags HandleTypes;
	public ExternalMemoryBufferCreateInfo(
		in Vk.ExternalMemoryHandleTypeFlags handleTypes = default
	) {
		sType = TYPE;
		pNext = null;
		HandleTypes = handleTypes;
	}


	public readonly override bool Equals(object? obj) => (obj is ExternalMemoryBufferCreateInfo o) && (this == o);
	readonly bool IEquatable<ExternalMemoryBufferCreateInfo>.Equals(ExternalMemoryBufferCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ HandleTypes.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ExternalMemoryBufferCreateInfo l, in ExternalMemoryBufferCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.HandleTypes == r.HandleTypes)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ExternalMemoryBufferCreateInfo l, in ExternalMemoryBufferCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.HandleTypes != r.HandleTypes)
			;
	}


	/// <summary>Creates a new ExternalMemoryBufferCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ExternalMemoryBufferCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ExportMemoryAllocateInfo : IEquatable<ExportMemoryAllocateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ExportMemoryAllocateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.ExternalMemoryHandleTypeFlags HandleTypes;
	public ExportMemoryAllocateInfo(
		in Vk.ExternalMemoryHandleTypeFlags handleTypes = default
	) {
		sType = TYPE;
		pNext = null;
		HandleTypes = handleTypes;
	}


	public readonly override bool Equals(object? obj) => (obj is ExportMemoryAllocateInfo o) && (this == o);
	readonly bool IEquatable<ExportMemoryAllocateInfo>.Equals(ExportMemoryAllocateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ HandleTypes.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ExportMemoryAllocateInfo l, in ExportMemoryAllocateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.HandleTypes == r.HandleTypes)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ExportMemoryAllocateInfo l, in ExportMemoryAllocateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.HandleTypes != r.HandleTypes)
			;
	}


	/// <summary>Creates a new ExportMemoryAllocateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ExportMemoryAllocateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ImportMemoryWin32HandleInfo : IEquatable<ImportMemoryWin32HandleInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ImportMemoryWin32HandleInfoKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.ExternalMemoryHandleTypeFlags HandleType;
	public void* Handle;
	public ushort* Name;
	public ImportMemoryWin32HandleInfo(
		in Vk.ExternalMemoryHandleTypeFlags handleType = default,
		void* handle = default,
		ushort* name = default
	) {
		sType = TYPE;
		pNext = null;
		HandleType = handleType;
		Handle = handle;
		Name = name;
	}


	public readonly override bool Equals(object? obj) => (obj is ImportMemoryWin32HandleInfo o) && (this == o);
	readonly bool IEquatable<ImportMemoryWin32HandleInfo>.Equals(ImportMemoryWin32HandleInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ HandleType.GetHashCode() ^ ((ulong)Handle).GetHashCode()
			^ ((ulong)Name).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ImportMemoryWin32HandleInfo l, in ImportMemoryWin32HandleInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.HandleType == r.HandleType) && (l.Handle == r.Handle)
			&& (l.Name == r.Name)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ImportMemoryWin32HandleInfo l, in ImportMemoryWin32HandleInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.HandleType != r.HandleType) || (l.Handle != r.Handle)
			|| (l.Name != r.Name)
			;
	}


	/// <summary>Creates a new ImportMemoryWin32HandleInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ImportMemoryWin32HandleInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ExportMemoryWin32HandleInfo : IEquatable<ExportMemoryWin32HandleInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ExportMemoryWin32HandleInfoKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public void* Attributes;
	public uint DwAccess;
	public ushort* Name;
	public ExportMemoryWin32HandleInfo(
		void* attributes = default,
		uint dwAccess = default,
		ushort* name = default
	) {
		sType = TYPE;
		pNext = null;
		Attributes = attributes;
		DwAccess = dwAccess;
		Name = name;
	}


	public readonly override bool Equals(object? obj) => (obj is ExportMemoryWin32HandleInfo o) && (this == o);
	readonly bool IEquatable<ExportMemoryWin32HandleInfo>.Equals(ExportMemoryWin32HandleInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ((ulong)Attributes).GetHashCode() ^ DwAccess.GetHashCode()
			^ ((ulong)Name).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ExportMemoryWin32HandleInfo l, in ExportMemoryWin32HandleInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Attributes == r.Attributes) && (l.DwAccess == r.DwAccess)
			&& (l.Name == r.Name)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ExportMemoryWin32HandleInfo l, in ExportMemoryWin32HandleInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Attributes != r.Attributes) || (l.DwAccess != r.DwAccess)
			|| (l.Name != r.Name)
			;
	}


	/// <summary>Creates a new ExportMemoryWin32HandleInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ExportMemoryWin32HandleInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct MemoryWin32HandleProperties : IEquatable<MemoryWin32HandleProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.MemoryWin32HandlePropertiesKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public uint MemoryTypeBits;
	public MemoryWin32HandleProperties(
		uint memoryTypeBits = default
	) {
		sType = TYPE;
		pNext = null;
		MemoryTypeBits = memoryTypeBits;
	}


	public readonly override bool Equals(object? obj) => (obj is MemoryWin32HandleProperties o) && (this == o);
	readonly bool IEquatable<MemoryWin32HandleProperties>.Equals(MemoryWin32HandleProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MemoryTypeBits.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in MemoryWin32HandleProperties l, in MemoryWin32HandleProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MemoryTypeBits == r.MemoryTypeBits)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in MemoryWin32HandleProperties l, in MemoryWin32HandleProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MemoryTypeBits != r.MemoryTypeBits)
			;
	}


	/// <summary>Creates a new MemoryWin32HandleProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out MemoryWin32HandleProperties value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct MemoryGetWin32HandleInfo : IEquatable<MemoryGetWin32HandleInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.MemoryGetWin32HandleInfoKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Handle<Vk.DeviceMemory> Memory;
	public Vk.ExternalMemoryHandleTypeFlags HandleType;
	public MemoryGetWin32HandleInfo(
		in Vk.Handle<Vk.DeviceMemory> memory = default,
		in Vk.ExternalMemoryHandleTypeFlags handleType = default
	) {
		sType = TYPE;
		pNext = null;
		Memory = memory;
		HandleType = handleType;
	}


	public readonly override bool Equals(object? obj) => (obj is MemoryGetWin32HandleInfo o) && (this == o);
	readonly bool IEquatable<MemoryGetWin32HandleInfo>.Equals(MemoryGetWin32HandleInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Memory.GetHashCode() ^ HandleType.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in MemoryGetWin32HandleInfo l, in MemoryGetWin32HandleInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Memory == r.Memory) && (l.HandleType == r.HandleType)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in MemoryGetWin32HandleInfo l, in MemoryGetWin32HandleInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Memory != r.Memory) || (l.HandleType != r.HandleType)
			;
	}


	/// <summary>Creates a new MemoryGetWin32HandleInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out MemoryGetWin32HandleInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ImportMemoryFdInfo : IEquatable<ImportMemoryFdInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ImportMemoryFdInfoKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.ExternalMemoryHandleTypeFlags HandleType;
	public int Fd;
	public ImportMemoryFdInfo(
		in Vk.ExternalMemoryHandleTypeFlags handleType = default,
		int fd = default
	) {
		sType = TYPE;
		pNext = null;
		HandleType = handleType;
		Fd = fd;
	}


	public readonly override bool Equals(object? obj) => (obj is ImportMemoryFdInfo o) && (this == o);
	readonly bool IEquatable<ImportMemoryFdInfo>.Equals(ImportMemoryFdInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ HandleType.GetHashCode() ^ Fd.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ImportMemoryFdInfo l, in ImportMemoryFdInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.HandleType == r.HandleType) && (l.Fd == r.Fd)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ImportMemoryFdInfo l, in ImportMemoryFdInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.HandleType != r.HandleType) || (l.Fd != r.Fd)
			;
	}


	/// <summary>Creates a new ImportMemoryFdInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ImportMemoryFdInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct MemoryFdProperties : IEquatable<MemoryFdProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.MemoryFdPropertiesKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public uint MemoryTypeBits;
	public MemoryFdProperties(
		uint memoryTypeBits = default
	) {
		sType = TYPE;
		pNext = null;
		MemoryTypeBits = memoryTypeBits;
	}


	public readonly override bool Equals(object? obj) => (obj is MemoryFdProperties o) && (this == o);
	readonly bool IEquatable<MemoryFdProperties>.Equals(MemoryFdProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MemoryTypeBits.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in MemoryFdProperties l, in MemoryFdProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MemoryTypeBits == r.MemoryTypeBits)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in MemoryFdProperties l, in MemoryFdProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MemoryTypeBits != r.MemoryTypeBits)
			;
	}


	/// <summary>Creates a new MemoryFdProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out MemoryFdProperties value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct MemoryGetFdInfo : IEquatable<MemoryGetFdInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.MemoryGetFdInfoKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Handle<Vk.DeviceMemory> Memory;
	public Vk.ExternalMemoryHandleTypeFlags HandleType;
	public MemoryGetFdInfo(
		in Vk.Handle<Vk.DeviceMemory> memory = default,
		in Vk.ExternalMemoryHandleTypeFlags handleType = default
	) {
		sType = TYPE;
		pNext = null;
		Memory = memory;
		HandleType = handleType;
	}


	public readonly override bool Equals(object? obj) => (obj is MemoryGetFdInfo o) && (this == o);
	readonly bool IEquatable<MemoryGetFdInfo>.Equals(MemoryGetFdInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Memory.GetHashCode() ^ HandleType.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in MemoryGetFdInfo l, in MemoryGetFdInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Memory == r.Memory) && (l.HandleType == r.HandleType)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in MemoryGetFdInfo l, in MemoryGetFdInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Memory != r.Memory) || (l.HandleType != r.HandleType)
			;
	}


	/// <summary>Creates a new MemoryGetFdInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out MemoryGetFdInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct Win32KeyedMutexAcquireReleaseInfo : IEquatable<Win32KeyedMutexAcquireReleaseInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.Win32KeyedMutexAcquireReleaseInfoKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public uint AcquireCount;
	public Vk.Handle<Vk.DeviceMemory>* AcquireSyncs;
	public ulong* AcquireKeys;
	public uint* AcquireTimeouts;
	public uint ReleaseCount;
	public Vk.Handle<Vk.DeviceMemory>* ReleaseSyncs;
	public ulong* ReleaseKeys;
	public Win32KeyedMutexAcquireReleaseInfo(
		uint acquireCount = default,
		in Vk.Handle<Vk.DeviceMemory>* acquireSyncs = default,
		ulong* acquireKeys = default,
		uint* acquireTimeouts = default,
		uint releaseCount = default,
		in Vk.Handle<Vk.DeviceMemory>* releaseSyncs = default,
		ulong* releaseKeys = default
	) {
		sType = TYPE;
		pNext = null;
		AcquireCount = acquireCount;
		AcquireSyncs = acquireSyncs;
		AcquireKeys = acquireKeys;
		AcquireTimeouts = acquireTimeouts;
		ReleaseCount = releaseCount;
		ReleaseSyncs = releaseSyncs;
		ReleaseKeys = releaseKeys;
	}


	public readonly override bool Equals(object? obj) => (obj is Win32KeyedMutexAcquireReleaseInfo o) && (this == o);
	readonly bool IEquatable<Win32KeyedMutexAcquireReleaseInfo>.Equals(Win32KeyedMutexAcquireReleaseInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ AcquireCount.GetHashCode() ^ ((ulong)AcquireSyncs).GetHashCode()
			^ ((ulong)AcquireKeys).GetHashCode() ^ ((ulong)AcquireTimeouts).GetHashCode() ^ ReleaseCount.GetHashCode() ^ ((ulong)ReleaseSyncs).GetHashCode()
			^ ((ulong)ReleaseKeys).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in Win32KeyedMutexAcquireReleaseInfo l, in Win32KeyedMutexAcquireReleaseInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.AcquireCount == r.AcquireCount) && (l.AcquireSyncs == r.AcquireSyncs)
			&& (l.AcquireKeys == r.AcquireKeys) && (l.AcquireTimeouts == r.AcquireTimeouts) && (l.ReleaseCount == r.ReleaseCount) && (l.ReleaseSyncs == r.ReleaseSyncs)
			&& (l.ReleaseKeys == r.ReleaseKeys)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in Win32KeyedMutexAcquireReleaseInfo l, in Win32KeyedMutexAcquireReleaseInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.AcquireCount != r.AcquireCount) || (l.AcquireSyncs != r.AcquireSyncs)
			|| (l.AcquireKeys != r.AcquireKeys) || (l.AcquireTimeouts != r.AcquireTimeouts) || (l.ReleaseCount != r.ReleaseCount) || (l.ReleaseSyncs != r.ReleaseSyncs)
			|| (l.ReleaseKeys != r.ReleaseKeys)
			;
	}


	/// <summary>Creates a new Win32KeyedMutexAcquireReleaseInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out Win32KeyedMutexAcquireReleaseInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceExternalSemaphoreInfo : IEquatable<PhysicalDeviceExternalSemaphoreInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceExternalSemaphoreInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.ExternalSemaphoreHandleTypeFlags HandleType;
	public PhysicalDeviceExternalSemaphoreInfo(
		in Vk.ExternalSemaphoreHandleTypeFlags handleType = default
	) {
		sType = TYPE;
		pNext = null;
		HandleType = handleType;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceExternalSemaphoreInfo o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceExternalSemaphoreInfo>.Equals(PhysicalDeviceExternalSemaphoreInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ HandleType.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceExternalSemaphoreInfo l, in PhysicalDeviceExternalSemaphoreInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.HandleType == r.HandleType)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceExternalSemaphoreInfo l, in PhysicalDeviceExternalSemaphoreInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.HandleType != r.HandleType)
			;
	}


	/// <summary>Creates a new PhysicalDeviceExternalSemaphoreInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceExternalSemaphoreInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ExternalSemaphoreProperties : IEquatable<ExternalSemaphoreProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ExternalSemaphoreProperties;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.ExternalSemaphoreHandleTypeFlags ExportFromImportedHandleTypes;
	public Vk.ExternalSemaphoreHandleTypeFlags CompatibleHandleTypes;
	public Vk.ExternalSemaphoreFeatureFlags ExternalSemaphoreFeatures;
	public ExternalSemaphoreProperties(
		in Vk.ExternalSemaphoreHandleTypeFlags exportFromImportedHandleTypes = default,
		in Vk.ExternalSemaphoreHandleTypeFlags compatibleHandleTypes = default,
		in Vk.ExternalSemaphoreFeatureFlags externalSemaphoreFeatures = default
	) {
		sType = TYPE;
		pNext = null;
		ExportFromImportedHandleTypes = exportFromImportedHandleTypes;
		CompatibleHandleTypes = compatibleHandleTypes;
		ExternalSemaphoreFeatures = externalSemaphoreFeatures;
	}


	public readonly override bool Equals(object? obj) => (obj is ExternalSemaphoreProperties o) && (this == o);
	readonly bool IEquatable<ExternalSemaphoreProperties>.Equals(ExternalSemaphoreProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ExportFromImportedHandleTypes.GetHashCode() ^ CompatibleHandleTypes.GetHashCode()
			^ ExternalSemaphoreFeatures.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ExternalSemaphoreProperties l, in ExternalSemaphoreProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ExportFromImportedHandleTypes == r.ExportFromImportedHandleTypes) && (l.CompatibleHandleTypes == r.CompatibleHandleTypes)
			&& (l.ExternalSemaphoreFeatures == r.ExternalSemaphoreFeatures)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ExternalSemaphoreProperties l, in ExternalSemaphoreProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ExportFromImportedHandleTypes != r.ExportFromImportedHandleTypes) || (l.CompatibleHandleTypes != r.CompatibleHandleTypes)
			|| (l.ExternalSemaphoreFeatures != r.ExternalSemaphoreFeatures)
			;
	}


	/// <summary>Creates a new ExternalSemaphoreProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ExternalSemaphoreProperties value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ExportSemaphoreCreateInfo : IEquatable<ExportSemaphoreCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ExportSemaphoreCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.ExternalSemaphoreHandleTypeFlags HandleTypes;
	public ExportSemaphoreCreateInfo(
		in Vk.ExternalSemaphoreHandleTypeFlags handleTypes = default
	) {
		sType = TYPE;
		pNext = null;
		HandleTypes = handleTypes;
	}


	public readonly override bool Equals(object? obj) => (obj is ExportSemaphoreCreateInfo o) && (this == o);
	readonly bool IEquatable<ExportSemaphoreCreateInfo>.Equals(ExportSemaphoreCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ HandleTypes.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ExportSemaphoreCreateInfo l, in ExportSemaphoreCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.HandleTypes == r.HandleTypes)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ExportSemaphoreCreateInfo l, in ExportSemaphoreCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.HandleTypes != r.HandleTypes)
			;
	}


	/// <summary>Creates a new ExportSemaphoreCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ExportSemaphoreCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ImportSemaphoreWin32HandleInfo : IEquatable<ImportSemaphoreWin32HandleInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ImportSemaphoreWin32HandleInfoKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Handle<Vk.Semaphore> Semaphore;
	public Vk.SemaphoreImportFlags Flags;
	public Vk.ExternalSemaphoreHandleTypeFlags HandleType;
	public void* Handle;
	public ushort* Name;
	public ImportSemaphoreWin32HandleInfo(
		in Vk.Handle<Vk.Semaphore> semaphore = default,
		in Vk.SemaphoreImportFlags flags = default,
		in Vk.ExternalSemaphoreHandleTypeFlags handleType = default,
		void* handle = default,
		ushort* name = default
	) {
		sType = TYPE;
		pNext = null;
		Semaphore = semaphore;
		Flags = flags;
		HandleType = handleType;
		Handle = handle;
		Name = name;
	}


	public readonly override bool Equals(object? obj) => (obj is ImportSemaphoreWin32HandleInfo o) && (this == o);
	readonly bool IEquatable<ImportSemaphoreWin32HandleInfo>.Equals(ImportSemaphoreWin32HandleInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Semaphore.GetHashCode() ^ Flags.GetHashCode()
			^ HandleType.GetHashCode() ^ ((ulong)Handle).GetHashCode() ^ ((ulong)Name).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ImportSemaphoreWin32HandleInfo l, in ImportSemaphoreWin32HandleInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Semaphore == r.Semaphore) && (l.Flags == r.Flags)
			&& (l.HandleType == r.HandleType) && (l.Handle == r.Handle) && (l.Name == r.Name)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ImportSemaphoreWin32HandleInfo l, in ImportSemaphoreWin32HandleInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Semaphore != r.Semaphore) || (l.Flags != r.Flags)
			|| (l.HandleType != r.HandleType) || (l.Handle != r.Handle) || (l.Name != r.Name)
			;
	}


	/// <summary>Creates a new ImportSemaphoreWin32HandleInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ImportSemaphoreWin32HandleInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ExportSemaphoreWin32HandleInfo : IEquatable<ExportSemaphoreWin32HandleInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ExportSemaphoreWin32HandleInfoKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public void* Attributes;
	public uint DwAccess;
	public ushort* Name;
	public ExportSemaphoreWin32HandleInfo(
		void* attributes = default,
		uint dwAccess = default,
		ushort* name = default
	) {
		sType = TYPE;
		pNext = null;
		Attributes = attributes;
		DwAccess = dwAccess;
		Name = name;
	}


	public readonly override bool Equals(object? obj) => (obj is ExportSemaphoreWin32HandleInfo o) && (this == o);
	readonly bool IEquatable<ExportSemaphoreWin32HandleInfo>.Equals(ExportSemaphoreWin32HandleInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ((ulong)Attributes).GetHashCode() ^ DwAccess.GetHashCode()
			^ ((ulong)Name).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ExportSemaphoreWin32HandleInfo l, in ExportSemaphoreWin32HandleInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Attributes == r.Attributes) && (l.DwAccess == r.DwAccess)
			&& (l.Name == r.Name)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ExportSemaphoreWin32HandleInfo l, in ExportSemaphoreWin32HandleInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Attributes != r.Attributes) || (l.DwAccess != r.DwAccess)
			|| (l.Name != r.Name)
			;
	}


	/// <summary>Creates a new ExportSemaphoreWin32HandleInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ExportSemaphoreWin32HandleInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct D3D12FenceSubmitInfo : IEquatable<D3D12FenceSubmitInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.D3d12FenceSubmitInfoKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public uint WaitSemaphoreValuesCount;
	public ulong* WaitSemaphoreValues;
	public uint SignalSemaphoreValuesCount;
	public ulong* SignalSemaphoreValues;
	public D3D12FenceSubmitInfo(
		uint waitSemaphoreValuesCount = default,
		ulong* waitSemaphoreValues = default,
		uint signalSemaphoreValuesCount = default,
		ulong* signalSemaphoreValues = default
	) {
		sType = TYPE;
		pNext = null;
		WaitSemaphoreValuesCount = waitSemaphoreValuesCount;
		WaitSemaphoreValues = waitSemaphoreValues;
		SignalSemaphoreValuesCount = signalSemaphoreValuesCount;
		SignalSemaphoreValues = signalSemaphoreValues;
	}


	public readonly override bool Equals(object? obj) => (obj is D3D12FenceSubmitInfo o) && (this == o);
	readonly bool IEquatable<D3D12FenceSubmitInfo>.Equals(D3D12FenceSubmitInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ WaitSemaphoreValuesCount.GetHashCode() ^ ((ulong)WaitSemaphoreValues).GetHashCode()
			^ SignalSemaphoreValuesCount.GetHashCode() ^ ((ulong)SignalSemaphoreValues).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in D3D12FenceSubmitInfo l, in D3D12FenceSubmitInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.WaitSemaphoreValuesCount == r.WaitSemaphoreValuesCount) && (l.WaitSemaphoreValues == r.WaitSemaphoreValues)
			&& (l.SignalSemaphoreValuesCount == r.SignalSemaphoreValuesCount) && (l.SignalSemaphoreValues == r.SignalSemaphoreValues)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in D3D12FenceSubmitInfo l, in D3D12FenceSubmitInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.WaitSemaphoreValuesCount != r.WaitSemaphoreValuesCount) || (l.WaitSemaphoreValues != r.WaitSemaphoreValues)
			|| (l.SignalSemaphoreValuesCount != r.SignalSemaphoreValuesCount) || (l.SignalSemaphoreValues != r.SignalSemaphoreValues)
			;
	}


	/// <summary>Creates a new D3D12FenceSubmitInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out D3D12FenceSubmitInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SemaphoreGetWin32HandleInfo : IEquatable<SemaphoreGetWin32HandleInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.SemaphoreGetWin32HandleInfoKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Handle<Vk.Semaphore> Semaphore;
	public Vk.ExternalSemaphoreHandleTypeFlags HandleType;
	public SemaphoreGetWin32HandleInfo(
		in Vk.Handle<Vk.Semaphore> semaphore = default,
		in Vk.ExternalSemaphoreHandleTypeFlags handleType = default
	) {
		sType = TYPE;
		pNext = null;
		Semaphore = semaphore;
		HandleType = handleType;
	}


	public readonly override bool Equals(object? obj) => (obj is SemaphoreGetWin32HandleInfo o) && (this == o);
	readonly bool IEquatable<SemaphoreGetWin32HandleInfo>.Equals(SemaphoreGetWin32HandleInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Semaphore.GetHashCode() ^ HandleType.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SemaphoreGetWin32HandleInfo l, in SemaphoreGetWin32HandleInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Semaphore == r.Semaphore) && (l.HandleType == r.HandleType)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SemaphoreGetWin32HandleInfo l, in SemaphoreGetWin32HandleInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Semaphore != r.Semaphore) || (l.HandleType != r.HandleType)
			;
	}


	/// <summary>Creates a new SemaphoreGetWin32HandleInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SemaphoreGetWin32HandleInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ImportSemaphoreFdInfo : IEquatable<ImportSemaphoreFdInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ImportSemaphoreFdInfoKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Handle<Vk.Semaphore> Semaphore;
	public Vk.SemaphoreImportFlags Flags;
	public Vk.ExternalSemaphoreHandleTypeFlags HandleType;
	public int Fd;
	public ImportSemaphoreFdInfo(
		in Vk.Handle<Vk.Semaphore> semaphore = default,
		in Vk.SemaphoreImportFlags flags = default,
		in Vk.ExternalSemaphoreHandleTypeFlags handleType = default,
		int fd = default
	) {
		sType = TYPE;
		pNext = null;
		Semaphore = semaphore;
		Flags = flags;
		HandleType = handleType;
		Fd = fd;
	}


	public readonly override bool Equals(object? obj) => (obj is ImportSemaphoreFdInfo o) && (this == o);
	readonly bool IEquatable<ImportSemaphoreFdInfo>.Equals(ImportSemaphoreFdInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Semaphore.GetHashCode() ^ Flags.GetHashCode()
			^ HandleType.GetHashCode() ^ Fd.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ImportSemaphoreFdInfo l, in ImportSemaphoreFdInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Semaphore == r.Semaphore) && (l.Flags == r.Flags)
			&& (l.HandleType == r.HandleType) && (l.Fd == r.Fd)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ImportSemaphoreFdInfo l, in ImportSemaphoreFdInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Semaphore != r.Semaphore) || (l.Flags != r.Flags)
			|| (l.HandleType != r.HandleType) || (l.Fd != r.Fd)
			;
	}


	/// <summary>Creates a new ImportSemaphoreFdInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ImportSemaphoreFdInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SemaphoreGetFdInfo : IEquatable<SemaphoreGetFdInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.SemaphoreGetFdInfoKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Handle<Vk.Semaphore> Semaphore;
	public Vk.ExternalSemaphoreHandleTypeFlags HandleType;
	public SemaphoreGetFdInfo(
		in Vk.Handle<Vk.Semaphore> semaphore = default,
		in Vk.ExternalSemaphoreHandleTypeFlags handleType = default
	) {
		sType = TYPE;
		pNext = null;
		Semaphore = semaphore;
		HandleType = handleType;
	}


	public readonly override bool Equals(object? obj) => (obj is SemaphoreGetFdInfo o) && (this == o);
	readonly bool IEquatable<SemaphoreGetFdInfo>.Equals(SemaphoreGetFdInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Semaphore.GetHashCode() ^ HandleType.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SemaphoreGetFdInfo l, in SemaphoreGetFdInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Semaphore == r.Semaphore) && (l.HandleType == r.HandleType)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SemaphoreGetFdInfo l, in SemaphoreGetFdInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Semaphore != r.Semaphore) || (l.HandleType != r.HandleType)
			;
	}


	/// <summary>Creates a new SemaphoreGetFdInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SemaphoreGetFdInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceExternalFenceInfo : IEquatable<PhysicalDeviceExternalFenceInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceExternalFenceInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.ExternalFenceHandleTypeFlags HandleType;
	public PhysicalDeviceExternalFenceInfo(
		in Vk.ExternalFenceHandleTypeFlags handleType = default
	) {
		sType = TYPE;
		pNext = null;
		HandleType = handleType;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceExternalFenceInfo o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceExternalFenceInfo>.Equals(PhysicalDeviceExternalFenceInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ HandleType.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceExternalFenceInfo l, in PhysicalDeviceExternalFenceInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.HandleType == r.HandleType)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceExternalFenceInfo l, in PhysicalDeviceExternalFenceInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.HandleType != r.HandleType)
			;
	}


	/// <summary>Creates a new PhysicalDeviceExternalFenceInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceExternalFenceInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ExternalFenceProperties : IEquatable<ExternalFenceProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ExternalFenceProperties;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.ExternalFenceHandleTypeFlags ExportFromImportedHandleTypes;
	public Vk.ExternalFenceHandleTypeFlags CompatibleHandleTypes;
	public Vk.ExternalFenceFeatureFlags ExternalFenceFeatures;
	public ExternalFenceProperties(
		in Vk.ExternalFenceHandleTypeFlags exportFromImportedHandleTypes = default,
		in Vk.ExternalFenceHandleTypeFlags compatibleHandleTypes = default,
		in Vk.ExternalFenceFeatureFlags externalFenceFeatures = default
	) {
		sType = TYPE;
		pNext = null;
		ExportFromImportedHandleTypes = exportFromImportedHandleTypes;
		CompatibleHandleTypes = compatibleHandleTypes;
		ExternalFenceFeatures = externalFenceFeatures;
	}


	public readonly override bool Equals(object? obj) => (obj is ExternalFenceProperties o) && (this == o);
	readonly bool IEquatable<ExternalFenceProperties>.Equals(ExternalFenceProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ExportFromImportedHandleTypes.GetHashCode() ^ CompatibleHandleTypes.GetHashCode()
			^ ExternalFenceFeatures.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ExternalFenceProperties l, in ExternalFenceProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ExportFromImportedHandleTypes == r.ExportFromImportedHandleTypes) && (l.CompatibleHandleTypes == r.CompatibleHandleTypes)
			&& (l.ExternalFenceFeatures == r.ExternalFenceFeatures)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ExternalFenceProperties l, in ExternalFenceProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ExportFromImportedHandleTypes != r.ExportFromImportedHandleTypes) || (l.CompatibleHandleTypes != r.CompatibleHandleTypes)
			|| (l.ExternalFenceFeatures != r.ExternalFenceFeatures)
			;
	}


	/// <summary>Creates a new ExternalFenceProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ExternalFenceProperties value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ExportFenceCreateInfo : IEquatable<ExportFenceCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ExportFenceCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.ExternalFenceHandleTypeFlags HandleTypes;
	public ExportFenceCreateInfo(
		in Vk.ExternalFenceHandleTypeFlags handleTypes = default
	) {
		sType = TYPE;
		pNext = null;
		HandleTypes = handleTypes;
	}


	public readonly override bool Equals(object? obj) => (obj is ExportFenceCreateInfo o) && (this == o);
	readonly bool IEquatable<ExportFenceCreateInfo>.Equals(ExportFenceCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ HandleTypes.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ExportFenceCreateInfo l, in ExportFenceCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.HandleTypes == r.HandleTypes)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ExportFenceCreateInfo l, in ExportFenceCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.HandleTypes != r.HandleTypes)
			;
	}


	/// <summary>Creates a new ExportFenceCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ExportFenceCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ImportFenceWin32HandleInfo : IEquatable<ImportFenceWin32HandleInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ImportFenceWin32HandleInfoKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Handle<Vk.Fence> Fence;
	public Vk.FenceImportFlags Flags;
	public Vk.ExternalFenceHandleTypeFlags HandleType;
	public void* Handle;
	public ushort* Name;
	public ImportFenceWin32HandleInfo(
		in Vk.Handle<Vk.Fence> fence = default,
		in Vk.FenceImportFlags flags = default,
		in Vk.ExternalFenceHandleTypeFlags handleType = default,
		void* handle = default,
		ushort* name = default
	) {
		sType = TYPE;
		pNext = null;
		Fence = fence;
		Flags = flags;
		HandleType = handleType;
		Handle = handle;
		Name = name;
	}


	public readonly override bool Equals(object? obj) => (obj is ImportFenceWin32HandleInfo o) && (this == o);
	readonly bool IEquatable<ImportFenceWin32HandleInfo>.Equals(ImportFenceWin32HandleInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Fence.GetHashCode() ^ Flags.GetHashCode()
			^ HandleType.GetHashCode() ^ ((ulong)Handle).GetHashCode() ^ ((ulong)Name).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ImportFenceWin32HandleInfo l, in ImportFenceWin32HandleInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Fence == r.Fence) && (l.Flags == r.Flags)
			&& (l.HandleType == r.HandleType) && (l.Handle == r.Handle) && (l.Name == r.Name)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ImportFenceWin32HandleInfo l, in ImportFenceWin32HandleInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Fence != r.Fence) || (l.Flags != r.Flags)
			|| (l.HandleType != r.HandleType) || (l.Handle != r.Handle) || (l.Name != r.Name)
			;
	}


	/// <summary>Creates a new ImportFenceWin32HandleInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ImportFenceWin32HandleInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ExportFenceWin32HandleInfo : IEquatable<ExportFenceWin32HandleInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ExportFenceWin32HandleInfoKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public void* Attributes;
	public uint DwAccess;
	public ushort* Name;
	public ExportFenceWin32HandleInfo(
		void* attributes = default,
		uint dwAccess = default,
		ushort* name = default
	) {
		sType = TYPE;
		pNext = null;
		Attributes = attributes;
		DwAccess = dwAccess;
		Name = name;
	}


	public readonly override bool Equals(object? obj) => (obj is ExportFenceWin32HandleInfo o) && (this == o);
	readonly bool IEquatable<ExportFenceWin32HandleInfo>.Equals(ExportFenceWin32HandleInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ((ulong)Attributes).GetHashCode() ^ DwAccess.GetHashCode()
			^ ((ulong)Name).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ExportFenceWin32HandleInfo l, in ExportFenceWin32HandleInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Attributes == r.Attributes) && (l.DwAccess == r.DwAccess)
			&& (l.Name == r.Name)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ExportFenceWin32HandleInfo l, in ExportFenceWin32HandleInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Attributes != r.Attributes) || (l.DwAccess != r.DwAccess)
			|| (l.Name != r.Name)
			;
	}


	/// <summary>Creates a new ExportFenceWin32HandleInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ExportFenceWin32HandleInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct FenceGetWin32HandleInfo : IEquatable<FenceGetWin32HandleInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.FenceGetWin32HandleInfoKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Handle<Vk.Fence> Fence;
	public Vk.ExternalFenceHandleTypeFlags HandleType;
	public FenceGetWin32HandleInfo(
		in Vk.Handle<Vk.Fence> fence = default,
		in Vk.ExternalFenceHandleTypeFlags handleType = default
	) {
		sType = TYPE;
		pNext = null;
		Fence = fence;
		HandleType = handleType;
	}


	public readonly override bool Equals(object? obj) => (obj is FenceGetWin32HandleInfo o) && (this == o);
	readonly bool IEquatable<FenceGetWin32HandleInfo>.Equals(FenceGetWin32HandleInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Fence.GetHashCode() ^ HandleType.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in FenceGetWin32HandleInfo l, in FenceGetWin32HandleInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Fence == r.Fence) && (l.HandleType == r.HandleType)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in FenceGetWin32HandleInfo l, in FenceGetWin32HandleInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Fence != r.Fence) || (l.HandleType != r.HandleType)
			;
	}


	/// <summary>Creates a new FenceGetWin32HandleInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out FenceGetWin32HandleInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ImportFenceFdInfo : IEquatable<ImportFenceFdInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ImportFenceFdInfoKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Handle<Vk.Fence> Fence;
	public Vk.FenceImportFlags Flags;
	public Vk.ExternalFenceHandleTypeFlags HandleType;
	public int Fd;
	public ImportFenceFdInfo(
		in Vk.Handle<Vk.Fence> fence = default,
		in Vk.FenceImportFlags flags = default,
		in Vk.ExternalFenceHandleTypeFlags handleType = default,
		int fd = default
	) {
		sType = TYPE;
		pNext = null;
		Fence = fence;
		Flags = flags;
		HandleType = handleType;
		Fd = fd;
	}


	public readonly override bool Equals(object? obj) => (obj is ImportFenceFdInfo o) && (this == o);
	readonly bool IEquatable<ImportFenceFdInfo>.Equals(ImportFenceFdInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Fence.GetHashCode() ^ Flags.GetHashCode()
			^ HandleType.GetHashCode() ^ Fd.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ImportFenceFdInfo l, in ImportFenceFdInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Fence == r.Fence) && (l.Flags == r.Flags)
			&& (l.HandleType == r.HandleType) && (l.Fd == r.Fd)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ImportFenceFdInfo l, in ImportFenceFdInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Fence != r.Fence) || (l.Flags != r.Flags)
			|| (l.HandleType != r.HandleType) || (l.Fd != r.Fd)
			;
	}


	/// <summary>Creates a new ImportFenceFdInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ImportFenceFdInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct FenceGetFdInfo : IEquatable<FenceGetFdInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.FenceGetFdInfoKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Handle<Vk.Fence> Fence;
	public Vk.ExternalFenceHandleTypeFlags HandleType;
	public FenceGetFdInfo(
		in Vk.Handle<Vk.Fence> fence = default,
		in Vk.ExternalFenceHandleTypeFlags handleType = default
	) {
		sType = TYPE;
		pNext = null;
		Fence = fence;
		HandleType = handleType;
	}


	public readonly override bool Equals(object? obj) => (obj is FenceGetFdInfo o) && (this == o);
	readonly bool IEquatable<FenceGetFdInfo>.Equals(FenceGetFdInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Fence.GetHashCode() ^ HandleType.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in FenceGetFdInfo l, in FenceGetFdInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Fence == r.Fence) && (l.HandleType == r.HandleType)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in FenceGetFdInfo l, in FenceGetFdInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Fence != r.Fence) || (l.HandleType != r.HandleType)
			;
	}


	/// <summary>Creates a new FenceGetFdInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out FenceGetFdInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceMultiviewFeatures : IEquatable<PhysicalDeviceMultiviewFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceMultiviewFeatures;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 Multiview;
	public Vk.Bool32 MultiviewGeometryShader;
	public Vk.Bool32 MultiviewTessellationShader;
	public PhysicalDeviceMultiviewFeatures(
		in Vk.Bool32 multiview = default,
		in Vk.Bool32 multiviewGeometryShader = default,
		in Vk.Bool32 multiviewTessellationShader = default
	) {
		sType = TYPE;
		pNext = null;
		Multiview = multiview;
		MultiviewGeometryShader = multiviewGeometryShader;
		MultiviewTessellationShader = multiviewTessellationShader;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceMultiviewFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceMultiviewFeatures>.Equals(PhysicalDeviceMultiviewFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Multiview.GetHashCode() ^ MultiviewGeometryShader.GetHashCode()
			^ MultiviewTessellationShader.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceMultiviewFeatures l, in PhysicalDeviceMultiviewFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Multiview == r.Multiview) && (l.MultiviewGeometryShader == r.MultiviewGeometryShader)
			&& (l.MultiviewTessellationShader == r.MultiviewTessellationShader)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceMultiviewFeatures l, in PhysicalDeviceMultiviewFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Multiview != r.Multiview) || (l.MultiviewGeometryShader != r.MultiviewGeometryShader)
			|| (l.MultiviewTessellationShader != r.MultiviewTessellationShader)
			;
	}


	/// <summary>Creates a new PhysicalDeviceMultiviewFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceMultiviewFeatures value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceMultiviewProperties : IEquatable<PhysicalDeviceMultiviewProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceMultiviewProperties;

	public Vk.StructureType sType;
	public void* pNext;
	public uint MaxMultiviewViewCount;
	public uint MaxMultiviewInstanceIndex;
	public PhysicalDeviceMultiviewProperties(
		uint maxMultiviewViewCount = default,
		uint maxMultiviewInstanceIndex = default
	) {
		sType = TYPE;
		pNext = null;
		MaxMultiviewViewCount = maxMultiviewViewCount;
		MaxMultiviewInstanceIndex = maxMultiviewInstanceIndex;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceMultiviewProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceMultiviewProperties>.Equals(PhysicalDeviceMultiviewProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MaxMultiviewViewCount.GetHashCode() ^ MaxMultiviewInstanceIndex.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceMultiviewProperties l, in PhysicalDeviceMultiviewProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MaxMultiviewViewCount == r.MaxMultiviewViewCount) && (l.MaxMultiviewInstanceIndex == r.MaxMultiviewInstanceIndex)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceMultiviewProperties l, in PhysicalDeviceMultiviewProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MaxMultiviewViewCount != r.MaxMultiviewViewCount) || (l.MaxMultiviewInstanceIndex != r.MaxMultiviewInstanceIndex)
			;
	}


	/// <summary>Creates a new PhysicalDeviceMultiviewProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceMultiviewProperties value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct RenderPassMultiviewCreateInfo : IEquatable<RenderPassMultiviewCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.RenderPassMultiviewCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public uint SubpassCount;
	public uint* ViewMasks;
	public uint DependencyCount;
	public int* ViewOffsets;
	public uint CorrelationMaskCount;
	public uint* CorrelationMasks;
	public RenderPassMultiviewCreateInfo(
		uint subpassCount = default,
		uint* viewMasks = default,
		uint dependencyCount = default,
		int* viewOffsets = default,
		uint correlationMaskCount = default,
		uint* correlationMasks = default
	) {
		sType = TYPE;
		pNext = null;
		SubpassCount = subpassCount;
		ViewMasks = viewMasks;
		DependencyCount = dependencyCount;
		ViewOffsets = viewOffsets;
		CorrelationMaskCount = correlationMaskCount;
		CorrelationMasks = correlationMasks;
	}


	public readonly override bool Equals(object? obj) => (obj is RenderPassMultiviewCreateInfo o) && (this == o);
	readonly bool IEquatable<RenderPassMultiviewCreateInfo>.Equals(RenderPassMultiviewCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SubpassCount.GetHashCode() ^ ((ulong)ViewMasks).GetHashCode()
			^ DependencyCount.GetHashCode() ^ ((ulong)ViewOffsets).GetHashCode() ^ CorrelationMaskCount.GetHashCode() ^ ((ulong)CorrelationMasks).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in RenderPassMultiviewCreateInfo l, in RenderPassMultiviewCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SubpassCount == r.SubpassCount) && (l.ViewMasks == r.ViewMasks)
			&& (l.DependencyCount == r.DependencyCount) && (l.ViewOffsets == r.ViewOffsets) && (l.CorrelationMaskCount == r.CorrelationMaskCount) && (l.CorrelationMasks == r.CorrelationMasks)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in RenderPassMultiviewCreateInfo l, in RenderPassMultiviewCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SubpassCount != r.SubpassCount) || (l.ViewMasks != r.ViewMasks)
			|| (l.DependencyCount != r.DependencyCount) || (l.ViewOffsets != r.ViewOffsets) || (l.CorrelationMaskCount != r.CorrelationMaskCount) || (l.CorrelationMasks != r.CorrelationMasks)
			;
	}


	/// <summary>Creates a new RenderPassMultiviewCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out RenderPassMultiviewCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceGroupProperties : IEquatable<PhysicalDeviceGroupProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceGroupProperties;

	public Vk.StructureType sType;
	public void* pNext;
	public uint PhysicalDeviceCount;
	public Vk.Handle<Vk.PhysicalDevice> PhysicalDevices_0;
	public Vk.Handle<Vk.PhysicalDevice> PhysicalDevices_1;
	public Vk.Handle<Vk.PhysicalDevice> PhysicalDevices_2;
	public Vk.Handle<Vk.PhysicalDevice> PhysicalDevices_3;
	public Vk.Handle<Vk.PhysicalDevice> PhysicalDevices_4;
	public Vk.Handle<Vk.PhysicalDevice> PhysicalDevices_5;
	public Vk.Handle<Vk.PhysicalDevice> PhysicalDevices_6;
	public Vk.Handle<Vk.PhysicalDevice> PhysicalDevices_7;
	public Vk.Handle<Vk.PhysicalDevice> PhysicalDevices_8;
	public Vk.Handle<Vk.PhysicalDevice> PhysicalDevices_9;
	public Vk.Handle<Vk.PhysicalDevice> PhysicalDevices_10;
	public Vk.Handle<Vk.PhysicalDevice> PhysicalDevices_11;
	public Vk.Handle<Vk.PhysicalDevice> PhysicalDevices_12;
	public Vk.Handle<Vk.PhysicalDevice> PhysicalDevices_13;
	public Vk.Handle<Vk.PhysicalDevice> PhysicalDevices_14;
	public Vk.Handle<Vk.PhysicalDevice> PhysicalDevices_15;
	public Vk.Handle<Vk.PhysicalDevice> PhysicalDevices_16;
	public Vk.Handle<Vk.PhysicalDevice> PhysicalDevices_17;
	public Vk.Handle<Vk.PhysicalDevice> PhysicalDevices_18;
	public Vk.Handle<Vk.PhysicalDevice> PhysicalDevices_19;
	public Vk.Handle<Vk.PhysicalDevice> PhysicalDevices_20;
	public Vk.Handle<Vk.PhysicalDevice> PhysicalDevices_21;
	public Vk.Handle<Vk.PhysicalDevice> PhysicalDevices_22;
	public Vk.Handle<Vk.PhysicalDevice> PhysicalDevices_23;
	public Vk.Handle<Vk.PhysicalDevice> PhysicalDevices_24;
	public Vk.Handle<Vk.PhysicalDevice> PhysicalDevices_25;
	public Vk.Handle<Vk.PhysicalDevice> PhysicalDevices_26;
	public Vk.Handle<Vk.PhysicalDevice> PhysicalDevices_27;
	public Vk.Handle<Vk.PhysicalDevice> PhysicalDevices_28;
	public Vk.Handle<Vk.PhysicalDevice> PhysicalDevices_29;
	public Vk.Handle<Vk.PhysicalDevice> PhysicalDevices_30;
	public Vk.Handle<Vk.PhysicalDevice> PhysicalDevices_31;
	public Vk.Bool32 SubsetAllocation;
	public PhysicalDeviceGroupProperties(
		uint physicalDeviceCount = default,
		in Vk.Handle<Vk.PhysicalDevice> physicalDevices0 = default,
		in Vk.Handle<Vk.PhysicalDevice> physicalDevices1 = default,
		in Vk.Handle<Vk.PhysicalDevice> physicalDevices2 = default,
		in Vk.Handle<Vk.PhysicalDevice> physicalDevices3 = default,
		in Vk.Handle<Vk.PhysicalDevice> physicalDevices4 = default,
		in Vk.Handle<Vk.PhysicalDevice> physicalDevices5 = default,
		in Vk.Handle<Vk.PhysicalDevice> physicalDevices6 = default,
		in Vk.Handle<Vk.PhysicalDevice> physicalDevices7 = default,
		in Vk.Handle<Vk.PhysicalDevice> physicalDevices8 = default,
		in Vk.Handle<Vk.PhysicalDevice> physicalDevices9 = default,
		in Vk.Handle<Vk.PhysicalDevice> physicalDevices10 = default,
		in Vk.Handle<Vk.PhysicalDevice> physicalDevices11 = default,
		in Vk.Handle<Vk.PhysicalDevice> physicalDevices12 = default,
		in Vk.Handle<Vk.PhysicalDevice> physicalDevices13 = default,
		in Vk.Handle<Vk.PhysicalDevice> physicalDevices14 = default,
		in Vk.Handle<Vk.PhysicalDevice> physicalDevices15 = default,
		in Vk.Handle<Vk.PhysicalDevice> physicalDevices16 = default,
		in Vk.Handle<Vk.PhysicalDevice> physicalDevices17 = default,
		in Vk.Handle<Vk.PhysicalDevice> physicalDevices18 = default,
		in Vk.Handle<Vk.PhysicalDevice> physicalDevices19 = default,
		in Vk.Handle<Vk.PhysicalDevice> physicalDevices20 = default,
		in Vk.Handle<Vk.PhysicalDevice> physicalDevices21 = default,
		in Vk.Handle<Vk.PhysicalDevice> physicalDevices22 = default,
		in Vk.Handle<Vk.PhysicalDevice> physicalDevices23 = default,
		in Vk.Handle<Vk.PhysicalDevice> physicalDevices24 = default,
		in Vk.Handle<Vk.PhysicalDevice> physicalDevices25 = default,
		in Vk.Handle<Vk.PhysicalDevice> physicalDevices26 = default,
		in Vk.Handle<Vk.PhysicalDevice> physicalDevices27 = default,
		in Vk.Handle<Vk.PhysicalDevice> physicalDevices28 = default,
		in Vk.Handle<Vk.PhysicalDevice> physicalDevices29 = default,
		in Vk.Handle<Vk.PhysicalDevice> physicalDevices30 = default,
		in Vk.Handle<Vk.PhysicalDevice> physicalDevices31 = default,
		in Vk.Bool32 subsetAllocation = default
	) {
		sType = TYPE;
		pNext = null;
		PhysicalDeviceCount = physicalDeviceCount;
		PhysicalDevices_0 = physicalDevices0;
		PhysicalDevices_1 = physicalDevices1;
		PhysicalDevices_2 = physicalDevices2;
		PhysicalDevices_3 = physicalDevices3;
		PhysicalDevices_4 = physicalDevices4;
		PhysicalDevices_5 = physicalDevices5;
		PhysicalDevices_6 = physicalDevices6;
		PhysicalDevices_7 = physicalDevices7;
		PhysicalDevices_8 = physicalDevices8;
		PhysicalDevices_9 = physicalDevices9;
		PhysicalDevices_10 = physicalDevices10;
		PhysicalDevices_11 = physicalDevices11;
		PhysicalDevices_12 = physicalDevices12;
		PhysicalDevices_13 = physicalDevices13;
		PhysicalDevices_14 = physicalDevices14;
		PhysicalDevices_15 = physicalDevices15;
		PhysicalDevices_16 = physicalDevices16;
		PhysicalDevices_17 = physicalDevices17;
		PhysicalDevices_18 = physicalDevices18;
		PhysicalDevices_19 = physicalDevices19;
		PhysicalDevices_20 = physicalDevices20;
		PhysicalDevices_21 = physicalDevices21;
		PhysicalDevices_22 = physicalDevices22;
		PhysicalDevices_23 = physicalDevices23;
		PhysicalDevices_24 = physicalDevices24;
		PhysicalDevices_25 = physicalDevices25;
		PhysicalDevices_26 = physicalDevices26;
		PhysicalDevices_27 = physicalDevices27;
		PhysicalDevices_28 = physicalDevices28;
		PhysicalDevices_29 = physicalDevices29;
		PhysicalDevices_30 = physicalDevices30;
		PhysicalDevices_31 = physicalDevices31;
		SubsetAllocation = subsetAllocation;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceGroupProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceGroupProperties>.Equals(PhysicalDeviceGroupProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ PhysicalDeviceCount.GetHashCode() ^ PhysicalDevices_0.GetHashCode()
			^ PhysicalDevices_1.GetHashCode() ^ PhysicalDevices_2.GetHashCode() ^ PhysicalDevices_3.GetHashCode() ^ PhysicalDevices_4.GetHashCode()
			^ PhysicalDevices_5.GetHashCode() ^ PhysicalDevices_6.GetHashCode() ^ PhysicalDevices_7.GetHashCode() ^ PhysicalDevices_8.GetHashCode()
			^ PhysicalDevices_9.GetHashCode() ^ PhysicalDevices_10.GetHashCode() ^ PhysicalDevices_11.GetHashCode() ^ PhysicalDevices_12.GetHashCode()
			^ PhysicalDevices_13.GetHashCode() ^ PhysicalDevices_14.GetHashCode() ^ PhysicalDevices_15.GetHashCode() ^ PhysicalDevices_16.GetHashCode()
			^ PhysicalDevices_17.GetHashCode() ^ PhysicalDevices_18.GetHashCode() ^ PhysicalDevices_19.GetHashCode() ^ PhysicalDevices_20.GetHashCode()
			^ PhysicalDevices_21.GetHashCode() ^ PhysicalDevices_22.GetHashCode() ^ PhysicalDevices_23.GetHashCode() ^ PhysicalDevices_24.GetHashCode()
			^ PhysicalDevices_25.GetHashCode() ^ PhysicalDevices_26.GetHashCode() ^ PhysicalDevices_27.GetHashCode() ^ PhysicalDevices_28.GetHashCode()
			^ PhysicalDevices_29.GetHashCode() ^ PhysicalDevices_30.GetHashCode() ^ PhysicalDevices_31.GetHashCode() ^ SubsetAllocation.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceGroupProperties l, in PhysicalDeviceGroupProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.PhysicalDeviceCount == r.PhysicalDeviceCount) && (l.PhysicalDevices_0 == r.PhysicalDevices_0)
			&& (l.PhysicalDevices_1 == r.PhysicalDevices_1) && (l.PhysicalDevices_2 == r.PhysicalDevices_2) && (l.PhysicalDevices_3 == r.PhysicalDevices_3) && (l.PhysicalDevices_4 == r.PhysicalDevices_4)
			&& (l.PhysicalDevices_5 == r.PhysicalDevices_5) && (l.PhysicalDevices_6 == r.PhysicalDevices_6) && (l.PhysicalDevices_7 == r.PhysicalDevices_7) && (l.PhysicalDevices_8 == r.PhysicalDevices_8)
			&& (l.PhysicalDevices_9 == r.PhysicalDevices_9) && (l.PhysicalDevices_10 == r.PhysicalDevices_10) && (l.PhysicalDevices_11 == r.PhysicalDevices_11) && (l.PhysicalDevices_12 == r.PhysicalDevices_12)
			&& (l.PhysicalDevices_13 == r.PhysicalDevices_13) && (l.PhysicalDevices_14 == r.PhysicalDevices_14) && (l.PhysicalDevices_15 == r.PhysicalDevices_15) && (l.PhysicalDevices_16 == r.PhysicalDevices_16)
			&& (l.PhysicalDevices_17 == r.PhysicalDevices_17) && (l.PhysicalDevices_18 == r.PhysicalDevices_18) && (l.PhysicalDevices_19 == r.PhysicalDevices_19) && (l.PhysicalDevices_20 == r.PhysicalDevices_20)
			&& (l.PhysicalDevices_21 == r.PhysicalDevices_21) && (l.PhysicalDevices_22 == r.PhysicalDevices_22) && (l.PhysicalDevices_23 == r.PhysicalDevices_23) && (l.PhysicalDevices_24 == r.PhysicalDevices_24)
			&& (l.PhysicalDevices_25 == r.PhysicalDevices_25) && (l.PhysicalDevices_26 == r.PhysicalDevices_26) && (l.PhysicalDevices_27 == r.PhysicalDevices_27) && (l.PhysicalDevices_28 == r.PhysicalDevices_28)
			&& (l.PhysicalDevices_29 == r.PhysicalDevices_29) && (l.PhysicalDevices_30 == r.PhysicalDevices_30) && (l.PhysicalDevices_31 == r.PhysicalDevices_31) && (l.SubsetAllocation == r.SubsetAllocation)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceGroupProperties l, in PhysicalDeviceGroupProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.PhysicalDeviceCount != r.PhysicalDeviceCount) || (l.PhysicalDevices_0 != r.PhysicalDevices_0)
			|| (l.PhysicalDevices_1 != r.PhysicalDevices_1) || (l.PhysicalDevices_2 != r.PhysicalDevices_2) || (l.PhysicalDevices_3 != r.PhysicalDevices_3) || (l.PhysicalDevices_4 != r.PhysicalDevices_4)
			|| (l.PhysicalDevices_5 != r.PhysicalDevices_5) || (l.PhysicalDevices_6 != r.PhysicalDevices_6) || (l.PhysicalDevices_7 != r.PhysicalDevices_7) || (l.PhysicalDevices_8 != r.PhysicalDevices_8)
			|| (l.PhysicalDevices_9 != r.PhysicalDevices_9) || (l.PhysicalDevices_10 != r.PhysicalDevices_10) || (l.PhysicalDevices_11 != r.PhysicalDevices_11) || (l.PhysicalDevices_12 != r.PhysicalDevices_12)
			|| (l.PhysicalDevices_13 != r.PhysicalDevices_13) || (l.PhysicalDevices_14 != r.PhysicalDevices_14) || (l.PhysicalDevices_15 != r.PhysicalDevices_15) || (l.PhysicalDevices_16 != r.PhysicalDevices_16)
			|| (l.PhysicalDevices_17 != r.PhysicalDevices_17) || (l.PhysicalDevices_18 != r.PhysicalDevices_18) || (l.PhysicalDevices_19 != r.PhysicalDevices_19) || (l.PhysicalDevices_20 != r.PhysicalDevices_20)
			|| (l.PhysicalDevices_21 != r.PhysicalDevices_21) || (l.PhysicalDevices_22 != r.PhysicalDevices_22) || (l.PhysicalDevices_23 != r.PhysicalDevices_23) || (l.PhysicalDevices_24 != r.PhysicalDevices_24)
			|| (l.PhysicalDevices_25 != r.PhysicalDevices_25) || (l.PhysicalDevices_26 != r.PhysicalDevices_26) || (l.PhysicalDevices_27 != r.PhysicalDevices_27) || (l.PhysicalDevices_28 != r.PhysicalDevices_28)
			|| (l.PhysicalDevices_29 != r.PhysicalDevices_29) || (l.PhysicalDevices_30 != r.PhysicalDevices_30) || (l.PhysicalDevices_31 != r.PhysicalDevices_31) || (l.SubsetAllocation != r.SubsetAllocation)
			;
	}


	/// <summary>Creates a new PhysicalDeviceGroupProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceGroupProperties value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct MemoryAllocateFlagsInfo : IEquatable<MemoryAllocateFlagsInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.MemoryAllocateFlagsInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.MemoryAllocateFlags Flags;
	public uint DeviceMask;
	public MemoryAllocateFlagsInfo(
		in Vk.MemoryAllocateFlags flags = default,
		uint deviceMask = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		DeviceMask = deviceMask;
	}


	public readonly override bool Equals(object? obj) => (obj is MemoryAllocateFlagsInfo o) && (this == o);
	readonly bool IEquatable<MemoryAllocateFlagsInfo>.Equals(MemoryAllocateFlagsInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ DeviceMask.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in MemoryAllocateFlagsInfo l, in MemoryAllocateFlagsInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.DeviceMask == r.DeviceMask)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in MemoryAllocateFlagsInfo l, in MemoryAllocateFlagsInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.DeviceMask != r.DeviceMask)
			;
	}


	/// <summary>Creates a new MemoryAllocateFlagsInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out MemoryAllocateFlagsInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct BindBufferMemoryInfo : IEquatable<BindBufferMemoryInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.BindBufferMemoryInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Handle<Vk.Buffer> Buffer;
	public Vk.Handle<Vk.DeviceMemory> Memory;
	public Vk.DeviceSize MemoryOffset;
	public BindBufferMemoryInfo(
		in Vk.Handle<Vk.Buffer> buffer = default,
		in Vk.Handle<Vk.DeviceMemory> memory = default,
		in Vk.DeviceSize memoryOffset = default
	) {
		sType = TYPE;
		pNext = null;
		Buffer = buffer;
		Memory = memory;
		MemoryOffset = memoryOffset;
	}


	public readonly override bool Equals(object? obj) => (obj is BindBufferMemoryInfo o) && (this == o);
	readonly bool IEquatable<BindBufferMemoryInfo>.Equals(BindBufferMemoryInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Buffer.GetHashCode() ^ Memory.GetHashCode()
			^ MemoryOffset.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in BindBufferMemoryInfo l, in BindBufferMemoryInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Buffer == r.Buffer) && (l.Memory == r.Memory)
			&& (l.MemoryOffset == r.MemoryOffset)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in BindBufferMemoryInfo l, in BindBufferMemoryInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Buffer != r.Buffer) || (l.Memory != r.Memory)
			|| (l.MemoryOffset != r.MemoryOffset)
			;
	}


	/// <summary>Creates a new BindBufferMemoryInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out BindBufferMemoryInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct BindBufferMemoryDeviceGroupInfo : IEquatable<BindBufferMemoryDeviceGroupInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.BindBufferMemoryDeviceGroupInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public uint DeviceIndexCount;
	public uint* DeviceIndices;
	public BindBufferMemoryDeviceGroupInfo(
		uint deviceIndexCount = default,
		uint* deviceIndices = default
	) {
		sType = TYPE;
		pNext = null;
		DeviceIndexCount = deviceIndexCount;
		DeviceIndices = deviceIndices;
	}


	public readonly override bool Equals(object? obj) => (obj is BindBufferMemoryDeviceGroupInfo o) && (this == o);
	readonly bool IEquatable<BindBufferMemoryDeviceGroupInfo>.Equals(BindBufferMemoryDeviceGroupInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DeviceIndexCount.GetHashCode() ^ ((ulong)DeviceIndices).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in BindBufferMemoryDeviceGroupInfo l, in BindBufferMemoryDeviceGroupInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DeviceIndexCount == r.DeviceIndexCount) && (l.DeviceIndices == r.DeviceIndices)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in BindBufferMemoryDeviceGroupInfo l, in BindBufferMemoryDeviceGroupInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DeviceIndexCount != r.DeviceIndexCount) || (l.DeviceIndices != r.DeviceIndices)
			;
	}


	/// <summary>Creates a new BindBufferMemoryDeviceGroupInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out BindBufferMemoryDeviceGroupInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct BindImageMemoryInfo : IEquatable<BindImageMemoryInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.BindImageMemoryInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Handle<Vk.Image> Image;
	public Vk.Handle<Vk.DeviceMemory> Memory;
	public Vk.DeviceSize MemoryOffset;
	public BindImageMemoryInfo(
		in Vk.Handle<Vk.Image> image = default,
		in Vk.Handle<Vk.DeviceMemory> memory = default,
		in Vk.DeviceSize memoryOffset = default
	) {
		sType = TYPE;
		pNext = null;
		Image = image;
		Memory = memory;
		MemoryOffset = memoryOffset;
	}


	public readonly override bool Equals(object? obj) => (obj is BindImageMemoryInfo o) && (this == o);
	readonly bool IEquatable<BindImageMemoryInfo>.Equals(BindImageMemoryInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Image.GetHashCode() ^ Memory.GetHashCode()
			^ MemoryOffset.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in BindImageMemoryInfo l, in BindImageMemoryInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Image == r.Image) && (l.Memory == r.Memory)
			&& (l.MemoryOffset == r.MemoryOffset)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in BindImageMemoryInfo l, in BindImageMemoryInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Image != r.Image) || (l.Memory != r.Memory)
			|| (l.MemoryOffset != r.MemoryOffset)
			;
	}


	/// <summary>Creates a new BindImageMemoryInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out BindImageMemoryInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct BindImageMemoryDeviceGroupInfo : IEquatable<BindImageMemoryDeviceGroupInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.BindImageMemoryDeviceGroupInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public uint DeviceIndexCount;
	public uint* DeviceIndices;
	public uint SplitInstanceBindRegionCount;
	public Vk.Rect2D* SplitInstanceBindRegions;
	public BindImageMemoryDeviceGroupInfo(
		uint deviceIndexCount = default,
		uint* deviceIndices = default,
		uint splitInstanceBindRegionCount = default,
		in Vk.Rect2D* splitInstanceBindRegions = default
	) {
		sType = TYPE;
		pNext = null;
		DeviceIndexCount = deviceIndexCount;
		DeviceIndices = deviceIndices;
		SplitInstanceBindRegionCount = splitInstanceBindRegionCount;
		SplitInstanceBindRegions = splitInstanceBindRegions;
	}


	public readonly override bool Equals(object? obj) => (obj is BindImageMemoryDeviceGroupInfo o) && (this == o);
	readonly bool IEquatable<BindImageMemoryDeviceGroupInfo>.Equals(BindImageMemoryDeviceGroupInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DeviceIndexCount.GetHashCode() ^ ((ulong)DeviceIndices).GetHashCode()
			^ SplitInstanceBindRegionCount.GetHashCode() ^ ((ulong)SplitInstanceBindRegions).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in BindImageMemoryDeviceGroupInfo l, in BindImageMemoryDeviceGroupInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DeviceIndexCount == r.DeviceIndexCount) && (l.DeviceIndices == r.DeviceIndices)
			&& (l.SplitInstanceBindRegionCount == r.SplitInstanceBindRegionCount) && (l.SplitInstanceBindRegions == r.SplitInstanceBindRegions)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in BindImageMemoryDeviceGroupInfo l, in BindImageMemoryDeviceGroupInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DeviceIndexCount != r.DeviceIndexCount) || (l.DeviceIndices != r.DeviceIndices)
			|| (l.SplitInstanceBindRegionCount != r.SplitInstanceBindRegionCount) || (l.SplitInstanceBindRegions != r.SplitInstanceBindRegions)
			;
	}


	/// <summary>Creates a new BindImageMemoryDeviceGroupInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out BindImageMemoryDeviceGroupInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DeviceGroupRenderPassBeginInfo : IEquatable<DeviceGroupRenderPassBeginInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DeviceGroupRenderPassBeginInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public uint DeviceMask;
	public uint DeviceRenderAreaCount;
	public Vk.Rect2D* DeviceRenderAreas;
	public DeviceGroupRenderPassBeginInfo(
		uint deviceMask = default,
		uint deviceRenderAreaCount = default,
		in Vk.Rect2D* deviceRenderAreas = default
	) {
		sType = TYPE;
		pNext = null;
		DeviceMask = deviceMask;
		DeviceRenderAreaCount = deviceRenderAreaCount;
		DeviceRenderAreas = deviceRenderAreas;
	}


	public readonly override bool Equals(object? obj) => (obj is DeviceGroupRenderPassBeginInfo o) && (this == o);
	readonly bool IEquatable<DeviceGroupRenderPassBeginInfo>.Equals(DeviceGroupRenderPassBeginInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DeviceMask.GetHashCode() ^ DeviceRenderAreaCount.GetHashCode()
			^ ((ulong)DeviceRenderAreas).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DeviceGroupRenderPassBeginInfo l, in DeviceGroupRenderPassBeginInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DeviceMask == r.DeviceMask) && (l.DeviceRenderAreaCount == r.DeviceRenderAreaCount)
			&& (l.DeviceRenderAreas == r.DeviceRenderAreas)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DeviceGroupRenderPassBeginInfo l, in DeviceGroupRenderPassBeginInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DeviceMask != r.DeviceMask) || (l.DeviceRenderAreaCount != r.DeviceRenderAreaCount)
			|| (l.DeviceRenderAreas != r.DeviceRenderAreas)
			;
	}


	/// <summary>Creates a new DeviceGroupRenderPassBeginInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DeviceGroupRenderPassBeginInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DeviceGroupCommandBufferBeginInfo : IEquatable<DeviceGroupCommandBufferBeginInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DeviceGroupCommandBufferBeginInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public uint DeviceMask;
	public DeviceGroupCommandBufferBeginInfo(
		uint deviceMask = default
	) {
		sType = TYPE;
		pNext = null;
		DeviceMask = deviceMask;
	}


	public readonly override bool Equals(object? obj) => (obj is DeviceGroupCommandBufferBeginInfo o) && (this == o);
	readonly bool IEquatable<DeviceGroupCommandBufferBeginInfo>.Equals(DeviceGroupCommandBufferBeginInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DeviceMask.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DeviceGroupCommandBufferBeginInfo l, in DeviceGroupCommandBufferBeginInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DeviceMask == r.DeviceMask)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DeviceGroupCommandBufferBeginInfo l, in DeviceGroupCommandBufferBeginInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DeviceMask != r.DeviceMask)
			;
	}


	/// <summary>Creates a new DeviceGroupCommandBufferBeginInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DeviceGroupCommandBufferBeginInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DeviceGroupSubmitInfo : IEquatable<DeviceGroupSubmitInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DeviceGroupSubmitInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public uint WaitSemaphoreCount;
	public uint* WaitSemaphoreDeviceIndices;
	public uint CommandBufferCount;
	public uint* CommandBufferDeviceMasks;
	public uint SignalSemaphoreCount;
	public uint* SignalSemaphoreDeviceIndices;
	public DeviceGroupSubmitInfo(
		uint waitSemaphoreCount = default,
		uint* waitSemaphoreDeviceIndices = default,
		uint commandBufferCount = default,
		uint* commandBufferDeviceMasks = default,
		uint signalSemaphoreCount = default,
		uint* signalSemaphoreDeviceIndices = default
	) {
		sType = TYPE;
		pNext = null;
		WaitSemaphoreCount = waitSemaphoreCount;
		WaitSemaphoreDeviceIndices = waitSemaphoreDeviceIndices;
		CommandBufferCount = commandBufferCount;
		CommandBufferDeviceMasks = commandBufferDeviceMasks;
		SignalSemaphoreCount = signalSemaphoreCount;
		SignalSemaphoreDeviceIndices = signalSemaphoreDeviceIndices;
	}


	public readonly override bool Equals(object? obj) => (obj is DeviceGroupSubmitInfo o) && (this == o);
	readonly bool IEquatable<DeviceGroupSubmitInfo>.Equals(DeviceGroupSubmitInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ WaitSemaphoreCount.GetHashCode() ^ ((ulong)WaitSemaphoreDeviceIndices).GetHashCode()
			^ CommandBufferCount.GetHashCode() ^ ((ulong)CommandBufferDeviceMasks).GetHashCode() ^ SignalSemaphoreCount.GetHashCode() ^ ((ulong)SignalSemaphoreDeviceIndices).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DeviceGroupSubmitInfo l, in DeviceGroupSubmitInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.WaitSemaphoreCount == r.WaitSemaphoreCount) && (l.WaitSemaphoreDeviceIndices == r.WaitSemaphoreDeviceIndices)
			&& (l.CommandBufferCount == r.CommandBufferCount) && (l.CommandBufferDeviceMasks == r.CommandBufferDeviceMasks) && (l.SignalSemaphoreCount == r.SignalSemaphoreCount) && (l.SignalSemaphoreDeviceIndices == r.SignalSemaphoreDeviceIndices)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DeviceGroupSubmitInfo l, in DeviceGroupSubmitInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.WaitSemaphoreCount != r.WaitSemaphoreCount) || (l.WaitSemaphoreDeviceIndices != r.WaitSemaphoreDeviceIndices)
			|| (l.CommandBufferCount != r.CommandBufferCount) || (l.CommandBufferDeviceMasks != r.CommandBufferDeviceMasks) || (l.SignalSemaphoreCount != r.SignalSemaphoreCount) || (l.SignalSemaphoreDeviceIndices != r.SignalSemaphoreDeviceIndices)
			;
	}


	/// <summary>Creates a new DeviceGroupSubmitInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DeviceGroupSubmitInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DeviceGroupBindSparseInfo : IEquatable<DeviceGroupBindSparseInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DeviceGroupBindSparseInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public uint ResourceDeviceIndex;
	public uint MemoryDeviceIndex;
	public DeviceGroupBindSparseInfo(
		uint resourceDeviceIndex = default,
		uint memoryDeviceIndex = default
	) {
		sType = TYPE;
		pNext = null;
		ResourceDeviceIndex = resourceDeviceIndex;
		MemoryDeviceIndex = memoryDeviceIndex;
	}


	public readonly override bool Equals(object? obj) => (obj is DeviceGroupBindSparseInfo o) && (this == o);
	readonly bool IEquatable<DeviceGroupBindSparseInfo>.Equals(DeviceGroupBindSparseInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ResourceDeviceIndex.GetHashCode() ^ MemoryDeviceIndex.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DeviceGroupBindSparseInfo l, in DeviceGroupBindSparseInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ResourceDeviceIndex == r.ResourceDeviceIndex) && (l.MemoryDeviceIndex == r.MemoryDeviceIndex)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DeviceGroupBindSparseInfo l, in DeviceGroupBindSparseInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ResourceDeviceIndex != r.ResourceDeviceIndex) || (l.MemoryDeviceIndex != r.MemoryDeviceIndex)
			;
	}


	/// <summary>Creates a new DeviceGroupBindSparseInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DeviceGroupBindSparseInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DeviceGroupPresentCapabilities : IEquatable<DeviceGroupPresentCapabilities>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DeviceGroupPresentCapabilitiesKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public fixed uint PresentMask[(int)Vk.Constants.MAX_DEVICE_GROUP_SIZE];
	public Vk.KHR.DeviceGroupPresentModeFlags Modes;
	public DeviceGroupPresentCapabilities(
		uint presentMask0 = default,
		uint presentMask1 = default,
		uint presentMask2 = default,
		uint presentMask3 = default,
		uint presentMask4 = default,
		uint presentMask5 = default,
		uint presentMask6 = default,
		uint presentMask7 = default,
		uint presentMask8 = default,
		uint presentMask9 = default,
		uint presentMask10 = default,
		uint presentMask11 = default,
		uint presentMask12 = default,
		uint presentMask13 = default,
		uint presentMask14 = default,
		uint presentMask15 = default,
		uint presentMask16 = default,
		uint presentMask17 = default,
		uint presentMask18 = default,
		uint presentMask19 = default,
		uint presentMask20 = default,
		uint presentMask21 = default,
		uint presentMask22 = default,
		uint presentMask23 = default,
		uint presentMask24 = default,
		uint presentMask25 = default,
		uint presentMask26 = default,
		uint presentMask27 = default,
		uint presentMask28 = default,
		uint presentMask29 = default,
		uint presentMask30 = default,
		uint presentMask31 = default,
		in Vk.KHR.DeviceGroupPresentModeFlags modes = default
	) {
		sType = TYPE;
		pNext = null;
		PresentMask[0] = presentMask0;
		PresentMask[1] = presentMask1;
		PresentMask[2] = presentMask2;
		PresentMask[3] = presentMask3;
		PresentMask[4] = presentMask4;
		PresentMask[5] = presentMask5;
		PresentMask[6] = presentMask6;
		PresentMask[7] = presentMask7;
		PresentMask[8] = presentMask8;
		PresentMask[9] = presentMask9;
		PresentMask[10] = presentMask10;
		PresentMask[11] = presentMask11;
		PresentMask[12] = presentMask12;
		PresentMask[13] = presentMask13;
		PresentMask[14] = presentMask14;
		PresentMask[15] = presentMask15;
		PresentMask[16] = presentMask16;
		PresentMask[17] = presentMask17;
		PresentMask[18] = presentMask18;
		PresentMask[19] = presentMask19;
		PresentMask[20] = presentMask20;
		PresentMask[21] = presentMask21;
		PresentMask[22] = presentMask22;
		PresentMask[23] = presentMask23;
		PresentMask[24] = presentMask24;
		PresentMask[25] = presentMask25;
		PresentMask[26] = presentMask26;
		PresentMask[27] = presentMask27;
		PresentMask[28] = presentMask28;
		PresentMask[29] = presentMask29;
		PresentMask[30] = presentMask30;
		PresentMask[31] = presentMask31;
		Modes = modes;
	}


	public readonly override bool Equals(object? obj) => (obj is DeviceGroupPresentCapabilities o) && (this == o);
	readonly bool IEquatable<DeviceGroupPresentCapabilities>.Equals(DeviceGroupPresentCapabilities obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ PresentMask[0].GetHashCode() ^ PresentMask[1].GetHashCode()
			^ PresentMask[2].GetHashCode() ^ PresentMask[3].GetHashCode() ^ PresentMask[4].GetHashCode() ^ PresentMask[5].GetHashCode()
			^ PresentMask[6].GetHashCode() ^ PresentMask[7].GetHashCode() ^ PresentMask[8].GetHashCode() ^ PresentMask[9].GetHashCode()
			^ PresentMask[10].GetHashCode() ^ PresentMask[11].GetHashCode() ^ PresentMask[12].GetHashCode() ^ PresentMask[13].GetHashCode()
			^ PresentMask[14].GetHashCode() ^ PresentMask[15].GetHashCode() ^ PresentMask[16].GetHashCode() ^ PresentMask[17].GetHashCode()
			^ PresentMask[18].GetHashCode() ^ PresentMask[19].GetHashCode() ^ PresentMask[20].GetHashCode() ^ PresentMask[21].GetHashCode()
			^ PresentMask[22].GetHashCode() ^ PresentMask[23].GetHashCode() ^ PresentMask[24].GetHashCode() ^ PresentMask[25].GetHashCode()
			^ PresentMask[26].GetHashCode() ^ PresentMask[27].GetHashCode() ^ PresentMask[28].GetHashCode() ^ PresentMask[29].GetHashCode()
			^ PresentMask[30].GetHashCode() ^ PresentMask[31].GetHashCode() ^ Modes.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DeviceGroupPresentCapabilities l, in DeviceGroupPresentCapabilities r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.PresentMask[0] == r.PresentMask[0]) && (l.PresentMask[1] == r.PresentMask[1])
			&& (l.PresentMask[2] == r.PresentMask[2]) && (l.PresentMask[3] == r.PresentMask[3]) && (l.PresentMask[4] == r.PresentMask[4]) && (l.PresentMask[5] == r.PresentMask[5])
			&& (l.PresentMask[6] == r.PresentMask[6]) && (l.PresentMask[7] == r.PresentMask[7]) && (l.PresentMask[8] == r.PresentMask[8]) && (l.PresentMask[9] == r.PresentMask[9])
			&& (l.PresentMask[10] == r.PresentMask[10]) && (l.PresentMask[11] == r.PresentMask[11]) && (l.PresentMask[12] == r.PresentMask[12]) && (l.PresentMask[13] == r.PresentMask[13])
			&& (l.PresentMask[14] == r.PresentMask[14]) && (l.PresentMask[15] == r.PresentMask[15]) && (l.PresentMask[16] == r.PresentMask[16]) && (l.PresentMask[17] == r.PresentMask[17])
			&& (l.PresentMask[18] == r.PresentMask[18]) && (l.PresentMask[19] == r.PresentMask[19]) && (l.PresentMask[20] == r.PresentMask[20]) && (l.PresentMask[21] == r.PresentMask[21])
			&& (l.PresentMask[22] == r.PresentMask[22]) && (l.PresentMask[23] == r.PresentMask[23]) && (l.PresentMask[24] == r.PresentMask[24]) && (l.PresentMask[25] == r.PresentMask[25])
			&& (l.PresentMask[26] == r.PresentMask[26]) && (l.PresentMask[27] == r.PresentMask[27]) && (l.PresentMask[28] == r.PresentMask[28]) && (l.PresentMask[29] == r.PresentMask[29])
			&& (l.PresentMask[30] == r.PresentMask[30]) && (l.PresentMask[31] == r.PresentMask[31]) && (l.Modes == r.Modes)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DeviceGroupPresentCapabilities l, in DeviceGroupPresentCapabilities r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.PresentMask[0] != r.PresentMask[0]) || (l.PresentMask[1] != r.PresentMask[1])
			|| (l.PresentMask[2] != r.PresentMask[2]) || (l.PresentMask[3] != r.PresentMask[3]) || (l.PresentMask[4] != r.PresentMask[4]) || (l.PresentMask[5] != r.PresentMask[5])
			|| (l.PresentMask[6] != r.PresentMask[6]) || (l.PresentMask[7] != r.PresentMask[7]) || (l.PresentMask[8] != r.PresentMask[8]) || (l.PresentMask[9] != r.PresentMask[9])
			|| (l.PresentMask[10] != r.PresentMask[10]) || (l.PresentMask[11] != r.PresentMask[11]) || (l.PresentMask[12] != r.PresentMask[12]) || (l.PresentMask[13] != r.PresentMask[13])
			|| (l.PresentMask[14] != r.PresentMask[14]) || (l.PresentMask[15] != r.PresentMask[15]) || (l.PresentMask[16] != r.PresentMask[16]) || (l.PresentMask[17] != r.PresentMask[17])
			|| (l.PresentMask[18] != r.PresentMask[18]) || (l.PresentMask[19] != r.PresentMask[19]) || (l.PresentMask[20] != r.PresentMask[20]) || (l.PresentMask[21] != r.PresentMask[21])
			|| (l.PresentMask[22] != r.PresentMask[22]) || (l.PresentMask[23] != r.PresentMask[23]) || (l.PresentMask[24] != r.PresentMask[24]) || (l.PresentMask[25] != r.PresentMask[25])
			|| (l.PresentMask[26] != r.PresentMask[26]) || (l.PresentMask[27] != r.PresentMask[27]) || (l.PresentMask[28] != r.PresentMask[28]) || (l.PresentMask[29] != r.PresentMask[29])
			|| (l.PresentMask[30] != r.PresentMask[30]) || (l.PresentMask[31] != r.PresentMask[31]) || (l.Modes != r.Modes)
			;
	}


	/// <summary>Creates a new DeviceGroupPresentCapabilities value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DeviceGroupPresentCapabilities value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ImageSwapchainCreateInfo : IEquatable<ImageSwapchainCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ImageSwapchainCreateInfoKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Handle<Vk.KHR.Swapchain> Swapchain;
	public ImageSwapchainCreateInfo(
		in Vk.Handle<Vk.KHR.Swapchain> swapchain = default
	) {
		sType = TYPE;
		pNext = null;
		Swapchain = swapchain;
	}


	public readonly override bool Equals(object? obj) => (obj is ImageSwapchainCreateInfo o) && (this == o);
	readonly bool IEquatable<ImageSwapchainCreateInfo>.Equals(ImageSwapchainCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Swapchain.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ImageSwapchainCreateInfo l, in ImageSwapchainCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Swapchain == r.Swapchain)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ImageSwapchainCreateInfo l, in ImageSwapchainCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Swapchain != r.Swapchain)
			;
	}


	/// <summary>Creates a new ImageSwapchainCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ImageSwapchainCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct BindImageMemorySwapchainInfo : IEquatable<BindImageMemorySwapchainInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.BindImageMemorySwapchainInfoKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Handle<Vk.KHR.Swapchain> Swapchain;
	public uint ImageIndex;
	public BindImageMemorySwapchainInfo(
		in Vk.Handle<Vk.KHR.Swapchain> swapchain = default,
		uint imageIndex = default
	) {
		sType = TYPE;
		pNext = null;
		Swapchain = swapchain;
		ImageIndex = imageIndex;
	}


	public readonly override bool Equals(object? obj) => (obj is BindImageMemorySwapchainInfo o) && (this == o);
	readonly bool IEquatable<BindImageMemorySwapchainInfo>.Equals(BindImageMemorySwapchainInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Swapchain.GetHashCode() ^ ImageIndex.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in BindImageMemorySwapchainInfo l, in BindImageMemorySwapchainInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Swapchain == r.Swapchain) && (l.ImageIndex == r.ImageIndex)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in BindImageMemorySwapchainInfo l, in BindImageMemorySwapchainInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Swapchain != r.Swapchain) || (l.ImageIndex != r.ImageIndex)
			;
	}


	/// <summary>Creates a new BindImageMemorySwapchainInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out BindImageMemorySwapchainInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct AcquireNextImageInfo : IEquatable<AcquireNextImageInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.AcquireNextImageInfoKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Handle<Vk.KHR.Swapchain> Swapchain;
	public ulong Timeout;
	public Vk.Handle<Vk.Semaphore> Semaphore;
	public Vk.Handle<Vk.Fence> Fence;
	public uint DeviceMask;
	public AcquireNextImageInfo(
		in Vk.Handle<Vk.KHR.Swapchain> swapchain = default,
		ulong timeout = default,
		in Vk.Handle<Vk.Semaphore> semaphore = default,
		in Vk.Handle<Vk.Fence> fence = default,
		uint deviceMask = default
	) {
		sType = TYPE;
		pNext = null;
		Swapchain = swapchain;
		Timeout = timeout;
		Semaphore = semaphore;
		Fence = fence;
		DeviceMask = deviceMask;
	}


	public readonly override bool Equals(object? obj) => (obj is AcquireNextImageInfo o) && (this == o);
	readonly bool IEquatable<AcquireNextImageInfo>.Equals(AcquireNextImageInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Swapchain.GetHashCode() ^ Timeout.GetHashCode()
			^ Semaphore.GetHashCode() ^ Fence.GetHashCode() ^ DeviceMask.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in AcquireNextImageInfo l, in AcquireNextImageInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Swapchain == r.Swapchain) && (l.Timeout == r.Timeout)
			&& (l.Semaphore == r.Semaphore) && (l.Fence == r.Fence) && (l.DeviceMask == r.DeviceMask)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in AcquireNextImageInfo l, in AcquireNextImageInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Swapchain != r.Swapchain) || (l.Timeout != r.Timeout)
			|| (l.Semaphore != r.Semaphore) || (l.Fence != r.Fence) || (l.DeviceMask != r.DeviceMask)
			;
	}


	/// <summary>Creates a new AcquireNextImageInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out AcquireNextImageInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DeviceGroupPresentInfo : IEquatable<DeviceGroupPresentInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DeviceGroupPresentInfoKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public uint SwapchainCount;
	public uint* DeviceMasks;
	public Vk.KHR.DeviceGroupPresentModeFlags Mode;
	public DeviceGroupPresentInfo(
		uint swapchainCount = default,
		uint* deviceMasks = default,
		in Vk.KHR.DeviceGroupPresentModeFlags mode = default
	) {
		sType = TYPE;
		pNext = null;
		SwapchainCount = swapchainCount;
		DeviceMasks = deviceMasks;
		Mode = mode;
	}


	public readonly override bool Equals(object? obj) => (obj is DeviceGroupPresentInfo o) && (this == o);
	readonly bool IEquatable<DeviceGroupPresentInfo>.Equals(DeviceGroupPresentInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SwapchainCount.GetHashCode() ^ ((ulong)DeviceMasks).GetHashCode()
			^ Mode.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DeviceGroupPresentInfo l, in DeviceGroupPresentInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SwapchainCount == r.SwapchainCount) && (l.DeviceMasks == r.DeviceMasks)
			&& (l.Mode == r.Mode)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DeviceGroupPresentInfo l, in DeviceGroupPresentInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SwapchainCount != r.SwapchainCount) || (l.DeviceMasks != r.DeviceMasks)
			|| (l.Mode != r.Mode)
			;
	}


	/// <summary>Creates a new DeviceGroupPresentInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DeviceGroupPresentInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DeviceGroupDeviceCreateInfo : IEquatable<DeviceGroupDeviceCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DeviceGroupDeviceCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public uint PhysicalDeviceCount;
	public Vk.Handle<Vk.PhysicalDevice>* PhysicalDevices;
	public DeviceGroupDeviceCreateInfo(
		uint physicalDeviceCount = default,
		in Vk.Handle<Vk.PhysicalDevice>* physicalDevices = default
	) {
		sType = TYPE;
		pNext = null;
		PhysicalDeviceCount = physicalDeviceCount;
		PhysicalDevices = physicalDevices;
	}


	public readonly override bool Equals(object? obj) => (obj is DeviceGroupDeviceCreateInfo o) && (this == o);
	readonly bool IEquatable<DeviceGroupDeviceCreateInfo>.Equals(DeviceGroupDeviceCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ PhysicalDeviceCount.GetHashCode() ^ ((ulong)PhysicalDevices).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DeviceGroupDeviceCreateInfo l, in DeviceGroupDeviceCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.PhysicalDeviceCount == r.PhysicalDeviceCount) && (l.PhysicalDevices == r.PhysicalDevices)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DeviceGroupDeviceCreateInfo l, in DeviceGroupDeviceCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.PhysicalDeviceCount != r.PhysicalDeviceCount) || (l.PhysicalDevices != r.PhysicalDevices)
			;
	}


	/// <summary>Creates a new DeviceGroupDeviceCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DeviceGroupDeviceCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DeviceGroupSwapchainCreateInfo : IEquatable<DeviceGroupSwapchainCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DeviceGroupSwapchainCreateInfoKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.KHR.DeviceGroupPresentModeFlags Modes;
	public DeviceGroupSwapchainCreateInfo(
		in Vk.KHR.DeviceGroupPresentModeFlags modes = default
	) {
		sType = TYPE;
		pNext = null;
		Modes = modes;
	}


	public readonly override bool Equals(object? obj) => (obj is DeviceGroupSwapchainCreateInfo o) && (this == o);
	readonly bool IEquatable<DeviceGroupSwapchainCreateInfo>.Equals(DeviceGroupSwapchainCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Modes.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DeviceGroupSwapchainCreateInfo l, in DeviceGroupSwapchainCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Modes == r.Modes)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DeviceGroupSwapchainCreateInfo l, in DeviceGroupSwapchainCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Modes != r.Modes)
			;
	}


	/// <summary>Creates a new DeviceGroupSwapchainCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DeviceGroupSwapchainCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DescriptorUpdateTemplateEntry : IEquatable<DescriptorUpdateTemplateEntry>
{
	public uint DstBinding;
	public uint DstArrayElement;
	public uint DescriptorCount;
	public Vk.DescriptorType DescriptorType;
	public ulong Offset;
	public ulong Stride;
	public DescriptorUpdateTemplateEntry(
		uint dstBinding = default,
		uint dstArrayElement = default,
		uint descriptorCount = default,
		in Vk.DescriptorType descriptorType = default,
		ulong offset = default,
		ulong stride = default
	) {
		DstBinding = dstBinding;
		DstArrayElement = dstArrayElement;
		DescriptorCount = descriptorCount;
		DescriptorType = descriptorType;
		Offset = offset;
		Stride = stride;
	}


	public readonly override bool Equals(object? obj) => (obj is DescriptorUpdateTemplateEntry o) && (this == o);
	readonly bool IEquatable<DescriptorUpdateTemplateEntry>.Equals(DescriptorUpdateTemplateEntry obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			DstBinding.GetHashCode() ^ DstArrayElement.GetHashCode() ^ DescriptorCount.GetHashCode() ^ DescriptorType.GetHashCode()
			^ Offset.GetHashCode() ^ Stride.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DescriptorUpdateTemplateEntry l, in DescriptorUpdateTemplateEntry r)
	{
		return
			(l.DstBinding == r.DstBinding) && (l.DstArrayElement == r.DstArrayElement) && (l.DescriptorCount == r.DescriptorCount) && (l.DescriptorType == r.DescriptorType)
			&& (l.Offset == r.Offset) && (l.Stride == r.Stride)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DescriptorUpdateTemplateEntry l, in DescriptorUpdateTemplateEntry r)
	{
		return
			(l.DstBinding != r.DstBinding) || (l.DstArrayElement != r.DstArrayElement) || (l.DescriptorCount != r.DescriptorCount) || (l.DescriptorType != r.DescriptorType)
			|| (l.Offset != r.Offset) || (l.Stride != r.Stride)
			;
	}


	/// <summary>Creates a new DescriptorUpdateTemplateEntry value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DescriptorUpdateTemplateEntry value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DescriptorUpdateTemplateCreateInfo : IEquatable<DescriptorUpdateTemplateCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DescriptorUpdateTemplateCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.DescriptorUpdateTemplateCreateFlags Flags;
	public uint DescriptorUpdateEntryCount;
	public Vk.DescriptorUpdateTemplateEntry* DescriptorUpdateEntries;
	public Vk.DescriptorUpdateTemplateType TemplateType;
	public Vk.Handle<Vk.DescriptorSetLayout> DescriptorSetLayout;
	public Vk.PipelineBindPoint PipelineBindPoint;
	public Vk.Handle<Vk.PipelineLayout> PipelineLayout;
	public uint Set;
	public DescriptorUpdateTemplateCreateInfo(
		in Vk.DescriptorUpdateTemplateCreateFlags flags = default,
		uint descriptorUpdateEntryCount = default,
		in Vk.DescriptorUpdateTemplateEntry* descriptorUpdateEntries = default,
		in Vk.DescriptorUpdateTemplateType templateType = default,
		in Vk.Handle<Vk.DescriptorSetLayout> descriptorSetLayout = default,
		in Vk.PipelineBindPoint pipelineBindPoint = default,
		in Vk.Handle<Vk.PipelineLayout> pipelineLayout = default,
		uint set = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		DescriptorUpdateEntryCount = descriptorUpdateEntryCount;
		DescriptorUpdateEntries = descriptorUpdateEntries;
		TemplateType = templateType;
		DescriptorSetLayout = descriptorSetLayout;
		PipelineBindPoint = pipelineBindPoint;
		PipelineLayout = pipelineLayout;
		Set = set;
	}


	public readonly override bool Equals(object? obj) => (obj is DescriptorUpdateTemplateCreateInfo o) && (this == o);
	readonly bool IEquatable<DescriptorUpdateTemplateCreateInfo>.Equals(DescriptorUpdateTemplateCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ DescriptorUpdateEntryCount.GetHashCode()
			^ ((ulong)DescriptorUpdateEntries).GetHashCode() ^ TemplateType.GetHashCode() ^ DescriptorSetLayout.GetHashCode() ^ PipelineBindPoint.GetHashCode()
			^ PipelineLayout.GetHashCode() ^ Set.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DescriptorUpdateTemplateCreateInfo l, in DescriptorUpdateTemplateCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.DescriptorUpdateEntryCount == r.DescriptorUpdateEntryCount)
			&& (l.DescriptorUpdateEntries == r.DescriptorUpdateEntries) && (l.TemplateType == r.TemplateType) && (l.DescriptorSetLayout == r.DescriptorSetLayout) && (l.PipelineBindPoint == r.PipelineBindPoint)
			&& (l.PipelineLayout == r.PipelineLayout) && (l.Set == r.Set)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DescriptorUpdateTemplateCreateInfo l, in DescriptorUpdateTemplateCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.DescriptorUpdateEntryCount != r.DescriptorUpdateEntryCount)
			|| (l.DescriptorUpdateEntries != r.DescriptorUpdateEntries) || (l.TemplateType != r.TemplateType) || (l.DescriptorSetLayout != r.DescriptorSetLayout) || (l.PipelineBindPoint != r.PipelineBindPoint)
			|| (l.PipelineLayout != r.PipelineLayout) || (l.Set != r.Set)
			;
	}


	/// <summary>Creates a new DescriptorUpdateTemplateCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DescriptorUpdateTemplateCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct InputAttachmentAspectReference : IEquatable<InputAttachmentAspectReference>
{
	public uint Subpass;
	public uint InputAttachmentIndex;
	public Vk.ImageAspectFlags AspectMask;
	public InputAttachmentAspectReference(
		uint subpass = default,
		uint inputAttachmentIndex = default,
		in Vk.ImageAspectFlags aspectMask = default
	) {
		Subpass = subpass;
		InputAttachmentIndex = inputAttachmentIndex;
		AspectMask = aspectMask;
	}


	public readonly override bool Equals(object? obj) => (obj is InputAttachmentAspectReference o) && (this == o);
	readonly bool IEquatable<InputAttachmentAspectReference>.Equals(InputAttachmentAspectReference obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Subpass.GetHashCode() ^ InputAttachmentIndex.GetHashCode() ^ AspectMask.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in InputAttachmentAspectReference l, in InputAttachmentAspectReference r)
	{
		return
			(l.Subpass == r.Subpass) && (l.InputAttachmentIndex == r.InputAttachmentIndex) && (l.AspectMask == r.AspectMask)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in InputAttachmentAspectReference l, in InputAttachmentAspectReference r)
	{
		return
			(l.Subpass != r.Subpass) || (l.InputAttachmentIndex != r.InputAttachmentIndex) || (l.AspectMask != r.AspectMask)
			;
	}


	/// <summary>Creates a new InputAttachmentAspectReference value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out InputAttachmentAspectReference value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct RenderPassInputAttachmentAspectCreateInfo : IEquatable<RenderPassInputAttachmentAspectCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.RenderPassInputAttachmentAspectCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public uint AspectReferenceCount;
	public Vk.InputAttachmentAspectReference* AspectReferences;
	public RenderPassInputAttachmentAspectCreateInfo(
		uint aspectReferenceCount = default,
		in Vk.InputAttachmentAspectReference* aspectReferences = default
	) {
		sType = TYPE;
		pNext = null;
		AspectReferenceCount = aspectReferenceCount;
		AspectReferences = aspectReferences;
	}


	public readonly override bool Equals(object? obj) => (obj is RenderPassInputAttachmentAspectCreateInfo o) && (this == o);
	readonly bool IEquatable<RenderPassInputAttachmentAspectCreateInfo>.Equals(RenderPassInputAttachmentAspectCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ AspectReferenceCount.GetHashCode() ^ ((ulong)AspectReferences).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in RenderPassInputAttachmentAspectCreateInfo l, in RenderPassInputAttachmentAspectCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.AspectReferenceCount == r.AspectReferenceCount) && (l.AspectReferences == r.AspectReferences)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in RenderPassInputAttachmentAspectCreateInfo l, in RenderPassInputAttachmentAspectCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.AspectReferenceCount != r.AspectReferenceCount) || (l.AspectReferences != r.AspectReferences)
			;
	}


	/// <summary>Creates a new RenderPassInputAttachmentAspectCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out RenderPassInputAttachmentAspectCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceSurfaceInfo2 : IEquatable<PhysicalDeviceSurfaceInfo2>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceSurfaceInfo2KHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Handle<Vk.KHR.Surface> Surface;
	public PhysicalDeviceSurfaceInfo2(
		in Vk.Handle<Vk.KHR.Surface> surface = default
	) {
		sType = TYPE;
		pNext = null;
		Surface = surface;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceSurfaceInfo2 o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceSurfaceInfo2>.Equals(PhysicalDeviceSurfaceInfo2 obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Surface.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceSurfaceInfo2 l, in PhysicalDeviceSurfaceInfo2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Surface == r.Surface)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceSurfaceInfo2 l, in PhysicalDeviceSurfaceInfo2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Surface != r.Surface)
			;
	}


	/// <summary>Creates a new PhysicalDeviceSurfaceInfo2 value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceSurfaceInfo2 value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SurfaceCapabilities2 : IEquatable<SurfaceCapabilities2>
{
	public const Vk.StructureType TYPE = Vk.StructureType.SurfaceCapabilities2KHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.KHR.SurfaceCapabilities SurfaceCapabilities;
	public SurfaceCapabilities2(
		in Vk.KHR.SurfaceCapabilities surfaceCapabilities = default
	) {
		sType = TYPE;
		pNext = null;
		SurfaceCapabilities = surfaceCapabilities;
	}


	public readonly override bool Equals(object? obj) => (obj is SurfaceCapabilities2 o) && (this == o);
	readonly bool IEquatable<SurfaceCapabilities2>.Equals(SurfaceCapabilities2 obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SurfaceCapabilities.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SurfaceCapabilities2 l, in SurfaceCapabilities2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SurfaceCapabilities == r.SurfaceCapabilities)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SurfaceCapabilities2 l, in SurfaceCapabilities2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SurfaceCapabilities != r.SurfaceCapabilities)
			;
	}


	/// <summary>Creates a new SurfaceCapabilities2 value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SurfaceCapabilities2 value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SurfaceFormat2 : IEquatable<SurfaceFormat2>
{
	public const Vk.StructureType TYPE = Vk.StructureType.SurfaceFormat2KHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.KHR.SurfaceFormat SurfaceFormat;
	public SurfaceFormat2(
		in Vk.KHR.SurfaceFormat surfaceFormat = default
	) {
		sType = TYPE;
		pNext = null;
		SurfaceFormat = surfaceFormat;
	}


	public readonly override bool Equals(object? obj) => (obj is SurfaceFormat2 o) && (this == o);
	readonly bool IEquatable<SurfaceFormat2>.Equals(SurfaceFormat2 obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SurfaceFormat.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SurfaceFormat2 l, in SurfaceFormat2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SurfaceFormat == r.SurfaceFormat)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SurfaceFormat2 l, in SurfaceFormat2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SurfaceFormat != r.SurfaceFormat)
			;
	}


	/// <summary>Creates a new SurfaceFormat2 value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SurfaceFormat2 value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DisplayProperties2 : IEquatable<DisplayProperties2>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DisplayProperties2KHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.KHR.DisplayProperties DisplayProperties;
	public DisplayProperties2(
		in Vk.KHR.DisplayProperties displayProperties = default
	) {
		sType = TYPE;
		pNext = null;
		DisplayProperties = displayProperties;
	}


	public readonly override bool Equals(object? obj) => (obj is DisplayProperties2 o) && (this == o);
	readonly bool IEquatable<DisplayProperties2>.Equals(DisplayProperties2 obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DisplayProperties.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DisplayProperties2 l, in DisplayProperties2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DisplayProperties == r.DisplayProperties)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DisplayProperties2 l, in DisplayProperties2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DisplayProperties != r.DisplayProperties)
			;
	}


	/// <summary>Creates a new DisplayProperties2 value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DisplayProperties2 value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DisplayPlaneProperties2 : IEquatable<DisplayPlaneProperties2>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DisplayPlaneProperties2KHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.KHR.DisplayPlaneProperties DisplayPlaneProperties;
	public DisplayPlaneProperties2(
		in Vk.KHR.DisplayPlaneProperties displayPlaneProperties = default
	) {
		sType = TYPE;
		pNext = null;
		DisplayPlaneProperties = displayPlaneProperties;
	}


	public readonly override bool Equals(object? obj) => (obj is DisplayPlaneProperties2 o) && (this == o);
	readonly bool IEquatable<DisplayPlaneProperties2>.Equals(DisplayPlaneProperties2 obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DisplayPlaneProperties.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DisplayPlaneProperties2 l, in DisplayPlaneProperties2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DisplayPlaneProperties == r.DisplayPlaneProperties)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DisplayPlaneProperties2 l, in DisplayPlaneProperties2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DisplayPlaneProperties != r.DisplayPlaneProperties)
			;
	}


	/// <summary>Creates a new DisplayPlaneProperties2 value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DisplayPlaneProperties2 value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DisplayModeProperties2 : IEquatable<DisplayModeProperties2>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DisplayModeProperties2KHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.KHR.DisplayModeProperties DisplayModeProperties;
	public DisplayModeProperties2(
		in Vk.KHR.DisplayModeProperties displayModeProperties = default
	) {
		sType = TYPE;
		pNext = null;
		DisplayModeProperties = displayModeProperties;
	}


	public readonly override bool Equals(object? obj) => (obj is DisplayModeProperties2 o) && (this == o);
	readonly bool IEquatable<DisplayModeProperties2>.Equals(DisplayModeProperties2 obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DisplayModeProperties.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DisplayModeProperties2 l, in DisplayModeProperties2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DisplayModeProperties == r.DisplayModeProperties)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DisplayModeProperties2 l, in DisplayModeProperties2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DisplayModeProperties != r.DisplayModeProperties)
			;
	}


	/// <summary>Creates a new DisplayModeProperties2 value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DisplayModeProperties2 value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DisplayPlaneInfo2 : IEquatable<DisplayPlaneInfo2>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DisplayPlaneInfo2KHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Handle<Vk.KHR.DisplayMode> Mode;
	public uint PlaneIndex;
	public DisplayPlaneInfo2(
		in Vk.Handle<Vk.KHR.DisplayMode> mode = default,
		uint planeIndex = default
	) {
		sType = TYPE;
		pNext = null;
		Mode = mode;
		PlaneIndex = planeIndex;
	}


	public readonly override bool Equals(object? obj) => (obj is DisplayPlaneInfo2 o) && (this == o);
	readonly bool IEquatable<DisplayPlaneInfo2>.Equals(DisplayPlaneInfo2 obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Mode.GetHashCode() ^ PlaneIndex.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DisplayPlaneInfo2 l, in DisplayPlaneInfo2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Mode == r.Mode) && (l.PlaneIndex == r.PlaneIndex)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DisplayPlaneInfo2 l, in DisplayPlaneInfo2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Mode != r.Mode) || (l.PlaneIndex != r.PlaneIndex)
			;
	}


	/// <summary>Creates a new DisplayPlaneInfo2 value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DisplayPlaneInfo2 value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DisplayPlaneCapabilities2 : IEquatable<DisplayPlaneCapabilities2>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DisplayPlaneCapabilities2KHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.KHR.DisplayPlaneCapabilities Capabilities;
	public DisplayPlaneCapabilities2(
		in Vk.KHR.DisplayPlaneCapabilities capabilities = default
	) {
		sType = TYPE;
		pNext = null;
		Capabilities = capabilities;
	}


	public readonly override bool Equals(object? obj) => (obj is DisplayPlaneCapabilities2 o) && (this == o);
	readonly bool IEquatable<DisplayPlaneCapabilities2>.Equals(DisplayPlaneCapabilities2 obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Capabilities.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DisplayPlaneCapabilities2 l, in DisplayPlaneCapabilities2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Capabilities == r.Capabilities)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DisplayPlaneCapabilities2 l, in DisplayPlaneCapabilities2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Capabilities != r.Capabilities)
			;
	}


	/// <summary>Creates a new DisplayPlaneCapabilities2 value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DisplayPlaneCapabilities2 value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SharedPresentSurfaceCapabilities : IEquatable<SharedPresentSurfaceCapabilities>
{
	public const Vk.StructureType TYPE = Vk.StructureType.SharedPresentSurfaceCapabilitiesKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.ImageUsageFlags SharedPresentSupportedUsageFlags;
	public SharedPresentSurfaceCapabilities(
		in Vk.ImageUsageFlags sharedPresentSupportedUsageFlags = default
	) {
		sType = TYPE;
		pNext = null;
		SharedPresentSupportedUsageFlags = sharedPresentSupportedUsageFlags;
	}


	public readonly override bool Equals(object? obj) => (obj is SharedPresentSurfaceCapabilities o) && (this == o);
	readonly bool IEquatable<SharedPresentSurfaceCapabilities>.Equals(SharedPresentSurfaceCapabilities obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SharedPresentSupportedUsageFlags.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SharedPresentSurfaceCapabilities l, in SharedPresentSurfaceCapabilities r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SharedPresentSupportedUsageFlags == r.SharedPresentSupportedUsageFlags)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SharedPresentSurfaceCapabilities l, in SharedPresentSurfaceCapabilities r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SharedPresentSupportedUsageFlags != r.SharedPresentSupportedUsageFlags)
			;
	}


	/// <summary>Creates a new SharedPresentSurfaceCapabilities value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SharedPresentSurfaceCapabilities value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDevice16BitStorageFeatures : IEquatable<PhysicalDevice16BitStorageFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDevice16BitStorageFeatures;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 StorageBuffer16BitAccess;
	public Vk.Bool32 UniformAndStorageBuffer16BitAccess;
	public Vk.Bool32 StoragePushConstant16;
	public Vk.Bool32 StorageInputOutput16;
	public PhysicalDevice16BitStorageFeatures(
		in Vk.Bool32 storageBuffer16BitAccess = default,
		in Vk.Bool32 uniformAndStorageBuffer16BitAccess = default,
		in Vk.Bool32 storagePushConstant16 = default,
		in Vk.Bool32 storageInputOutput16 = default
	) {
		sType = TYPE;
		pNext = null;
		StorageBuffer16BitAccess = storageBuffer16BitAccess;
		UniformAndStorageBuffer16BitAccess = uniformAndStorageBuffer16BitAccess;
		StoragePushConstant16 = storagePushConstant16;
		StorageInputOutput16 = storageInputOutput16;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDevice16BitStorageFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDevice16BitStorageFeatures>.Equals(PhysicalDevice16BitStorageFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ StorageBuffer16BitAccess.GetHashCode() ^ UniformAndStorageBuffer16BitAccess.GetHashCode()
			^ StoragePushConstant16.GetHashCode() ^ StorageInputOutput16.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDevice16BitStorageFeatures l, in PhysicalDevice16BitStorageFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.StorageBuffer16BitAccess == r.StorageBuffer16BitAccess) && (l.UniformAndStorageBuffer16BitAccess == r.UniformAndStorageBuffer16BitAccess)
			&& (l.StoragePushConstant16 == r.StoragePushConstant16) && (l.StorageInputOutput16 == r.StorageInputOutput16)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDevice16BitStorageFeatures l, in PhysicalDevice16BitStorageFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.StorageBuffer16BitAccess != r.StorageBuffer16BitAccess) || (l.UniformAndStorageBuffer16BitAccess != r.UniformAndStorageBuffer16BitAccess)
			|| (l.StoragePushConstant16 != r.StoragePushConstant16) || (l.StorageInputOutput16 != r.StorageInputOutput16)
			;
	}


	/// <summary>Creates a new PhysicalDevice16BitStorageFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDevice16BitStorageFeatures value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceShaderSubgroupExtendedTypesFeatures : IEquatable<PhysicalDeviceShaderSubgroupExtendedTypesFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceShaderSubgroupExtendedTypesFeatures;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 ShaderSubgroupExtendedTypes;
	public PhysicalDeviceShaderSubgroupExtendedTypesFeatures(
		in Vk.Bool32 shaderSubgroupExtendedTypes = default
	) {
		sType = TYPE;
		pNext = null;
		ShaderSubgroupExtendedTypes = shaderSubgroupExtendedTypes;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceShaderSubgroupExtendedTypesFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceShaderSubgroupExtendedTypesFeatures>.Equals(PhysicalDeviceShaderSubgroupExtendedTypesFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ShaderSubgroupExtendedTypes.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceShaderSubgroupExtendedTypesFeatures l, in PhysicalDeviceShaderSubgroupExtendedTypesFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ShaderSubgroupExtendedTypes == r.ShaderSubgroupExtendedTypes)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceShaderSubgroupExtendedTypesFeatures l, in PhysicalDeviceShaderSubgroupExtendedTypesFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ShaderSubgroupExtendedTypes != r.ShaderSubgroupExtendedTypes)
			;
	}


	/// <summary>Creates a new PhysicalDeviceShaderSubgroupExtendedTypesFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceShaderSubgroupExtendedTypesFeatures value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct BufferMemoryRequirementsInfo2 : IEquatable<BufferMemoryRequirementsInfo2>
{
	public const Vk.StructureType TYPE = Vk.StructureType.BufferMemoryRequirementsInfo2;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Handle<Vk.Buffer> Buffer;
	public BufferMemoryRequirementsInfo2(
		in Vk.Handle<Vk.Buffer> buffer = default
	) {
		sType = TYPE;
		pNext = null;
		Buffer = buffer;
	}


	public readonly override bool Equals(object? obj) => (obj is BufferMemoryRequirementsInfo2 o) && (this == o);
	readonly bool IEquatable<BufferMemoryRequirementsInfo2>.Equals(BufferMemoryRequirementsInfo2 obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Buffer.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in BufferMemoryRequirementsInfo2 l, in BufferMemoryRequirementsInfo2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Buffer == r.Buffer)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in BufferMemoryRequirementsInfo2 l, in BufferMemoryRequirementsInfo2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Buffer != r.Buffer)
			;
	}


	/// <summary>Creates a new BufferMemoryRequirementsInfo2 value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out BufferMemoryRequirementsInfo2 value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ImageMemoryRequirementsInfo2 : IEquatable<ImageMemoryRequirementsInfo2>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ImageMemoryRequirementsInfo2;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Handle<Vk.Image> Image;
	public ImageMemoryRequirementsInfo2(
		in Vk.Handle<Vk.Image> image = default
	) {
		sType = TYPE;
		pNext = null;
		Image = image;
	}


	public readonly override bool Equals(object? obj) => (obj is ImageMemoryRequirementsInfo2 o) && (this == o);
	readonly bool IEquatable<ImageMemoryRequirementsInfo2>.Equals(ImageMemoryRequirementsInfo2 obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Image.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ImageMemoryRequirementsInfo2 l, in ImageMemoryRequirementsInfo2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Image == r.Image)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ImageMemoryRequirementsInfo2 l, in ImageMemoryRequirementsInfo2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Image != r.Image)
			;
	}


	/// <summary>Creates a new ImageMemoryRequirementsInfo2 value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ImageMemoryRequirementsInfo2 value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ImageSparseMemoryRequirementsInfo2 : IEquatable<ImageSparseMemoryRequirementsInfo2>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ImageSparseMemoryRequirementsInfo2;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Handle<Vk.Image> Image;
	public ImageSparseMemoryRequirementsInfo2(
		in Vk.Handle<Vk.Image> image = default
	) {
		sType = TYPE;
		pNext = null;
		Image = image;
	}


	public readonly override bool Equals(object? obj) => (obj is ImageSparseMemoryRequirementsInfo2 o) && (this == o);
	readonly bool IEquatable<ImageSparseMemoryRequirementsInfo2>.Equals(ImageSparseMemoryRequirementsInfo2 obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Image.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ImageSparseMemoryRequirementsInfo2 l, in ImageSparseMemoryRequirementsInfo2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Image == r.Image)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ImageSparseMemoryRequirementsInfo2 l, in ImageSparseMemoryRequirementsInfo2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Image != r.Image)
			;
	}


	/// <summary>Creates a new ImageSparseMemoryRequirementsInfo2 value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ImageSparseMemoryRequirementsInfo2 value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct MemoryRequirements2 : IEquatable<MemoryRequirements2>
{
	public const Vk.StructureType TYPE = Vk.StructureType.MemoryRequirements2;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.MemoryRequirements MemoryRequirements;
	public MemoryRequirements2(
		in Vk.MemoryRequirements memoryRequirements = default
	) {
		sType = TYPE;
		pNext = null;
		MemoryRequirements = memoryRequirements;
	}


	public readonly override bool Equals(object? obj) => (obj is MemoryRequirements2 o) && (this == o);
	readonly bool IEquatable<MemoryRequirements2>.Equals(MemoryRequirements2 obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MemoryRequirements.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in MemoryRequirements2 l, in MemoryRequirements2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MemoryRequirements == r.MemoryRequirements)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in MemoryRequirements2 l, in MemoryRequirements2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MemoryRequirements != r.MemoryRequirements)
			;
	}


	/// <summary>Creates a new MemoryRequirements2 value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out MemoryRequirements2 value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SparseImageMemoryRequirements2 : IEquatable<SparseImageMemoryRequirements2>
{
	public const Vk.StructureType TYPE = Vk.StructureType.SparseImageMemoryRequirements2;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.SparseImageMemoryRequirements MemoryRequirements;
	public SparseImageMemoryRequirements2(
		in Vk.SparseImageMemoryRequirements memoryRequirements = default
	) {
		sType = TYPE;
		pNext = null;
		MemoryRequirements = memoryRequirements;
	}


	public readonly override bool Equals(object? obj) => (obj is SparseImageMemoryRequirements2 o) && (this == o);
	readonly bool IEquatable<SparseImageMemoryRequirements2>.Equals(SparseImageMemoryRequirements2 obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MemoryRequirements.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SparseImageMemoryRequirements2 l, in SparseImageMemoryRequirements2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MemoryRequirements == r.MemoryRequirements)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SparseImageMemoryRequirements2 l, in SparseImageMemoryRequirements2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MemoryRequirements != r.MemoryRequirements)
			;
	}


	/// <summary>Creates a new SparseImageMemoryRequirements2 value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SparseImageMemoryRequirements2 value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDevicePointClippingProperties : IEquatable<PhysicalDevicePointClippingProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDevicePointClippingProperties;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.PointClippingBehavior PointClippingBehavior;
	public PhysicalDevicePointClippingProperties(
		in Vk.PointClippingBehavior pointClippingBehavior = default
	) {
		sType = TYPE;
		pNext = null;
		PointClippingBehavior = pointClippingBehavior;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDevicePointClippingProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDevicePointClippingProperties>.Equals(PhysicalDevicePointClippingProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ PointClippingBehavior.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDevicePointClippingProperties l, in PhysicalDevicePointClippingProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.PointClippingBehavior == r.PointClippingBehavior)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDevicePointClippingProperties l, in PhysicalDevicePointClippingProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.PointClippingBehavior != r.PointClippingBehavior)
			;
	}


	/// <summary>Creates a new PhysicalDevicePointClippingProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDevicePointClippingProperties value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct MemoryDedicatedRequirements : IEquatable<MemoryDedicatedRequirements>
{
	public const Vk.StructureType TYPE = Vk.StructureType.MemoryDedicatedRequirements;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 PrefersDedicatedAllocation;
	public Vk.Bool32 RequiresDedicatedAllocation;
	public MemoryDedicatedRequirements(
		in Vk.Bool32 prefersDedicatedAllocation = default,
		in Vk.Bool32 requiresDedicatedAllocation = default
	) {
		sType = TYPE;
		pNext = null;
		PrefersDedicatedAllocation = prefersDedicatedAllocation;
		RequiresDedicatedAllocation = requiresDedicatedAllocation;
	}


	public readonly override bool Equals(object? obj) => (obj is MemoryDedicatedRequirements o) && (this == o);
	readonly bool IEquatable<MemoryDedicatedRequirements>.Equals(MemoryDedicatedRequirements obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ PrefersDedicatedAllocation.GetHashCode() ^ RequiresDedicatedAllocation.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in MemoryDedicatedRequirements l, in MemoryDedicatedRequirements r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.PrefersDedicatedAllocation == r.PrefersDedicatedAllocation) && (l.RequiresDedicatedAllocation == r.RequiresDedicatedAllocation)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in MemoryDedicatedRequirements l, in MemoryDedicatedRequirements r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.PrefersDedicatedAllocation != r.PrefersDedicatedAllocation) || (l.RequiresDedicatedAllocation != r.RequiresDedicatedAllocation)
			;
	}


	/// <summary>Creates a new MemoryDedicatedRequirements value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out MemoryDedicatedRequirements value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct MemoryDedicatedAllocateInfo : IEquatable<MemoryDedicatedAllocateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.MemoryDedicatedAllocateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Handle<Vk.Image> Image;
	public Vk.Handle<Vk.Buffer> Buffer;
	public MemoryDedicatedAllocateInfo(
		in Vk.Handle<Vk.Image> image = default,
		in Vk.Handle<Vk.Buffer> buffer = default
	) {
		sType = TYPE;
		pNext = null;
		Image = image;
		Buffer = buffer;
	}


	public readonly override bool Equals(object? obj) => (obj is MemoryDedicatedAllocateInfo o) && (this == o);
	readonly bool IEquatable<MemoryDedicatedAllocateInfo>.Equals(MemoryDedicatedAllocateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Image.GetHashCode() ^ Buffer.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in MemoryDedicatedAllocateInfo l, in MemoryDedicatedAllocateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Image == r.Image) && (l.Buffer == r.Buffer)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in MemoryDedicatedAllocateInfo l, in MemoryDedicatedAllocateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Image != r.Image) || (l.Buffer != r.Buffer)
			;
	}


	/// <summary>Creates a new MemoryDedicatedAllocateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out MemoryDedicatedAllocateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ImageViewUsageCreateInfo : IEquatable<ImageViewUsageCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ImageViewUsageCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.ImageUsageFlags Usage;
	public ImageViewUsageCreateInfo(
		in Vk.ImageUsageFlags usage = default
	) {
		sType = TYPE;
		pNext = null;
		Usage = usage;
	}


	public readonly override bool Equals(object? obj) => (obj is ImageViewUsageCreateInfo o) && (this == o);
	readonly bool IEquatable<ImageViewUsageCreateInfo>.Equals(ImageViewUsageCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Usage.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ImageViewUsageCreateInfo l, in ImageViewUsageCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Usage == r.Usage)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ImageViewUsageCreateInfo l, in ImageViewUsageCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Usage != r.Usage)
			;
	}


	/// <summary>Creates a new ImageViewUsageCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ImageViewUsageCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PipelineTessellationDomainOriginStateCreateInfo : IEquatable<PipelineTessellationDomainOriginStateCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PipelineTessellationDomainOriginStateCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.TessellationDomainOrigin DomainOrigin;
	public PipelineTessellationDomainOriginStateCreateInfo(
		in Vk.TessellationDomainOrigin domainOrigin = default
	) {
		sType = TYPE;
		pNext = null;
		DomainOrigin = domainOrigin;
	}


	public readonly override bool Equals(object? obj) => (obj is PipelineTessellationDomainOriginStateCreateInfo o) && (this == o);
	readonly bool IEquatable<PipelineTessellationDomainOriginStateCreateInfo>.Equals(PipelineTessellationDomainOriginStateCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DomainOrigin.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PipelineTessellationDomainOriginStateCreateInfo l, in PipelineTessellationDomainOriginStateCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DomainOrigin == r.DomainOrigin)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PipelineTessellationDomainOriginStateCreateInfo l, in PipelineTessellationDomainOriginStateCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DomainOrigin != r.DomainOrigin)
			;
	}


	/// <summary>Creates a new PipelineTessellationDomainOriginStateCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PipelineTessellationDomainOriginStateCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SamplerYcbcrConversionInfo : IEquatable<SamplerYcbcrConversionInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.SamplerYcbcrConversionInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Handle<Vk.SamplerYcbcrConversion> Conversion;
	public SamplerYcbcrConversionInfo(
		in Vk.Handle<Vk.SamplerYcbcrConversion> conversion = default
	) {
		sType = TYPE;
		pNext = null;
		Conversion = conversion;
	}


	public readonly override bool Equals(object? obj) => (obj is SamplerYcbcrConversionInfo o) && (this == o);
	readonly bool IEquatable<SamplerYcbcrConversionInfo>.Equals(SamplerYcbcrConversionInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Conversion.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SamplerYcbcrConversionInfo l, in SamplerYcbcrConversionInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Conversion == r.Conversion)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SamplerYcbcrConversionInfo l, in SamplerYcbcrConversionInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Conversion != r.Conversion)
			;
	}


	/// <summary>Creates a new SamplerYcbcrConversionInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SamplerYcbcrConversionInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SamplerYcbcrConversionCreateInfo : IEquatable<SamplerYcbcrConversionCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.SamplerYcbcrConversionCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Format Format;
	public Vk.SamplerYcbcrModelConversion YcbcrModel;
	public Vk.SamplerYcbcrRange YcbcrRange;
	public Vk.ComponentMapping Components;
	public Vk.ChromaLocation XChromaOffset;
	public Vk.ChromaLocation YChromaOffset;
	public Vk.Filter ChromaFilter;
	public Vk.Bool32 ForceExplicitReconstruction;
	public SamplerYcbcrConversionCreateInfo(
		in Vk.Format format = default,
		in Vk.SamplerYcbcrModelConversion ycbcrModel = default,
		in Vk.SamplerYcbcrRange ycbcrRange = default,
		in Vk.ComponentMapping components = default,
		in Vk.ChromaLocation xChromaOffset = default,
		in Vk.ChromaLocation yChromaOffset = default,
		in Vk.Filter chromaFilter = default,
		in Vk.Bool32 forceExplicitReconstruction = default
	) {
		sType = TYPE;
		pNext = null;
		Format = format;
		YcbcrModel = ycbcrModel;
		YcbcrRange = ycbcrRange;
		Components = components;
		XChromaOffset = xChromaOffset;
		YChromaOffset = yChromaOffset;
		ChromaFilter = chromaFilter;
		ForceExplicitReconstruction = forceExplicitReconstruction;
	}


	public readonly override bool Equals(object? obj) => (obj is SamplerYcbcrConversionCreateInfo o) && (this == o);
	readonly bool IEquatable<SamplerYcbcrConversionCreateInfo>.Equals(SamplerYcbcrConversionCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Format.GetHashCode() ^ YcbcrModel.GetHashCode()
			^ YcbcrRange.GetHashCode() ^ Components.GetHashCode() ^ XChromaOffset.GetHashCode() ^ YChromaOffset.GetHashCode()
			^ ChromaFilter.GetHashCode() ^ ForceExplicitReconstruction.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SamplerYcbcrConversionCreateInfo l, in SamplerYcbcrConversionCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Format == r.Format) && (l.YcbcrModel == r.YcbcrModel)
			&& (l.YcbcrRange == r.YcbcrRange) && (l.Components == r.Components) && (l.XChromaOffset == r.XChromaOffset) && (l.YChromaOffset == r.YChromaOffset)
			&& (l.ChromaFilter == r.ChromaFilter) && (l.ForceExplicitReconstruction == r.ForceExplicitReconstruction)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SamplerYcbcrConversionCreateInfo l, in SamplerYcbcrConversionCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Format != r.Format) || (l.YcbcrModel != r.YcbcrModel)
			|| (l.YcbcrRange != r.YcbcrRange) || (l.Components != r.Components) || (l.XChromaOffset != r.XChromaOffset) || (l.YChromaOffset != r.YChromaOffset)
			|| (l.ChromaFilter != r.ChromaFilter) || (l.ForceExplicitReconstruction != r.ForceExplicitReconstruction)
			;
	}


	/// <summary>Creates a new SamplerYcbcrConversionCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SamplerYcbcrConversionCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct BindImagePlaneMemoryInfo : IEquatable<BindImagePlaneMemoryInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.BindImagePlaneMemoryInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.ImageAspectFlags PlaneAspect;
	public BindImagePlaneMemoryInfo(
		in Vk.ImageAspectFlags planeAspect = default
	) {
		sType = TYPE;
		pNext = null;
		PlaneAspect = planeAspect;
	}


	public readonly override bool Equals(object? obj) => (obj is BindImagePlaneMemoryInfo o) && (this == o);
	readonly bool IEquatable<BindImagePlaneMemoryInfo>.Equals(BindImagePlaneMemoryInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ PlaneAspect.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in BindImagePlaneMemoryInfo l, in BindImagePlaneMemoryInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.PlaneAspect == r.PlaneAspect)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in BindImagePlaneMemoryInfo l, in BindImagePlaneMemoryInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.PlaneAspect != r.PlaneAspect)
			;
	}


	/// <summary>Creates a new BindImagePlaneMemoryInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out BindImagePlaneMemoryInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ImagePlaneMemoryRequirementsInfo : IEquatable<ImagePlaneMemoryRequirementsInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ImagePlaneMemoryRequirementsInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.ImageAspectFlags PlaneAspect;
	public ImagePlaneMemoryRequirementsInfo(
		in Vk.ImageAspectFlags planeAspect = default
	) {
		sType = TYPE;
		pNext = null;
		PlaneAspect = planeAspect;
	}


	public readonly override bool Equals(object? obj) => (obj is ImagePlaneMemoryRequirementsInfo o) && (this == o);
	readonly bool IEquatable<ImagePlaneMemoryRequirementsInfo>.Equals(ImagePlaneMemoryRequirementsInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ PlaneAspect.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ImagePlaneMemoryRequirementsInfo l, in ImagePlaneMemoryRequirementsInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.PlaneAspect == r.PlaneAspect)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ImagePlaneMemoryRequirementsInfo l, in ImagePlaneMemoryRequirementsInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.PlaneAspect != r.PlaneAspect)
			;
	}


	/// <summary>Creates a new ImagePlaneMemoryRequirementsInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ImagePlaneMemoryRequirementsInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceSamplerYcbcrConversionFeatures : IEquatable<PhysicalDeviceSamplerYcbcrConversionFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceSamplerYcbcrConversionFeatures;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 SamplerYcbcrConversion;
	public PhysicalDeviceSamplerYcbcrConversionFeatures(
		in Vk.Bool32 samplerYcbcrConversion = default
	) {
		sType = TYPE;
		pNext = null;
		SamplerYcbcrConversion = samplerYcbcrConversion;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceSamplerYcbcrConversionFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceSamplerYcbcrConversionFeatures>.Equals(PhysicalDeviceSamplerYcbcrConversionFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SamplerYcbcrConversion.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceSamplerYcbcrConversionFeatures l, in PhysicalDeviceSamplerYcbcrConversionFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SamplerYcbcrConversion == r.SamplerYcbcrConversion)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceSamplerYcbcrConversionFeatures l, in PhysicalDeviceSamplerYcbcrConversionFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SamplerYcbcrConversion != r.SamplerYcbcrConversion)
			;
	}


	/// <summary>Creates a new PhysicalDeviceSamplerYcbcrConversionFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceSamplerYcbcrConversionFeatures value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SamplerYcbcrConversionImageFormatProperties : IEquatable<SamplerYcbcrConversionImageFormatProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.SamplerYcbcrConversionImageFormatProperties;

	public Vk.StructureType sType;
	public void* pNext;
	public uint CombinedImageSamplerDescriptorCount;
	public SamplerYcbcrConversionImageFormatProperties(
		uint combinedImageSamplerDescriptorCount = default
	) {
		sType = TYPE;
		pNext = null;
		CombinedImageSamplerDescriptorCount = combinedImageSamplerDescriptorCount;
	}


	public readonly override bool Equals(object? obj) => (obj is SamplerYcbcrConversionImageFormatProperties o) && (this == o);
	readonly bool IEquatable<SamplerYcbcrConversionImageFormatProperties>.Equals(SamplerYcbcrConversionImageFormatProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ CombinedImageSamplerDescriptorCount.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SamplerYcbcrConversionImageFormatProperties l, in SamplerYcbcrConversionImageFormatProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.CombinedImageSamplerDescriptorCount == r.CombinedImageSamplerDescriptorCount)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SamplerYcbcrConversionImageFormatProperties l, in SamplerYcbcrConversionImageFormatProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.CombinedImageSamplerDescriptorCount != r.CombinedImageSamplerDescriptorCount)
			;
	}


	/// <summary>Creates a new SamplerYcbcrConversionImageFormatProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SamplerYcbcrConversionImageFormatProperties value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ImageFormatListCreateInfo : IEquatable<ImageFormatListCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ImageFormatListCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public uint ViewFormatCount;
	public Vk.Format* ViewFormats;
	public ImageFormatListCreateInfo(
		uint viewFormatCount = default,
		in Vk.Format* viewFormats = default
	) {
		sType = TYPE;
		pNext = null;
		ViewFormatCount = viewFormatCount;
		ViewFormats = viewFormats;
	}


	public readonly override bool Equals(object? obj) => (obj is ImageFormatListCreateInfo o) && (this == o);
	readonly bool IEquatable<ImageFormatListCreateInfo>.Equals(ImageFormatListCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ViewFormatCount.GetHashCode() ^ ((ulong)ViewFormats).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ImageFormatListCreateInfo l, in ImageFormatListCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ViewFormatCount == r.ViewFormatCount) && (l.ViewFormats == r.ViewFormats)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ImageFormatListCreateInfo l, in ImageFormatListCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ViewFormatCount != r.ViewFormatCount) || (l.ViewFormats != r.ViewFormats)
			;
	}


	/// <summary>Creates a new ImageFormatListCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ImageFormatListCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceMaintenance3Properties : IEquatable<PhysicalDeviceMaintenance3Properties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceMaintenance3Properties;

	public Vk.StructureType sType;
	public void* pNext;
	public uint MaxPerSetDescriptors;
	public Vk.DeviceSize MaxMemoryAllocationSize;
	public PhysicalDeviceMaintenance3Properties(
		uint maxPerSetDescriptors = default,
		in Vk.DeviceSize maxMemoryAllocationSize = default
	) {
		sType = TYPE;
		pNext = null;
		MaxPerSetDescriptors = maxPerSetDescriptors;
		MaxMemoryAllocationSize = maxMemoryAllocationSize;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceMaintenance3Properties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceMaintenance3Properties>.Equals(PhysicalDeviceMaintenance3Properties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MaxPerSetDescriptors.GetHashCode() ^ MaxMemoryAllocationSize.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceMaintenance3Properties l, in PhysicalDeviceMaintenance3Properties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MaxPerSetDescriptors == r.MaxPerSetDescriptors) && (l.MaxMemoryAllocationSize == r.MaxMemoryAllocationSize)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceMaintenance3Properties l, in PhysicalDeviceMaintenance3Properties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MaxPerSetDescriptors != r.MaxPerSetDescriptors) || (l.MaxMemoryAllocationSize != r.MaxMemoryAllocationSize)
			;
	}


	/// <summary>Creates a new PhysicalDeviceMaintenance3Properties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceMaintenance3Properties value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DescriptorSetLayoutSupport : IEquatable<DescriptorSetLayoutSupport>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DescriptorSetLayoutSupport;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 Supported;
	public DescriptorSetLayoutSupport(
		in Vk.Bool32 supported = default
	) {
		sType = TYPE;
		pNext = null;
		Supported = supported;
	}


	public readonly override bool Equals(object? obj) => (obj is DescriptorSetLayoutSupport o) && (this == o);
	readonly bool IEquatable<DescriptorSetLayoutSupport>.Equals(DescriptorSetLayoutSupport obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Supported.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DescriptorSetLayoutSupport l, in DescriptorSetLayoutSupport r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Supported == r.Supported)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DescriptorSetLayoutSupport l, in DescriptorSetLayoutSupport r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Supported != r.Supported)
			;
	}


	/// <summary>Creates a new DescriptorSetLayoutSupport value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DescriptorSetLayoutSupport value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceShaderFloat16Int8Features : IEquatable<PhysicalDeviceShaderFloat16Int8Features>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceShaderFloat16Int8Features;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 ShaderFloat16;
	public Vk.Bool32 ShaderInt8;
	public PhysicalDeviceShaderFloat16Int8Features(
		in Vk.Bool32 shaderFloat16 = default,
		in Vk.Bool32 shaderInt8 = default
	) {
		sType = TYPE;
		pNext = null;
		ShaderFloat16 = shaderFloat16;
		ShaderInt8 = shaderInt8;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceShaderFloat16Int8Features o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceShaderFloat16Int8Features>.Equals(PhysicalDeviceShaderFloat16Int8Features obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ShaderFloat16.GetHashCode() ^ ShaderInt8.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceShaderFloat16Int8Features l, in PhysicalDeviceShaderFloat16Int8Features r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ShaderFloat16 == r.ShaderFloat16) && (l.ShaderInt8 == r.ShaderInt8)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceShaderFloat16Int8Features l, in PhysicalDeviceShaderFloat16Int8Features r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ShaderFloat16 != r.ShaderFloat16) || (l.ShaderInt8 != r.ShaderInt8)
			;
	}


	/// <summary>Creates a new PhysicalDeviceShaderFloat16Int8Features value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceShaderFloat16Int8Features value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceFloat16Int8Features : IEquatable<PhysicalDeviceFloat16Int8Features>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceShaderFloat16Int8Features;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 ShaderFloat16;
	public Vk.Bool32 ShaderInt8;
	public PhysicalDeviceFloat16Int8Features(
		in Vk.Bool32 shaderFloat16 = default,
		in Vk.Bool32 shaderInt8 = default
	) {
		sType = TYPE;
		pNext = null;
		ShaderFloat16 = shaderFloat16;
		ShaderInt8 = shaderInt8;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceFloat16Int8Features o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceFloat16Int8Features>.Equals(PhysicalDeviceFloat16Int8Features obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ShaderFloat16.GetHashCode() ^ ShaderInt8.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceFloat16Int8Features l, in PhysicalDeviceFloat16Int8Features r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ShaderFloat16 == r.ShaderFloat16) && (l.ShaderInt8 == r.ShaderInt8)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceFloat16Int8Features l, in PhysicalDeviceFloat16Int8Features r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ShaderFloat16 != r.ShaderFloat16) || (l.ShaderInt8 != r.ShaderInt8)
			;
	}


	/// <summary>Creates a new PhysicalDeviceFloat16Int8Features value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceFloat16Int8Features value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceFloatControlsProperties : IEquatable<PhysicalDeviceFloatControlsProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceFloatControlsProperties;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.ShaderFloatControlsIndependence DenormBehaviorIndependence;
	public Vk.ShaderFloatControlsIndependence RoundingModeIndependence;
	public Vk.Bool32 ShaderSignedZeroInfNanPreserveFloat16;
	public Vk.Bool32 ShaderSignedZeroInfNanPreserveFloat32;
	public Vk.Bool32 ShaderSignedZeroInfNanPreserveFloat64;
	public Vk.Bool32 ShaderDenormPreserveFloat16;
	public Vk.Bool32 ShaderDenormPreserveFloat32;
	public Vk.Bool32 ShaderDenormPreserveFloat64;
	public Vk.Bool32 ShaderDenormFlushToZeroFloat16;
	public Vk.Bool32 ShaderDenormFlushToZeroFloat32;
	public Vk.Bool32 ShaderDenormFlushToZeroFloat64;
	public Vk.Bool32 ShaderRoundingModeRTEFloat16;
	public Vk.Bool32 ShaderRoundingModeRTEFloat32;
	public Vk.Bool32 ShaderRoundingModeRTEFloat64;
	public Vk.Bool32 ShaderRoundingModeRTZFloat16;
	public Vk.Bool32 ShaderRoundingModeRTZFloat32;
	public Vk.Bool32 ShaderRoundingModeRTZFloat64;
	public PhysicalDeviceFloatControlsProperties(
		in Vk.ShaderFloatControlsIndependence denormBehaviorIndependence = default,
		in Vk.ShaderFloatControlsIndependence roundingModeIndependence = default,
		in Vk.Bool32 shaderSignedZeroInfNanPreserveFloat16 = default,
		in Vk.Bool32 shaderSignedZeroInfNanPreserveFloat32 = default,
		in Vk.Bool32 shaderSignedZeroInfNanPreserveFloat64 = default,
		in Vk.Bool32 shaderDenormPreserveFloat16 = default,
		in Vk.Bool32 shaderDenormPreserveFloat32 = default,
		in Vk.Bool32 shaderDenormPreserveFloat64 = default,
		in Vk.Bool32 shaderDenormFlushToZeroFloat16 = default,
		in Vk.Bool32 shaderDenormFlushToZeroFloat32 = default,
		in Vk.Bool32 shaderDenormFlushToZeroFloat64 = default,
		in Vk.Bool32 shaderRoundingModeRTEFloat16 = default,
		in Vk.Bool32 shaderRoundingModeRTEFloat32 = default,
		in Vk.Bool32 shaderRoundingModeRTEFloat64 = default,
		in Vk.Bool32 shaderRoundingModeRTZFloat16 = default,
		in Vk.Bool32 shaderRoundingModeRTZFloat32 = default,
		in Vk.Bool32 shaderRoundingModeRTZFloat64 = default
	) {
		sType = TYPE;
		pNext = null;
		DenormBehaviorIndependence = denormBehaviorIndependence;
		RoundingModeIndependence = roundingModeIndependence;
		ShaderSignedZeroInfNanPreserveFloat16 = shaderSignedZeroInfNanPreserveFloat16;
		ShaderSignedZeroInfNanPreserveFloat32 = shaderSignedZeroInfNanPreserveFloat32;
		ShaderSignedZeroInfNanPreserveFloat64 = shaderSignedZeroInfNanPreserveFloat64;
		ShaderDenormPreserveFloat16 = shaderDenormPreserveFloat16;
		ShaderDenormPreserveFloat32 = shaderDenormPreserveFloat32;
		ShaderDenormPreserveFloat64 = shaderDenormPreserveFloat64;
		ShaderDenormFlushToZeroFloat16 = shaderDenormFlushToZeroFloat16;
		ShaderDenormFlushToZeroFloat32 = shaderDenormFlushToZeroFloat32;
		ShaderDenormFlushToZeroFloat64 = shaderDenormFlushToZeroFloat64;
		ShaderRoundingModeRTEFloat16 = shaderRoundingModeRTEFloat16;
		ShaderRoundingModeRTEFloat32 = shaderRoundingModeRTEFloat32;
		ShaderRoundingModeRTEFloat64 = shaderRoundingModeRTEFloat64;
		ShaderRoundingModeRTZFloat16 = shaderRoundingModeRTZFloat16;
		ShaderRoundingModeRTZFloat32 = shaderRoundingModeRTZFloat32;
		ShaderRoundingModeRTZFloat64 = shaderRoundingModeRTZFloat64;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceFloatControlsProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceFloatControlsProperties>.Equals(PhysicalDeviceFloatControlsProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DenormBehaviorIndependence.GetHashCode() ^ RoundingModeIndependence.GetHashCode()
			^ ShaderSignedZeroInfNanPreserveFloat16.GetHashCode() ^ ShaderSignedZeroInfNanPreserveFloat32.GetHashCode() ^ ShaderSignedZeroInfNanPreserveFloat64.GetHashCode() ^ ShaderDenormPreserveFloat16.GetHashCode()
			^ ShaderDenormPreserveFloat32.GetHashCode() ^ ShaderDenormPreserveFloat64.GetHashCode() ^ ShaderDenormFlushToZeroFloat16.GetHashCode() ^ ShaderDenormFlushToZeroFloat32.GetHashCode()
			^ ShaderDenormFlushToZeroFloat64.GetHashCode() ^ ShaderRoundingModeRTEFloat16.GetHashCode() ^ ShaderRoundingModeRTEFloat32.GetHashCode() ^ ShaderRoundingModeRTEFloat64.GetHashCode()
			^ ShaderRoundingModeRTZFloat16.GetHashCode() ^ ShaderRoundingModeRTZFloat32.GetHashCode() ^ ShaderRoundingModeRTZFloat64.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceFloatControlsProperties l, in PhysicalDeviceFloatControlsProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DenormBehaviorIndependence == r.DenormBehaviorIndependence) && (l.RoundingModeIndependence == r.RoundingModeIndependence)
			&& (l.ShaderSignedZeroInfNanPreserveFloat16 == r.ShaderSignedZeroInfNanPreserveFloat16) && (l.ShaderSignedZeroInfNanPreserveFloat32 == r.ShaderSignedZeroInfNanPreserveFloat32) && (l.ShaderSignedZeroInfNanPreserveFloat64 == r.ShaderSignedZeroInfNanPreserveFloat64) && (l.ShaderDenormPreserveFloat16 == r.ShaderDenormPreserveFloat16)
			&& (l.ShaderDenormPreserveFloat32 == r.ShaderDenormPreserveFloat32) && (l.ShaderDenormPreserveFloat64 == r.ShaderDenormPreserveFloat64) && (l.ShaderDenormFlushToZeroFloat16 == r.ShaderDenormFlushToZeroFloat16) && (l.ShaderDenormFlushToZeroFloat32 == r.ShaderDenormFlushToZeroFloat32)
			&& (l.ShaderDenormFlushToZeroFloat64 == r.ShaderDenormFlushToZeroFloat64) && (l.ShaderRoundingModeRTEFloat16 == r.ShaderRoundingModeRTEFloat16) && (l.ShaderRoundingModeRTEFloat32 == r.ShaderRoundingModeRTEFloat32) && (l.ShaderRoundingModeRTEFloat64 == r.ShaderRoundingModeRTEFloat64)
			&& (l.ShaderRoundingModeRTZFloat16 == r.ShaderRoundingModeRTZFloat16) && (l.ShaderRoundingModeRTZFloat32 == r.ShaderRoundingModeRTZFloat32) && (l.ShaderRoundingModeRTZFloat64 == r.ShaderRoundingModeRTZFloat64)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceFloatControlsProperties l, in PhysicalDeviceFloatControlsProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DenormBehaviorIndependence != r.DenormBehaviorIndependence) || (l.RoundingModeIndependence != r.RoundingModeIndependence)
			|| (l.ShaderSignedZeroInfNanPreserveFloat16 != r.ShaderSignedZeroInfNanPreserveFloat16) || (l.ShaderSignedZeroInfNanPreserveFloat32 != r.ShaderSignedZeroInfNanPreserveFloat32) || (l.ShaderSignedZeroInfNanPreserveFloat64 != r.ShaderSignedZeroInfNanPreserveFloat64) || (l.ShaderDenormPreserveFloat16 != r.ShaderDenormPreserveFloat16)
			|| (l.ShaderDenormPreserveFloat32 != r.ShaderDenormPreserveFloat32) || (l.ShaderDenormPreserveFloat64 != r.ShaderDenormPreserveFloat64) || (l.ShaderDenormFlushToZeroFloat16 != r.ShaderDenormFlushToZeroFloat16) || (l.ShaderDenormFlushToZeroFloat32 != r.ShaderDenormFlushToZeroFloat32)
			|| (l.ShaderDenormFlushToZeroFloat64 != r.ShaderDenormFlushToZeroFloat64) || (l.ShaderRoundingModeRTEFloat16 != r.ShaderRoundingModeRTEFloat16) || (l.ShaderRoundingModeRTEFloat32 != r.ShaderRoundingModeRTEFloat32) || (l.ShaderRoundingModeRTEFloat64 != r.ShaderRoundingModeRTEFloat64)
			|| (l.ShaderRoundingModeRTZFloat16 != r.ShaderRoundingModeRTZFloat16) || (l.ShaderRoundingModeRTZFloat32 != r.ShaderRoundingModeRTZFloat32) || (l.ShaderRoundingModeRTZFloat64 != r.ShaderRoundingModeRTZFloat64)
			;
	}


	/// <summary>Creates a new PhysicalDeviceFloatControlsProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceFloatControlsProperties value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct AttachmentDescription2 : IEquatable<AttachmentDescription2>
{
	public const Vk.StructureType TYPE = Vk.StructureType.AttachmentDescription2;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.AttachmentDescriptionFlags Flags;
	public Vk.Format Format;
	public Vk.SampleCountFlags Samples;
	public Vk.AttachmentLoadOp LoadOp;
	public Vk.AttachmentStoreOp StoreOp;
	public Vk.AttachmentLoadOp StencilLoadOp;
	public Vk.AttachmentStoreOp StencilStoreOp;
	public Vk.ImageLayout InitialLayout;
	public Vk.ImageLayout FinalLayout;
	public AttachmentDescription2(
		in Vk.AttachmentDescriptionFlags flags = default,
		in Vk.Format format = default,
		in Vk.SampleCountFlags samples = default,
		in Vk.AttachmentLoadOp loadOp = default,
		in Vk.AttachmentStoreOp storeOp = default,
		in Vk.AttachmentLoadOp stencilLoadOp = default,
		in Vk.AttachmentStoreOp stencilStoreOp = default,
		in Vk.ImageLayout initialLayout = default,
		in Vk.ImageLayout finalLayout = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		Format = format;
		Samples = samples;
		LoadOp = loadOp;
		StoreOp = storeOp;
		StencilLoadOp = stencilLoadOp;
		StencilStoreOp = stencilStoreOp;
		InitialLayout = initialLayout;
		FinalLayout = finalLayout;
	}


	public readonly override bool Equals(object? obj) => (obj is AttachmentDescription2 o) && (this == o);
	readonly bool IEquatable<AttachmentDescription2>.Equals(AttachmentDescription2 obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ Format.GetHashCode()
			^ Samples.GetHashCode() ^ LoadOp.GetHashCode() ^ StoreOp.GetHashCode() ^ StencilLoadOp.GetHashCode()
			^ StencilStoreOp.GetHashCode() ^ InitialLayout.GetHashCode() ^ FinalLayout.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in AttachmentDescription2 l, in AttachmentDescription2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.Format == r.Format)
			&& (l.Samples == r.Samples) && (l.LoadOp == r.LoadOp) && (l.StoreOp == r.StoreOp) && (l.StencilLoadOp == r.StencilLoadOp)
			&& (l.StencilStoreOp == r.StencilStoreOp) && (l.InitialLayout == r.InitialLayout) && (l.FinalLayout == r.FinalLayout)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in AttachmentDescription2 l, in AttachmentDescription2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.Format != r.Format)
			|| (l.Samples != r.Samples) || (l.LoadOp != r.LoadOp) || (l.StoreOp != r.StoreOp) || (l.StencilLoadOp != r.StencilLoadOp)
			|| (l.StencilStoreOp != r.StencilStoreOp) || (l.InitialLayout != r.InitialLayout) || (l.FinalLayout != r.FinalLayout)
			;
	}


	/// <summary>Creates a new AttachmentDescription2 value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out AttachmentDescription2 value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct AttachmentReference2 : IEquatable<AttachmentReference2>
{
	public const Vk.StructureType TYPE = Vk.StructureType.AttachmentReference2;

	public Vk.StructureType sType;
	public void* pNext;
	public uint Attachment;
	public Vk.ImageLayout Layout;
	public Vk.ImageAspectFlags AspectMask;
	public AttachmentReference2(
		uint attachment = default,
		in Vk.ImageLayout layout = default,
		in Vk.ImageAspectFlags aspectMask = default
	) {
		sType = TYPE;
		pNext = null;
		Attachment = attachment;
		Layout = layout;
		AspectMask = aspectMask;
	}


	public readonly override bool Equals(object? obj) => (obj is AttachmentReference2 o) && (this == o);
	readonly bool IEquatable<AttachmentReference2>.Equals(AttachmentReference2 obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Attachment.GetHashCode() ^ Layout.GetHashCode()
			^ AspectMask.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in AttachmentReference2 l, in AttachmentReference2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Attachment == r.Attachment) && (l.Layout == r.Layout)
			&& (l.AspectMask == r.AspectMask)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in AttachmentReference2 l, in AttachmentReference2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Attachment != r.Attachment) || (l.Layout != r.Layout)
			|| (l.AspectMask != r.AspectMask)
			;
	}


	/// <summary>Creates a new AttachmentReference2 value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out AttachmentReference2 value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SubpassDescription2 : IEquatable<SubpassDescription2>
{
	public const Vk.StructureType TYPE = Vk.StructureType.SubpassDescription2;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.SubpassDescriptionFlags Flags;
	public Vk.PipelineBindPoint PipelineBindPoint;
	public uint ViewMask;
	public uint InputAttachmentCount;
	public Vk.AttachmentReference2* InputAttachments;
	public uint ColorAttachmentCount;
	public Vk.AttachmentReference2* ColorAttachments;
	public Vk.AttachmentReference2* ResolveAttachments;
	public Vk.AttachmentReference2* DepthStencilAttachment;
	public uint PreserveAttachmentCount;
	public uint* PreserveAttachments;
	public SubpassDescription2(
		in Vk.SubpassDescriptionFlags flags = default,
		in Vk.PipelineBindPoint pipelineBindPoint = default,
		uint viewMask = default,
		uint inputAttachmentCount = default,
		in Vk.AttachmentReference2* inputAttachments = default,
		uint colorAttachmentCount = default,
		in Vk.AttachmentReference2* colorAttachments = default,
		in Vk.AttachmentReference2* resolveAttachments = default,
		in Vk.AttachmentReference2* depthStencilAttachment = default,
		uint preserveAttachmentCount = default,
		uint* preserveAttachments = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		PipelineBindPoint = pipelineBindPoint;
		ViewMask = viewMask;
		InputAttachmentCount = inputAttachmentCount;
		InputAttachments = inputAttachments;
		ColorAttachmentCount = colorAttachmentCount;
		ColorAttachments = colorAttachments;
		ResolveAttachments = resolveAttachments;
		DepthStencilAttachment = depthStencilAttachment;
		PreserveAttachmentCount = preserveAttachmentCount;
		PreserveAttachments = preserveAttachments;
	}


	public readonly override bool Equals(object? obj) => (obj is SubpassDescription2 o) && (this == o);
	readonly bool IEquatable<SubpassDescription2>.Equals(SubpassDescription2 obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ PipelineBindPoint.GetHashCode()
			^ ViewMask.GetHashCode() ^ InputAttachmentCount.GetHashCode() ^ ((ulong)InputAttachments).GetHashCode() ^ ColorAttachmentCount.GetHashCode()
			^ ((ulong)ColorAttachments).GetHashCode() ^ ((ulong)ResolveAttachments).GetHashCode() ^ ((ulong)DepthStencilAttachment).GetHashCode() ^ PreserveAttachmentCount.GetHashCode()
			^ ((ulong)PreserveAttachments).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SubpassDescription2 l, in SubpassDescription2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.PipelineBindPoint == r.PipelineBindPoint)
			&& (l.ViewMask == r.ViewMask) && (l.InputAttachmentCount == r.InputAttachmentCount) && (l.InputAttachments == r.InputAttachments) && (l.ColorAttachmentCount == r.ColorAttachmentCount)
			&& (l.ColorAttachments == r.ColorAttachments) && (l.ResolveAttachments == r.ResolveAttachments) && (l.DepthStencilAttachment == r.DepthStencilAttachment) && (l.PreserveAttachmentCount == r.PreserveAttachmentCount)
			&& (l.PreserveAttachments == r.PreserveAttachments)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SubpassDescription2 l, in SubpassDescription2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.PipelineBindPoint != r.PipelineBindPoint)
			|| (l.ViewMask != r.ViewMask) || (l.InputAttachmentCount != r.InputAttachmentCount) || (l.InputAttachments != r.InputAttachments) || (l.ColorAttachmentCount != r.ColorAttachmentCount)
			|| (l.ColorAttachments != r.ColorAttachments) || (l.ResolveAttachments != r.ResolveAttachments) || (l.DepthStencilAttachment != r.DepthStencilAttachment) || (l.PreserveAttachmentCount != r.PreserveAttachmentCount)
			|| (l.PreserveAttachments != r.PreserveAttachments)
			;
	}


	/// <summary>Creates a new SubpassDescription2 value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SubpassDescription2 value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SubpassDependency2 : IEquatable<SubpassDependency2>
{
	public const Vk.StructureType TYPE = Vk.StructureType.SubpassDependency2;

	public Vk.StructureType sType;
	public void* pNext;
	public uint SrcSubpass;
	public uint DstSubpass;
	public Vk.PipelineStageFlags SrcStageMask;
	public Vk.PipelineStageFlags DstStageMask;
	public Vk.AccessFlags SrcAccessMask;
	public Vk.AccessFlags DstAccessMask;
	public Vk.DependencyFlags DependencyFlags;
	public int ViewOffset;
	public SubpassDependency2(
		uint srcSubpass = default,
		uint dstSubpass = default,
		in Vk.PipelineStageFlags srcStageMask = default,
		in Vk.PipelineStageFlags dstStageMask = default,
		in Vk.AccessFlags srcAccessMask = default,
		in Vk.AccessFlags dstAccessMask = default,
		in Vk.DependencyFlags dependencyFlags = default,
		int viewOffset = default
	) {
		sType = TYPE;
		pNext = null;
		SrcSubpass = srcSubpass;
		DstSubpass = dstSubpass;
		SrcStageMask = srcStageMask;
		DstStageMask = dstStageMask;
		SrcAccessMask = srcAccessMask;
		DstAccessMask = dstAccessMask;
		DependencyFlags = dependencyFlags;
		ViewOffset = viewOffset;
	}


	public readonly override bool Equals(object? obj) => (obj is SubpassDependency2 o) && (this == o);
	readonly bool IEquatable<SubpassDependency2>.Equals(SubpassDependency2 obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SrcSubpass.GetHashCode() ^ DstSubpass.GetHashCode()
			^ SrcStageMask.GetHashCode() ^ DstStageMask.GetHashCode() ^ SrcAccessMask.GetHashCode() ^ DstAccessMask.GetHashCode()
			^ DependencyFlags.GetHashCode() ^ ViewOffset.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SubpassDependency2 l, in SubpassDependency2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SrcSubpass == r.SrcSubpass) && (l.DstSubpass == r.DstSubpass)
			&& (l.SrcStageMask == r.SrcStageMask) && (l.DstStageMask == r.DstStageMask) && (l.SrcAccessMask == r.SrcAccessMask) && (l.DstAccessMask == r.DstAccessMask)
			&& (l.DependencyFlags == r.DependencyFlags) && (l.ViewOffset == r.ViewOffset)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SubpassDependency2 l, in SubpassDependency2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SrcSubpass != r.SrcSubpass) || (l.DstSubpass != r.DstSubpass)
			|| (l.SrcStageMask != r.SrcStageMask) || (l.DstStageMask != r.DstStageMask) || (l.SrcAccessMask != r.SrcAccessMask) || (l.DstAccessMask != r.DstAccessMask)
			|| (l.DependencyFlags != r.DependencyFlags) || (l.ViewOffset != r.ViewOffset)
			;
	}


	/// <summary>Creates a new SubpassDependency2 value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SubpassDependency2 value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct RenderPassCreateInfo2 : IEquatable<RenderPassCreateInfo2>
{
	public const Vk.StructureType TYPE = Vk.StructureType.RenderPassCreateInfo2;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.RenderPassCreateFlags Flags;
	public uint AttachmentCount;
	public Vk.AttachmentDescription2* Attachments;
	public uint SubpassCount;
	public Vk.SubpassDescription2* Subpasses;
	public uint DependencyCount;
	public Vk.SubpassDependency2* Dependencies;
	public uint CorrelatedViewMaskCount;
	public uint* CorrelatedViewMasks;
	public RenderPassCreateInfo2(
		in Vk.RenderPassCreateFlags flags = default,
		uint attachmentCount = default,
		in Vk.AttachmentDescription2* attachments = default,
		uint subpassCount = default,
		in Vk.SubpassDescription2* subpasses = default,
		uint dependencyCount = default,
		in Vk.SubpassDependency2* dependencies = default,
		uint correlatedViewMaskCount = default,
		uint* correlatedViewMasks = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		AttachmentCount = attachmentCount;
		Attachments = attachments;
		SubpassCount = subpassCount;
		Subpasses = subpasses;
		DependencyCount = dependencyCount;
		Dependencies = dependencies;
		CorrelatedViewMaskCount = correlatedViewMaskCount;
		CorrelatedViewMasks = correlatedViewMasks;
	}


	public readonly override bool Equals(object? obj) => (obj is RenderPassCreateInfo2 o) && (this == o);
	readonly bool IEquatable<RenderPassCreateInfo2>.Equals(RenderPassCreateInfo2 obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ AttachmentCount.GetHashCode()
			^ ((ulong)Attachments).GetHashCode() ^ SubpassCount.GetHashCode() ^ ((ulong)Subpasses).GetHashCode() ^ DependencyCount.GetHashCode()
			^ ((ulong)Dependencies).GetHashCode() ^ CorrelatedViewMaskCount.GetHashCode() ^ ((ulong)CorrelatedViewMasks).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in RenderPassCreateInfo2 l, in RenderPassCreateInfo2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.AttachmentCount == r.AttachmentCount)
			&& (l.Attachments == r.Attachments) && (l.SubpassCount == r.SubpassCount) && (l.Subpasses == r.Subpasses) && (l.DependencyCount == r.DependencyCount)
			&& (l.Dependencies == r.Dependencies) && (l.CorrelatedViewMaskCount == r.CorrelatedViewMaskCount) && (l.CorrelatedViewMasks == r.CorrelatedViewMasks)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in RenderPassCreateInfo2 l, in RenderPassCreateInfo2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.AttachmentCount != r.AttachmentCount)
			|| (l.Attachments != r.Attachments) || (l.SubpassCount != r.SubpassCount) || (l.Subpasses != r.Subpasses) || (l.DependencyCount != r.DependencyCount)
			|| (l.Dependencies != r.Dependencies) || (l.CorrelatedViewMaskCount != r.CorrelatedViewMaskCount) || (l.CorrelatedViewMasks != r.CorrelatedViewMasks)
			;
	}


	/// <summary>Creates a new RenderPassCreateInfo2 value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out RenderPassCreateInfo2 value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SubpassBeginInfo : IEquatable<SubpassBeginInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.SubpassBeginInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.SubpassContents Contents;
	public SubpassBeginInfo(
		in Vk.SubpassContents contents = default
	) {
		sType = TYPE;
		pNext = null;
		Contents = contents;
	}


	public readonly override bool Equals(object? obj) => (obj is SubpassBeginInfo o) && (this == o);
	readonly bool IEquatable<SubpassBeginInfo>.Equals(SubpassBeginInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Contents.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SubpassBeginInfo l, in SubpassBeginInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Contents == r.Contents)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SubpassBeginInfo l, in SubpassBeginInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Contents != r.Contents)
			;
	}


	/// <summary>Creates a new SubpassBeginInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SubpassBeginInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SubpassEndInfo : IEquatable<SubpassEndInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.SubpassEndInfo;

	public Vk.StructureType sType;
	public void* pNext;

	public readonly override bool Equals(object? obj) => (obj is SubpassEndInfo o) && (this == o);
	readonly bool IEquatable<SubpassEndInfo>.Equals(SubpassEndInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SubpassEndInfo l, in SubpassEndInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SubpassEndInfo l, in SubpassEndInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext)
			;
	}


	/// <summary>Creates a new SubpassEndInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SubpassEndInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceTimelineSemaphoreFeatures : IEquatable<PhysicalDeviceTimelineSemaphoreFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceTimelineSemaphoreFeatures;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 TimelineSemaphore;
	public PhysicalDeviceTimelineSemaphoreFeatures(
		in Vk.Bool32 timelineSemaphore = default
	) {
		sType = TYPE;
		pNext = null;
		TimelineSemaphore = timelineSemaphore;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceTimelineSemaphoreFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceTimelineSemaphoreFeatures>.Equals(PhysicalDeviceTimelineSemaphoreFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ TimelineSemaphore.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceTimelineSemaphoreFeatures l, in PhysicalDeviceTimelineSemaphoreFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.TimelineSemaphore == r.TimelineSemaphore)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceTimelineSemaphoreFeatures l, in PhysicalDeviceTimelineSemaphoreFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.TimelineSemaphore != r.TimelineSemaphore)
			;
	}


	/// <summary>Creates a new PhysicalDeviceTimelineSemaphoreFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceTimelineSemaphoreFeatures value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceTimelineSemaphoreProperties : IEquatable<PhysicalDeviceTimelineSemaphoreProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceTimelineSemaphoreProperties;

	public Vk.StructureType sType;
	public void* pNext;
	public ulong MaxTimelineSemaphoreValueDifference;
	public PhysicalDeviceTimelineSemaphoreProperties(
		ulong maxTimelineSemaphoreValueDifference = default
	) {
		sType = TYPE;
		pNext = null;
		MaxTimelineSemaphoreValueDifference = maxTimelineSemaphoreValueDifference;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceTimelineSemaphoreProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceTimelineSemaphoreProperties>.Equals(PhysicalDeviceTimelineSemaphoreProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MaxTimelineSemaphoreValueDifference.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceTimelineSemaphoreProperties l, in PhysicalDeviceTimelineSemaphoreProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MaxTimelineSemaphoreValueDifference == r.MaxTimelineSemaphoreValueDifference)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceTimelineSemaphoreProperties l, in PhysicalDeviceTimelineSemaphoreProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MaxTimelineSemaphoreValueDifference != r.MaxTimelineSemaphoreValueDifference)
			;
	}


	/// <summary>Creates a new PhysicalDeviceTimelineSemaphoreProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceTimelineSemaphoreProperties value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SemaphoreTypeCreateInfo : IEquatable<SemaphoreTypeCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.SemaphoreTypeCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.SemaphoreType SemaphoreType;
	public ulong InitialValue;
	public SemaphoreTypeCreateInfo(
		in Vk.SemaphoreType semaphoreType = default,
		ulong initialValue = default
	) {
		sType = TYPE;
		pNext = null;
		SemaphoreType = semaphoreType;
		InitialValue = initialValue;
	}


	public readonly override bool Equals(object? obj) => (obj is SemaphoreTypeCreateInfo o) && (this == o);
	readonly bool IEquatable<SemaphoreTypeCreateInfo>.Equals(SemaphoreTypeCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SemaphoreType.GetHashCode() ^ InitialValue.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SemaphoreTypeCreateInfo l, in SemaphoreTypeCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SemaphoreType == r.SemaphoreType) && (l.InitialValue == r.InitialValue)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SemaphoreTypeCreateInfo l, in SemaphoreTypeCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SemaphoreType != r.SemaphoreType) || (l.InitialValue != r.InitialValue)
			;
	}


	/// <summary>Creates a new SemaphoreTypeCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SemaphoreTypeCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct TimelineSemaphoreSubmitInfo : IEquatable<TimelineSemaphoreSubmitInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.TimelineSemaphoreSubmitInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public uint WaitSemaphoreValueCount;
	public ulong* WaitSemaphoreValues;
	public uint SignalSemaphoreValueCount;
	public ulong* SignalSemaphoreValues;
	public TimelineSemaphoreSubmitInfo(
		uint waitSemaphoreValueCount = default,
		ulong* waitSemaphoreValues = default,
		uint signalSemaphoreValueCount = default,
		ulong* signalSemaphoreValues = default
	) {
		sType = TYPE;
		pNext = null;
		WaitSemaphoreValueCount = waitSemaphoreValueCount;
		WaitSemaphoreValues = waitSemaphoreValues;
		SignalSemaphoreValueCount = signalSemaphoreValueCount;
		SignalSemaphoreValues = signalSemaphoreValues;
	}


	public readonly override bool Equals(object? obj) => (obj is TimelineSemaphoreSubmitInfo o) && (this == o);
	readonly bool IEquatable<TimelineSemaphoreSubmitInfo>.Equals(TimelineSemaphoreSubmitInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ WaitSemaphoreValueCount.GetHashCode() ^ ((ulong)WaitSemaphoreValues).GetHashCode()
			^ SignalSemaphoreValueCount.GetHashCode() ^ ((ulong)SignalSemaphoreValues).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in TimelineSemaphoreSubmitInfo l, in TimelineSemaphoreSubmitInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.WaitSemaphoreValueCount == r.WaitSemaphoreValueCount) && (l.WaitSemaphoreValues == r.WaitSemaphoreValues)
			&& (l.SignalSemaphoreValueCount == r.SignalSemaphoreValueCount) && (l.SignalSemaphoreValues == r.SignalSemaphoreValues)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in TimelineSemaphoreSubmitInfo l, in TimelineSemaphoreSubmitInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.WaitSemaphoreValueCount != r.WaitSemaphoreValueCount) || (l.WaitSemaphoreValues != r.WaitSemaphoreValues)
			|| (l.SignalSemaphoreValueCount != r.SignalSemaphoreValueCount) || (l.SignalSemaphoreValues != r.SignalSemaphoreValues)
			;
	}


	/// <summary>Creates a new TimelineSemaphoreSubmitInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out TimelineSemaphoreSubmitInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SemaphoreWaitInfo : IEquatable<SemaphoreWaitInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.SemaphoreWaitInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.SemaphoreWaitFlags Flags;
	public uint SemaphoreCount;
	public Vk.Handle<Vk.Semaphore>* Semaphores;
	public ulong* Values;
	public SemaphoreWaitInfo(
		in Vk.SemaphoreWaitFlags flags = default,
		uint semaphoreCount = default,
		in Vk.Handle<Vk.Semaphore>* semaphores = default,
		ulong* values = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		SemaphoreCount = semaphoreCount;
		Semaphores = semaphores;
		Values = values;
	}


	public readonly override bool Equals(object? obj) => (obj is SemaphoreWaitInfo o) && (this == o);
	readonly bool IEquatable<SemaphoreWaitInfo>.Equals(SemaphoreWaitInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ SemaphoreCount.GetHashCode()
			^ ((ulong)Semaphores).GetHashCode() ^ ((ulong)Values).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SemaphoreWaitInfo l, in SemaphoreWaitInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.SemaphoreCount == r.SemaphoreCount)
			&& (l.Semaphores == r.Semaphores) && (l.Values == r.Values)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SemaphoreWaitInfo l, in SemaphoreWaitInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.SemaphoreCount != r.SemaphoreCount)
			|| (l.Semaphores != r.Semaphores) || (l.Values != r.Values)
			;
	}


	/// <summary>Creates a new SemaphoreWaitInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SemaphoreWaitInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SemaphoreSignalInfo : IEquatable<SemaphoreSignalInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.SemaphoreSignalInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Handle<Vk.Semaphore> Semaphore;
	public ulong Value;
	public SemaphoreSignalInfo(
		in Vk.Handle<Vk.Semaphore> semaphore = default,
		ulong value = default
	) {
		sType = TYPE;
		pNext = null;
		Semaphore = semaphore;
		Value = value;
	}


	public readonly override bool Equals(object? obj) => (obj is SemaphoreSignalInfo o) && (this == o);
	readonly bool IEquatable<SemaphoreSignalInfo>.Equals(SemaphoreSignalInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Semaphore.GetHashCode() ^ Value.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SemaphoreSignalInfo l, in SemaphoreSignalInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Semaphore == r.Semaphore) && (l.Value == r.Value)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SemaphoreSignalInfo l, in SemaphoreSignalInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Semaphore != r.Semaphore) || (l.Value != r.Value)
			;
	}


	/// <summary>Creates a new SemaphoreSignalInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SemaphoreSignalInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDevice8BitStorageFeatures : IEquatable<PhysicalDevice8BitStorageFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDevice8BitStorageFeatures;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 StorageBuffer8BitAccess;
	public Vk.Bool32 UniformAndStorageBuffer8BitAccess;
	public Vk.Bool32 StoragePushConstant8;
	public PhysicalDevice8BitStorageFeatures(
		in Vk.Bool32 storageBuffer8BitAccess = default,
		in Vk.Bool32 uniformAndStorageBuffer8BitAccess = default,
		in Vk.Bool32 storagePushConstant8 = default
	) {
		sType = TYPE;
		pNext = null;
		StorageBuffer8BitAccess = storageBuffer8BitAccess;
		UniformAndStorageBuffer8BitAccess = uniformAndStorageBuffer8BitAccess;
		StoragePushConstant8 = storagePushConstant8;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDevice8BitStorageFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDevice8BitStorageFeatures>.Equals(PhysicalDevice8BitStorageFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ StorageBuffer8BitAccess.GetHashCode() ^ UniformAndStorageBuffer8BitAccess.GetHashCode()
			^ StoragePushConstant8.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDevice8BitStorageFeatures l, in PhysicalDevice8BitStorageFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.StorageBuffer8BitAccess == r.StorageBuffer8BitAccess) && (l.UniformAndStorageBuffer8BitAccess == r.UniformAndStorageBuffer8BitAccess)
			&& (l.StoragePushConstant8 == r.StoragePushConstant8)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDevice8BitStorageFeatures l, in PhysicalDevice8BitStorageFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.StorageBuffer8BitAccess != r.StorageBuffer8BitAccess) || (l.UniformAndStorageBuffer8BitAccess != r.UniformAndStorageBuffer8BitAccess)
			|| (l.StoragePushConstant8 != r.StoragePushConstant8)
			;
	}


	/// <summary>Creates a new PhysicalDevice8BitStorageFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDevice8BitStorageFeatures value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceVulkanMemoryModelFeatures : IEquatable<PhysicalDeviceVulkanMemoryModelFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceVulkanMemoryModelFeatures;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 VulkanMemoryModel;
	public Vk.Bool32 VulkanMemoryModelDeviceScope;
	public Vk.Bool32 VulkanMemoryModelAvailabilityVisibilityChains;
	public PhysicalDeviceVulkanMemoryModelFeatures(
		in Vk.Bool32 vulkanMemoryModel = default,
		in Vk.Bool32 vulkanMemoryModelDeviceScope = default,
		in Vk.Bool32 vulkanMemoryModelAvailabilityVisibilityChains = default
	) {
		sType = TYPE;
		pNext = null;
		VulkanMemoryModel = vulkanMemoryModel;
		VulkanMemoryModelDeviceScope = vulkanMemoryModelDeviceScope;
		VulkanMemoryModelAvailabilityVisibilityChains = vulkanMemoryModelAvailabilityVisibilityChains;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceVulkanMemoryModelFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceVulkanMemoryModelFeatures>.Equals(PhysicalDeviceVulkanMemoryModelFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ VulkanMemoryModel.GetHashCode() ^ VulkanMemoryModelDeviceScope.GetHashCode()
			^ VulkanMemoryModelAvailabilityVisibilityChains.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceVulkanMemoryModelFeatures l, in PhysicalDeviceVulkanMemoryModelFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.VulkanMemoryModel == r.VulkanMemoryModel) && (l.VulkanMemoryModelDeviceScope == r.VulkanMemoryModelDeviceScope)
			&& (l.VulkanMemoryModelAvailabilityVisibilityChains == r.VulkanMemoryModelAvailabilityVisibilityChains)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceVulkanMemoryModelFeatures l, in PhysicalDeviceVulkanMemoryModelFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.VulkanMemoryModel != r.VulkanMemoryModel) || (l.VulkanMemoryModelDeviceScope != r.VulkanMemoryModelDeviceScope)
			|| (l.VulkanMemoryModelAvailabilityVisibilityChains != r.VulkanMemoryModelAvailabilityVisibilityChains)
			;
	}


	/// <summary>Creates a new PhysicalDeviceVulkanMemoryModelFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceVulkanMemoryModelFeatures value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceShaderAtomicInt64Features : IEquatable<PhysicalDeviceShaderAtomicInt64Features>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceShaderAtomicInt64Features;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 ShaderBufferInt64Atomics;
	public Vk.Bool32 ShaderSharedInt64Atomics;
	public PhysicalDeviceShaderAtomicInt64Features(
		in Vk.Bool32 shaderBufferInt64Atomics = default,
		in Vk.Bool32 shaderSharedInt64Atomics = default
	) {
		sType = TYPE;
		pNext = null;
		ShaderBufferInt64Atomics = shaderBufferInt64Atomics;
		ShaderSharedInt64Atomics = shaderSharedInt64Atomics;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceShaderAtomicInt64Features o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceShaderAtomicInt64Features>.Equals(PhysicalDeviceShaderAtomicInt64Features obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ShaderBufferInt64Atomics.GetHashCode() ^ ShaderSharedInt64Atomics.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceShaderAtomicInt64Features l, in PhysicalDeviceShaderAtomicInt64Features r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ShaderBufferInt64Atomics == r.ShaderBufferInt64Atomics) && (l.ShaderSharedInt64Atomics == r.ShaderSharedInt64Atomics)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceShaderAtomicInt64Features l, in PhysicalDeviceShaderAtomicInt64Features r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ShaderBufferInt64Atomics != r.ShaderBufferInt64Atomics) || (l.ShaderSharedInt64Atomics != r.ShaderSharedInt64Atomics)
			;
	}


	/// <summary>Creates a new PhysicalDeviceShaderAtomicInt64Features value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceShaderAtomicInt64Features value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceDepthStencilResolveProperties : IEquatable<PhysicalDeviceDepthStencilResolveProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceDepthStencilResolveProperties;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.ResolveModeFlags SupportedDepthResolveModes;
	public Vk.ResolveModeFlags SupportedStencilResolveModes;
	public Vk.Bool32 IndependentResolveNone;
	public Vk.Bool32 IndependentResolve;
	public PhysicalDeviceDepthStencilResolveProperties(
		in Vk.ResolveModeFlags supportedDepthResolveModes = default,
		in Vk.ResolveModeFlags supportedStencilResolveModes = default,
		in Vk.Bool32 independentResolveNone = default,
		in Vk.Bool32 independentResolve = default
	) {
		sType = TYPE;
		pNext = null;
		SupportedDepthResolveModes = supportedDepthResolveModes;
		SupportedStencilResolveModes = supportedStencilResolveModes;
		IndependentResolveNone = independentResolveNone;
		IndependentResolve = independentResolve;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceDepthStencilResolveProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceDepthStencilResolveProperties>.Equals(PhysicalDeviceDepthStencilResolveProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SupportedDepthResolveModes.GetHashCode() ^ SupportedStencilResolveModes.GetHashCode()
			^ IndependentResolveNone.GetHashCode() ^ IndependentResolve.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceDepthStencilResolveProperties l, in PhysicalDeviceDepthStencilResolveProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SupportedDepthResolveModes == r.SupportedDepthResolveModes) && (l.SupportedStencilResolveModes == r.SupportedStencilResolveModes)
			&& (l.IndependentResolveNone == r.IndependentResolveNone) && (l.IndependentResolve == r.IndependentResolve)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceDepthStencilResolveProperties l, in PhysicalDeviceDepthStencilResolveProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SupportedDepthResolveModes != r.SupportedDepthResolveModes) || (l.SupportedStencilResolveModes != r.SupportedStencilResolveModes)
			|| (l.IndependentResolveNone != r.IndependentResolveNone) || (l.IndependentResolve != r.IndependentResolve)
			;
	}


	/// <summary>Creates a new PhysicalDeviceDepthStencilResolveProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceDepthStencilResolveProperties value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SubpassDescriptionDepthStencilResolve : IEquatable<SubpassDescriptionDepthStencilResolve>
{
	public const Vk.StructureType TYPE = Vk.StructureType.SubpassDescriptionDepthStencilResolve;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.ResolveModeFlags DepthResolveMode;
	public Vk.ResolveModeFlags StencilResolveMode;
	public Vk.AttachmentReference2* DepthStencilResolveAttachment;
	public SubpassDescriptionDepthStencilResolve(
		in Vk.ResolveModeFlags depthResolveMode = default,
		in Vk.ResolveModeFlags stencilResolveMode = default,
		in Vk.AttachmentReference2* depthStencilResolveAttachment = default
	) {
		sType = TYPE;
		pNext = null;
		DepthResolveMode = depthResolveMode;
		StencilResolveMode = stencilResolveMode;
		DepthStencilResolveAttachment = depthStencilResolveAttachment;
	}


	public readonly override bool Equals(object? obj) => (obj is SubpassDescriptionDepthStencilResolve o) && (this == o);
	readonly bool IEquatable<SubpassDescriptionDepthStencilResolve>.Equals(SubpassDescriptionDepthStencilResolve obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DepthResolveMode.GetHashCode() ^ StencilResolveMode.GetHashCode()
			^ ((ulong)DepthStencilResolveAttachment).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SubpassDescriptionDepthStencilResolve l, in SubpassDescriptionDepthStencilResolve r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DepthResolveMode == r.DepthResolveMode) && (l.StencilResolveMode == r.StencilResolveMode)
			&& (l.DepthStencilResolveAttachment == r.DepthStencilResolveAttachment)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SubpassDescriptionDepthStencilResolve l, in SubpassDescriptionDepthStencilResolve r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DepthResolveMode != r.DepthResolveMode) || (l.StencilResolveMode != r.StencilResolveMode)
			|| (l.DepthStencilResolveAttachment != r.DepthStencilResolveAttachment)
			;
	}


	/// <summary>Creates a new SubpassDescriptionDepthStencilResolve value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SubpassDescriptionDepthStencilResolve value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct RayTracingShaderGroupCreateInfo : IEquatable<RayTracingShaderGroupCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.RayTracingShaderGroupCreateInfoKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.KHR.RayTracingShaderGroupType Type;
	public uint GeneralShader;
	public uint ClosestHitShader;
	public uint AnyHitShader;
	public uint IntersectionShader;
	public void* ShaderGroupCaptureReplayHandle;
	public RayTracingShaderGroupCreateInfo(
		in Vk.KHR.RayTracingShaderGroupType type = default,
		uint generalShader = default,
		uint closestHitShader = default,
		uint anyHitShader = default,
		uint intersectionShader = default,
		void* shaderGroupCaptureReplayHandle = default
	) {
		sType = TYPE;
		pNext = null;
		Type = type;
		GeneralShader = generalShader;
		ClosestHitShader = closestHitShader;
		AnyHitShader = anyHitShader;
		IntersectionShader = intersectionShader;
		ShaderGroupCaptureReplayHandle = shaderGroupCaptureReplayHandle;
	}


	public readonly override bool Equals(object? obj) => (obj is RayTracingShaderGroupCreateInfo o) && (this == o);
	readonly bool IEquatable<RayTracingShaderGroupCreateInfo>.Equals(RayTracingShaderGroupCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Type.GetHashCode() ^ GeneralShader.GetHashCode()
			^ ClosestHitShader.GetHashCode() ^ AnyHitShader.GetHashCode() ^ IntersectionShader.GetHashCode() ^ ((ulong)ShaderGroupCaptureReplayHandle).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in RayTracingShaderGroupCreateInfo l, in RayTracingShaderGroupCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Type == r.Type) && (l.GeneralShader == r.GeneralShader)
			&& (l.ClosestHitShader == r.ClosestHitShader) && (l.AnyHitShader == r.AnyHitShader) && (l.IntersectionShader == r.IntersectionShader) && (l.ShaderGroupCaptureReplayHandle == r.ShaderGroupCaptureReplayHandle)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in RayTracingShaderGroupCreateInfo l, in RayTracingShaderGroupCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Type != r.Type) || (l.GeneralShader != r.GeneralShader)
			|| (l.ClosestHitShader != r.ClosestHitShader) || (l.AnyHitShader != r.AnyHitShader) || (l.IntersectionShader != r.IntersectionShader) || (l.ShaderGroupCaptureReplayHandle != r.ShaderGroupCaptureReplayHandle)
			;
	}


	/// <summary>Creates a new RayTracingShaderGroupCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out RayTracingShaderGroupCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct RayTracingPipelineCreateInfo : IEquatable<RayTracingPipelineCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.RayTracingPipelineCreateInfoKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.PipelineCreateFlags Flags;
	public uint StageCount;
	public Vk.PipelineShaderStageCreateInfo* Stages;
	public uint GroupCount;
	public Vk.KHR.RayTracingShaderGroupCreateInfo* Groups;
	public uint MaxRecursionDepth;
	public Vk.KHR.PipelineLibraryCreateInfo Libraries;
	public Vk.KHR.RayTracingPipelineInterfaceCreateInfo* LibraryInterface;
	public Vk.Handle<Vk.PipelineLayout> Layout;
	public Vk.Handle<Vk.Pipeline> BasePipelineHandle;
	public int BasePipelineIndex;
	public RayTracingPipelineCreateInfo(
		in Vk.PipelineCreateFlags flags = default,
		uint stageCount = default,
		in Vk.PipelineShaderStageCreateInfo* stages = default,
		uint groupCount = default,
		in Vk.KHR.RayTracingShaderGroupCreateInfo* groups = default,
		uint maxRecursionDepth = default,
		in Vk.KHR.PipelineLibraryCreateInfo libraries = default,
		in Vk.KHR.RayTracingPipelineInterfaceCreateInfo* libraryInterface = default,
		in Vk.Handle<Vk.PipelineLayout> layout = default,
		in Vk.Handle<Vk.Pipeline> basePipelineHandle = default,
		int basePipelineIndex = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		StageCount = stageCount;
		Stages = stages;
		GroupCount = groupCount;
		Groups = groups;
		MaxRecursionDepth = maxRecursionDepth;
		Libraries = libraries;
		LibraryInterface = libraryInterface;
		Layout = layout;
		BasePipelineHandle = basePipelineHandle;
		BasePipelineIndex = basePipelineIndex;
	}


	public readonly override bool Equals(object? obj) => (obj is RayTracingPipelineCreateInfo o) && (this == o);
	readonly bool IEquatable<RayTracingPipelineCreateInfo>.Equals(RayTracingPipelineCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ StageCount.GetHashCode()
			^ ((ulong)Stages).GetHashCode() ^ GroupCount.GetHashCode() ^ ((ulong)Groups).GetHashCode() ^ MaxRecursionDepth.GetHashCode()
			^ Libraries.GetHashCode() ^ ((ulong)LibraryInterface).GetHashCode() ^ Layout.GetHashCode() ^ BasePipelineHandle.GetHashCode()
			^ BasePipelineIndex.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in RayTracingPipelineCreateInfo l, in RayTracingPipelineCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.StageCount == r.StageCount)
			&& (l.Stages == r.Stages) && (l.GroupCount == r.GroupCount) && (l.Groups == r.Groups) && (l.MaxRecursionDepth == r.MaxRecursionDepth)
			&& (l.Libraries == r.Libraries) && (l.LibraryInterface == r.LibraryInterface) && (l.Layout == r.Layout) && (l.BasePipelineHandle == r.BasePipelineHandle)
			&& (l.BasePipelineIndex == r.BasePipelineIndex)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in RayTracingPipelineCreateInfo l, in RayTracingPipelineCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.StageCount != r.StageCount)
			|| (l.Stages != r.Stages) || (l.GroupCount != r.GroupCount) || (l.Groups != r.Groups) || (l.MaxRecursionDepth != r.MaxRecursionDepth)
			|| (l.Libraries != r.Libraries) || (l.LibraryInterface != r.LibraryInterface) || (l.Layout != r.Layout) || (l.BasePipelineHandle != r.BasePipelineHandle)
			|| (l.BasePipelineIndex != r.BasePipelineIndex)
			;
	}


	/// <summary>Creates a new RayTracingPipelineCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out RayTracingPipelineCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct BindAccelerationStructureMemoryInfo : IEquatable<BindAccelerationStructureMemoryInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.BindAccelerationStructureMemoryInfoKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Handle<Vk.KHR.AccelerationStructure> AccelerationStructure;
	public Vk.Handle<Vk.DeviceMemory> Memory;
	public Vk.DeviceSize MemoryOffset;
	public uint DeviceIndexCount;
	public uint* DeviceIndices;
	public BindAccelerationStructureMemoryInfo(
		in Vk.Handle<Vk.KHR.AccelerationStructure> accelerationStructure = default,
		in Vk.Handle<Vk.DeviceMemory> memory = default,
		in Vk.DeviceSize memoryOffset = default,
		uint deviceIndexCount = default,
		uint* deviceIndices = default
	) {
		sType = TYPE;
		pNext = null;
		AccelerationStructure = accelerationStructure;
		Memory = memory;
		MemoryOffset = memoryOffset;
		DeviceIndexCount = deviceIndexCount;
		DeviceIndices = deviceIndices;
	}


	public readonly override bool Equals(object? obj) => (obj is BindAccelerationStructureMemoryInfo o) && (this == o);
	readonly bool IEquatable<BindAccelerationStructureMemoryInfo>.Equals(BindAccelerationStructureMemoryInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ AccelerationStructure.GetHashCode() ^ Memory.GetHashCode()
			^ MemoryOffset.GetHashCode() ^ DeviceIndexCount.GetHashCode() ^ ((ulong)DeviceIndices).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in BindAccelerationStructureMemoryInfo l, in BindAccelerationStructureMemoryInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.AccelerationStructure == r.AccelerationStructure) && (l.Memory == r.Memory)
			&& (l.MemoryOffset == r.MemoryOffset) && (l.DeviceIndexCount == r.DeviceIndexCount) && (l.DeviceIndices == r.DeviceIndices)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in BindAccelerationStructureMemoryInfo l, in BindAccelerationStructureMemoryInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.AccelerationStructure != r.AccelerationStructure) || (l.Memory != r.Memory)
			|| (l.MemoryOffset != r.MemoryOffset) || (l.DeviceIndexCount != r.DeviceIndexCount) || (l.DeviceIndices != r.DeviceIndices)
			;
	}


	/// <summary>Creates a new BindAccelerationStructureMemoryInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out BindAccelerationStructureMemoryInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct WriteDescriptorSetAccelerationStructure : IEquatable<WriteDescriptorSetAccelerationStructure>
{
	public const Vk.StructureType TYPE = Vk.StructureType.WriteDescriptorSetAccelerationStructureKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public uint AccelerationStructureCount;
	public Vk.Handle<Vk.KHR.AccelerationStructure>* AccelerationStructures;
	public WriteDescriptorSetAccelerationStructure(
		uint accelerationStructureCount = default,
		in Vk.Handle<Vk.KHR.AccelerationStructure>* accelerationStructures = default
	) {
		sType = TYPE;
		pNext = null;
		AccelerationStructureCount = accelerationStructureCount;
		AccelerationStructures = accelerationStructures;
	}


	public readonly override bool Equals(object? obj) => (obj is WriteDescriptorSetAccelerationStructure o) && (this == o);
	readonly bool IEquatable<WriteDescriptorSetAccelerationStructure>.Equals(WriteDescriptorSetAccelerationStructure obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ AccelerationStructureCount.GetHashCode() ^ ((ulong)AccelerationStructures).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in WriteDescriptorSetAccelerationStructure l, in WriteDescriptorSetAccelerationStructure r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.AccelerationStructureCount == r.AccelerationStructureCount) && (l.AccelerationStructures == r.AccelerationStructures)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in WriteDescriptorSetAccelerationStructure l, in WriteDescriptorSetAccelerationStructure r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.AccelerationStructureCount != r.AccelerationStructureCount) || (l.AccelerationStructures != r.AccelerationStructures)
			;
	}


	/// <summary>Creates a new WriteDescriptorSetAccelerationStructure value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out WriteDescriptorSetAccelerationStructure value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct AccelerationStructureMemoryRequirementsInfo : IEquatable<AccelerationStructureMemoryRequirementsInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.AccelerationStructureMemoryRequirementsInfoKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.KHR.AccelerationStructureMemoryRequirementsType Type;
	public Vk.KHR.AccelerationStructureBuildType BuildType;
	public Vk.Handle<Vk.KHR.AccelerationStructure> AccelerationStructure;
	public AccelerationStructureMemoryRequirementsInfo(
		in Vk.KHR.AccelerationStructureMemoryRequirementsType type = default,
		in Vk.KHR.AccelerationStructureBuildType buildType = default,
		in Vk.Handle<Vk.KHR.AccelerationStructure> accelerationStructure = default
	) {
		sType = TYPE;
		pNext = null;
		Type = type;
		BuildType = buildType;
		AccelerationStructure = accelerationStructure;
	}


	public readonly override bool Equals(object? obj) => (obj is AccelerationStructureMemoryRequirementsInfo o) && (this == o);
	readonly bool IEquatable<AccelerationStructureMemoryRequirementsInfo>.Equals(AccelerationStructureMemoryRequirementsInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Type.GetHashCode() ^ BuildType.GetHashCode()
			^ AccelerationStructure.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in AccelerationStructureMemoryRequirementsInfo l, in AccelerationStructureMemoryRequirementsInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Type == r.Type) && (l.BuildType == r.BuildType)
			&& (l.AccelerationStructure == r.AccelerationStructure)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in AccelerationStructureMemoryRequirementsInfo l, in AccelerationStructureMemoryRequirementsInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Type != r.Type) || (l.BuildType != r.BuildType)
			|| (l.AccelerationStructure != r.AccelerationStructure)
			;
	}


	/// <summary>Creates a new AccelerationStructureMemoryRequirementsInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out AccelerationStructureMemoryRequirementsInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceRayTracingFeatures : IEquatable<PhysicalDeviceRayTracingFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceRayTracingFeaturesKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 RayTracing;
	public Vk.Bool32 RayTracingShaderGroupHandleCaptureReplay;
	public Vk.Bool32 RayTracingShaderGroupHandleCaptureReplayMixed;
	public Vk.Bool32 RayTracingAccelerationStructureCaptureReplay;
	public Vk.Bool32 RayTracingIndirectTraceRays;
	public Vk.Bool32 RayTracingIndirectAccelerationStructureBuild;
	public Vk.Bool32 RayTracingHostAccelerationStructureCommands;
	public Vk.Bool32 RayQuery;
	public Vk.Bool32 RayTracingPrimitiveCulling;
	public PhysicalDeviceRayTracingFeatures(
		in Vk.Bool32 rayTracing = default,
		in Vk.Bool32 rayTracingShaderGroupHandleCaptureReplay = default,
		in Vk.Bool32 rayTracingShaderGroupHandleCaptureReplayMixed = default,
		in Vk.Bool32 rayTracingAccelerationStructureCaptureReplay = default,
		in Vk.Bool32 rayTracingIndirectTraceRays = default,
		in Vk.Bool32 rayTracingIndirectAccelerationStructureBuild = default,
		in Vk.Bool32 rayTracingHostAccelerationStructureCommands = default,
		in Vk.Bool32 rayQuery = default,
		in Vk.Bool32 rayTracingPrimitiveCulling = default
	) {
		sType = TYPE;
		pNext = null;
		RayTracing = rayTracing;
		RayTracingShaderGroupHandleCaptureReplay = rayTracingShaderGroupHandleCaptureReplay;
		RayTracingShaderGroupHandleCaptureReplayMixed = rayTracingShaderGroupHandleCaptureReplayMixed;
		RayTracingAccelerationStructureCaptureReplay = rayTracingAccelerationStructureCaptureReplay;
		RayTracingIndirectTraceRays = rayTracingIndirectTraceRays;
		RayTracingIndirectAccelerationStructureBuild = rayTracingIndirectAccelerationStructureBuild;
		RayTracingHostAccelerationStructureCommands = rayTracingHostAccelerationStructureCommands;
		RayQuery = rayQuery;
		RayTracingPrimitiveCulling = rayTracingPrimitiveCulling;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceRayTracingFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceRayTracingFeatures>.Equals(PhysicalDeviceRayTracingFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ RayTracing.GetHashCode() ^ RayTracingShaderGroupHandleCaptureReplay.GetHashCode()
			^ RayTracingShaderGroupHandleCaptureReplayMixed.GetHashCode() ^ RayTracingAccelerationStructureCaptureReplay.GetHashCode() ^ RayTracingIndirectTraceRays.GetHashCode() ^ RayTracingIndirectAccelerationStructureBuild.GetHashCode()
			^ RayTracingHostAccelerationStructureCommands.GetHashCode() ^ RayQuery.GetHashCode() ^ RayTracingPrimitiveCulling.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceRayTracingFeatures l, in PhysicalDeviceRayTracingFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.RayTracing == r.RayTracing) && (l.RayTracingShaderGroupHandleCaptureReplay == r.RayTracingShaderGroupHandleCaptureReplay)
			&& (l.RayTracingShaderGroupHandleCaptureReplayMixed == r.RayTracingShaderGroupHandleCaptureReplayMixed) && (l.RayTracingAccelerationStructureCaptureReplay == r.RayTracingAccelerationStructureCaptureReplay) && (l.RayTracingIndirectTraceRays == r.RayTracingIndirectTraceRays) && (l.RayTracingIndirectAccelerationStructureBuild == r.RayTracingIndirectAccelerationStructureBuild)
			&& (l.RayTracingHostAccelerationStructureCommands == r.RayTracingHostAccelerationStructureCommands) && (l.RayQuery == r.RayQuery) && (l.RayTracingPrimitiveCulling == r.RayTracingPrimitiveCulling)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceRayTracingFeatures l, in PhysicalDeviceRayTracingFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.RayTracing != r.RayTracing) || (l.RayTracingShaderGroupHandleCaptureReplay != r.RayTracingShaderGroupHandleCaptureReplay)
			|| (l.RayTracingShaderGroupHandleCaptureReplayMixed != r.RayTracingShaderGroupHandleCaptureReplayMixed) || (l.RayTracingAccelerationStructureCaptureReplay != r.RayTracingAccelerationStructureCaptureReplay) || (l.RayTracingIndirectTraceRays != r.RayTracingIndirectTraceRays) || (l.RayTracingIndirectAccelerationStructureBuild != r.RayTracingIndirectAccelerationStructureBuild)
			|| (l.RayTracingHostAccelerationStructureCommands != r.RayTracingHostAccelerationStructureCommands) || (l.RayQuery != r.RayQuery) || (l.RayTracingPrimitiveCulling != r.RayTracingPrimitiveCulling)
			;
	}


	/// <summary>Creates a new PhysicalDeviceRayTracingFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceRayTracingFeatures value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceRayTracingProperties : IEquatable<PhysicalDeviceRayTracingProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceRayTracingPropertiesKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public uint ShaderGroupHandleSize;
	public uint MaxRecursionDepth;
	public uint MaxShaderGroupStride;
	public uint ShaderGroupBaseAlignment;
	public ulong MaxGeometryCount;
	public ulong MaxInstanceCount;
	public ulong MaxPrimitiveCount;
	public uint MaxDescriptorSetAccelerationStructures;
	public uint ShaderGroupHandleCaptureReplaySize;
	public PhysicalDeviceRayTracingProperties(
		uint shaderGroupHandleSize = default,
		uint maxRecursionDepth = default,
		uint maxShaderGroupStride = default,
		uint shaderGroupBaseAlignment = default,
		ulong maxGeometryCount = default,
		ulong maxInstanceCount = default,
		ulong maxPrimitiveCount = default,
		uint maxDescriptorSetAccelerationStructures = default,
		uint shaderGroupHandleCaptureReplaySize = default
	) {
		sType = TYPE;
		pNext = null;
		ShaderGroupHandleSize = shaderGroupHandleSize;
		MaxRecursionDepth = maxRecursionDepth;
		MaxShaderGroupStride = maxShaderGroupStride;
		ShaderGroupBaseAlignment = shaderGroupBaseAlignment;
		MaxGeometryCount = maxGeometryCount;
		MaxInstanceCount = maxInstanceCount;
		MaxPrimitiveCount = maxPrimitiveCount;
		MaxDescriptorSetAccelerationStructures = maxDescriptorSetAccelerationStructures;
		ShaderGroupHandleCaptureReplaySize = shaderGroupHandleCaptureReplaySize;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceRayTracingProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceRayTracingProperties>.Equals(PhysicalDeviceRayTracingProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ShaderGroupHandleSize.GetHashCode() ^ MaxRecursionDepth.GetHashCode()
			^ MaxShaderGroupStride.GetHashCode() ^ ShaderGroupBaseAlignment.GetHashCode() ^ MaxGeometryCount.GetHashCode() ^ MaxInstanceCount.GetHashCode()
			^ MaxPrimitiveCount.GetHashCode() ^ MaxDescriptorSetAccelerationStructures.GetHashCode() ^ ShaderGroupHandleCaptureReplaySize.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceRayTracingProperties l, in PhysicalDeviceRayTracingProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ShaderGroupHandleSize == r.ShaderGroupHandleSize) && (l.MaxRecursionDepth == r.MaxRecursionDepth)
			&& (l.MaxShaderGroupStride == r.MaxShaderGroupStride) && (l.ShaderGroupBaseAlignment == r.ShaderGroupBaseAlignment) && (l.MaxGeometryCount == r.MaxGeometryCount) && (l.MaxInstanceCount == r.MaxInstanceCount)
			&& (l.MaxPrimitiveCount == r.MaxPrimitiveCount) && (l.MaxDescriptorSetAccelerationStructures == r.MaxDescriptorSetAccelerationStructures) && (l.ShaderGroupHandleCaptureReplaySize == r.ShaderGroupHandleCaptureReplaySize)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceRayTracingProperties l, in PhysicalDeviceRayTracingProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ShaderGroupHandleSize != r.ShaderGroupHandleSize) || (l.MaxRecursionDepth != r.MaxRecursionDepth)
			|| (l.MaxShaderGroupStride != r.MaxShaderGroupStride) || (l.ShaderGroupBaseAlignment != r.ShaderGroupBaseAlignment) || (l.MaxGeometryCount != r.MaxGeometryCount) || (l.MaxInstanceCount != r.MaxInstanceCount)
			|| (l.MaxPrimitiveCount != r.MaxPrimitiveCount) || (l.MaxDescriptorSetAccelerationStructures != r.MaxDescriptorSetAccelerationStructures) || (l.ShaderGroupHandleCaptureReplaySize != r.ShaderGroupHandleCaptureReplaySize)
			;
	}


	/// <summary>Creates a new PhysicalDeviceRayTracingProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceRayTracingProperties value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct StridedBufferRegion : IEquatable<StridedBufferRegion>
{
	public Vk.Handle<Vk.Buffer> Buffer;
	public Vk.DeviceSize Offset;
	public Vk.DeviceSize Stride;
	public Vk.DeviceSize Size;
	public StridedBufferRegion(
		in Vk.Handle<Vk.Buffer> buffer = default,
		in Vk.DeviceSize offset = default,
		in Vk.DeviceSize stride = default,
		in Vk.DeviceSize size = default
	) {
		Buffer = buffer;
		Offset = offset;
		Stride = stride;
		Size = size;
	}


	public readonly override bool Equals(object? obj) => (obj is StridedBufferRegion o) && (this == o);
	readonly bool IEquatable<StridedBufferRegion>.Equals(StridedBufferRegion obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Buffer.GetHashCode() ^ Offset.GetHashCode() ^ Stride.GetHashCode() ^ Size.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in StridedBufferRegion l, in StridedBufferRegion r)
	{
		return
			(l.Buffer == r.Buffer) && (l.Offset == r.Offset) && (l.Stride == r.Stride) && (l.Size == r.Size)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in StridedBufferRegion l, in StridedBufferRegion r)
	{
		return
			(l.Buffer != r.Buffer) || (l.Offset != r.Offset) || (l.Stride != r.Stride) || (l.Size != r.Size)
			;
	}


	/// <summary>Creates a new StridedBufferRegion value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out StridedBufferRegion value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct TraceRaysIndirectCommand : IEquatable<TraceRaysIndirectCommand>
{
	public uint Width;
	public uint Height;
	public uint Depth;
	public TraceRaysIndirectCommand(
		uint width = default,
		uint height = default,
		uint depth = default
	) {
		Width = width;
		Height = height;
		Depth = depth;
	}


	public readonly override bool Equals(object? obj) => (obj is TraceRaysIndirectCommand o) && (this == o);
	readonly bool IEquatable<TraceRaysIndirectCommand>.Equals(TraceRaysIndirectCommand obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Width.GetHashCode() ^ Height.GetHashCode() ^ Depth.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in TraceRaysIndirectCommand l, in TraceRaysIndirectCommand r)
	{
		return
			(l.Width == r.Width) && (l.Height == r.Height) && (l.Depth == r.Depth)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in TraceRaysIndirectCommand l, in TraceRaysIndirectCommand r)
	{
		return
			(l.Width != r.Width) || (l.Height != r.Height) || (l.Depth != r.Depth)
			;
	}


	/// <summary>Creates a new TraceRaysIndirectCommand value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out TraceRaysIndirectCommand value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SurfaceProtectedCapabilities : IEquatable<SurfaceProtectedCapabilities>
{
	public const Vk.StructureType TYPE = Vk.StructureType.SurfaceProtectedCapabilitiesKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 SupportsProtected;
	public SurfaceProtectedCapabilities(
		in Vk.Bool32 supportsProtected = default
	) {
		sType = TYPE;
		pNext = null;
		SupportsProtected = supportsProtected;
	}


	public readonly override bool Equals(object? obj) => (obj is SurfaceProtectedCapabilities o) && (this == o);
	readonly bool IEquatable<SurfaceProtectedCapabilities>.Equals(SurfaceProtectedCapabilities obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SupportsProtected.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SurfaceProtectedCapabilities l, in SurfaceProtectedCapabilities r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SupportsProtected == r.SupportsProtected)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SurfaceProtectedCapabilities l, in SurfaceProtectedCapabilities r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SupportsProtected != r.SupportsProtected)
			;
	}


	/// <summary>Creates a new SurfaceProtectedCapabilities value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SurfaceProtectedCapabilities value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceUniformBufferStandardLayoutFeatures : IEquatable<PhysicalDeviceUniformBufferStandardLayoutFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceUniformBufferStandardLayoutFeatures;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 UniformBufferStandardLayout;
	public PhysicalDeviceUniformBufferStandardLayoutFeatures(
		in Vk.Bool32 uniformBufferStandardLayout = default
	) {
		sType = TYPE;
		pNext = null;
		UniformBufferStandardLayout = uniformBufferStandardLayout;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceUniformBufferStandardLayoutFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceUniformBufferStandardLayoutFeatures>.Equals(PhysicalDeviceUniformBufferStandardLayoutFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ UniformBufferStandardLayout.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceUniformBufferStandardLayoutFeatures l, in PhysicalDeviceUniformBufferStandardLayoutFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.UniformBufferStandardLayout == r.UniformBufferStandardLayout)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceUniformBufferStandardLayoutFeatures l, in PhysicalDeviceUniformBufferStandardLayoutFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.UniformBufferStandardLayout != r.UniformBufferStandardLayout)
			;
	}


	/// <summary>Creates a new PhysicalDeviceUniformBufferStandardLayoutFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceUniformBufferStandardLayoutFeatures value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceBufferDeviceAddressFeatures : IEquatable<PhysicalDeviceBufferDeviceAddressFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceBufferDeviceAddressFeatures;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 BufferDeviceAddress;
	public Vk.Bool32 BufferDeviceAddressCaptureReplay;
	public Vk.Bool32 BufferDeviceAddressMultiDevice;
	public PhysicalDeviceBufferDeviceAddressFeatures(
		in Vk.Bool32 bufferDeviceAddress = default,
		in Vk.Bool32 bufferDeviceAddressCaptureReplay = default,
		in Vk.Bool32 bufferDeviceAddressMultiDevice = default
	) {
		sType = TYPE;
		pNext = null;
		BufferDeviceAddress = bufferDeviceAddress;
		BufferDeviceAddressCaptureReplay = bufferDeviceAddressCaptureReplay;
		BufferDeviceAddressMultiDevice = bufferDeviceAddressMultiDevice;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceBufferDeviceAddressFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceBufferDeviceAddressFeatures>.Equals(PhysicalDeviceBufferDeviceAddressFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ BufferDeviceAddress.GetHashCode() ^ BufferDeviceAddressCaptureReplay.GetHashCode()
			^ BufferDeviceAddressMultiDevice.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceBufferDeviceAddressFeatures l, in PhysicalDeviceBufferDeviceAddressFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.BufferDeviceAddress == r.BufferDeviceAddress) && (l.BufferDeviceAddressCaptureReplay == r.BufferDeviceAddressCaptureReplay)
			&& (l.BufferDeviceAddressMultiDevice == r.BufferDeviceAddressMultiDevice)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceBufferDeviceAddressFeatures l, in PhysicalDeviceBufferDeviceAddressFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.BufferDeviceAddress != r.BufferDeviceAddress) || (l.BufferDeviceAddressCaptureReplay != r.BufferDeviceAddressCaptureReplay)
			|| (l.BufferDeviceAddressMultiDevice != r.BufferDeviceAddressMultiDevice)
			;
	}


	/// <summary>Creates a new PhysicalDeviceBufferDeviceAddressFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceBufferDeviceAddressFeatures value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct BufferDeviceAddressInfo : IEquatable<BufferDeviceAddressInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.BufferDeviceAddressInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Handle<Vk.Buffer> Buffer;
	public BufferDeviceAddressInfo(
		in Vk.Handle<Vk.Buffer> buffer = default
	) {
		sType = TYPE;
		pNext = null;
		Buffer = buffer;
	}


	public readonly override bool Equals(object? obj) => (obj is BufferDeviceAddressInfo o) && (this == o);
	readonly bool IEquatable<BufferDeviceAddressInfo>.Equals(BufferDeviceAddressInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Buffer.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in BufferDeviceAddressInfo l, in BufferDeviceAddressInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Buffer == r.Buffer)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in BufferDeviceAddressInfo l, in BufferDeviceAddressInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Buffer != r.Buffer)
			;
	}


	/// <summary>Creates a new BufferDeviceAddressInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out BufferDeviceAddressInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct BufferOpaqueCaptureAddressCreateInfo : IEquatable<BufferOpaqueCaptureAddressCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.BufferOpaqueCaptureAddressCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public ulong OpaqueCaptureAddress;
	public BufferOpaqueCaptureAddressCreateInfo(
		ulong opaqueCaptureAddress = default
	) {
		sType = TYPE;
		pNext = null;
		OpaqueCaptureAddress = opaqueCaptureAddress;
	}


	public readonly override bool Equals(object? obj) => (obj is BufferOpaqueCaptureAddressCreateInfo o) && (this == o);
	readonly bool IEquatable<BufferOpaqueCaptureAddressCreateInfo>.Equals(BufferOpaqueCaptureAddressCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ OpaqueCaptureAddress.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in BufferOpaqueCaptureAddressCreateInfo l, in BufferOpaqueCaptureAddressCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.OpaqueCaptureAddress == r.OpaqueCaptureAddress)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in BufferOpaqueCaptureAddressCreateInfo l, in BufferOpaqueCaptureAddressCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.OpaqueCaptureAddress != r.OpaqueCaptureAddress)
			;
	}


	/// <summary>Creates a new BufferOpaqueCaptureAddressCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out BufferOpaqueCaptureAddressCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceImagelessFramebufferFeatures : IEquatable<PhysicalDeviceImagelessFramebufferFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceImagelessFramebufferFeatures;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 ImagelessFramebuffer;
	public PhysicalDeviceImagelessFramebufferFeatures(
		in Vk.Bool32 imagelessFramebuffer = default
	) {
		sType = TYPE;
		pNext = null;
		ImagelessFramebuffer = imagelessFramebuffer;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceImagelessFramebufferFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceImagelessFramebufferFeatures>.Equals(PhysicalDeviceImagelessFramebufferFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ImagelessFramebuffer.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceImagelessFramebufferFeatures l, in PhysicalDeviceImagelessFramebufferFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ImagelessFramebuffer == r.ImagelessFramebuffer)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceImagelessFramebufferFeatures l, in PhysicalDeviceImagelessFramebufferFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ImagelessFramebuffer != r.ImagelessFramebuffer)
			;
	}


	/// <summary>Creates a new PhysicalDeviceImagelessFramebufferFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceImagelessFramebufferFeatures value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct FramebufferAttachmentsCreateInfo : IEquatable<FramebufferAttachmentsCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.FramebufferAttachmentsCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public uint AttachmentImageInfoCount;
	public Vk.FramebufferAttachmentImageInfo* AttachmentImageInfos;
	public FramebufferAttachmentsCreateInfo(
		uint attachmentImageInfoCount = default,
		in Vk.FramebufferAttachmentImageInfo* attachmentImageInfos = default
	) {
		sType = TYPE;
		pNext = null;
		AttachmentImageInfoCount = attachmentImageInfoCount;
		AttachmentImageInfos = attachmentImageInfos;
	}


	public readonly override bool Equals(object? obj) => (obj is FramebufferAttachmentsCreateInfo o) && (this == o);
	readonly bool IEquatable<FramebufferAttachmentsCreateInfo>.Equals(FramebufferAttachmentsCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ AttachmentImageInfoCount.GetHashCode() ^ ((ulong)AttachmentImageInfos).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in FramebufferAttachmentsCreateInfo l, in FramebufferAttachmentsCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.AttachmentImageInfoCount == r.AttachmentImageInfoCount) && (l.AttachmentImageInfos == r.AttachmentImageInfos)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in FramebufferAttachmentsCreateInfo l, in FramebufferAttachmentsCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.AttachmentImageInfoCount != r.AttachmentImageInfoCount) || (l.AttachmentImageInfos != r.AttachmentImageInfos)
			;
	}


	/// <summary>Creates a new FramebufferAttachmentsCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out FramebufferAttachmentsCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct FramebufferAttachmentImageInfo : IEquatable<FramebufferAttachmentImageInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.FramebufferAttachmentImageInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.ImageCreateFlags Flags;
	public Vk.ImageUsageFlags Usage;
	public uint Width;
	public uint Height;
	public uint LayerCount;
	public uint ViewFormatCount;
	public Vk.Format* ViewFormats;
	public FramebufferAttachmentImageInfo(
		in Vk.ImageCreateFlags flags = default,
		in Vk.ImageUsageFlags usage = default,
		uint width = default,
		uint height = default,
		uint layerCount = default,
		uint viewFormatCount = default,
		in Vk.Format* viewFormats = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		Usage = usage;
		Width = width;
		Height = height;
		LayerCount = layerCount;
		ViewFormatCount = viewFormatCount;
		ViewFormats = viewFormats;
	}


	public readonly override bool Equals(object? obj) => (obj is FramebufferAttachmentImageInfo o) && (this == o);
	readonly bool IEquatable<FramebufferAttachmentImageInfo>.Equals(FramebufferAttachmentImageInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ Usage.GetHashCode()
			^ Width.GetHashCode() ^ Height.GetHashCode() ^ LayerCount.GetHashCode() ^ ViewFormatCount.GetHashCode()
			^ ((ulong)ViewFormats).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in FramebufferAttachmentImageInfo l, in FramebufferAttachmentImageInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.Usage == r.Usage)
			&& (l.Width == r.Width) && (l.Height == r.Height) && (l.LayerCount == r.LayerCount) && (l.ViewFormatCount == r.ViewFormatCount)
			&& (l.ViewFormats == r.ViewFormats)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in FramebufferAttachmentImageInfo l, in FramebufferAttachmentImageInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.Usage != r.Usage)
			|| (l.Width != r.Width) || (l.Height != r.Height) || (l.LayerCount != r.LayerCount) || (l.ViewFormatCount != r.ViewFormatCount)
			|| (l.ViewFormats != r.ViewFormats)
			;
	}


	/// <summary>Creates a new FramebufferAttachmentImageInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out FramebufferAttachmentImageInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct RenderPassAttachmentBeginInfo : IEquatable<RenderPassAttachmentBeginInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.RenderPassAttachmentBeginInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public uint AttachmentCount;
	public Vk.Handle<Vk.ImageView>* Attachments;
	public RenderPassAttachmentBeginInfo(
		uint attachmentCount = default,
		in Vk.Handle<Vk.ImageView>* attachments = default
	) {
		sType = TYPE;
		pNext = null;
		AttachmentCount = attachmentCount;
		Attachments = attachments;
	}


	public readonly override bool Equals(object? obj) => (obj is RenderPassAttachmentBeginInfo o) && (this == o);
	readonly bool IEquatable<RenderPassAttachmentBeginInfo>.Equals(RenderPassAttachmentBeginInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ AttachmentCount.GetHashCode() ^ ((ulong)Attachments).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in RenderPassAttachmentBeginInfo l, in RenderPassAttachmentBeginInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.AttachmentCount == r.AttachmentCount) && (l.Attachments == r.Attachments)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in RenderPassAttachmentBeginInfo l, in RenderPassAttachmentBeginInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.AttachmentCount != r.AttachmentCount) || (l.Attachments != r.Attachments)
			;
	}


	/// <summary>Creates a new RenderPassAttachmentBeginInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out RenderPassAttachmentBeginInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDevicePerformanceQueryFeatures : IEquatable<PhysicalDevicePerformanceQueryFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDevicePerformanceQueryFeaturesKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 PerformanceCounterQueryPools;
	public Vk.Bool32 PerformanceCounterMultipleQueryPools;
	public PhysicalDevicePerformanceQueryFeatures(
		in Vk.Bool32 performanceCounterQueryPools = default,
		in Vk.Bool32 performanceCounterMultipleQueryPools = default
	) {
		sType = TYPE;
		pNext = null;
		PerformanceCounterQueryPools = performanceCounterQueryPools;
		PerformanceCounterMultipleQueryPools = performanceCounterMultipleQueryPools;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDevicePerformanceQueryFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDevicePerformanceQueryFeatures>.Equals(PhysicalDevicePerformanceQueryFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ PerformanceCounterQueryPools.GetHashCode() ^ PerformanceCounterMultipleQueryPools.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDevicePerformanceQueryFeatures l, in PhysicalDevicePerformanceQueryFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.PerformanceCounterQueryPools == r.PerformanceCounterQueryPools) && (l.PerformanceCounterMultipleQueryPools == r.PerformanceCounterMultipleQueryPools)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDevicePerformanceQueryFeatures l, in PhysicalDevicePerformanceQueryFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.PerformanceCounterQueryPools != r.PerformanceCounterQueryPools) || (l.PerformanceCounterMultipleQueryPools != r.PerformanceCounterMultipleQueryPools)
			;
	}


	/// <summary>Creates a new PhysicalDevicePerformanceQueryFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDevicePerformanceQueryFeatures value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDevicePerformanceQueryProperties : IEquatable<PhysicalDevicePerformanceQueryProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDevicePerformanceQueryPropertiesKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 AllowCommandBufferQueryCopies;
	public PhysicalDevicePerformanceQueryProperties(
		in Vk.Bool32 allowCommandBufferQueryCopies = default
	) {
		sType = TYPE;
		pNext = null;
		AllowCommandBufferQueryCopies = allowCommandBufferQueryCopies;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDevicePerformanceQueryProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDevicePerformanceQueryProperties>.Equals(PhysicalDevicePerformanceQueryProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ AllowCommandBufferQueryCopies.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDevicePerformanceQueryProperties l, in PhysicalDevicePerformanceQueryProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.AllowCommandBufferQueryCopies == r.AllowCommandBufferQueryCopies)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDevicePerformanceQueryProperties l, in PhysicalDevicePerformanceQueryProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.AllowCommandBufferQueryCopies != r.AllowCommandBufferQueryCopies)
			;
	}


	/// <summary>Creates a new PhysicalDevicePerformanceQueryProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDevicePerformanceQueryProperties value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PerformanceCounter : IEquatable<PerformanceCounter>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PerformanceCounterKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.KHR.PerformanceCounterUnit Unit;
	public Vk.KHR.PerformanceCounterScope Scope;
	public Vk.KHR.PerformanceCounterStorage Storage;
	public Vk.UUID Uuid;
	public PerformanceCounter(
		in Vk.KHR.PerformanceCounterUnit unit = default,
		in Vk.KHR.PerformanceCounterScope scope = default,
		in Vk.KHR.PerformanceCounterStorage storage = default,
		in Vk.UUID uuid = default
	) {
		sType = TYPE;
		pNext = null;
		Unit = unit;
		Scope = scope;
		Storage = storage;
		Uuid = uuid;
	}


	public readonly override bool Equals(object? obj) => (obj is PerformanceCounter o) && (this == o);
	readonly bool IEquatable<PerformanceCounter>.Equals(PerformanceCounter obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Unit.GetHashCode() ^ Scope.GetHashCode()
			^ Storage.GetHashCode() ^ Uuid.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PerformanceCounter l, in PerformanceCounter r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Unit == r.Unit) && (l.Scope == r.Scope)
			&& (l.Storage == r.Storage) && (l.Uuid == r.Uuid)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PerformanceCounter l, in PerformanceCounter r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Unit != r.Unit) || (l.Scope != r.Scope)
			|| (l.Storage != r.Storage) || (l.Uuid != r.Uuid)
			;
	}


	/// <summary>Creates a new PerformanceCounter value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PerformanceCounter value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PerformanceCounterDescription : IEquatable<PerformanceCounterDescription>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PerformanceCounterDescriptionKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.KHR.PerformanceCounterDescriptionFlags Flags;
	public Vk.FixedString Name;
	public Vk.FixedString Category;
	public Vk.FixedString Description;
	public PerformanceCounterDescription(
		in Vk.KHR.PerformanceCounterDescriptionFlags flags = default,
		in Vk.FixedString name = default,
		in Vk.FixedString category = default,
		in Vk.FixedString description = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		Name = name;
		Category = category;
		Description = description;
	}


	public readonly override bool Equals(object? obj) => (obj is PerformanceCounterDescription o) && (this == o);
	readonly bool IEquatable<PerformanceCounterDescription>.Equals(PerformanceCounterDescription obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ Name.GetHashCode()
			^ Category.GetHashCode() ^ Description.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PerformanceCounterDescription l, in PerformanceCounterDescription r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.Name == r.Name)
			&& (l.Category == r.Category) && (l.Description == r.Description)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PerformanceCounterDescription l, in PerformanceCounterDescription r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.Name != r.Name)
			|| (l.Category != r.Category) || (l.Description != r.Description)
			;
	}


	/// <summary>Creates a new PerformanceCounterDescription value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PerformanceCounterDescription value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct QueryPoolPerformanceCreateInfo : IEquatable<QueryPoolPerformanceCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.QueryPoolPerformanceCreateInfoKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public uint QueueFamilyIndex;
	public uint CounterIndexCount;
	public uint* CounterIndices;
	public QueryPoolPerformanceCreateInfo(
		uint queueFamilyIndex = default,
		uint counterIndexCount = default,
		uint* counterIndices = default
	) {
		sType = TYPE;
		pNext = null;
		QueueFamilyIndex = queueFamilyIndex;
		CounterIndexCount = counterIndexCount;
		CounterIndices = counterIndices;
	}


	public readonly override bool Equals(object? obj) => (obj is QueryPoolPerformanceCreateInfo o) && (this == o);
	readonly bool IEquatable<QueryPoolPerformanceCreateInfo>.Equals(QueryPoolPerformanceCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ QueueFamilyIndex.GetHashCode() ^ CounterIndexCount.GetHashCode()
			^ ((ulong)CounterIndices).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in QueryPoolPerformanceCreateInfo l, in QueryPoolPerformanceCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.QueueFamilyIndex == r.QueueFamilyIndex) && (l.CounterIndexCount == r.CounterIndexCount)
			&& (l.CounterIndices == r.CounterIndices)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in QueryPoolPerformanceCreateInfo l, in QueryPoolPerformanceCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.QueueFamilyIndex != r.QueueFamilyIndex) || (l.CounterIndexCount != r.CounterIndexCount)
			|| (l.CounterIndices != r.CounterIndices)
			;
	}


	/// <summary>Creates a new QueryPoolPerformanceCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out QueryPoolPerformanceCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Explicit)]
public unsafe partial struct PerformanceCounterResult : IEquatable<PerformanceCounterResult>
{
	[FieldOffset(0)] public int Int32;
	[FieldOffset(0)] public long Int64;
	[FieldOffset(0)] public uint Uint32;
	[FieldOffset(0)] public ulong Uint64;
	[FieldOffset(0)] public float Float32;
	[FieldOffset(0)] public double Float64;

	public readonly override bool Equals(object? obj) => (obj is PerformanceCounterResult o) && (this == o);
	readonly bool IEquatable<PerformanceCounterResult>.Equals(PerformanceCounterResult obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Int32.GetHashCode() ^ Int64.GetHashCode() ^ Uint32.GetHashCode() ^ Uint64.GetHashCode()
			^ Float32.GetHashCode() ^ Float64.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PerformanceCounterResult l, in PerformanceCounterResult r)
	{
		return
			(l.Int32 == r.Int32) && (l.Int64 == r.Int64) && (l.Uint32 == r.Uint32) && (l.Uint64 == r.Uint64)
			&& (l.Float32 == r.Float32) && (l.Float64 == r.Float64)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PerformanceCounterResult l, in PerformanceCounterResult r)
	{
		return
			(l.Int32 != r.Int32) || (l.Int64 != r.Int64) || (l.Uint32 != r.Uint32) || (l.Uint64 != r.Uint64)
			|| (l.Float32 != r.Float32) || (l.Float64 != r.Float64)
			;
	}


	/// <summary>Creates a new PerformanceCounterResult value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PerformanceCounterResult value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct AcquireProfilingLockInfo : IEquatable<AcquireProfilingLockInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.AcquireProfilingLockInfoKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.KHR.AcquireProfilingLockFlags Flags;
	public ulong Timeout;
	public AcquireProfilingLockInfo(
		in Vk.KHR.AcquireProfilingLockFlags flags = default,
		ulong timeout = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		Timeout = timeout;
	}


	public readonly override bool Equals(object? obj) => (obj is AcquireProfilingLockInfo o) && (this == o);
	readonly bool IEquatable<AcquireProfilingLockInfo>.Equals(AcquireProfilingLockInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ Timeout.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in AcquireProfilingLockInfo l, in AcquireProfilingLockInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.Timeout == r.Timeout)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in AcquireProfilingLockInfo l, in AcquireProfilingLockInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.Timeout != r.Timeout)
			;
	}


	/// <summary>Creates a new AcquireProfilingLockInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out AcquireProfilingLockInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PerformanceQuerySubmitInfo : IEquatable<PerformanceQuerySubmitInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PerformanceQuerySubmitInfoKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public uint CounterPassIndex;
	public PerformanceQuerySubmitInfo(
		uint counterPassIndex = default
	) {
		sType = TYPE;
		pNext = null;
		CounterPassIndex = counterPassIndex;
	}


	public readonly override bool Equals(object? obj) => (obj is PerformanceQuerySubmitInfo o) && (this == o);
	readonly bool IEquatable<PerformanceQuerySubmitInfo>.Equals(PerformanceQuerySubmitInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ CounterPassIndex.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PerformanceQuerySubmitInfo l, in PerformanceQuerySubmitInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.CounterPassIndex == r.CounterPassIndex)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PerformanceQuerySubmitInfo l, in PerformanceQuerySubmitInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.CounterPassIndex != r.CounterPassIndex)
			;
	}


	/// <summary>Creates a new PerformanceQuerySubmitInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PerformanceQuerySubmitInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceShaderClockFeatures : IEquatable<PhysicalDeviceShaderClockFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceShaderClockFeaturesKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 ShaderSubgroupClock;
	public Vk.Bool32 ShaderDeviceClock;
	public PhysicalDeviceShaderClockFeatures(
		in Vk.Bool32 shaderSubgroupClock = default,
		in Vk.Bool32 shaderDeviceClock = default
	) {
		sType = TYPE;
		pNext = null;
		ShaderSubgroupClock = shaderSubgroupClock;
		ShaderDeviceClock = shaderDeviceClock;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceShaderClockFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceShaderClockFeatures>.Equals(PhysicalDeviceShaderClockFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ShaderSubgroupClock.GetHashCode() ^ ShaderDeviceClock.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceShaderClockFeatures l, in PhysicalDeviceShaderClockFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ShaderSubgroupClock == r.ShaderSubgroupClock) && (l.ShaderDeviceClock == r.ShaderDeviceClock)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceShaderClockFeatures l, in PhysicalDeviceShaderClockFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ShaderSubgroupClock != r.ShaderSubgroupClock) || (l.ShaderDeviceClock != r.ShaderDeviceClock)
			;
	}


	/// <summary>Creates a new PhysicalDeviceShaderClockFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceShaderClockFeatures value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceSeparateDepthStencilLayoutsFeatures : IEquatable<PhysicalDeviceSeparateDepthStencilLayoutsFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceSeparateDepthStencilLayoutsFeatures;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 SeparateDepthStencilLayouts;
	public PhysicalDeviceSeparateDepthStencilLayoutsFeatures(
		in Vk.Bool32 separateDepthStencilLayouts = default
	) {
		sType = TYPE;
		pNext = null;
		SeparateDepthStencilLayouts = separateDepthStencilLayouts;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceSeparateDepthStencilLayoutsFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceSeparateDepthStencilLayoutsFeatures>.Equals(PhysicalDeviceSeparateDepthStencilLayoutsFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SeparateDepthStencilLayouts.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceSeparateDepthStencilLayoutsFeatures l, in PhysicalDeviceSeparateDepthStencilLayoutsFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SeparateDepthStencilLayouts == r.SeparateDepthStencilLayouts)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceSeparateDepthStencilLayoutsFeatures l, in PhysicalDeviceSeparateDepthStencilLayoutsFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SeparateDepthStencilLayouts != r.SeparateDepthStencilLayouts)
			;
	}


	/// <summary>Creates a new PhysicalDeviceSeparateDepthStencilLayoutsFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceSeparateDepthStencilLayoutsFeatures value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct AttachmentReferenceStencilLayout : IEquatable<AttachmentReferenceStencilLayout>
{
	public const Vk.StructureType TYPE = Vk.StructureType.AttachmentReferenceStencilLayout;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.ImageLayout StencilLayout;
	public AttachmentReferenceStencilLayout(
		in Vk.ImageLayout stencilLayout = default
	) {
		sType = TYPE;
		pNext = null;
		StencilLayout = stencilLayout;
	}


	public readonly override bool Equals(object? obj) => (obj is AttachmentReferenceStencilLayout o) && (this == o);
	readonly bool IEquatable<AttachmentReferenceStencilLayout>.Equals(AttachmentReferenceStencilLayout obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ StencilLayout.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in AttachmentReferenceStencilLayout l, in AttachmentReferenceStencilLayout r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.StencilLayout == r.StencilLayout)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in AttachmentReferenceStencilLayout l, in AttachmentReferenceStencilLayout r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.StencilLayout != r.StencilLayout)
			;
	}


	/// <summary>Creates a new AttachmentReferenceStencilLayout value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out AttachmentReferenceStencilLayout value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct AttachmentDescriptionStencilLayout : IEquatable<AttachmentDescriptionStencilLayout>
{
	public const Vk.StructureType TYPE = Vk.StructureType.AttachmentDescriptionStencilLayout;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.ImageLayout StencilInitialLayout;
	public Vk.ImageLayout StencilFinalLayout;
	public AttachmentDescriptionStencilLayout(
		in Vk.ImageLayout stencilInitialLayout = default,
		in Vk.ImageLayout stencilFinalLayout = default
	) {
		sType = TYPE;
		pNext = null;
		StencilInitialLayout = stencilInitialLayout;
		StencilFinalLayout = stencilFinalLayout;
	}


	public readonly override bool Equals(object? obj) => (obj is AttachmentDescriptionStencilLayout o) && (this == o);
	readonly bool IEquatable<AttachmentDescriptionStencilLayout>.Equals(AttachmentDescriptionStencilLayout obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ StencilInitialLayout.GetHashCode() ^ StencilFinalLayout.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in AttachmentDescriptionStencilLayout l, in AttachmentDescriptionStencilLayout r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.StencilInitialLayout == r.StencilInitialLayout) && (l.StencilFinalLayout == r.StencilFinalLayout)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in AttachmentDescriptionStencilLayout l, in AttachmentDescriptionStencilLayout r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.StencilInitialLayout != r.StencilInitialLayout) || (l.StencilFinalLayout != r.StencilFinalLayout)
			;
	}


	/// <summary>Creates a new AttachmentDescriptionStencilLayout value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out AttachmentDescriptionStencilLayout value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDevicePipelineExecutablePropertiesFeatures : IEquatable<PhysicalDevicePipelineExecutablePropertiesFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDevicePipelineExecutablePropertiesFeaturesKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 PipelineExecutableInfo;
	public PhysicalDevicePipelineExecutablePropertiesFeatures(
		in Vk.Bool32 pipelineExecutableInfo = default
	) {
		sType = TYPE;
		pNext = null;
		PipelineExecutableInfo = pipelineExecutableInfo;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDevicePipelineExecutablePropertiesFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDevicePipelineExecutablePropertiesFeatures>.Equals(PhysicalDevicePipelineExecutablePropertiesFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ PipelineExecutableInfo.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDevicePipelineExecutablePropertiesFeatures l, in PhysicalDevicePipelineExecutablePropertiesFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.PipelineExecutableInfo == r.PipelineExecutableInfo)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDevicePipelineExecutablePropertiesFeatures l, in PhysicalDevicePipelineExecutablePropertiesFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.PipelineExecutableInfo != r.PipelineExecutableInfo)
			;
	}


	/// <summary>Creates a new PhysicalDevicePipelineExecutablePropertiesFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDevicePipelineExecutablePropertiesFeatures value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PipelineInfo : IEquatable<PipelineInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PipelineInfoKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Handle<Vk.Pipeline> Pipeline;
	public PipelineInfo(
		in Vk.Handle<Vk.Pipeline> pipeline = default
	) {
		sType = TYPE;
		pNext = null;
		Pipeline = pipeline;
	}


	public readonly override bool Equals(object? obj) => (obj is PipelineInfo o) && (this == o);
	readonly bool IEquatable<PipelineInfo>.Equals(PipelineInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Pipeline.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PipelineInfo l, in PipelineInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Pipeline == r.Pipeline)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PipelineInfo l, in PipelineInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Pipeline != r.Pipeline)
			;
	}


	/// <summary>Creates a new PipelineInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PipelineInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PipelineExecutableProperties : IEquatable<PipelineExecutableProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PipelineExecutablePropertiesKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.ShaderStageFlags Stages;
	public Vk.FixedString Name;
	public Vk.FixedString Description;
	public uint SubgroupSize;
	public PipelineExecutableProperties(
		in Vk.ShaderStageFlags stages = default,
		in Vk.FixedString name = default,
		in Vk.FixedString description = default,
		uint subgroupSize = default
	) {
		sType = TYPE;
		pNext = null;
		Stages = stages;
		Name = name;
		Description = description;
		SubgroupSize = subgroupSize;
	}


	public readonly override bool Equals(object? obj) => (obj is PipelineExecutableProperties o) && (this == o);
	readonly bool IEquatable<PipelineExecutableProperties>.Equals(PipelineExecutableProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Stages.GetHashCode() ^ Name.GetHashCode()
			^ Description.GetHashCode() ^ SubgroupSize.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PipelineExecutableProperties l, in PipelineExecutableProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Stages == r.Stages) && (l.Name == r.Name)
			&& (l.Description == r.Description) && (l.SubgroupSize == r.SubgroupSize)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PipelineExecutableProperties l, in PipelineExecutableProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Stages != r.Stages) || (l.Name != r.Name)
			|| (l.Description != r.Description) || (l.SubgroupSize != r.SubgroupSize)
			;
	}


	/// <summary>Creates a new PipelineExecutableProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PipelineExecutableProperties value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PipelineExecutableInfo : IEquatable<PipelineExecutableInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PipelineExecutableInfoKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Handle<Vk.Pipeline> Pipeline;
	public uint ExecutableIndex;
	public PipelineExecutableInfo(
		in Vk.Handle<Vk.Pipeline> pipeline = default,
		uint executableIndex = default
	) {
		sType = TYPE;
		pNext = null;
		Pipeline = pipeline;
		ExecutableIndex = executableIndex;
	}


	public readonly override bool Equals(object? obj) => (obj is PipelineExecutableInfo o) && (this == o);
	readonly bool IEquatable<PipelineExecutableInfo>.Equals(PipelineExecutableInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Pipeline.GetHashCode() ^ ExecutableIndex.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PipelineExecutableInfo l, in PipelineExecutableInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Pipeline == r.Pipeline) && (l.ExecutableIndex == r.ExecutableIndex)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PipelineExecutableInfo l, in PipelineExecutableInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Pipeline != r.Pipeline) || (l.ExecutableIndex != r.ExecutableIndex)
			;
	}


	/// <summary>Creates a new PipelineExecutableInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PipelineExecutableInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Explicit)]
public unsafe partial struct PipelineExecutableStatisticValue : IEquatable<PipelineExecutableStatisticValue>
{
	[FieldOffset(0)] public Vk.Bool32 B32;
	[FieldOffset(0)] public long I64;
	[FieldOffset(0)] public ulong U64;
	[FieldOffset(0)] public double F64;

	public readonly override bool Equals(object? obj) => (obj is PipelineExecutableStatisticValue o) && (this == o);
	readonly bool IEquatable<PipelineExecutableStatisticValue>.Equals(PipelineExecutableStatisticValue obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			B32.GetHashCode() ^ I64.GetHashCode() ^ U64.GetHashCode() ^ F64.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PipelineExecutableStatisticValue l, in PipelineExecutableStatisticValue r)
	{
		return
			(l.B32 == r.B32) && (l.I64 == r.I64) && (l.U64 == r.U64) && (l.F64 == r.F64)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PipelineExecutableStatisticValue l, in PipelineExecutableStatisticValue r)
	{
		return
			(l.B32 != r.B32) || (l.I64 != r.I64) || (l.U64 != r.U64) || (l.F64 != r.F64)
			;
	}


	/// <summary>Creates a new PipelineExecutableStatisticValue value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PipelineExecutableStatisticValue value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PipelineExecutableStatistic : IEquatable<PipelineExecutableStatistic>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PipelineExecutableStatisticKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.FixedString Name;
	public Vk.FixedString Description;
	public Vk.KHR.PipelineExecutableStatisticFormat Format;
	public Vk.KHR.PipelineExecutableStatisticValue Value;
	public PipelineExecutableStatistic(
		in Vk.FixedString name = default,
		in Vk.FixedString description = default,
		in Vk.KHR.PipelineExecutableStatisticFormat format = default,
		in Vk.KHR.PipelineExecutableStatisticValue value = default
	) {
		sType = TYPE;
		pNext = null;
		Name = name;
		Description = description;
		Format = format;
		Value = value;
	}


	public readonly override bool Equals(object? obj) => (obj is PipelineExecutableStatistic o) && (this == o);
	readonly bool IEquatable<PipelineExecutableStatistic>.Equals(PipelineExecutableStatistic obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Name.GetHashCode() ^ Description.GetHashCode()
			^ Format.GetHashCode() ^ Value.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PipelineExecutableStatistic l, in PipelineExecutableStatistic r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Name == r.Name) && (l.Description == r.Description)
			&& (l.Format == r.Format) && (l.Value == r.Value)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PipelineExecutableStatistic l, in PipelineExecutableStatistic r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Name != r.Name) || (l.Description != r.Description)
			|| (l.Format != r.Format) || (l.Value != r.Value)
			;
	}


	/// <summary>Creates a new PipelineExecutableStatistic value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PipelineExecutableStatistic value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PipelineExecutableInternalRepresentation : IEquatable<PipelineExecutableInternalRepresentation>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PipelineExecutableInternalRepresentationKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.FixedString Name;
	public Vk.FixedString Description;
	public Vk.Bool32 IsText;
	public ulong DataSize;
	public void* Data;
	public PipelineExecutableInternalRepresentation(
		in Vk.FixedString name = default,
		in Vk.FixedString description = default,
		in Vk.Bool32 isText = default,
		ulong dataSize = default,
		void* data = default
	) {
		sType = TYPE;
		pNext = null;
		Name = name;
		Description = description;
		IsText = isText;
		DataSize = dataSize;
		Data = data;
	}


	public readonly override bool Equals(object? obj) => (obj is PipelineExecutableInternalRepresentation o) && (this == o);
	readonly bool IEquatable<PipelineExecutableInternalRepresentation>.Equals(PipelineExecutableInternalRepresentation obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Name.GetHashCode() ^ Description.GetHashCode()
			^ IsText.GetHashCode() ^ DataSize.GetHashCode() ^ ((ulong)Data).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PipelineExecutableInternalRepresentation l, in PipelineExecutableInternalRepresentation r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Name == r.Name) && (l.Description == r.Description)
			&& (l.IsText == r.IsText) && (l.DataSize == r.DataSize) && (l.Data == r.Data)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PipelineExecutableInternalRepresentation l, in PipelineExecutableInternalRepresentation r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Name != r.Name) || (l.Description != r.Description)
			|| (l.IsText != r.IsText) || (l.DataSize != r.DataSize) || (l.Data != r.Data)
			;
	}


	/// <summary>Creates a new PipelineExecutableInternalRepresentation value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PipelineExecutableInternalRepresentation value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct MemoryOpaqueCaptureAddressAllocateInfo : IEquatable<MemoryOpaqueCaptureAddressAllocateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.MemoryOpaqueCaptureAddressAllocateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public ulong OpaqueCaptureAddress;
	public MemoryOpaqueCaptureAddressAllocateInfo(
		ulong opaqueCaptureAddress = default
	) {
		sType = TYPE;
		pNext = null;
		OpaqueCaptureAddress = opaqueCaptureAddress;
	}


	public readonly override bool Equals(object? obj) => (obj is MemoryOpaqueCaptureAddressAllocateInfo o) && (this == o);
	readonly bool IEquatable<MemoryOpaqueCaptureAddressAllocateInfo>.Equals(MemoryOpaqueCaptureAddressAllocateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ OpaqueCaptureAddress.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in MemoryOpaqueCaptureAddressAllocateInfo l, in MemoryOpaqueCaptureAddressAllocateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.OpaqueCaptureAddress == r.OpaqueCaptureAddress)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in MemoryOpaqueCaptureAddressAllocateInfo l, in MemoryOpaqueCaptureAddressAllocateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.OpaqueCaptureAddress != r.OpaqueCaptureAddress)
			;
	}


	/// <summary>Creates a new MemoryOpaqueCaptureAddressAllocateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out MemoryOpaqueCaptureAddressAllocateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DeviceMemoryOpaqueCaptureAddressInfo : IEquatable<DeviceMemoryOpaqueCaptureAddressInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DeviceMemoryOpaqueCaptureAddressInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Handle<Vk.DeviceMemory> Memory;
	public DeviceMemoryOpaqueCaptureAddressInfo(
		in Vk.Handle<Vk.DeviceMemory> memory = default
	) {
		sType = TYPE;
		pNext = null;
		Memory = memory;
	}


	public readonly override bool Equals(object? obj) => (obj is DeviceMemoryOpaqueCaptureAddressInfo o) && (this == o);
	readonly bool IEquatable<DeviceMemoryOpaqueCaptureAddressInfo>.Equals(DeviceMemoryOpaqueCaptureAddressInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Memory.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DeviceMemoryOpaqueCaptureAddressInfo l, in DeviceMemoryOpaqueCaptureAddressInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Memory == r.Memory)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DeviceMemoryOpaqueCaptureAddressInfo l, in DeviceMemoryOpaqueCaptureAddressInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Memory != r.Memory)
			;
	}


	/// <summary>Creates a new DeviceMemoryOpaqueCaptureAddressInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DeviceMemoryOpaqueCaptureAddressInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Explicit)]
public unsafe partial struct DeviceOrHostAddress : IEquatable<DeviceOrHostAddress>
{
	[FieldOffset(0)] public ulong DeviceAddress;
	[FieldOffset(0)] public void* HostAddress;

	public readonly override bool Equals(object? obj) => (obj is DeviceOrHostAddress o) && (this == o);
	readonly bool IEquatable<DeviceOrHostAddress>.Equals(DeviceOrHostAddress obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			DeviceAddress.GetHashCode() ^ ((ulong)HostAddress).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DeviceOrHostAddress l, in DeviceOrHostAddress r)
	{
		return
			(l.DeviceAddress == r.DeviceAddress) && (l.HostAddress == r.HostAddress)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DeviceOrHostAddress l, in DeviceOrHostAddress r)
	{
		return
			(l.DeviceAddress != r.DeviceAddress) || (l.HostAddress != r.HostAddress)
			;
	}


	/// <summary>Creates a new DeviceOrHostAddress value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DeviceOrHostAddress value) => value = new();
}

[StructLayout(LayoutKind.Explicit)]
public unsafe partial struct DeviceOrHostAddressConst : IEquatable<DeviceOrHostAddressConst>
{
	[FieldOffset(0)] public ulong DeviceAddress;
	[FieldOffset(0)] public void* HostAddress;

	public readonly override bool Equals(object? obj) => (obj is DeviceOrHostAddressConst o) && (this == o);
	readonly bool IEquatable<DeviceOrHostAddressConst>.Equals(DeviceOrHostAddressConst obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			DeviceAddress.GetHashCode() ^ ((ulong)HostAddress).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DeviceOrHostAddressConst l, in DeviceOrHostAddressConst r)
	{
		return
			(l.DeviceAddress == r.DeviceAddress) && (l.HostAddress == r.HostAddress)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DeviceOrHostAddressConst l, in DeviceOrHostAddressConst r)
	{
		return
			(l.DeviceAddress != r.DeviceAddress) || (l.HostAddress != r.HostAddress)
			;
	}


	/// <summary>Creates a new DeviceOrHostAddressConst value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DeviceOrHostAddressConst value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct AccelerationStructureGeometryTrianglesData : IEquatable<AccelerationStructureGeometryTrianglesData>
{
	public const Vk.StructureType TYPE = Vk.StructureType.AccelerationStructureGeometryTrianglesDataKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Format VertexFormat;
	public Vk.KHR.DeviceOrHostAddressConst VertexData;
	public Vk.DeviceSize VertexStride;
	public Vk.IndexType IndexType;
	public Vk.KHR.DeviceOrHostAddressConst IndexData;
	public Vk.KHR.DeviceOrHostAddressConst TransformData;
	public AccelerationStructureGeometryTrianglesData(
		in Vk.Format vertexFormat = default,
		in Vk.KHR.DeviceOrHostAddressConst vertexData = default,
		in Vk.DeviceSize vertexStride = default,
		in Vk.IndexType indexType = default,
		in Vk.KHR.DeviceOrHostAddressConst indexData = default,
		in Vk.KHR.DeviceOrHostAddressConst transformData = default
	) {
		sType = TYPE;
		pNext = null;
		VertexFormat = vertexFormat;
		VertexData = vertexData;
		VertexStride = vertexStride;
		IndexType = indexType;
		IndexData = indexData;
		TransformData = transformData;
	}


	public readonly override bool Equals(object? obj) => (obj is AccelerationStructureGeometryTrianglesData o) && (this == o);
	readonly bool IEquatable<AccelerationStructureGeometryTrianglesData>.Equals(AccelerationStructureGeometryTrianglesData obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ VertexFormat.GetHashCode() ^ VertexData.GetHashCode()
			^ VertexStride.GetHashCode() ^ IndexType.GetHashCode() ^ IndexData.GetHashCode() ^ TransformData.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in AccelerationStructureGeometryTrianglesData l, in AccelerationStructureGeometryTrianglesData r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.VertexFormat == r.VertexFormat) && (l.VertexData == r.VertexData)
			&& (l.VertexStride == r.VertexStride) && (l.IndexType == r.IndexType) && (l.IndexData == r.IndexData) && (l.TransformData == r.TransformData)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in AccelerationStructureGeometryTrianglesData l, in AccelerationStructureGeometryTrianglesData r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.VertexFormat != r.VertexFormat) || (l.VertexData != r.VertexData)
			|| (l.VertexStride != r.VertexStride) || (l.IndexType != r.IndexType) || (l.IndexData != r.IndexData) || (l.TransformData != r.TransformData)
			;
	}


	/// <summary>Creates a new AccelerationStructureGeometryTrianglesData value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out AccelerationStructureGeometryTrianglesData value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct AccelerationStructureGeometryAabbsData : IEquatable<AccelerationStructureGeometryAabbsData>
{
	public const Vk.StructureType TYPE = Vk.StructureType.AccelerationStructureGeometryAabbsDataKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.KHR.DeviceOrHostAddressConst Data;
	public Vk.DeviceSize Stride;
	public AccelerationStructureGeometryAabbsData(
		in Vk.KHR.DeviceOrHostAddressConst data = default,
		in Vk.DeviceSize stride = default
	) {
		sType = TYPE;
		pNext = null;
		Data = data;
		Stride = stride;
	}


	public readonly override bool Equals(object? obj) => (obj is AccelerationStructureGeometryAabbsData o) && (this == o);
	readonly bool IEquatable<AccelerationStructureGeometryAabbsData>.Equals(AccelerationStructureGeometryAabbsData obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Data.GetHashCode() ^ Stride.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in AccelerationStructureGeometryAabbsData l, in AccelerationStructureGeometryAabbsData r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Data == r.Data) && (l.Stride == r.Stride)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in AccelerationStructureGeometryAabbsData l, in AccelerationStructureGeometryAabbsData r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Data != r.Data) || (l.Stride != r.Stride)
			;
	}


	/// <summary>Creates a new AccelerationStructureGeometryAabbsData value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out AccelerationStructureGeometryAabbsData value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct AccelerationStructureGeometryInstancesData : IEquatable<AccelerationStructureGeometryInstancesData>
{
	public const Vk.StructureType TYPE = Vk.StructureType.AccelerationStructureGeometryInstancesDataKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 ArrayOfPointers;
	public Vk.KHR.DeviceOrHostAddressConst Data;
	public AccelerationStructureGeometryInstancesData(
		in Vk.Bool32 arrayOfPointers = default,
		in Vk.KHR.DeviceOrHostAddressConst data = default
	) {
		sType = TYPE;
		pNext = null;
		ArrayOfPointers = arrayOfPointers;
		Data = data;
	}


	public readonly override bool Equals(object? obj) => (obj is AccelerationStructureGeometryInstancesData o) && (this == o);
	readonly bool IEquatable<AccelerationStructureGeometryInstancesData>.Equals(AccelerationStructureGeometryInstancesData obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ArrayOfPointers.GetHashCode() ^ Data.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in AccelerationStructureGeometryInstancesData l, in AccelerationStructureGeometryInstancesData r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ArrayOfPointers == r.ArrayOfPointers) && (l.Data == r.Data)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in AccelerationStructureGeometryInstancesData l, in AccelerationStructureGeometryInstancesData r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ArrayOfPointers != r.ArrayOfPointers) || (l.Data != r.Data)
			;
	}


	/// <summary>Creates a new AccelerationStructureGeometryInstancesData value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out AccelerationStructureGeometryInstancesData value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Explicit)]
public unsafe partial struct AccelerationStructureGeometryData : IEquatable<AccelerationStructureGeometryData>
{
	[FieldOffset(0)] public Vk.KHR.AccelerationStructureGeometryTrianglesData Triangles;
	[FieldOffset(0)] public Vk.KHR.AccelerationStructureGeometryAabbsData Aabbs;
	[FieldOffset(0)] public Vk.KHR.AccelerationStructureGeometryInstancesData Instances;

	public readonly override bool Equals(object? obj) => (obj is AccelerationStructureGeometryData o) && (this == o);
	readonly bool IEquatable<AccelerationStructureGeometryData>.Equals(AccelerationStructureGeometryData obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Triangles.GetHashCode() ^ Aabbs.GetHashCode() ^ Instances.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in AccelerationStructureGeometryData l, in AccelerationStructureGeometryData r)
	{
		return
			(l.Triangles == r.Triangles) && (l.Aabbs == r.Aabbs) && (l.Instances == r.Instances)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in AccelerationStructureGeometryData l, in AccelerationStructureGeometryData r)
	{
		return
			(l.Triangles != r.Triangles) || (l.Aabbs != r.Aabbs) || (l.Instances != r.Instances)
			;
	}


	/// <summary>Creates a new AccelerationStructureGeometryData value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out AccelerationStructureGeometryData value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct AccelerationStructureGeometry : IEquatable<AccelerationStructureGeometry>
{
	public const Vk.StructureType TYPE = Vk.StructureType.AccelerationStructureGeometryKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.KHR.GeometryType GeometryType;
	public Vk.KHR.AccelerationStructureGeometryData Geometry;
	public Vk.KHR.GeometryFlags Flags;
	public AccelerationStructureGeometry(
		in Vk.KHR.GeometryType geometryType = default,
		in Vk.KHR.AccelerationStructureGeometryData geometry = default,
		in Vk.KHR.GeometryFlags flags = default
	) {
		sType = TYPE;
		pNext = null;
		GeometryType = geometryType;
		Geometry = geometry;
		Flags = flags;
	}


	public readonly override bool Equals(object? obj) => (obj is AccelerationStructureGeometry o) && (this == o);
	readonly bool IEquatable<AccelerationStructureGeometry>.Equals(AccelerationStructureGeometry obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ GeometryType.GetHashCode() ^ Geometry.GetHashCode()
			^ Flags.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in AccelerationStructureGeometry l, in AccelerationStructureGeometry r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.GeometryType == r.GeometryType) && (l.Geometry == r.Geometry)
			&& (l.Flags == r.Flags)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in AccelerationStructureGeometry l, in AccelerationStructureGeometry r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.GeometryType != r.GeometryType) || (l.Geometry != r.Geometry)
			|| (l.Flags != r.Flags)
			;
	}


	/// <summary>Creates a new AccelerationStructureGeometry value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out AccelerationStructureGeometry value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct AccelerationStructureBuildGeometryInfo : IEquatable<AccelerationStructureBuildGeometryInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.AccelerationStructureBuildGeometryInfoKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.KHR.AccelerationStructureType Type;
	public Vk.KHR.BuildAccelerationStructureFlags Flags;
	public Vk.Bool32 Update;
	public Vk.Handle<Vk.KHR.AccelerationStructure> SrcAccelerationStructure;
	public Vk.Handle<Vk.KHR.AccelerationStructure> DstAccelerationStructure;
	public Vk.Bool32 GeometryArrayOfPointers;
	public uint GeometryCount;
	public Vk.KHR.AccelerationStructureGeometry** Geometries;
	public Vk.KHR.DeviceOrHostAddress ScratchData;
	public AccelerationStructureBuildGeometryInfo(
		in Vk.KHR.AccelerationStructureType type = default,
		in Vk.KHR.BuildAccelerationStructureFlags flags = default,
		in Vk.Bool32 update = default,
		in Vk.Handle<Vk.KHR.AccelerationStructure> srcAccelerationStructure = default,
		in Vk.Handle<Vk.KHR.AccelerationStructure> dstAccelerationStructure = default,
		in Vk.Bool32 geometryArrayOfPointers = default,
		uint geometryCount = default,
		in Vk.KHR.AccelerationStructureGeometry** geometries = default,
		in Vk.KHR.DeviceOrHostAddress scratchData = default
	) {
		sType = TYPE;
		pNext = null;
		Type = type;
		Flags = flags;
		Update = update;
		SrcAccelerationStructure = srcAccelerationStructure;
		DstAccelerationStructure = dstAccelerationStructure;
		GeometryArrayOfPointers = geometryArrayOfPointers;
		GeometryCount = geometryCount;
		Geometries = geometries;
		ScratchData = scratchData;
	}


	public readonly override bool Equals(object? obj) => (obj is AccelerationStructureBuildGeometryInfo o) && (this == o);
	readonly bool IEquatable<AccelerationStructureBuildGeometryInfo>.Equals(AccelerationStructureBuildGeometryInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Type.GetHashCode() ^ Flags.GetHashCode()
			^ Update.GetHashCode() ^ SrcAccelerationStructure.GetHashCode() ^ DstAccelerationStructure.GetHashCode() ^ GeometryArrayOfPointers.GetHashCode()
			^ GeometryCount.GetHashCode() ^ ((ulong)Geometries).GetHashCode() ^ ScratchData.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in AccelerationStructureBuildGeometryInfo l, in AccelerationStructureBuildGeometryInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Type == r.Type) && (l.Flags == r.Flags)
			&& (l.Update == r.Update) && (l.SrcAccelerationStructure == r.SrcAccelerationStructure) && (l.DstAccelerationStructure == r.DstAccelerationStructure) && (l.GeometryArrayOfPointers == r.GeometryArrayOfPointers)
			&& (l.GeometryCount == r.GeometryCount) && (l.Geometries == r.Geometries) && (l.ScratchData == r.ScratchData)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in AccelerationStructureBuildGeometryInfo l, in AccelerationStructureBuildGeometryInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Type != r.Type) || (l.Flags != r.Flags)
			|| (l.Update != r.Update) || (l.SrcAccelerationStructure != r.SrcAccelerationStructure) || (l.DstAccelerationStructure != r.DstAccelerationStructure) || (l.GeometryArrayOfPointers != r.GeometryArrayOfPointers)
			|| (l.GeometryCount != r.GeometryCount) || (l.Geometries != r.Geometries) || (l.ScratchData != r.ScratchData)
			;
	}


	/// <summary>Creates a new AccelerationStructureBuildGeometryInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out AccelerationStructureBuildGeometryInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct AccelerationStructureBuildOffsetInfo : IEquatable<AccelerationStructureBuildOffsetInfo>
{
	public uint PrimitiveCount;
	public uint PrimitiveOffset;
	public uint FirstVertex;
	public uint TransformOffset;
	public AccelerationStructureBuildOffsetInfo(
		uint primitiveCount = default,
		uint primitiveOffset = default,
		uint firstVertex = default,
		uint transformOffset = default
	) {
		PrimitiveCount = primitiveCount;
		PrimitiveOffset = primitiveOffset;
		FirstVertex = firstVertex;
		TransformOffset = transformOffset;
	}


	public readonly override bool Equals(object? obj) => (obj is AccelerationStructureBuildOffsetInfo o) && (this == o);
	readonly bool IEquatable<AccelerationStructureBuildOffsetInfo>.Equals(AccelerationStructureBuildOffsetInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			PrimitiveCount.GetHashCode() ^ PrimitiveOffset.GetHashCode() ^ FirstVertex.GetHashCode() ^ TransformOffset.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in AccelerationStructureBuildOffsetInfo l, in AccelerationStructureBuildOffsetInfo r)
	{
		return
			(l.PrimitiveCount == r.PrimitiveCount) && (l.PrimitiveOffset == r.PrimitiveOffset) && (l.FirstVertex == r.FirstVertex) && (l.TransformOffset == r.TransformOffset)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in AccelerationStructureBuildOffsetInfo l, in AccelerationStructureBuildOffsetInfo r)
	{
		return
			(l.PrimitiveCount != r.PrimitiveCount) || (l.PrimitiveOffset != r.PrimitiveOffset) || (l.FirstVertex != r.FirstVertex) || (l.TransformOffset != r.TransformOffset)
			;
	}


	/// <summary>Creates a new AccelerationStructureBuildOffsetInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out AccelerationStructureBuildOffsetInfo value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct AccelerationStructureCreateGeometryTypeInfo : IEquatable<AccelerationStructureCreateGeometryTypeInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.AccelerationStructureCreateGeometryTypeInfoKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.KHR.GeometryType GeometryType;
	public uint MaxPrimitiveCount;
	public Vk.IndexType IndexType;
	public uint MaxVertexCount;
	public Vk.Format VertexFormat;
	public Vk.Bool32 AllowsTransforms;
	public AccelerationStructureCreateGeometryTypeInfo(
		in Vk.KHR.GeometryType geometryType = default,
		uint maxPrimitiveCount = default,
		in Vk.IndexType indexType = default,
		uint maxVertexCount = default,
		in Vk.Format vertexFormat = default,
		in Vk.Bool32 allowsTransforms = default
	) {
		sType = TYPE;
		pNext = null;
		GeometryType = geometryType;
		MaxPrimitiveCount = maxPrimitiveCount;
		IndexType = indexType;
		MaxVertexCount = maxVertexCount;
		VertexFormat = vertexFormat;
		AllowsTransforms = allowsTransforms;
	}


	public readonly override bool Equals(object? obj) => (obj is AccelerationStructureCreateGeometryTypeInfo o) && (this == o);
	readonly bool IEquatable<AccelerationStructureCreateGeometryTypeInfo>.Equals(AccelerationStructureCreateGeometryTypeInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ GeometryType.GetHashCode() ^ MaxPrimitiveCount.GetHashCode()
			^ IndexType.GetHashCode() ^ MaxVertexCount.GetHashCode() ^ VertexFormat.GetHashCode() ^ AllowsTransforms.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in AccelerationStructureCreateGeometryTypeInfo l, in AccelerationStructureCreateGeometryTypeInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.GeometryType == r.GeometryType) && (l.MaxPrimitiveCount == r.MaxPrimitiveCount)
			&& (l.IndexType == r.IndexType) && (l.MaxVertexCount == r.MaxVertexCount) && (l.VertexFormat == r.VertexFormat) && (l.AllowsTransforms == r.AllowsTransforms)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in AccelerationStructureCreateGeometryTypeInfo l, in AccelerationStructureCreateGeometryTypeInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.GeometryType != r.GeometryType) || (l.MaxPrimitiveCount != r.MaxPrimitiveCount)
			|| (l.IndexType != r.IndexType) || (l.MaxVertexCount != r.MaxVertexCount) || (l.VertexFormat != r.VertexFormat) || (l.AllowsTransforms != r.AllowsTransforms)
			;
	}


	/// <summary>Creates a new AccelerationStructureCreateGeometryTypeInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out AccelerationStructureCreateGeometryTypeInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct AccelerationStructureCreateInfo : IEquatable<AccelerationStructureCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.AccelerationStructureCreateInfoKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.DeviceSize CompactedSize;
	public Vk.KHR.AccelerationStructureType Type;
	public Vk.KHR.BuildAccelerationStructureFlags Flags;
	public uint MaxGeometryCount;
	public Vk.KHR.AccelerationStructureCreateGeometryTypeInfo* GeometryInfos;
	public ulong DeviceAddress;
	public AccelerationStructureCreateInfo(
		in Vk.DeviceSize compactedSize = default,
		in Vk.KHR.AccelerationStructureType type = default,
		in Vk.KHR.BuildAccelerationStructureFlags flags = default,
		uint maxGeometryCount = default,
		in Vk.KHR.AccelerationStructureCreateGeometryTypeInfo* geometryInfos = default,
		ulong deviceAddress = default
	) {
		sType = TYPE;
		pNext = null;
		CompactedSize = compactedSize;
		Type = type;
		Flags = flags;
		MaxGeometryCount = maxGeometryCount;
		GeometryInfos = geometryInfos;
		DeviceAddress = deviceAddress;
	}


	public readonly override bool Equals(object? obj) => (obj is AccelerationStructureCreateInfo o) && (this == o);
	readonly bool IEquatable<AccelerationStructureCreateInfo>.Equals(AccelerationStructureCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ CompactedSize.GetHashCode() ^ Type.GetHashCode()
			^ Flags.GetHashCode() ^ MaxGeometryCount.GetHashCode() ^ ((ulong)GeometryInfos).GetHashCode() ^ DeviceAddress.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in AccelerationStructureCreateInfo l, in AccelerationStructureCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.CompactedSize == r.CompactedSize) && (l.Type == r.Type)
			&& (l.Flags == r.Flags) && (l.MaxGeometryCount == r.MaxGeometryCount) && (l.GeometryInfos == r.GeometryInfos) && (l.DeviceAddress == r.DeviceAddress)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in AccelerationStructureCreateInfo l, in AccelerationStructureCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.CompactedSize != r.CompactedSize) || (l.Type != r.Type)
			|| (l.Flags != r.Flags) || (l.MaxGeometryCount != r.MaxGeometryCount) || (l.GeometryInfos != r.GeometryInfos) || (l.DeviceAddress != r.DeviceAddress)
			;
	}


	/// <summary>Creates a new AccelerationStructureCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out AccelerationStructureCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct AabbPositions : IEquatable<AabbPositions>
{
	public float MinX;
	public float MinY;
	public float MinZ;
	public float MaxX;
	public float MaxY;
	public float MaxZ;
	public AabbPositions(
		float minX = default,
		float minY = default,
		float minZ = default,
		float maxX = default,
		float maxY = default,
		float maxZ = default
	) {
		MinX = minX;
		MinY = minY;
		MinZ = minZ;
		MaxX = maxX;
		MaxY = maxY;
		MaxZ = maxZ;
	}


	public readonly override bool Equals(object? obj) => (obj is AabbPositions o) && (this == o);
	readonly bool IEquatable<AabbPositions>.Equals(AabbPositions obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			MinX.GetHashCode() ^ MinY.GetHashCode() ^ MinZ.GetHashCode() ^ MaxX.GetHashCode()
			^ MaxY.GetHashCode() ^ MaxZ.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in AabbPositions l, in AabbPositions r)
	{
		return
			(l.MinX == r.MinX) && (l.MinY == r.MinY) && (l.MinZ == r.MinZ) && (l.MaxX == r.MaxX)
			&& (l.MaxY == r.MaxY) && (l.MaxZ == r.MaxZ)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in AabbPositions l, in AabbPositions r)
	{
		return
			(l.MinX != r.MinX) || (l.MinY != r.MinY) || (l.MinZ != r.MinZ) || (l.MaxX != r.MaxX)
			|| (l.MaxY != r.MaxY) || (l.MaxZ != r.MaxZ)
			;
	}


	/// <summary>Creates a new AabbPositions value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out AabbPositions value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct TransformMatrix : IEquatable<TransformMatrix>
{
	public fixed float Matrix[12];
	public TransformMatrix(
		float matrix0 = default,
		float matrix1 = default,
		float matrix2 = default,
		float matrix3 = default,
		float matrix4 = default,
		float matrix5 = default,
		float matrix6 = default,
		float matrix7 = default,
		float matrix8 = default,
		float matrix9 = default,
		float matrix10 = default,
		float matrix11 = default
	) {
		Matrix[0] = matrix0;
		Matrix[1] = matrix1;
		Matrix[2] = matrix2;
		Matrix[3] = matrix3;
		Matrix[4] = matrix4;
		Matrix[5] = matrix5;
		Matrix[6] = matrix6;
		Matrix[7] = matrix7;
		Matrix[8] = matrix8;
		Matrix[9] = matrix9;
		Matrix[10] = matrix10;
		Matrix[11] = matrix11;
	}


	public readonly override bool Equals(object? obj) => (obj is TransformMatrix o) && (this == o);
	readonly bool IEquatable<TransformMatrix>.Equals(TransformMatrix obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Matrix[0].GetHashCode() ^ Matrix[1].GetHashCode() ^ Matrix[2].GetHashCode() ^ Matrix[3].GetHashCode()
			^ Matrix[4].GetHashCode() ^ Matrix[5].GetHashCode() ^ Matrix[6].GetHashCode() ^ Matrix[7].GetHashCode()
			^ Matrix[8].GetHashCode() ^ Matrix[9].GetHashCode() ^ Matrix[10].GetHashCode() ^ Matrix[11].GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in TransformMatrix l, in TransformMatrix r)
	{
		return
			(l.Matrix[0] == r.Matrix[0]) && (l.Matrix[1] == r.Matrix[1]) && (l.Matrix[2] == r.Matrix[2]) && (l.Matrix[3] == r.Matrix[3])
			&& (l.Matrix[4] == r.Matrix[4]) && (l.Matrix[5] == r.Matrix[5]) && (l.Matrix[6] == r.Matrix[6]) && (l.Matrix[7] == r.Matrix[7])
			&& (l.Matrix[8] == r.Matrix[8]) && (l.Matrix[9] == r.Matrix[9]) && (l.Matrix[10] == r.Matrix[10]) && (l.Matrix[11] == r.Matrix[11])
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in TransformMatrix l, in TransformMatrix r)
	{
		return
			(l.Matrix[0] != r.Matrix[0]) || (l.Matrix[1] != r.Matrix[1]) || (l.Matrix[2] != r.Matrix[2]) || (l.Matrix[3] != r.Matrix[3])
			|| (l.Matrix[4] != r.Matrix[4]) || (l.Matrix[5] != r.Matrix[5]) || (l.Matrix[6] != r.Matrix[6]) || (l.Matrix[7] != r.Matrix[7])
			|| (l.Matrix[8] != r.Matrix[8]) || (l.Matrix[9] != r.Matrix[9]) || (l.Matrix[10] != r.Matrix[10]) || (l.Matrix[11] != r.Matrix[11])
			;
	}


	/// <summary>Creates a new TransformMatrix value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out TransformMatrix value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct AccelerationStructureInstance : IEquatable<AccelerationStructureInstance>
{
	public Vk.KHR.TransformMatrix Transform;
	public uint InstanceCustomIndex;
	public uint Mask;
	public uint InstanceShaderBindingTableRecordOffset;
	public Vk.KHR.GeometryInstanceFlags Flags;
	public ulong AccelerationStructureReference;
	public AccelerationStructureInstance(
		in Vk.KHR.TransformMatrix transform = default,
		uint instanceCustomIndex = default,
		uint mask = default,
		uint instanceShaderBindingTableRecordOffset = default,
		in Vk.KHR.GeometryInstanceFlags flags = default,
		ulong accelerationStructureReference = default
	) {
		Transform = transform;
		InstanceCustomIndex = instanceCustomIndex;
		Mask = mask;
		InstanceShaderBindingTableRecordOffset = instanceShaderBindingTableRecordOffset;
		Flags = flags;
		AccelerationStructureReference = accelerationStructureReference;
	}


	public readonly override bool Equals(object? obj) => (obj is AccelerationStructureInstance o) && (this == o);
	readonly bool IEquatable<AccelerationStructureInstance>.Equals(AccelerationStructureInstance obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Transform.GetHashCode() ^ InstanceCustomIndex.GetHashCode() ^ Mask.GetHashCode() ^ InstanceShaderBindingTableRecordOffset.GetHashCode()
			^ Flags.GetHashCode() ^ AccelerationStructureReference.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in AccelerationStructureInstance l, in AccelerationStructureInstance r)
	{
		return
			(l.Transform == r.Transform) && (l.InstanceCustomIndex == r.InstanceCustomIndex) && (l.Mask == r.Mask) && (l.InstanceShaderBindingTableRecordOffset == r.InstanceShaderBindingTableRecordOffset)
			&& (l.Flags == r.Flags) && (l.AccelerationStructureReference == r.AccelerationStructureReference)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in AccelerationStructureInstance l, in AccelerationStructureInstance r)
	{
		return
			(l.Transform != r.Transform) || (l.InstanceCustomIndex != r.InstanceCustomIndex) || (l.Mask != r.Mask) || (l.InstanceShaderBindingTableRecordOffset != r.InstanceShaderBindingTableRecordOffset)
			|| (l.Flags != r.Flags) || (l.AccelerationStructureReference != r.AccelerationStructureReference)
			;
	}


	/// <summary>Creates a new AccelerationStructureInstance value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out AccelerationStructureInstance value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct AccelerationStructureDeviceAddressInfo : IEquatable<AccelerationStructureDeviceAddressInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.AccelerationStructureDeviceAddressInfoKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Handle<Vk.KHR.AccelerationStructure> AccelerationStructure;
	public AccelerationStructureDeviceAddressInfo(
		in Vk.Handle<Vk.KHR.AccelerationStructure> accelerationStructure = default
	) {
		sType = TYPE;
		pNext = null;
		AccelerationStructure = accelerationStructure;
	}


	public readonly override bool Equals(object? obj) => (obj is AccelerationStructureDeviceAddressInfo o) && (this == o);
	readonly bool IEquatable<AccelerationStructureDeviceAddressInfo>.Equals(AccelerationStructureDeviceAddressInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ AccelerationStructure.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in AccelerationStructureDeviceAddressInfo l, in AccelerationStructureDeviceAddressInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.AccelerationStructure == r.AccelerationStructure)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in AccelerationStructureDeviceAddressInfo l, in AccelerationStructureDeviceAddressInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.AccelerationStructure != r.AccelerationStructure)
			;
	}


	/// <summary>Creates a new AccelerationStructureDeviceAddressInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out AccelerationStructureDeviceAddressInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct AccelerationStructureVersion : IEquatable<AccelerationStructureVersion>
{
	public const Vk.StructureType TYPE = Vk.StructureType.AccelerationStructureVersionKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public byte* VersionData;
	public AccelerationStructureVersion(
		byte* versionData = default
	) {
		sType = TYPE;
		pNext = null;
		VersionData = versionData;
	}


	public readonly override bool Equals(object? obj) => (obj is AccelerationStructureVersion o) && (this == o);
	readonly bool IEquatable<AccelerationStructureVersion>.Equals(AccelerationStructureVersion obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ((ulong)VersionData).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in AccelerationStructureVersion l, in AccelerationStructureVersion r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.VersionData == r.VersionData)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in AccelerationStructureVersion l, in AccelerationStructureVersion r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.VersionData != r.VersionData)
			;
	}


	/// <summary>Creates a new AccelerationStructureVersion value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out AccelerationStructureVersion value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct CopyAccelerationStructureInfo : IEquatable<CopyAccelerationStructureInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.CopyAccelerationStructureInfoKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Handle<Vk.KHR.AccelerationStructure> Src;
	public Vk.Handle<Vk.KHR.AccelerationStructure> Dst;
	public Vk.KHR.CopyAccelerationStructureMode Mode;
	public CopyAccelerationStructureInfo(
		in Vk.Handle<Vk.KHR.AccelerationStructure> src = default,
		in Vk.Handle<Vk.KHR.AccelerationStructure> dst = default,
		in Vk.KHR.CopyAccelerationStructureMode mode = default
	) {
		sType = TYPE;
		pNext = null;
		Src = src;
		Dst = dst;
		Mode = mode;
	}


	public readonly override bool Equals(object? obj) => (obj is CopyAccelerationStructureInfo o) && (this == o);
	readonly bool IEquatable<CopyAccelerationStructureInfo>.Equals(CopyAccelerationStructureInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Src.GetHashCode() ^ Dst.GetHashCode()
			^ Mode.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in CopyAccelerationStructureInfo l, in CopyAccelerationStructureInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Src == r.Src) && (l.Dst == r.Dst)
			&& (l.Mode == r.Mode)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in CopyAccelerationStructureInfo l, in CopyAccelerationStructureInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Src != r.Src) || (l.Dst != r.Dst)
			|| (l.Mode != r.Mode)
			;
	}


	/// <summary>Creates a new CopyAccelerationStructureInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out CopyAccelerationStructureInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct CopyAccelerationStructureToMemoryInfo : IEquatable<CopyAccelerationStructureToMemoryInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.CopyAccelerationStructureToMemoryInfoKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Handle<Vk.KHR.AccelerationStructure> Src;
	public Vk.KHR.DeviceOrHostAddress Dst;
	public Vk.KHR.CopyAccelerationStructureMode Mode;
	public CopyAccelerationStructureToMemoryInfo(
		in Vk.Handle<Vk.KHR.AccelerationStructure> src = default,
		in Vk.KHR.DeviceOrHostAddress dst = default,
		in Vk.KHR.CopyAccelerationStructureMode mode = default
	) {
		sType = TYPE;
		pNext = null;
		Src = src;
		Dst = dst;
		Mode = mode;
	}


	public readonly override bool Equals(object? obj) => (obj is CopyAccelerationStructureToMemoryInfo o) && (this == o);
	readonly bool IEquatable<CopyAccelerationStructureToMemoryInfo>.Equals(CopyAccelerationStructureToMemoryInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Src.GetHashCode() ^ Dst.GetHashCode()
			^ Mode.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in CopyAccelerationStructureToMemoryInfo l, in CopyAccelerationStructureToMemoryInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Src == r.Src) && (l.Dst == r.Dst)
			&& (l.Mode == r.Mode)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in CopyAccelerationStructureToMemoryInfo l, in CopyAccelerationStructureToMemoryInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Src != r.Src) || (l.Dst != r.Dst)
			|| (l.Mode != r.Mode)
			;
	}


	/// <summary>Creates a new CopyAccelerationStructureToMemoryInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out CopyAccelerationStructureToMemoryInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct CopyMemoryToAccelerationStructureInfo : IEquatable<CopyMemoryToAccelerationStructureInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.CopyMemoryToAccelerationStructureInfoKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.KHR.DeviceOrHostAddressConst Src;
	public Vk.Handle<Vk.KHR.AccelerationStructure> Dst;
	public Vk.KHR.CopyAccelerationStructureMode Mode;
	public CopyMemoryToAccelerationStructureInfo(
		in Vk.KHR.DeviceOrHostAddressConst src = default,
		in Vk.Handle<Vk.KHR.AccelerationStructure> dst = default,
		in Vk.KHR.CopyAccelerationStructureMode mode = default
	) {
		sType = TYPE;
		pNext = null;
		Src = src;
		Dst = dst;
		Mode = mode;
	}


	public readonly override bool Equals(object? obj) => (obj is CopyMemoryToAccelerationStructureInfo o) && (this == o);
	readonly bool IEquatable<CopyMemoryToAccelerationStructureInfo>.Equals(CopyMemoryToAccelerationStructureInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Src.GetHashCode() ^ Dst.GetHashCode()
			^ Mode.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in CopyMemoryToAccelerationStructureInfo l, in CopyMemoryToAccelerationStructureInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Src == r.Src) && (l.Dst == r.Dst)
			&& (l.Mode == r.Mode)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in CopyMemoryToAccelerationStructureInfo l, in CopyMemoryToAccelerationStructureInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Src != r.Src) || (l.Dst != r.Dst)
			|| (l.Mode != r.Mode)
			;
	}


	/// <summary>Creates a new CopyMemoryToAccelerationStructureInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out CopyMemoryToAccelerationStructureInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct RayTracingPipelineInterfaceCreateInfo : IEquatable<RayTracingPipelineInterfaceCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.RayTracingPipelineInterfaceCreateInfoKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public uint MaxPayloadSize;
	public uint MaxAttributeSize;
	public uint MaxCallableSize;
	public RayTracingPipelineInterfaceCreateInfo(
		uint maxPayloadSize = default,
		uint maxAttributeSize = default,
		uint maxCallableSize = default
	) {
		sType = TYPE;
		pNext = null;
		MaxPayloadSize = maxPayloadSize;
		MaxAttributeSize = maxAttributeSize;
		MaxCallableSize = maxCallableSize;
	}


	public readonly override bool Equals(object? obj) => (obj is RayTracingPipelineInterfaceCreateInfo o) && (this == o);
	readonly bool IEquatable<RayTracingPipelineInterfaceCreateInfo>.Equals(RayTracingPipelineInterfaceCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MaxPayloadSize.GetHashCode() ^ MaxAttributeSize.GetHashCode()
			^ MaxCallableSize.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in RayTracingPipelineInterfaceCreateInfo l, in RayTracingPipelineInterfaceCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MaxPayloadSize == r.MaxPayloadSize) && (l.MaxAttributeSize == r.MaxAttributeSize)
			&& (l.MaxCallableSize == r.MaxCallableSize)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in RayTracingPipelineInterfaceCreateInfo l, in RayTracingPipelineInterfaceCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MaxPayloadSize != r.MaxPayloadSize) || (l.MaxAttributeSize != r.MaxAttributeSize)
			|| (l.MaxCallableSize != r.MaxCallableSize)
			;
	}


	/// <summary>Creates a new RayTracingPipelineInterfaceCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out RayTracingPipelineInterfaceCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DeferredOperationInfo : IEquatable<DeferredOperationInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DeferredOperationInfoKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Handle<Vk.KHR.DeferredOperation> OperationHandle;
	public DeferredOperationInfo(
		in Vk.Handle<Vk.KHR.DeferredOperation> operationHandle = default
	) {
		sType = TYPE;
		pNext = null;
		OperationHandle = operationHandle;
	}


	public readonly override bool Equals(object? obj) => (obj is DeferredOperationInfo o) && (this == o);
	readonly bool IEquatable<DeferredOperationInfo>.Equals(DeferredOperationInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ OperationHandle.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DeferredOperationInfo l, in DeferredOperationInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.OperationHandle == r.OperationHandle)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DeferredOperationInfo l, in DeferredOperationInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.OperationHandle != r.OperationHandle)
			;
	}


	/// <summary>Creates a new DeferredOperationInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DeferredOperationInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PipelineLibraryCreateInfo : IEquatable<PipelineLibraryCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PipelineLibraryCreateInfoKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public uint LibraryCount;
	public Vk.Handle<Vk.Pipeline>* Libraries;
	public PipelineLibraryCreateInfo(
		uint libraryCount = default,
		in Vk.Handle<Vk.Pipeline>* libraries = default
	) {
		sType = TYPE;
		pNext = null;
		LibraryCount = libraryCount;
		Libraries = libraries;
	}


	public readonly override bool Equals(object? obj) => (obj is PipelineLibraryCreateInfo o) && (this == o);
	readonly bool IEquatable<PipelineLibraryCreateInfo>.Equals(PipelineLibraryCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ LibraryCount.GetHashCode() ^ ((ulong)Libraries).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PipelineLibraryCreateInfo l, in PipelineLibraryCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.LibraryCount == r.LibraryCount) && (l.Libraries == r.Libraries)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PipelineLibraryCreateInfo l, in PipelineLibraryCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.LibraryCount != r.LibraryCount) || (l.Libraries != r.Libraries)
			;
	}


	/// <summary>Creates a new PipelineLibraryCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PipelineLibraryCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDevicePortabilitySubsetFeatures : IEquatable<PhysicalDevicePortabilitySubsetFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDevicePortabilitySubsetFeaturesKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 ConstantAlphaColorBlendFactors;
	public Vk.Bool32 Events;
	public Vk.Bool32 ImageViewFormatReinterpretation;
	public Vk.Bool32 ImageViewFormatSwizzle;
	public Vk.Bool32 ImageView2DOn3DImage;
	public Vk.Bool32 MultisampleArrayImage;
	public Vk.Bool32 MutableComparisonSamplers;
	public Vk.Bool32 PointPolygons;
	public Vk.Bool32 SamplerMipLodBias;
	public Vk.Bool32 SeparateStencilMaskRef;
	public Vk.Bool32 ShaderSampleRateInterpolationFunctions;
	public Vk.Bool32 TessellationIsolines;
	public Vk.Bool32 TessellationPointMode;
	public Vk.Bool32 TriangleFans;
	public Vk.Bool32 VertexAttributeAccessBeyondStride;
	public PhysicalDevicePortabilitySubsetFeatures(
		in Vk.Bool32 constantAlphaColorBlendFactors = default,
		in Vk.Bool32 events = default,
		in Vk.Bool32 imageViewFormatReinterpretation = default,
		in Vk.Bool32 imageViewFormatSwizzle = default,
		in Vk.Bool32 imageView2DOn3DImage = default,
		in Vk.Bool32 multisampleArrayImage = default,
		in Vk.Bool32 mutableComparisonSamplers = default,
		in Vk.Bool32 pointPolygons = default,
		in Vk.Bool32 samplerMipLodBias = default,
		in Vk.Bool32 separateStencilMaskRef = default,
		in Vk.Bool32 shaderSampleRateInterpolationFunctions = default,
		in Vk.Bool32 tessellationIsolines = default,
		in Vk.Bool32 tessellationPointMode = default,
		in Vk.Bool32 triangleFans = default,
		in Vk.Bool32 vertexAttributeAccessBeyondStride = default
	) {
		sType = TYPE;
		pNext = null;
		ConstantAlphaColorBlendFactors = constantAlphaColorBlendFactors;
		Events = events;
		ImageViewFormatReinterpretation = imageViewFormatReinterpretation;
		ImageViewFormatSwizzle = imageViewFormatSwizzle;
		ImageView2DOn3DImage = imageView2DOn3DImage;
		MultisampleArrayImage = multisampleArrayImage;
		MutableComparisonSamplers = mutableComparisonSamplers;
		PointPolygons = pointPolygons;
		SamplerMipLodBias = samplerMipLodBias;
		SeparateStencilMaskRef = separateStencilMaskRef;
		ShaderSampleRateInterpolationFunctions = shaderSampleRateInterpolationFunctions;
		TessellationIsolines = tessellationIsolines;
		TessellationPointMode = tessellationPointMode;
		TriangleFans = triangleFans;
		VertexAttributeAccessBeyondStride = vertexAttributeAccessBeyondStride;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDevicePortabilitySubsetFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDevicePortabilitySubsetFeatures>.Equals(PhysicalDevicePortabilitySubsetFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ConstantAlphaColorBlendFactors.GetHashCode() ^ Events.GetHashCode()
			^ ImageViewFormatReinterpretation.GetHashCode() ^ ImageViewFormatSwizzle.GetHashCode() ^ ImageView2DOn3DImage.GetHashCode() ^ MultisampleArrayImage.GetHashCode()
			^ MutableComparisonSamplers.GetHashCode() ^ PointPolygons.GetHashCode() ^ SamplerMipLodBias.GetHashCode() ^ SeparateStencilMaskRef.GetHashCode()
			^ ShaderSampleRateInterpolationFunctions.GetHashCode() ^ TessellationIsolines.GetHashCode() ^ TessellationPointMode.GetHashCode() ^ TriangleFans.GetHashCode()
			^ VertexAttributeAccessBeyondStride.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDevicePortabilitySubsetFeatures l, in PhysicalDevicePortabilitySubsetFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ConstantAlphaColorBlendFactors == r.ConstantAlphaColorBlendFactors) && (l.Events == r.Events)
			&& (l.ImageViewFormatReinterpretation == r.ImageViewFormatReinterpretation) && (l.ImageViewFormatSwizzle == r.ImageViewFormatSwizzle) && (l.ImageView2DOn3DImage == r.ImageView2DOn3DImage) && (l.MultisampleArrayImage == r.MultisampleArrayImage)
			&& (l.MutableComparisonSamplers == r.MutableComparisonSamplers) && (l.PointPolygons == r.PointPolygons) && (l.SamplerMipLodBias == r.SamplerMipLodBias) && (l.SeparateStencilMaskRef == r.SeparateStencilMaskRef)
			&& (l.ShaderSampleRateInterpolationFunctions == r.ShaderSampleRateInterpolationFunctions) && (l.TessellationIsolines == r.TessellationIsolines) && (l.TessellationPointMode == r.TessellationPointMode) && (l.TriangleFans == r.TriangleFans)
			&& (l.VertexAttributeAccessBeyondStride == r.VertexAttributeAccessBeyondStride)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDevicePortabilitySubsetFeatures l, in PhysicalDevicePortabilitySubsetFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ConstantAlphaColorBlendFactors != r.ConstantAlphaColorBlendFactors) || (l.Events != r.Events)
			|| (l.ImageViewFormatReinterpretation != r.ImageViewFormatReinterpretation) || (l.ImageViewFormatSwizzle != r.ImageViewFormatSwizzle) || (l.ImageView2DOn3DImage != r.ImageView2DOn3DImage) || (l.MultisampleArrayImage != r.MultisampleArrayImage)
			|| (l.MutableComparisonSamplers != r.MutableComparisonSamplers) || (l.PointPolygons != r.PointPolygons) || (l.SamplerMipLodBias != r.SamplerMipLodBias) || (l.SeparateStencilMaskRef != r.SeparateStencilMaskRef)
			|| (l.ShaderSampleRateInterpolationFunctions != r.ShaderSampleRateInterpolationFunctions) || (l.TessellationIsolines != r.TessellationIsolines) || (l.TessellationPointMode != r.TessellationPointMode) || (l.TriangleFans != r.TriangleFans)
			|| (l.VertexAttributeAccessBeyondStride != r.VertexAttributeAccessBeyondStride)
			;
	}


	/// <summary>Creates a new PhysicalDevicePortabilitySubsetFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDevicePortabilitySubsetFeatures value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDevicePortabilitySubsetProperties : IEquatable<PhysicalDevicePortabilitySubsetProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDevicePortabilitySubsetPropertiesKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public uint MinVertexInputBindingStrideAlignment;
	public PhysicalDevicePortabilitySubsetProperties(
		uint minVertexInputBindingStrideAlignment = default
	) {
		sType = TYPE;
		pNext = null;
		MinVertexInputBindingStrideAlignment = minVertexInputBindingStrideAlignment;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDevicePortabilitySubsetProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDevicePortabilitySubsetProperties>.Equals(PhysicalDevicePortabilitySubsetProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MinVertexInputBindingStrideAlignment.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDevicePortabilitySubsetProperties l, in PhysicalDevicePortabilitySubsetProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MinVertexInputBindingStrideAlignment == r.MinVertexInputBindingStrideAlignment)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDevicePortabilitySubsetProperties l, in PhysicalDevicePortabilitySubsetProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MinVertexInputBindingStrideAlignment != r.MinVertexInputBindingStrideAlignment)
			;
	}


	/// <summary>Creates a new PhysicalDevicePortabilitySubsetProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDevicePortabilitySubsetProperties value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct BufferCopy2 : IEquatable<BufferCopy2>
{
	public const Vk.StructureType TYPE = Vk.StructureType.BufferCopy2KHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.DeviceSize SrcOffset;
	public Vk.DeviceSize DstOffset;
	public Vk.DeviceSize Size;
	public BufferCopy2(
		in Vk.DeviceSize srcOffset = default,
		in Vk.DeviceSize dstOffset = default,
		in Vk.DeviceSize size = default
	) {
		sType = TYPE;
		pNext = null;
		SrcOffset = srcOffset;
		DstOffset = dstOffset;
		Size = size;
	}


	public readonly override bool Equals(object? obj) => (obj is BufferCopy2 o) && (this == o);
	readonly bool IEquatable<BufferCopy2>.Equals(BufferCopy2 obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SrcOffset.GetHashCode() ^ DstOffset.GetHashCode()
			^ Size.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in BufferCopy2 l, in BufferCopy2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SrcOffset == r.SrcOffset) && (l.DstOffset == r.DstOffset)
			&& (l.Size == r.Size)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in BufferCopy2 l, in BufferCopy2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SrcOffset != r.SrcOffset) || (l.DstOffset != r.DstOffset)
			|| (l.Size != r.Size)
			;
	}


	/// <summary>Creates a new BufferCopy2 value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out BufferCopy2 value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ImageCopy2 : IEquatable<ImageCopy2>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ImageCopy2KHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.ImageSubresourceLayers SrcSubresource;
	public Vk.Offset3D SrcOffset;
	public Vk.ImageSubresourceLayers DstSubresource;
	public Vk.Offset3D DstOffset;
	public Vk.Extent3D Extent;
	public ImageCopy2(
		in Vk.ImageSubresourceLayers srcSubresource = default,
		in Vk.Offset3D srcOffset = default,
		in Vk.ImageSubresourceLayers dstSubresource = default,
		in Vk.Offset3D dstOffset = default,
		in Vk.Extent3D extent = default
	) {
		sType = TYPE;
		pNext = null;
		SrcSubresource = srcSubresource;
		SrcOffset = srcOffset;
		DstSubresource = dstSubresource;
		DstOffset = dstOffset;
		Extent = extent;
	}


	public readonly override bool Equals(object? obj) => (obj is ImageCopy2 o) && (this == o);
	readonly bool IEquatable<ImageCopy2>.Equals(ImageCopy2 obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SrcSubresource.GetHashCode() ^ SrcOffset.GetHashCode()
			^ DstSubresource.GetHashCode() ^ DstOffset.GetHashCode() ^ Extent.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ImageCopy2 l, in ImageCopy2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SrcSubresource == r.SrcSubresource) && (l.SrcOffset == r.SrcOffset)
			&& (l.DstSubresource == r.DstSubresource) && (l.DstOffset == r.DstOffset) && (l.Extent == r.Extent)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ImageCopy2 l, in ImageCopy2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SrcSubresource != r.SrcSubresource) || (l.SrcOffset != r.SrcOffset)
			|| (l.DstSubresource != r.DstSubresource) || (l.DstOffset != r.DstOffset) || (l.Extent != r.Extent)
			;
	}


	/// <summary>Creates a new ImageCopy2 value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ImageCopy2 value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ImageBlit2 : IEquatable<ImageBlit2>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ImageBlit2KHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.ImageSubresourceLayers SrcSubresource;
	public Vk.Offset3D SrcOffsets_0;
	public Vk.Offset3D SrcOffsets_1;
	public Vk.ImageSubresourceLayers DstSubresource;
	public Vk.Offset3D DstOffsets_0;
	public Vk.Offset3D DstOffsets_1;
	public ImageBlit2(
		in Vk.ImageSubresourceLayers srcSubresource = default,
		in Vk.Offset3D srcOffsets0 = default,
		in Vk.Offset3D srcOffsets1 = default,
		in Vk.ImageSubresourceLayers dstSubresource = default,
		in Vk.Offset3D dstOffsets0 = default,
		in Vk.Offset3D dstOffsets1 = default
	) {
		sType = TYPE;
		pNext = null;
		SrcSubresource = srcSubresource;
		SrcOffsets_0 = srcOffsets0;
		SrcOffsets_1 = srcOffsets1;
		DstSubresource = dstSubresource;
		DstOffsets_0 = dstOffsets0;
		DstOffsets_1 = dstOffsets1;
	}


	public readonly override bool Equals(object? obj) => (obj is ImageBlit2 o) && (this == o);
	readonly bool IEquatable<ImageBlit2>.Equals(ImageBlit2 obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SrcSubresource.GetHashCode() ^ SrcOffsets_0.GetHashCode()
			^ SrcOffsets_1.GetHashCode() ^ DstSubresource.GetHashCode() ^ DstOffsets_0.GetHashCode() ^ DstOffsets_1.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ImageBlit2 l, in ImageBlit2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SrcSubresource == r.SrcSubresource) && (l.SrcOffsets_0 == r.SrcOffsets_0)
			&& (l.SrcOffsets_1 == r.SrcOffsets_1) && (l.DstSubresource == r.DstSubresource) && (l.DstOffsets_0 == r.DstOffsets_0) && (l.DstOffsets_1 == r.DstOffsets_1)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ImageBlit2 l, in ImageBlit2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SrcSubresource != r.SrcSubresource) || (l.SrcOffsets_0 != r.SrcOffsets_0)
			|| (l.SrcOffsets_1 != r.SrcOffsets_1) || (l.DstSubresource != r.DstSubresource) || (l.DstOffsets_0 != r.DstOffsets_0) || (l.DstOffsets_1 != r.DstOffsets_1)
			;
	}


	/// <summary>Creates a new ImageBlit2 value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ImageBlit2 value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct BufferImageCopy2 : IEquatable<BufferImageCopy2>
{
	public const Vk.StructureType TYPE = Vk.StructureType.BufferImageCopy2KHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.DeviceSize BufferOffset;
	public uint BufferRowLength;
	public uint BufferImageHeight;
	public Vk.ImageSubresourceLayers ImageSubresource;
	public Vk.Offset3D ImageOffset;
	public Vk.Extent3D ImageExtent;
	public BufferImageCopy2(
		in Vk.DeviceSize bufferOffset = default,
		uint bufferRowLength = default,
		uint bufferImageHeight = default,
		in Vk.ImageSubresourceLayers imageSubresource = default,
		in Vk.Offset3D imageOffset = default,
		in Vk.Extent3D imageExtent = default
	) {
		sType = TYPE;
		pNext = null;
		BufferOffset = bufferOffset;
		BufferRowLength = bufferRowLength;
		BufferImageHeight = bufferImageHeight;
		ImageSubresource = imageSubresource;
		ImageOffset = imageOffset;
		ImageExtent = imageExtent;
	}


	public readonly override bool Equals(object? obj) => (obj is BufferImageCopy2 o) && (this == o);
	readonly bool IEquatable<BufferImageCopy2>.Equals(BufferImageCopy2 obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ BufferOffset.GetHashCode() ^ BufferRowLength.GetHashCode()
			^ BufferImageHeight.GetHashCode() ^ ImageSubresource.GetHashCode() ^ ImageOffset.GetHashCode() ^ ImageExtent.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in BufferImageCopy2 l, in BufferImageCopy2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.BufferOffset == r.BufferOffset) && (l.BufferRowLength == r.BufferRowLength)
			&& (l.BufferImageHeight == r.BufferImageHeight) && (l.ImageSubresource == r.ImageSubresource) && (l.ImageOffset == r.ImageOffset) && (l.ImageExtent == r.ImageExtent)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in BufferImageCopy2 l, in BufferImageCopy2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.BufferOffset != r.BufferOffset) || (l.BufferRowLength != r.BufferRowLength)
			|| (l.BufferImageHeight != r.BufferImageHeight) || (l.ImageSubresource != r.ImageSubresource) || (l.ImageOffset != r.ImageOffset) || (l.ImageExtent != r.ImageExtent)
			;
	}


	/// <summary>Creates a new BufferImageCopy2 value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out BufferImageCopy2 value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ImageResolve2 : IEquatable<ImageResolve2>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ImageResolve2KHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.ImageSubresourceLayers SrcSubresource;
	public Vk.Offset3D SrcOffset;
	public Vk.ImageSubresourceLayers DstSubresource;
	public Vk.Offset3D DstOffset;
	public Vk.Extent3D Extent;
	public ImageResolve2(
		in Vk.ImageSubresourceLayers srcSubresource = default,
		in Vk.Offset3D srcOffset = default,
		in Vk.ImageSubresourceLayers dstSubresource = default,
		in Vk.Offset3D dstOffset = default,
		in Vk.Extent3D extent = default
	) {
		sType = TYPE;
		pNext = null;
		SrcSubresource = srcSubresource;
		SrcOffset = srcOffset;
		DstSubresource = dstSubresource;
		DstOffset = dstOffset;
		Extent = extent;
	}


	public readonly override bool Equals(object? obj) => (obj is ImageResolve2 o) && (this == o);
	readonly bool IEquatable<ImageResolve2>.Equals(ImageResolve2 obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SrcSubresource.GetHashCode() ^ SrcOffset.GetHashCode()
			^ DstSubresource.GetHashCode() ^ DstOffset.GetHashCode() ^ Extent.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ImageResolve2 l, in ImageResolve2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SrcSubresource == r.SrcSubresource) && (l.SrcOffset == r.SrcOffset)
			&& (l.DstSubresource == r.DstSubresource) && (l.DstOffset == r.DstOffset) && (l.Extent == r.Extent)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ImageResolve2 l, in ImageResolve2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SrcSubresource != r.SrcSubresource) || (l.SrcOffset != r.SrcOffset)
			|| (l.DstSubresource != r.DstSubresource) || (l.DstOffset != r.DstOffset) || (l.Extent != r.Extent)
			;
	}


	/// <summary>Creates a new ImageResolve2 value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ImageResolve2 value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct CopyBufferInfo2 : IEquatable<CopyBufferInfo2>
{
	public const Vk.StructureType TYPE = Vk.StructureType.CopyBufferInfo2KHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Handle<Vk.Buffer> SrcBuffer;
	public Vk.Handle<Vk.Buffer> DstBuffer;
	public uint RegionCount;
	public Vk.KHR.BufferCopy2* Regions;
	public CopyBufferInfo2(
		in Vk.Handle<Vk.Buffer> srcBuffer = default,
		in Vk.Handle<Vk.Buffer> dstBuffer = default,
		uint regionCount = default,
		in Vk.KHR.BufferCopy2* regions = default
	) {
		sType = TYPE;
		pNext = null;
		SrcBuffer = srcBuffer;
		DstBuffer = dstBuffer;
		RegionCount = regionCount;
		Regions = regions;
	}


	public readonly override bool Equals(object? obj) => (obj is CopyBufferInfo2 o) && (this == o);
	readonly bool IEquatable<CopyBufferInfo2>.Equals(CopyBufferInfo2 obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SrcBuffer.GetHashCode() ^ DstBuffer.GetHashCode()
			^ RegionCount.GetHashCode() ^ ((ulong)Regions).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in CopyBufferInfo2 l, in CopyBufferInfo2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SrcBuffer == r.SrcBuffer) && (l.DstBuffer == r.DstBuffer)
			&& (l.RegionCount == r.RegionCount) && (l.Regions == r.Regions)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in CopyBufferInfo2 l, in CopyBufferInfo2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SrcBuffer != r.SrcBuffer) || (l.DstBuffer != r.DstBuffer)
			|| (l.RegionCount != r.RegionCount) || (l.Regions != r.Regions)
			;
	}


	/// <summary>Creates a new CopyBufferInfo2 value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out CopyBufferInfo2 value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct CopyImageInfo2 : IEquatable<CopyImageInfo2>
{
	public const Vk.StructureType TYPE = Vk.StructureType.CopyImageInfo2KHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Handle<Vk.Image> SrcImage;
	public Vk.ImageLayout SrcImageLayout;
	public Vk.Handle<Vk.Image> DstImage;
	public Vk.ImageLayout DstImageLayout;
	public uint RegionCount;
	public Vk.KHR.ImageCopy2* Regions;
	public CopyImageInfo2(
		in Vk.Handle<Vk.Image> srcImage = default,
		in Vk.ImageLayout srcImageLayout = default,
		in Vk.Handle<Vk.Image> dstImage = default,
		in Vk.ImageLayout dstImageLayout = default,
		uint regionCount = default,
		in Vk.KHR.ImageCopy2* regions = default
	) {
		sType = TYPE;
		pNext = null;
		SrcImage = srcImage;
		SrcImageLayout = srcImageLayout;
		DstImage = dstImage;
		DstImageLayout = dstImageLayout;
		RegionCount = regionCount;
		Regions = regions;
	}


	public readonly override bool Equals(object? obj) => (obj is CopyImageInfo2 o) && (this == o);
	readonly bool IEquatable<CopyImageInfo2>.Equals(CopyImageInfo2 obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SrcImage.GetHashCode() ^ SrcImageLayout.GetHashCode()
			^ DstImage.GetHashCode() ^ DstImageLayout.GetHashCode() ^ RegionCount.GetHashCode() ^ ((ulong)Regions).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in CopyImageInfo2 l, in CopyImageInfo2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SrcImage == r.SrcImage) && (l.SrcImageLayout == r.SrcImageLayout)
			&& (l.DstImage == r.DstImage) && (l.DstImageLayout == r.DstImageLayout) && (l.RegionCount == r.RegionCount) && (l.Regions == r.Regions)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in CopyImageInfo2 l, in CopyImageInfo2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SrcImage != r.SrcImage) || (l.SrcImageLayout != r.SrcImageLayout)
			|| (l.DstImage != r.DstImage) || (l.DstImageLayout != r.DstImageLayout) || (l.RegionCount != r.RegionCount) || (l.Regions != r.Regions)
			;
	}


	/// <summary>Creates a new CopyImageInfo2 value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out CopyImageInfo2 value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct BlitImageInfo2 : IEquatable<BlitImageInfo2>
{
	public const Vk.StructureType TYPE = Vk.StructureType.BlitImageInfo2KHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Handle<Vk.Image> SrcImage;
	public Vk.ImageLayout SrcImageLayout;
	public Vk.Handle<Vk.Image> DstImage;
	public Vk.ImageLayout DstImageLayout;
	public uint RegionCount;
	public Vk.KHR.ImageBlit2* Regions;
	public Vk.Filter Filter;
	public BlitImageInfo2(
		in Vk.Handle<Vk.Image> srcImage = default,
		in Vk.ImageLayout srcImageLayout = default,
		in Vk.Handle<Vk.Image> dstImage = default,
		in Vk.ImageLayout dstImageLayout = default,
		uint regionCount = default,
		in Vk.KHR.ImageBlit2* regions = default,
		in Vk.Filter filter = default
	) {
		sType = TYPE;
		pNext = null;
		SrcImage = srcImage;
		SrcImageLayout = srcImageLayout;
		DstImage = dstImage;
		DstImageLayout = dstImageLayout;
		RegionCount = regionCount;
		Regions = regions;
		Filter = filter;
	}


	public readonly override bool Equals(object? obj) => (obj is BlitImageInfo2 o) && (this == o);
	readonly bool IEquatable<BlitImageInfo2>.Equals(BlitImageInfo2 obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SrcImage.GetHashCode() ^ SrcImageLayout.GetHashCode()
			^ DstImage.GetHashCode() ^ DstImageLayout.GetHashCode() ^ RegionCount.GetHashCode() ^ ((ulong)Regions).GetHashCode()
			^ Filter.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in BlitImageInfo2 l, in BlitImageInfo2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SrcImage == r.SrcImage) && (l.SrcImageLayout == r.SrcImageLayout)
			&& (l.DstImage == r.DstImage) && (l.DstImageLayout == r.DstImageLayout) && (l.RegionCount == r.RegionCount) && (l.Regions == r.Regions)
			&& (l.Filter == r.Filter)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in BlitImageInfo2 l, in BlitImageInfo2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SrcImage != r.SrcImage) || (l.SrcImageLayout != r.SrcImageLayout)
			|| (l.DstImage != r.DstImage) || (l.DstImageLayout != r.DstImageLayout) || (l.RegionCount != r.RegionCount) || (l.Regions != r.Regions)
			|| (l.Filter != r.Filter)
			;
	}


	/// <summary>Creates a new BlitImageInfo2 value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out BlitImageInfo2 value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct CopyBufferToImageInfo2 : IEquatable<CopyBufferToImageInfo2>
{
	public const Vk.StructureType TYPE = Vk.StructureType.CopyBufferToImageInfo2KHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Handle<Vk.Buffer> SrcBuffer;
	public Vk.Handle<Vk.Image> DstImage;
	public Vk.ImageLayout DstImageLayout;
	public uint RegionCount;
	public Vk.KHR.BufferImageCopy2* Regions;
	public CopyBufferToImageInfo2(
		in Vk.Handle<Vk.Buffer> srcBuffer = default,
		in Vk.Handle<Vk.Image> dstImage = default,
		in Vk.ImageLayout dstImageLayout = default,
		uint regionCount = default,
		in Vk.KHR.BufferImageCopy2* regions = default
	) {
		sType = TYPE;
		pNext = null;
		SrcBuffer = srcBuffer;
		DstImage = dstImage;
		DstImageLayout = dstImageLayout;
		RegionCount = regionCount;
		Regions = regions;
	}


	public readonly override bool Equals(object? obj) => (obj is CopyBufferToImageInfo2 o) && (this == o);
	readonly bool IEquatable<CopyBufferToImageInfo2>.Equals(CopyBufferToImageInfo2 obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SrcBuffer.GetHashCode() ^ DstImage.GetHashCode()
			^ DstImageLayout.GetHashCode() ^ RegionCount.GetHashCode() ^ ((ulong)Regions).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in CopyBufferToImageInfo2 l, in CopyBufferToImageInfo2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SrcBuffer == r.SrcBuffer) && (l.DstImage == r.DstImage)
			&& (l.DstImageLayout == r.DstImageLayout) && (l.RegionCount == r.RegionCount) && (l.Regions == r.Regions)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in CopyBufferToImageInfo2 l, in CopyBufferToImageInfo2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SrcBuffer != r.SrcBuffer) || (l.DstImage != r.DstImage)
			|| (l.DstImageLayout != r.DstImageLayout) || (l.RegionCount != r.RegionCount) || (l.Regions != r.Regions)
			;
	}


	/// <summary>Creates a new CopyBufferToImageInfo2 value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out CopyBufferToImageInfo2 value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct CopyImageToBufferInfo2 : IEquatable<CopyImageToBufferInfo2>
{
	public const Vk.StructureType TYPE = Vk.StructureType.CopyImageToBufferInfo2KHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Handle<Vk.Image> SrcImage;
	public Vk.ImageLayout SrcImageLayout;
	public Vk.Handle<Vk.Buffer> DstBuffer;
	public uint RegionCount;
	public Vk.KHR.BufferImageCopy2* Regions;
	public CopyImageToBufferInfo2(
		in Vk.Handle<Vk.Image> srcImage = default,
		in Vk.ImageLayout srcImageLayout = default,
		in Vk.Handle<Vk.Buffer> dstBuffer = default,
		uint regionCount = default,
		in Vk.KHR.BufferImageCopy2* regions = default
	) {
		sType = TYPE;
		pNext = null;
		SrcImage = srcImage;
		SrcImageLayout = srcImageLayout;
		DstBuffer = dstBuffer;
		RegionCount = regionCount;
		Regions = regions;
	}


	public readonly override bool Equals(object? obj) => (obj is CopyImageToBufferInfo2 o) && (this == o);
	readonly bool IEquatable<CopyImageToBufferInfo2>.Equals(CopyImageToBufferInfo2 obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SrcImage.GetHashCode() ^ SrcImageLayout.GetHashCode()
			^ DstBuffer.GetHashCode() ^ RegionCount.GetHashCode() ^ ((ulong)Regions).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in CopyImageToBufferInfo2 l, in CopyImageToBufferInfo2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SrcImage == r.SrcImage) && (l.SrcImageLayout == r.SrcImageLayout)
			&& (l.DstBuffer == r.DstBuffer) && (l.RegionCount == r.RegionCount) && (l.Regions == r.Regions)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in CopyImageToBufferInfo2 l, in CopyImageToBufferInfo2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SrcImage != r.SrcImage) || (l.SrcImageLayout != r.SrcImageLayout)
			|| (l.DstBuffer != r.DstBuffer) || (l.RegionCount != r.RegionCount) || (l.Regions != r.Regions)
			;
	}


	/// <summary>Creates a new CopyImageToBufferInfo2 value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out CopyImageToBufferInfo2 value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ResolveImageInfo2 : IEquatable<ResolveImageInfo2>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ResolveImageInfo2KHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Handle<Vk.Image> SrcImage;
	public Vk.ImageLayout SrcImageLayout;
	public Vk.Handle<Vk.Image> DstImage;
	public Vk.ImageLayout DstImageLayout;
	public uint RegionCount;
	public Vk.KHR.ImageResolve2* Regions;
	public ResolveImageInfo2(
		in Vk.Handle<Vk.Image> srcImage = default,
		in Vk.ImageLayout srcImageLayout = default,
		in Vk.Handle<Vk.Image> dstImage = default,
		in Vk.ImageLayout dstImageLayout = default,
		uint regionCount = default,
		in Vk.KHR.ImageResolve2* regions = default
	) {
		sType = TYPE;
		pNext = null;
		SrcImage = srcImage;
		SrcImageLayout = srcImageLayout;
		DstImage = dstImage;
		DstImageLayout = dstImageLayout;
		RegionCount = regionCount;
		Regions = regions;
	}


	public readonly override bool Equals(object? obj) => (obj is ResolveImageInfo2 o) && (this == o);
	readonly bool IEquatable<ResolveImageInfo2>.Equals(ResolveImageInfo2 obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SrcImage.GetHashCode() ^ SrcImageLayout.GetHashCode()
			^ DstImage.GetHashCode() ^ DstImageLayout.GetHashCode() ^ RegionCount.GetHashCode() ^ ((ulong)Regions).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ResolveImageInfo2 l, in ResolveImageInfo2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SrcImage == r.SrcImage) && (l.SrcImageLayout == r.SrcImageLayout)
			&& (l.DstImage == r.DstImage) && (l.DstImageLayout == r.DstImageLayout) && (l.RegionCount == r.RegionCount) && (l.Regions == r.Regions)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ResolveImageInfo2 l, in ResolveImageInfo2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SrcImage != r.SrcImage) || (l.SrcImageLayout != r.SrcImageLayout)
			|| (l.DstImage != r.DstImage) || (l.DstImageLayout != r.DstImageLayout) || (l.RegionCount != r.RegionCount) || (l.Regions != r.Regions)
			;
	}


	/// <summary>Creates a new ResolveImageInfo2 value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ResolveImageInfo2 value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct FragmentShadingRateAttachmentInfo : IEquatable<FragmentShadingRateAttachmentInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.FragmentShadingRateAttachmentInfoKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.AttachmentReference2* FragmentShadingRateAttachment;
	public Vk.Extent2D ShadingRateAttachmentTexelSize;
	public FragmentShadingRateAttachmentInfo(
		in Vk.AttachmentReference2* fragmentShadingRateAttachment = default,
		in Vk.Extent2D shadingRateAttachmentTexelSize = default
	) {
		sType = TYPE;
		pNext = null;
		FragmentShadingRateAttachment = fragmentShadingRateAttachment;
		ShadingRateAttachmentTexelSize = shadingRateAttachmentTexelSize;
	}


	public readonly override bool Equals(object? obj) => (obj is FragmentShadingRateAttachmentInfo o) && (this == o);
	readonly bool IEquatable<FragmentShadingRateAttachmentInfo>.Equals(FragmentShadingRateAttachmentInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ((ulong)FragmentShadingRateAttachment).GetHashCode() ^ ShadingRateAttachmentTexelSize.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in FragmentShadingRateAttachmentInfo l, in FragmentShadingRateAttachmentInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.FragmentShadingRateAttachment == r.FragmentShadingRateAttachment) && (l.ShadingRateAttachmentTexelSize == r.ShadingRateAttachmentTexelSize)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in FragmentShadingRateAttachmentInfo l, in FragmentShadingRateAttachmentInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.FragmentShadingRateAttachment != r.FragmentShadingRateAttachment) || (l.ShadingRateAttachmentTexelSize != r.ShadingRateAttachmentTexelSize)
			;
	}


	/// <summary>Creates a new FragmentShadingRateAttachmentInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out FragmentShadingRateAttachmentInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PipelineFragmentShadingRateStateCreateInfo : IEquatable<PipelineFragmentShadingRateStateCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PipelineFragmentShadingRateStateCreateInfoKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Extent2D FragmentSize;
	public Vk.KHR.FragmentShadingRateCombinerOp CombinerOps_0;
	public Vk.KHR.FragmentShadingRateCombinerOp CombinerOps_1;
	public PipelineFragmentShadingRateStateCreateInfo(
		in Vk.Extent2D fragmentSize = default,
		in Vk.KHR.FragmentShadingRateCombinerOp combinerOps0 = default,
		in Vk.KHR.FragmentShadingRateCombinerOp combinerOps1 = default
	) {
		sType = TYPE;
		pNext = null;
		FragmentSize = fragmentSize;
		CombinerOps_0 = combinerOps0;
		CombinerOps_1 = combinerOps1;
	}


	public readonly override bool Equals(object? obj) => (obj is PipelineFragmentShadingRateStateCreateInfo o) && (this == o);
	readonly bool IEquatable<PipelineFragmentShadingRateStateCreateInfo>.Equals(PipelineFragmentShadingRateStateCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ FragmentSize.GetHashCode() ^ CombinerOps_0.GetHashCode()
			^ CombinerOps_1.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PipelineFragmentShadingRateStateCreateInfo l, in PipelineFragmentShadingRateStateCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.FragmentSize == r.FragmentSize) && (l.CombinerOps_0 == r.CombinerOps_0)
			&& (l.CombinerOps_1 == r.CombinerOps_1)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PipelineFragmentShadingRateStateCreateInfo l, in PipelineFragmentShadingRateStateCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.FragmentSize != r.FragmentSize) || (l.CombinerOps_0 != r.CombinerOps_0)
			|| (l.CombinerOps_1 != r.CombinerOps_1)
			;
	}


	/// <summary>Creates a new PipelineFragmentShadingRateStateCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PipelineFragmentShadingRateStateCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceFragmentShadingRateFeatures : IEquatable<PhysicalDeviceFragmentShadingRateFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceFragmentShadingRateFeaturesKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 PipelineFragmentShadingRate;
	public Vk.Bool32 PrimitiveFragmentShadingRate;
	public Vk.Bool32 AttachmentFragmentShadingRate;
	public PhysicalDeviceFragmentShadingRateFeatures(
		in Vk.Bool32 pipelineFragmentShadingRate = default,
		in Vk.Bool32 primitiveFragmentShadingRate = default,
		in Vk.Bool32 attachmentFragmentShadingRate = default
	) {
		sType = TYPE;
		pNext = null;
		PipelineFragmentShadingRate = pipelineFragmentShadingRate;
		PrimitiveFragmentShadingRate = primitiveFragmentShadingRate;
		AttachmentFragmentShadingRate = attachmentFragmentShadingRate;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceFragmentShadingRateFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceFragmentShadingRateFeatures>.Equals(PhysicalDeviceFragmentShadingRateFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ PipelineFragmentShadingRate.GetHashCode() ^ PrimitiveFragmentShadingRate.GetHashCode()
			^ AttachmentFragmentShadingRate.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceFragmentShadingRateFeatures l, in PhysicalDeviceFragmentShadingRateFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.PipelineFragmentShadingRate == r.PipelineFragmentShadingRate) && (l.PrimitiveFragmentShadingRate == r.PrimitiveFragmentShadingRate)
			&& (l.AttachmentFragmentShadingRate == r.AttachmentFragmentShadingRate)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceFragmentShadingRateFeatures l, in PhysicalDeviceFragmentShadingRateFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.PipelineFragmentShadingRate != r.PipelineFragmentShadingRate) || (l.PrimitiveFragmentShadingRate != r.PrimitiveFragmentShadingRate)
			|| (l.AttachmentFragmentShadingRate != r.AttachmentFragmentShadingRate)
			;
	}


	/// <summary>Creates a new PhysicalDeviceFragmentShadingRateFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceFragmentShadingRateFeatures value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceFragmentShadingRateProperties : IEquatable<PhysicalDeviceFragmentShadingRateProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceFragmentShadingRatePropertiesKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Extent2D MinFragmentShadingRateAttachmentTexelSize;
	public Vk.Extent2D MaxFragmentShadingRateAttachmentTexelSize;
	public uint MaxFragmentShadingRateAttachmentTexelSizeAspectRatio;
	public Vk.Bool32 PrimitiveFragmentShadingRateWithMultipleViewports;
	public Vk.Bool32 LayeredShadingRateAttachments;
	public Vk.Bool32 FragmentShadingRateNonTrivialCombinerOps;
	public Vk.Extent2D MaxFragmentSize;
	public uint MaxFragmentSizeAspectRatio;
	public uint MaxFragmentShadingRateCoverageSamples;
	public Vk.SampleCountFlags MaxFragmentShadingRateRasterizationSamples;
	public Vk.Bool32 FragmentShadingRateWithShaderDepthStencilWrites;
	public Vk.Bool32 FragmentShadingRateWithSampleMask;
	public Vk.Bool32 FragmentShadingRateWithShaderSampleMask;
	public Vk.Bool32 FragmentShadingRateWithConservativeRasterization;
	public Vk.Bool32 FragmentShadingRateWithFragmentShaderInterlock;
	public Vk.Bool32 FragmentShadingRateWithCustomSampleLocations;
	public Vk.Bool32 FragmentShadingRateStrictMultiplyCombiner;
	public PhysicalDeviceFragmentShadingRateProperties(
		in Vk.Extent2D minFragmentShadingRateAttachmentTexelSize = default,
		in Vk.Extent2D maxFragmentShadingRateAttachmentTexelSize = default,
		uint maxFragmentShadingRateAttachmentTexelSizeAspectRatio = default,
		in Vk.Bool32 primitiveFragmentShadingRateWithMultipleViewports = default,
		in Vk.Bool32 layeredShadingRateAttachments = default,
		in Vk.Bool32 fragmentShadingRateNonTrivialCombinerOps = default,
		in Vk.Extent2D maxFragmentSize = default,
		uint maxFragmentSizeAspectRatio = default,
		uint maxFragmentShadingRateCoverageSamples = default,
		in Vk.SampleCountFlags maxFragmentShadingRateRasterizationSamples = default,
		in Vk.Bool32 fragmentShadingRateWithShaderDepthStencilWrites = default,
		in Vk.Bool32 fragmentShadingRateWithSampleMask = default,
		in Vk.Bool32 fragmentShadingRateWithShaderSampleMask = default,
		in Vk.Bool32 fragmentShadingRateWithConservativeRasterization = default,
		in Vk.Bool32 fragmentShadingRateWithFragmentShaderInterlock = default,
		in Vk.Bool32 fragmentShadingRateWithCustomSampleLocations = default,
		in Vk.Bool32 fragmentShadingRateStrictMultiplyCombiner = default
	) {
		sType = TYPE;
		pNext = null;
		MinFragmentShadingRateAttachmentTexelSize = minFragmentShadingRateAttachmentTexelSize;
		MaxFragmentShadingRateAttachmentTexelSize = maxFragmentShadingRateAttachmentTexelSize;
		MaxFragmentShadingRateAttachmentTexelSizeAspectRatio = maxFragmentShadingRateAttachmentTexelSizeAspectRatio;
		PrimitiveFragmentShadingRateWithMultipleViewports = primitiveFragmentShadingRateWithMultipleViewports;
		LayeredShadingRateAttachments = layeredShadingRateAttachments;
		FragmentShadingRateNonTrivialCombinerOps = fragmentShadingRateNonTrivialCombinerOps;
		MaxFragmentSize = maxFragmentSize;
		MaxFragmentSizeAspectRatio = maxFragmentSizeAspectRatio;
		MaxFragmentShadingRateCoverageSamples = maxFragmentShadingRateCoverageSamples;
		MaxFragmentShadingRateRasterizationSamples = maxFragmentShadingRateRasterizationSamples;
		FragmentShadingRateWithShaderDepthStencilWrites = fragmentShadingRateWithShaderDepthStencilWrites;
		FragmentShadingRateWithSampleMask = fragmentShadingRateWithSampleMask;
		FragmentShadingRateWithShaderSampleMask = fragmentShadingRateWithShaderSampleMask;
		FragmentShadingRateWithConservativeRasterization = fragmentShadingRateWithConservativeRasterization;
		FragmentShadingRateWithFragmentShaderInterlock = fragmentShadingRateWithFragmentShaderInterlock;
		FragmentShadingRateWithCustomSampleLocations = fragmentShadingRateWithCustomSampleLocations;
		FragmentShadingRateStrictMultiplyCombiner = fragmentShadingRateStrictMultiplyCombiner;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceFragmentShadingRateProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceFragmentShadingRateProperties>.Equals(PhysicalDeviceFragmentShadingRateProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MinFragmentShadingRateAttachmentTexelSize.GetHashCode() ^ MaxFragmentShadingRateAttachmentTexelSize.GetHashCode()
			^ MaxFragmentShadingRateAttachmentTexelSizeAspectRatio.GetHashCode() ^ PrimitiveFragmentShadingRateWithMultipleViewports.GetHashCode() ^ LayeredShadingRateAttachments.GetHashCode() ^ FragmentShadingRateNonTrivialCombinerOps.GetHashCode()
			^ MaxFragmentSize.GetHashCode() ^ MaxFragmentSizeAspectRatio.GetHashCode() ^ MaxFragmentShadingRateCoverageSamples.GetHashCode() ^ MaxFragmentShadingRateRasterizationSamples.GetHashCode()
			^ FragmentShadingRateWithShaderDepthStencilWrites.GetHashCode() ^ FragmentShadingRateWithSampleMask.GetHashCode() ^ FragmentShadingRateWithShaderSampleMask.GetHashCode() ^ FragmentShadingRateWithConservativeRasterization.GetHashCode()
			^ FragmentShadingRateWithFragmentShaderInterlock.GetHashCode() ^ FragmentShadingRateWithCustomSampleLocations.GetHashCode() ^ FragmentShadingRateStrictMultiplyCombiner.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceFragmentShadingRateProperties l, in PhysicalDeviceFragmentShadingRateProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MinFragmentShadingRateAttachmentTexelSize == r.MinFragmentShadingRateAttachmentTexelSize) && (l.MaxFragmentShadingRateAttachmentTexelSize == r.MaxFragmentShadingRateAttachmentTexelSize)
			&& (l.MaxFragmentShadingRateAttachmentTexelSizeAspectRatio == r.MaxFragmentShadingRateAttachmentTexelSizeAspectRatio) && (l.PrimitiveFragmentShadingRateWithMultipleViewports == r.PrimitiveFragmentShadingRateWithMultipleViewports) && (l.LayeredShadingRateAttachments == r.LayeredShadingRateAttachments) && (l.FragmentShadingRateNonTrivialCombinerOps == r.FragmentShadingRateNonTrivialCombinerOps)
			&& (l.MaxFragmentSize == r.MaxFragmentSize) && (l.MaxFragmentSizeAspectRatio == r.MaxFragmentSizeAspectRatio) && (l.MaxFragmentShadingRateCoverageSamples == r.MaxFragmentShadingRateCoverageSamples) && (l.MaxFragmentShadingRateRasterizationSamples == r.MaxFragmentShadingRateRasterizationSamples)
			&& (l.FragmentShadingRateWithShaderDepthStencilWrites == r.FragmentShadingRateWithShaderDepthStencilWrites) && (l.FragmentShadingRateWithSampleMask == r.FragmentShadingRateWithSampleMask) && (l.FragmentShadingRateWithShaderSampleMask == r.FragmentShadingRateWithShaderSampleMask) && (l.FragmentShadingRateWithConservativeRasterization == r.FragmentShadingRateWithConservativeRasterization)
			&& (l.FragmentShadingRateWithFragmentShaderInterlock == r.FragmentShadingRateWithFragmentShaderInterlock) && (l.FragmentShadingRateWithCustomSampleLocations == r.FragmentShadingRateWithCustomSampleLocations) && (l.FragmentShadingRateStrictMultiplyCombiner == r.FragmentShadingRateStrictMultiplyCombiner)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceFragmentShadingRateProperties l, in PhysicalDeviceFragmentShadingRateProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MinFragmentShadingRateAttachmentTexelSize != r.MinFragmentShadingRateAttachmentTexelSize) || (l.MaxFragmentShadingRateAttachmentTexelSize != r.MaxFragmentShadingRateAttachmentTexelSize)
			|| (l.MaxFragmentShadingRateAttachmentTexelSizeAspectRatio != r.MaxFragmentShadingRateAttachmentTexelSizeAspectRatio) || (l.PrimitiveFragmentShadingRateWithMultipleViewports != r.PrimitiveFragmentShadingRateWithMultipleViewports) || (l.LayeredShadingRateAttachments != r.LayeredShadingRateAttachments) || (l.FragmentShadingRateNonTrivialCombinerOps != r.FragmentShadingRateNonTrivialCombinerOps)
			|| (l.MaxFragmentSize != r.MaxFragmentSize) || (l.MaxFragmentSizeAspectRatio != r.MaxFragmentSizeAspectRatio) || (l.MaxFragmentShadingRateCoverageSamples != r.MaxFragmentShadingRateCoverageSamples) || (l.MaxFragmentShadingRateRasterizationSamples != r.MaxFragmentShadingRateRasterizationSamples)
			|| (l.FragmentShadingRateWithShaderDepthStencilWrites != r.FragmentShadingRateWithShaderDepthStencilWrites) || (l.FragmentShadingRateWithSampleMask != r.FragmentShadingRateWithSampleMask) || (l.FragmentShadingRateWithShaderSampleMask != r.FragmentShadingRateWithShaderSampleMask) || (l.FragmentShadingRateWithConservativeRasterization != r.FragmentShadingRateWithConservativeRasterization)
			|| (l.FragmentShadingRateWithFragmentShaderInterlock != r.FragmentShadingRateWithFragmentShaderInterlock) || (l.FragmentShadingRateWithCustomSampleLocations != r.FragmentShadingRateWithCustomSampleLocations) || (l.FragmentShadingRateStrictMultiplyCombiner != r.FragmentShadingRateStrictMultiplyCombiner)
			;
	}


	/// <summary>Creates a new PhysicalDeviceFragmentShadingRateProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceFragmentShadingRateProperties value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceFragmentShadingRate : IEquatable<PhysicalDeviceFragmentShadingRate>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceFragmentShadingRateKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.SampleCountFlags SampleCounts;
	public Vk.Extent2D FragmentSize;
	public PhysicalDeviceFragmentShadingRate(
		in Vk.SampleCountFlags sampleCounts = default,
		in Vk.Extent2D fragmentSize = default
	) {
		sType = TYPE;
		pNext = null;
		SampleCounts = sampleCounts;
		FragmentSize = fragmentSize;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceFragmentShadingRate o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceFragmentShadingRate>.Equals(PhysicalDeviceFragmentShadingRate obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SampleCounts.GetHashCode() ^ FragmentSize.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceFragmentShadingRate l, in PhysicalDeviceFragmentShadingRate r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SampleCounts == r.SampleCounts) && (l.FragmentSize == r.FragmentSize)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceFragmentShadingRate l, in PhysicalDeviceFragmentShadingRate r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SampleCounts != r.SampleCounts) || (l.FragmentSize != r.FragmentSize)
			;
	}


	/// <summary>Creates a new PhysicalDeviceFragmentShadingRate value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceFragmentShadingRate value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceShaderTerminateInvocationFeatures : IEquatable<PhysicalDeviceShaderTerminateInvocationFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceShaderTerminateInvocationFeaturesKHR;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 ShaderTerminateInvocation;
	public PhysicalDeviceShaderTerminateInvocationFeatures(
		in Vk.Bool32 shaderTerminateInvocation = default
	) {
		sType = TYPE;
		pNext = null;
		ShaderTerminateInvocation = shaderTerminateInvocation;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceShaderTerminateInvocationFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceShaderTerminateInvocationFeatures>.Equals(PhysicalDeviceShaderTerminateInvocationFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ShaderTerminateInvocation.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceShaderTerminateInvocationFeatures l, in PhysicalDeviceShaderTerminateInvocationFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ShaderTerminateInvocation == r.ShaderTerminateInvocation)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceShaderTerminateInvocationFeatures l, in PhysicalDeviceShaderTerminateInvocationFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ShaderTerminateInvocation != r.ShaderTerminateInvocation)
			;
	}


	/// <summary>Creates a new PhysicalDeviceShaderTerminateInvocationFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceShaderTerminateInvocationFeatures value) => value = new() { sType = TYPE };
}

} // namespace Vk.KHR
