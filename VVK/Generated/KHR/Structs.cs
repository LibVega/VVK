/*
 * MIT License - Copyright(c) 2020 Sean Moss
 * This file is subject to the terms and conditions of the MIT License, the text of which can be found in the 'LICENSE'
 * file at the root of this repository, or online at <https://opensource.org/licenses/MIT>.
 */

/// This file was generated by VVKGen. Edits to this file will be lost on next generation.

using System;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;

namespace Vulkan
{

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDisplayPropertiesKHR : IEquatable<VkDisplayPropertiesKHR>
{
	public VulkanHandle<VkDisplayKHR> Display;
	public byte* DisplayName;
	public VkExtent2D PhysicalDimensions;
	public VkExtent2D PhysicalResolution;
	public VkSurfaceTransformFlagsKHR SupportedTransforms;
	public VkBool32 PlaneReorderPossible;
	public VkBool32 PersistentContent;

	public VkDisplayPropertiesKHR(
		VulkanHandle<VkDisplayKHR> display = default,
		byte* displayName = default,
		VkExtent2D physicalDimensions = default,
		VkExtent2D physicalResolution = default,
		VkSurfaceTransformFlagsKHR supportedTransforms = default,
		VkBool32 planeReorderPossible = default,
		VkBool32 persistentContent = default
	) {
		Display = display;
		DisplayName = displayName;
		PhysicalDimensions = physicalDimensions;
		PhysicalResolution = physicalResolution;
		SupportedTransforms = supportedTransforms;
		PlaneReorderPossible = planeReorderPossible;
		PersistentContent = persistentContent;
	}

	public readonly override bool Equals(object? o) => (o is VkDisplayPropertiesKHR s) && (this == s);
	readonly bool IEquatable<VkDisplayPropertiesKHR>.Equals(VkDisplayPropertiesKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Display.GetHashCode() ^ ((ulong)DisplayName).GetHashCode() ^ PhysicalDimensions.GetHashCode() ^ PhysicalResolution.GetHashCode()
			^ SupportedTransforms.GetHashCode() ^ PlaneReorderPossible.GetHashCode() ^ PersistentContent.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDisplayPropertiesKHR l, in VkDisplayPropertiesKHR r)
	{
		return
			(l.Display == r.Display) && (l.DisplayName == r.DisplayName) && (l.PhysicalDimensions == r.PhysicalDimensions) && (l.PhysicalResolution == r.PhysicalResolution)
			&& (l.SupportedTransforms == r.SupportedTransforms) && (l.PlaneReorderPossible == r.PlaneReorderPossible) && (l.PersistentContent == r.PersistentContent)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDisplayPropertiesKHR l, in VkDisplayPropertiesKHR r)
	{
		return
			(l.Display != r.Display) || (l.DisplayName != r.DisplayName) || (l.PhysicalDimensions != r.PhysicalDimensions) || (l.PhysicalResolution != r.PhysicalResolution)
			|| (l.SupportedTransforms != r.SupportedTransforms) || (l.PlaneReorderPossible != r.PlaneReorderPossible) || (l.PersistentContent != r.PersistentContent)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDisplayPropertiesKHR s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDisplayPlanePropertiesKHR : IEquatable<VkDisplayPlanePropertiesKHR>
{
	public VulkanHandle<VkDisplayKHR> CurrentDisplay;
	public uint CurrentStackIndex;

	public VkDisplayPlanePropertiesKHR(
		VulkanHandle<VkDisplayKHR> currentDisplay = default,
		uint currentStackIndex = default
	) {
		CurrentDisplay = currentDisplay;
		CurrentStackIndex = currentStackIndex;
	}

	public readonly override bool Equals(object? o) => (o is VkDisplayPlanePropertiesKHR s) && (this == s);
	readonly bool IEquatable<VkDisplayPlanePropertiesKHR>.Equals(VkDisplayPlanePropertiesKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			CurrentDisplay.GetHashCode() ^ CurrentStackIndex.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDisplayPlanePropertiesKHR l, in VkDisplayPlanePropertiesKHR r)
	{
		return
			(l.CurrentDisplay == r.CurrentDisplay) && (l.CurrentStackIndex == r.CurrentStackIndex)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDisplayPlanePropertiesKHR l, in VkDisplayPlanePropertiesKHR r)
	{
		return
			(l.CurrentDisplay != r.CurrentDisplay) || (l.CurrentStackIndex != r.CurrentStackIndex)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDisplayPlanePropertiesKHR s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDisplayModeParametersKHR : IEquatable<VkDisplayModeParametersKHR>
{
	public VkExtent2D VisibleRegion;
	public uint RefreshRate;

	public VkDisplayModeParametersKHR(
		VkExtent2D visibleRegion = default,
		uint refreshRate = default
	) {
		VisibleRegion = visibleRegion;
		RefreshRate = refreshRate;
	}

	public readonly override bool Equals(object? o) => (o is VkDisplayModeParametersKHR s) && (this == s);
	readonly bool IEquatable<VkDisplayModeParametersKHR>.Equals(VkDisplayModeParametersKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			VisibleRegion.GetHashCode() ^ RefreshRate.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDisplayModeParametersKHR l, in VkDisplayModeParametersKHR r)
	{
		return
			(l.VisibleRegion == r.VisibleRegion) && (l.RefreshRate == r.RefreshRate)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDisplayModeParametersKHR l, in VkDisplayModeParametersKHR r)
	{
		return
			(l.VisibleRegion != r.VisibleRegion) || (l.RefreshRate != r.RefreshRate)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDisplayModeParametersKHR s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDisplayModePropertiesKHR : IEquatable<VkDisplayModePropertiesKHR>
{
	public VulkanHandle<VkDisplayModeKHR> DisplayMode;
	public VkDisplayModeParametersKHR Parameters;

	public VkDisplayModePropertiesKHR(
		VulkanHandle<VkDisplayModeKHR> displayMode = default,
		VkDisplayModeParametersKHR parameters = default
	) {
		DisplayMode = displayMode;
		Parameters = parameters;
	}

	public readonly override bool Equals(object? o) => (o is VkDisplayModePropertiesKHR s) && (this == s);
	readonly bool IEquatable<VkDisplayModePropertiesKHR>.Equals(VkDisplayModePropertiesKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			DisplayMode.GetHashCode() ^ Parameters.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDisplayModePropertiesKHR l, in VkDisplayModePropertiesKHR r)
	{
		return
			(l.DisplayMode == r.DisplayMode) && (l.Parameters == r.Parameters)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDisplayModePropertiesKHR l, in VkDisplayModePropertiesKHR r)
	{
		return
			(l.DisplayMode != r.DisplayMode) || (l.Parameters != r.Parameters)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDisplayModePropertiesKHR s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDisplayModeCreateInfoKHR : IEquatable<VkDisplayModeCreateInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.DisplayModeCreateInfoKhr;

	public VkStructureType sType;
	public void* pNext;
	public VkDisplayModeCreateFlagsKHR Flags;
	public VkDisplayModeParametersKHR Parameters;

	public VkDisplayModeCreateInfoKHR(
		VkDisplayModeCreateFlagsKHR flags = default,
		VkDisplayModeParametersKHR parameters = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		Parameters = parameters;
	}

	public readonly override bool Equals(object? o) => (o is VkDisplayModeCreateInfoKHR s) && (this == s);
	readonly bool IEquatable<VkDisplayModeCreateInfoKHR>.Equals(VkDisplayModeCreateInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ Parameters.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDisplayModeCreateInfoKHR l, in VkDisplayModeCreateInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.Parameters == r.Parameters)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDisplayModeCreateInfoKHR l, in VkDisplayModeCreateInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.Parameters != r.Parameters)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDisplayModeCreateInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDisplayPlaneCapabilitiesKHR : IEquatable<VkDisplayPlaneCapabilitiesKHR>
{
	public VkDisplayPlaneAlphaFlagsKHR SupportedAlpha;
	public VkOffset2D MinSrcPosition;
	public VkOffset2D MaxSrcPosition;
	public VkExtent2D MinSrcExtent;
	public VkExtent2D MaxSrcExtent;
	public VkOffset2D MinDstPosition;
	public VkOffset2D MaxDstPosition;
	public VkExtent2D MinDstExtent;
	public VkExtent2D MaxDstExtent;

	public VkDisplayPlaneCapabilitiesKHR(
		VkDisplayPlaneAlphaFlagsKHR supportedAlpha = default,
		VkOffset2D minSrcPosition = default,
		VkOffset2D maxSrcPosition = default,
		VkExtent2D minSrcExtent = default,
		VkExtent2D maxSrcExtent = default,
		VkOffset2D minDstPosition = default,
		VkOffset2D maxDstPosition = default,
		VkExtent2D minDstExtent = default,
		VkExtent2D maxDstExtent = default
	) {
		SupportedAlpha = supportedAlpha;
		MinSrcPosition = minSrcPosition;
		MaxSrcPosition = maxSrcPosition;
		MinSrcExtent = minSrcExtent;
		MaxSrcExtent = maxSrcExtent;
		MinDstPosition = minDstPosition;
		MaxDstPosition = maxDstPosition;
		MinDstExtent = minDstExtent;
		MaxDstExtent = maxDstExtent;
	}

	public readonly override bool Equals(object? o) => (o is VkDisplayPlaneCapabilitiesKHR s) && (this == s);
	readonly bool IEquatable<VkDisplayPlaneCapabilitiesKHR>.Equals(VkDisplayPlaneCapabilitiesKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			SupportedAlpha.GetHashCode() ^ MinSrcPosition.GetHashCode() ^ MaxSrcPosition.GetHashCode() ^ MinSrcExtent.GetHashCode()
			^ MaxSrcExtent.GetHashCode() ^ MinDstPosition.GetHashCode() ^ MaxDstPosition.GetHashCode() ^ MinDstExtent.GetHashCode()
			^ MaxDstExtent.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDisplayPlaneCapabilitiesKHR l, in VkDisplayPlaneCapabilitiesKHR r)
	{
		return
			(l.SupportedAlpha == r.SupportedAlpha) && (l.MinSrcPosition == r.MinSrcPosition) && (l.MaxSrcPosition == r.MaxSrcPosition) && (l.MinSrcExtent == r.MinSrcExtent)
			&& (l.MaxSrcExtent == r.MaxSrcExtent) && (l.MinDstPosition == r.MinDstPosition) && (l.MaxDstPosition == r.MaxDstPosition) && (l.MinDstExtent == r.MinDstExtent)
			&& (l.MaxDstExtent == r.MaxDstExtent)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDisplayPlaneCapabilitiesKHR l, in VkDisplayPlaneCapabilitiesKHR r)
	{
		return
			(l.SupportedAlpha != r.SupportedAlpha) || (l.MinSrcPosition != r.MinSrcPosition) || (l.MaxSrcPosition != r.MaxSrcPosition) || (l.MinSrcExtent != r.MinSrcExtent)
			|| (l.MaxSrcExtent != r.MaxSrcExtent) || (l.MinDstPosition != r.MinDstPosition) || (l.MaxDstPosition != r.MaxDstPosition) || (l.MinDstExtent != r.MinDstExtent)
			|| (l.MaxDstExtent != r.MaxDstExtent)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDisplayPlaneCapabilitiesKHR s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDisplaySurfaceCreateInfoKHR : IEquatable<VkDisplaySurfaceCreateInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.DisplaySurfaceCreateInfoKhr;

	public VkStructureType sType;
	public void* pNext;
	public VkDisplaySurfaceCreateFlagsKHR Flags;
	public VulkanHandle<VkDisplayModeKHR> DisplayMode;
	public uint PlaneIndex;
	public uint PlaneStackIndex;
	public VkSurfaceTransformFlagsKHR Transform;
	public float GlobalAlpha;
	public VkDisplayPlaneAlphaFlagsKHR AlphaMode;
	public VkExtent2D ImageExtent;

	public VkDisplaySurfaceCreateInfoKHR(
		VkDisplaySurfaceCreateFlagsKHR flags = default,
		VulkanHandle<VkDisplayModeKHR> displayMode = default,
		uint planeIndex = default,
		uint planeStackIndex = default,
		VkSurfaceTransformFlagsKHR transform = default,
		float globalAlpha = default,
		VkDisplayPlaneAlphaFlagsKHR alphaMode = default,
		VkExtent2D imageExtent = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		DisplayMode = displayMode;
		PlaneIndex = planeIndex;
		PlaneStackIndex = planeStackIndex;
		Transform = transform;
		GlobalAlpha = globalAlpha;
		AlphaMode = alphaMode;
		ImageExtent = imageExtent;
	}

	public readonly override bool Equals(object? o) => (o is VkDisplaySurfaceCreateInfoKHR s) && (this == s);
	readonly bool IEquatable<VkDisplaySurfaceCreateInfoKHR>.Equals(VkDisplaySurfaceCreateInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ DisplayMode.GetHashCode()
			^ PlaneIndex.GetHashCode() ^ PlaneStackIndex.GetHashCode() ^ Transform.GetHashCode() ^ GlobalAlpha.GetHashCode()
			^ AlphaMode.GetHashCode() ^ ImageExtent.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDisplaySurfaceCreateInfoKHR l, in VkDisplaySurfaceCreateInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.DisplayMode == r.DisplayMode)
			&& (l.PlaneIndex == r.PlaneIndex) && (l.PlaneStackIndex == r.PlaneStackIndex) && (l.Transform == r.Transform) && (l.GlobalAlpha == r.GlobalAlpha)
			&& (l.AlphaMode == r.AlphaMode) && (l.ImageExtent == r.ImageExtent)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDisplaySurfaceCreateInfoKHR l, in VkDisplaySurfaceCreateInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.DisplayMode != r.DisplayMode)
			|| (l.PlaneIndex != r.PlaneIndex) || (l.PlaneStackIndex != r.PlaneStackIndex) || (l.Transform != r.Transform) || (l.GlobalAlpha != r.GlobalAlpha)
			|| (l.AlphaMode != r.AlphaMode) || (l.ImageExtent != r.ImageExtent)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDisplaySurfaceCreateInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDisplayPresentInfoKHR : IEquatable<VkDisplayPresentInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.DisplayPresentInfoKhr;

	public VkStructureType sType;
	public void* pNext;
	public VkRect2D SrcRect;
	public VkRect2D DstRect;
	public VkBool32 Persistent;

	public VkDisplayPresentInfoKHR(
		VkRect2D srcRect = default,
		VkRect2D dstRect = default,
		VkBool32 persistent = default
	) {
		sType = TYPE;
		pNext = null;
		SrcRect = srcRect;
		DstRect = dstRect;
		Persistent = persistent;
	}

	public readonly override bool Equals(object? o) => (o is VkDisplayPresentInfoKHR s) && (this == s);
	readonly bool IEquatable<VkDisplayPresentInfoKHR>.Equals(VkDisplayPresentInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SrcRect.GetHashCode() ^ DstRect.GetHashCode()
			^ Persistent.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDisplayPresentInfoKHR l, in VkDisplayPresentInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SrcRect == r.SrcRect) && (l.DstRect == r.DstRect)
			&& (l.Persistent == r.Persistent)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDisplayPresentInfoKHR l, in VkDisplayPresentInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SrcRect != r.SrcRect) || (l.DstRect != r.DstRect)
			|| (l.Persistent != r.Persistent)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDisplayPresentInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkSurfaceCapabilitiesKHR : IEquatable<VkSurfaceCapabilitiesKHR>
{
	public uint MinImageCount;
	public uint MaxImageCount;
	public VkExtent2D CurrentExtent;
	public VkExtent2D MinImageExtent;
	public VkExtent2D MaxImageExtent;
	public uint MaxImageArrayLayers;
	public VkSurfaceTransformFlagsKHR SupportedTransforms;
	public VkSurfaceTransformFlagsKHR CurrentTransform;
	public VkCompositeAlphaFlagsKHR SupportedCompositeAlpha;
	public VkImageUsageFlags SupportedUsageFlags;

	public VkSurfaceCapabilitiesKHR(
		uint minImageCount = default,
		uint maxImageCount = default,
		VkExtent2D currentExtent = default,
		VkExtent2D minImageExtent = default,
		VkExtent2D maxImageExtent = default,
		uint maxImageArrayLayers = default,
		VkSurfaceTransformFlagsKHR supportedTransforms = default,
		VkSurfaceTransformFlagsKHR currentTransform = default,
		VkCompositeAlphaFlagsKHR supportedCompositeAlpha = default,
		VkImageUsageFlags supportedUsageFlags = default
	) {
		MinImageCount = minImageCount;
		MaxImageCount = maxImageCount;
		CurrentExtent = currentExtent;
		MinImageExtent = minImageExtent;
		MaxImageExtent = maxImageExtent;
		MaxImageArrayLayers = maxImageArrayLayers;
		SupportedTransforms = supportedTransforms;
		CurrentTransform = currentTransform;
		SupportedCompositeAlpha = supportedCompositeAlpha;
		SupportedUsageFlags = supportedUsageFlags;
	}

	public readonly override bool Equals(object? o) => (o is VkSurfaceCapabilitiesKHR s) && (this == s);
	readonly bool IEquatable<VkSurfaceCapabilitiesKHR>.Equals(VkSurfaceCapabilitiesKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			MinImageCount.GetHashCode() ^ MaxImageCount.GetHashCode() ^ CurrentExtent.GetHashCode() ^ MinImageExtent.GetHashCode()
			^ MaxImageExtent.GetHashCode() ^ MaxImageArrayLayers.GetHashCode() ^ SupportedTransforms.GetHashCode() ^ CurrentTransform.GetHashCode()
			^ SupportedCompositeAlpha.GetHashCode() ^ SupportedUsageFlags.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkSurfaceCapabilitiesKHR l, in VkSurfaceCapabilitiesKHR r)
	{
		return
			(l.MinImageCount == r.MinImageCount) && (l.MaxImageCount == r.MaxImageCount) && (l.CurrentExtent == r.CurrentExtent) && (l.MinImageExtent == r.MinImageExtent)
			&& (l.MaxImageExtent == r.MaxImageExtent) && (l.MaxImageArrayLayers == r.MaxImageArrayLayers) && (l.SupportedTransforms == r.SupportedTransforms) && (l.CurrentTransform == r.CurrentTransform)
			&& (l.SupportedCompositeAlpha == r.SupportedCompositeAlpha) && (l.SupportedUsageFlags == r.SupportedUsageFlags)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkSurfaceCapabilitiesKHR l, in VkSurfaceCapabilitiesKHR r)
	{
		return
			(l.MinImageCount != r.MinImageCount) || (l.MaxImageCount != r.MaxImageCount) || (l.CurrentExtent != r.CurrentExtent) || (l.MinImageExtent != r.MinImageExtent)
			|| (l.MaxImageExtent != r.MaxImageExtent) || (l.MaxImageArrayLayers != r.MaxImageArrayLayers) || (l.SupportedTransforms != r.SupportedTransforms) || (l.CurrentTransform != r.CurrentTransform)
			|| (l.SupportedCompositeAlpha != r.SupportedCompositeAlpha) || (l.SupportedUsageFlags != r.SupportedUsageFlags)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkSurfaceCapabilitiesKHR s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkAndroidSurfaceCreateInfoKHR : IEquatable<VkAndroidSurfaceCreateInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.AndroidSurfaceCreateInfoKhr;

	public VkStructureType sType;
	public void* pNext;
	public VkAndroidSurfaceCreateFlagsKHR Flags;
	public void* Window;

	public VkAndroidSurfaceCreateInfoKHR(
		VkAndroidSurfaceCreateFlagsKHR flags = default,
		void* window = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		Window = window;
	}

	public readonly override bool Equals(object? o) => (o is VkAndroidSurfaceCreateInfoKHR s) && (this == s);
	readonly bool IEquatable<VkAndroidSurfaceCreateInfoKHR>.Equals(VkAndroidSurfaceCreateInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ ((ulong)Window).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkAndroidSurfaceCreateInfoKHR l, in VkAndroidSurfaceCreateInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.Window == r.Window)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkAndroidSurfaceCreateInfoKHR l, in VkAndroidSurfaceCreateInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.Window != r.Window)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkAndroidSurfaceCreateInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkWaylandSurfaceCreateInfoKHR : IEquatable<VkWaylandSurfaceCreateInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.WaylandSurfaceCreateInfoKhr;

	public VkStructureType sType;
	public void* pNext;
	public VkWaylandSurfaceCreateFlagsKHR Flags;
	public void* Display;
	public void* Surface;

	public VkWaylandSurfaceCreateInfoKHR(
		VkWaylandSurfaceCreateFlagsKHR flags = default,
		void* display = default,
		void* surface = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		Display = display;
		Surface = surface;
	}

	public readonly override bool Equals(object? o) => (o is VkWaylandSurfaceCreateInfoKHR s) && (this == s);
	readonly bool IEquatable<VkWaylandSurfaceCreateInfoKHR>.Equals(VkWaylandSurfaceCreateInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ ((ulong)Display).GetHashCode()
			^ ((ulong)Surface).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkWaylandSurfaceCreateInfoKHR l, in VkWaylandSurfaceCreateInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.Display == r.Display)
			&& (l.Surface == r.Surface)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkWaylandSurfaceCreateInfoKHR l, in VkWaylandSurfaceCreateInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.Display != r.Display)
			|| (l.Surface != r.Surface)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkWaylandSurfaceCreateInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkWin32SurfaceCreateInfoKHR : IEquatable<VkWin32SurfaceCreateInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.Win32SurfaceCreateInfoKhr;

	public VkStructureType sType;
	public void* pNext;
	public VkWin32SurfaceCreateFlagsKHR Flags;
	public void* Hinstance;
	public void* Hwnd;

	public VkWin32SurfaceCreateInfoKHR(
		VkWin32SurfaceCreateFlagsKHR flags = default,
		void* hinstance = default,
		void* hwnd = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		Hinstance = hinstance;
		Hwnd = hwnd;
	}

	public readonly override bool Equals(object? o) => (o is VkWin32SurfaceCreateInfoKHR s) && (this == s);
	readonly bool IEquatable<VkWin32SurfaceCreateInfoKHR>.Equals(VkWin32SurfaceCreateInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ ((ulong)Hinstance).GetHashCode()
			^ ((ulong)Hwnd).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkWin32SurfaceCreateInfoKHR l, in VkWin32SurfaceCreateInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.Hinstance == r.Hinstance)
			&& (l.Hwnd == r.Hwnd)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkWin32SurfaceCreateInfoKHR l, in VkWin32SurfaceCreateInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.Hinstance != r.Hinstance)
			|| (l.Hwnd != r.Hwnd)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkWin32SurfaceCreateInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkXlibSurfaceCreateInfoKHR : IEquatable<VkXlibSurfaceCreateInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.XlibSurfaceCreateInfoKhr;

	public VkStructureType sType;
	public void* pNext;
	public VkXlibSurfaceCreateFlagsKHR Flags;
	public void* Dpy;
	public ulong Window;

	public VkXlibSurfaceCreateInfoKHR(
		VkXlibSurfaceCreateFlagsKHR flags = default,
		void* dpy = default,
		ulong window = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		Dpy = dpy;
		Window = window;
	}

	public readonly override bool Equals(object? o) => (o is VkXlibSurfaceCreateInfoKHR s) && (this == s);
	readonly bool IEquatable<VkXlibSurfaceCreateInfoKHR>.Equals(VkXlibSurfaceCreateInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ ((ulong)Dpy).GetHashCode()
			^ Window.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkXlibSurfaceCreateInfoKHR l, in VkXlibSurfaceCreateInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.Dpy == r.Dpy)
			&& (l.Window == r.Window)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkXlibSurfaceCreateInfoKHR l, in VkXlibSurfaceCreateInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.Dpy != r.Dpy)
			|| (l.Window != r.Window)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkXlibSurfaceCreateInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkXcbSurfaceCreateInfoKHR : IEquatable<VkXcbSurfaceCreateInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.XcbSurfaceCreateInfoKhr;

	public VkStructureType sType;
	public void* pNext;
	public VkXcbSurfaceCreateFlagsKHR Flags;
	public void* Connection;
	public uint Window;

	public VkXcbSurfaceCreateInfoKHR(
		VkXcbSurfaceCreateFlagsKHR flags = default,
		void* connection = default,
		uint window = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		Connection = connection;
		Window = window;
	}

	public readonly override bool Equals(object? o) => (o is VkXcbSurfaceCreateInfoKHR s) && (this == s);
	readonly bool IEquatable<VkXcbSurfaceCreateInfoKHR>.Equals(VkXcbSurfaceCreateInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ ((ulong)Connection).GetHashCode()
			^ Window.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkXcbSurfaceCreateInfoKHR l, in VkXcbSurfaceCreateInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.Connection == r.Connection)
			&& (l.Window == r.Window)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkXcbSurfaceCreateInfoKHR l, in VkXcbSurfaceCreateInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.Connection != r.Connection)
			|| (l.Window != r.Window)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkXcbSurfaceCreateInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkSurfaceFormatKHR : IEquatable<VkSurfaceFormatKHR>
{
	public VkFormat Format;
	public VkColorSpaceKHR ColorSpace;

	public VkSurfaceFormatKHR(
		VkFormat format = default,
		VkColorSpaceKHR colorSpace = default
	) {
		Format = format;
		ColorSpace = colorSpace;
	}

	public readonly override bool Equals(object? o) => (o is VkSurfaceFormatKHR s) && (this == s);
	readonly bool IEquatable<VkSurfaceFormatKHR>.Equals(VkSurfaceFormatKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Format.GetHashCode() ^ ColorSpace.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkSurfaceFormatKHR l, in VkSurfaceFormatKHR r)
	{
		return
			(l.Format == r.Format) && (l.ColorSpace == r.ColorSpace)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkSurfaceFormatKHR l, in VkSurfaceFormatKHR r)
	{
		return
			(l.Format != r.Format) || (l.ColorSpace != r.ColorSpace)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkSurfaceFormatKHR s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkSwapchainCreateInfoKHR : IEquatable<VkSwapchainCreateInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.SwapchainCreateInfoKhr;

	public VkStructureType sType;
	public void* pNext;
	public VkSwapchainCreateFlagsKHR Flags;
	public VulkanHandle<VkSurfaceKHR> Surface;
	public uint MinImageCount;
	public VkFormat ImageFormat;
	public VkColorSpaceKHR ImageColorSpace;
	public VkExtent2D ImageExtent;
	public uint ImageArrayLayers;
	public VkImageUsageFlags ImageUsage;
	public VkSharingMode ImageSharingMode;
	public uint QueueFamilyIndexCount;
	public uint* QueueFamilyIndices;
	public VkSurfaceTransformFlagsKHR PreTransform;
	public VkCompositeAlphaFlagsKHR CompositeAlpha;
	public VkPresentModeKHR PresentMode;
	public VkBool32 Clipped;
	public VulkanHandle<VkSwapchainKHR> OldSwapchain;

	public VkSwapchainCreateInfoKHR(
		VkSwapchainCreateFlagsKHR flags = default,
		VulkanHandle<VkSurfaceKHR> surface = default,
		uint minImageCount = default,
		VkFormat imageFormat = default,
		VkColorSpaceKHR imageColorSpace = default,
		VkExtent2D imageExtent = default,
		uint imageArrayLayers = default,
		VkImageUsageFlags imageUsage = default,
		VkSharingMode imageSharingMode = default,
		uint queueFamilyIndexCount = default,
		uint* queueFamilyIndices = default,
		VkSurfaceTransformFlagsKHR preTransform = default,
		VkCompositeAlphaFlagsKHR compositeAlpha = default,
		VkPresentModeKHR presentMode = default,
		VkBool32 clipped = default,
		VulkanHandle<VkSwapchainKHR> oldSwapchain = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		Surface = surface;
		MinImageCount = minImageCount;
		ImageFormat = imageFormat;
		ImageColorSpace = imageColorSpace;
		ImageExtent = imageExtent;
		ImageArrayLayers = imageArrayLayers;
		ImageUsage = imageUsage;
		ImageSharingMode = imageSharingMode;
		QueueFamilyIndexCount = queueFamilyIndexCount;
		QueueFamilyIndices = queueFamilyIndices;
		PreTransform = preTransform;
		CompositeAlpha = compositeAlpha;
		PresentMode = presentMode;
		Clipped = clipped;
		OldSwapchain = oldSwapchain;
	}

	public readonly override bool Equals(object? o) => (o is VkSwapchainCreateInfoKHR s) && (this == s);
	readonly bool IEquatable<VkSwapchainCreateInfoKHR>.Equals(VkSwapchainCreateInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ Surface.GetHashCode()
			^ MinImageCount.GetHashCode() ^ ImageFormat.GetHashCode() ^ ImageColorSpace.GetHashCode() ^ ImageExtent.GetHashCode()
			^ ImageArrayLayers.GetHashCode() ^ ImageUsage.GetHashCode() ^ ImageSharingMode.GetHashCode() ^ QueueFamilyIndexCount.GetHashCode()
			^ ((ulong)QueueFamilyIndices).GetHashCode() ^ PreTransform.GetHashCode() ^ CompositeAlpha.GetHashCode() ^ PresentMode.GetHashCode()
			^ Clipped.GetHashCode() ^ OldSwapchain.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkSwapchainCreateInfoKHR l, in VkSwapchainCreateInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.Surface == r.Surface)
			&& (l.MinImageCount == r.MinImageCount) && (l.ImageFormat == r.ImageFormat) && (l.ImageColorSpace == r.ImageColorSpace) && (l.ImageExtent == r.ImageExtent)
			&& (l.ImageArrayLayers == r.ImageArrayLayers) && (l.ImageUsage == r.ImageUsage) && (l.ImageSharingMode == r.ImageSharingMode) && (l.QueueFamilyIndexCount == r.QueueFamilyIndexCount)
			&& (l.QueueFamilyIndices == r.QueueFamilyIndices) && (l.PreTransform == r.PreTransform) && (l.CompositeAlpha == r.CompositeAlpha) && (l.PresentMode == r.PresentMode)
			&& (l.Clipped == r.Clipped) && (l.OldSwapchain == r.OldSwapchain)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkSwapchainCreateInfoKHR l, in VkSwapchainCreateInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.Surface != r.Surface)
			|| (l.MinImageCount != r.MinImageCount) || (l.ImageFormat != r.ImageFormat) || (l.ImageColorSpace != r.ImageColorSpace) || (l.ImageExtent != r.ImageExtent)
			|| (l.ImageArrayLayers != r.ImageArrayLayers) || (l.ImageUsage != r.ImageUsage) || (l.ImageSharingMode != r.ImageSharingMode) || (l.QueueFamilyIndexCount != r.QueueFamilyIndexCount)
			|| (l.QueueFamilyIndices != r.QueueFamilyIndices) || (l.PreTransform != r.PreTransform) || (l.CompositeAlpha != r.CompositeAlpha) || (l.PresentMode != r.PresentMode)
			|| (l.Clipped != r.Clipped) || (l.OldSwapchain != r.OldSwapchain)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkSwapchainCreateInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPresentInfoKHR : IEquatable<VkPresentInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.PresentInfoKhr;

	public VkStructureType sType;
	public void* pNext;
	public uint WaitSemaphoreCount;
	public VulkanHandle<VkSemaphore>* WaitSemaphores;
	public uint SwapchainCount;
	public VulkanHandle<VkSwapchainKHR>* Swapchains;
	public uint* ImageIndices;
	public VkResult* Results;

	public VkPresentInfoKHR(
		uint waitSemaphoreCount = default,
		VulkanHandle<VkSemaphore>* waitSemaphores = default,
		uint swapchainCount = default,
		VulkanHandle<VkSwapchainKHR>* swapchains = default,
		uint* imageIndices = default,
		VkResult* results = default
	) {
		sType = TYPE;
		pNext = null;
		WaitSemaphoreCount = waitSemaphoreCount;
		WaitSemaphores = waitSemaphores;
		SwapchainCount = swapchainCount;
		Swapchains = swapchains;
		ImageIndices = imageIndices;
		Results = results;
	}

	public readonly override bool Equals(object? o) => (o is VkPresentInfoKHR s) && (this == s);
	readonly bool IEquatable<VkPresentInfoKHR>.Equals(VkPresentInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ WaitSemaphoreCount.GetHashCode() ^ ((ulong)WaitSemaphores).GetHashCode()
			^ SwapchainCount.GetHashCode() ^ ((ulong)Swapchains).GetHashCode() ^ ((ulong)ImageIndices).GetHashCode() ^ ((ulong)Results).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPresentInfoKHR l, in VkPresentInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.WaitSemaphoreCount == r.WaitSemaphoreCount) && (l.WaitSemaphores == r.WaitSemaphores)
			&& (l.SwapchainCount == r.SwapchainCount) && (l.Swapchains == r.Swapchains) && (l.ImageIndices == r.ImageIndices) && (l.Results == r.Results)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPresentInfoKHR l, in VkPresentInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.WaitSemaphoreCount != r.WaitSemaphoreCount) || (l.WaitSemaphores != r.WaitSemaphores)
			|| (l.SwapchainCount != r.SwapchainCount) || (l.Swapchains != r.Swapchains) || (l.ImageIndices != r.ImageIndices) || (l.Results != r.Results)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPresentInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceFeatures2KHR : IEquatable<VkPhysicalDeviceFeatures2KHR>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceFeatures2;

	public VkStructureType sType;
	public void* pNext;
	public VkPhysicalDeviceFeatures Features;

	public VkPhysicalDeviceFeatures2KHR(
		VkPhysicalDeviceFeatures features = default
	) {
		sType = TYPE;
		pNext = null;
		Features = features;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceFeatures2KHR s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceFeatures2KHR>.Equals(VkPhysicalDeviceFeatures2KHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Features.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceFeatures2KHR l, in VkPhysicalDeviceFeatures2KHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Features == r.Features)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceFeatures2KHR l, in VkPhysicalDeviceFeatures2KHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Features != r.Features)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceFeatures2KHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceProperties2KHR : IEquatable<VkPhysicalDeviceProperties2KHR>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceProperties2;

	public VkStructureType sType;
	public void* pNext;
	public VkPhysicalDeviceProperties Properties;

	public VkPhysicalDeviceProperties2KHR(
		VkPhysicalDeviceProperties properties = default
	) {
		sType = TYPE;
		pNext = null;
		Properties = properties;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceProperties2KHR s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceProperties2KHR>.Equals(VkPhysicalDeviceProperties2KHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Properties.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceProperties2KHR l, in VkPhysicalDeviceProperties2KHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Properties == r.Properties)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceProperties2KHR l, in VkPhysicalDeviceProperties2KHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Properties != r.Properties)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceProperties2KHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkFormatProperties2KHR : IEquatable<VkFormatProperties2KHR>
{
	public const VkStructureType TYPE = VkStructureType.FormatProperties2;

	public VkStructureType sType;
	public void* pNext;
	public VkFormatProperties FormatProperties;

	public VkFormatProperties2KHR(
		VkFormatProperties formatProperties = default
	) {
		sType = TYPE;
		pNext = null;
		FormatProperties = formatProperties;
	}

	public readonly override bool Equals(object? o) => (o is VkFormatProperties2KHR s) && (this == s);
	readonly bool IEquatable<VkFormatProperties2KHR>.Equals(VkFormatProperties2KHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ FormatProperties.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkFormatProperties2KHR l, in VkFormatProperties2KHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.FormatProperties == r.FormatProperties)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkFormatProperties2KHR l, in VkFormatProperties2KHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.FormatProperties != r.FormatProperties)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkFormatProperties2KHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkImageFormatProperties2KHR : IEquatable<VkImageFormatProperties2KHR>
{
	public const VkStructureType TYPE = VkStructureType.ImageFormatProperties2;

	public VkStructureType sType;
	public void* pNext;
	public VkImageFormatProperties ImageFormatProperties;

	public VkImageFormatProperties2KHR(
		VkImageFormatProperties imageFormatProperties = default
	) {
		sType = TYPE;
		pNext = null;
		ImageFormatProperties = imageFormatProperties;
	}

	public readonly override bool Equals(object? o) => (o is VkImageFormatProperties2KHR s) && (this == s);
	readonly bool IEquatable<VkImageFormatProperties2KHR>.Equals(VkImageFormatProperties2KHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ImageFormatProperties.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkImageFormatProperties2KHR l, in VkImageFormatProperties2KHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ImageFormatProperties == r.ImageFormatProperties)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkImageFormatProperties2KHR l, in VkImageFormatProperties2KHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ImageFormatProperties != r.ImageFormatProperties)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkImageFormatProperties2KHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceImageFormatInfo2KHR : IEquatable<VkPhysicalDeviceImageFormatInfo2KHR>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceImageFormatInfo2;

	public VkStructureType sType;
	public void* pNext;
	public VkFormat Format;
	public VkImageType Type;
	public VkImageTiling Tiling;
	public VkImageUsageFlags Usage;
	public VkImageCreateFlags Flags;

	public VkPhysicalDeviceImageFormatInfo2KHR(
		VkFormat format = default,
		VkImageType type = default,
		VkImageTiling tiling = default,
		VkImageUsageFlags usage = default,
		VkImageCreateFlags flags = default
	) {
		sType = TYPE;
		pNext = null;
		Format = format;
		Type = type;
		Tiling = tiling;
		Usage = usage;
		Flags = flags;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceImageFormatInfo2KHR s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceImageFormatInfo2KHR>.Equals(VkPhysicalDeviceImageFormatInfo2KHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Format.GetHashCode() ^ Type.GetHashCode()
			^ Tiling.GetHashCode() ^ Usage.GetHashCode() ^ Flags.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceImageFormatInfo2KHR l, in VkPhysicalDeviceImageFormatInfo2KHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Format == r.Format) && (l.Type == r.Type)
			&& (l.Tiling == r.Tiling) && (l.Usage == r.Usage) && (l.Flags == r.Flags)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceImageFormatInfo2KHR l, in VkPhysicalDeviceImageFormatInfo2KHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Format != r.Format) || (l.Type != r.Type)
			|| (l.Tiling != r.Tiling) || (l.Usage != r.Usage) || (l.Flags != r.Flags)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceImageFormatInfo2KHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkQueueFamilyProperties2KHR : IEquatable<VkQueueFamilyProperties2KHR>
{
	public const VkStructureType TYPE = VkStructureType.QueueFamilyProperties2;

	public VkStructureType sType;
	public void* pNext;
	public VkQueueFamilyProperties QueueFamilyProperties;

	public VkQueueFamilyProperties2KHR(
		VkQueueFamilyProperties queueFamilyProperties = default
	) {
		sType = TYPE;
		pNext = null;
		QueueFamilyProperties = queueFamilyProperties;
	}

	public readonly override bool Equals(object? o) => (o is VkQueueFamilyProperties2KHR s) && (this == s);
	readonly bool IEquatable<VkQueueFamilyProperties2KHR>.Equals(VkQueueFamilyProperties2KHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ QueueFamilyProperties.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkQueueFamilyProperties2KHR l, in VkQueueFamilyProperties2KHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.QueueFamilyProperties == r.QueueFamilyProperties)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkQueueFamilyProperties2KHR l, in VkQueueFamilyProperties2KHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.QueueFamilyProperties != r.QueueFamilyProperties)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkQueueFamilyProperties2KHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceMemoryProperties2KHR : IEquatable<VkPhysicalDeviceMemoryProperties2KHR>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceMemoryProperties2;

	public VkStructureType sType;
	public void* pNext;
	public VkPhysicalDeviceMemoryProperties MemoryProperties;

	public VkPhysicalDeviceMemoryProperties2KHR(
		VkPhysicalDeviceMemoryProperties memoryProperties = default
	) {
		sType = TYPE;
		pNext = null;
		MemoryProperties = memoryProperties;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceMemoryProperties2KHR s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceMemoryProperties2KHR>.Equals(VkPhysicalDeviceMemoryProperties2KHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MemoryProperties.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceMemoryProperties2KHR l, in VkPhysicalDeviceMemoryProperties2KHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MemoryProperties == r.MemoryProperties)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceMemoryProperties2KHR l, in VkPhysicalDeviceMemoryProperties2KHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MemoryProperties != r.MemoryProperties)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceMemoryProperties2KHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkSparseImageFormatProperties2KHR : IEquatable<VkSparseImageFormatProperties2KHR>
{
	public const VkStructureType TYPE = VkStructureType.SparseImageFormatProperties2;

	public VkStructureType sType;
	public void* pNext;
	public VkSparseImageFormatProperties Properties;

	public VkSparseImageFormatProperties2KHR(
		VkSparseImageFormatProperties properties = default
	) {
		sType = TYPE;
		pNext = null;
		Properties = properties;
	}

	public readonly override bool Equals(object? o) => (o is VkSparseImageFormatProperties2KHR s) && (this == s);
	readonly bool IEquatable<VkSparseImageFormatProperties2KHR>.Equals(VkSparseImageFormatProperties2KHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Properties.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkSparseImageFormatProperties2KHR l, in VkSparseImageFormatProperties2KHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Properties == r.Properties)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkSparseImageFormatProperties2KHR l, in VkSparseImageFormatProperties2KHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Properties != r.Properties)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkSparseImageFormatProperties2KHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceSparseImageFormatInfo2KHR : IEquatable<VkPhysicalDeviceSparseImageFormatInfo2KHR>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceSparseImageFormatInfo2;

	public VkStructureType sType;
	public void* pNext;
	public VkFormat Format;
	public VkImageType Type;
	public VkSampleCountFlags Samples;
	public VkImageUsageFlags Usage;
	public VkImageTiling Tiling;

	public VkPhysicalDeviceSparseImageFormatInfo2KHR(
		VkFormat format = default,
		VkImageType type = default,
		VkSampleCountFlags samples = default,
		VkImageUsageFlags usage = default,
		VkImageTiling tiling = default
	) {
		sType = TYPE;
		pNext = null;
		Format = format;
		Type = type;
		Samples = samples;
		Usage = usage;
		Tiling = tiling;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceSparseImageFormatInfo2KHR s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceSparseImageFormatInfo2KHR>.Equals(VkPhysicalDeviceSparseImageFormatInfo2KHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Format.GetHashCode() ^ Type.GetHashCode()
			^ Samples.GetHashCode() ^ Usage.GetHashCode() ^ Tiling.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceSparseImageFormatInfo2KHR l, in VkPhysicalDeviceSparseImageFormatInfo2KHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Format == r.Format) && (l.Type == r.Type)
			&& (l.Samples == r.Samples) && (l.Usage == r.Usage) && (l.Tiling == r.Tiling)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceSparseImageFormatInfo2KHR l, in VkPhysicalDeviceSparseImageFormatInfo2KHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Format != r.Format) || (l.Type != r.Type)
			|| (l.Samples != r.Samples) || (l.Usage != r.Usage) || (l.Tiling != r.Tiling)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceSparseImageFormatInfo2KHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDevicePushDescriptorPropertiesKHR : IEquatable<VkPhysicalDevicePushDescriptorPropertiesKHR>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDevicePushDescriptorPropertiesKhr;

	public VkStructureType sType;
	public void* pNext;
	public uint MaxPushDescriptors;

	public VkPhysicalDevicePushDescriptorPropertiesKHR(
		uint maxPushDescriptors = default
	) {
		sType = TYPE;
		pNext = null;
		MaxPushDescriptors = maxPushDescriptors;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDevicePushDescriptorPropertiesKHR s) && (this == s);
	readonly bool IEquatable<VkPhysicalDevicePushDescriptorPropertiesKHR>.Equals(VkPhysicalDevicePushDescriptorPropertiesKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MaxPushDescriptors.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDevicePushDescriptorPropertiesKHR l, in VkPhysicalDevicePushDescriptorPropertiesKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MaxPushDescriptors == r.MaxPushDescriptors)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDevicePushDescriptorPropertiesKHR l, in VkPhysicalDevicePushDescriptorPropertiesKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MaxPushDescriptors != r.MaxPushDescriptors)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDevicePushDescriptorPropertiesKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkConformanceVersionKHR : IEquatable<VkConformanceVersionKHR>
{
	public byte Major;
	public byte Minor;
	public byte Subminor;
	public byte Patch;

	public VkConformanceVersionKHR(
		byte major = default,
		byte minor = default,
		byte subminor = default,
		byte patch = default
	) {
		Major = major;
		Minor = minor;
		Subminor = subminor;
		Patch = patch;
	}

	public readonly override bool Equals(object? o) => (o is VkConformanceVersionKHR s) && (this == s);
	readonly bool IEquatable<VkConformanceVersionKHR>.Equals(VkConformanceVersionKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Major.GetHashCode() ^ Minor.GetHashCode() ^ Subminor.GetHashCode() ^ Patch.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkConformanceVersionKHR l, in VkConformanceVersionKHR r)
	{
		return
			(l.Major == r.Major) && (l.Minor == r.Minor) && (l.Subminor == r.Subminor) && (l.Patch == r.Patch)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkConformanceVersionKHR l, in VkConformanceVersionKHR r)
	{
		return
			(l.Major != r.Major) || (l.Minor != r.Minor) || (l.Subminor != r.Subminor) || (l.Patch != r.Patch)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkConformanceVersionKHR s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceDriverPropertiesKHR : IEquatable<VkPhysicalDeviceDriverPropertiesKHR>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceDriverProperties;

	public VkStructureType sType;
	public void* pNext;
	public VkDriverId DriverID;
	public VVK.DriverName DriverName;
	public VVK.DriverInfo DriverInfo;
	public VkConformanceVersion ConformanceVersion;

	public VkPhysicalDeviceDriverPropertiesKHR(
		VkDriverId driverID = default,
		VVK.DriverName driverName = default,
		VVK.DriverInfo driverInfo = default,
		VkConformanceVersion conformanceVersion = default
	) {
		sType = TYPE;
		pNext = null;
		DriverID = driverID;
		DriverName = driverName;
		DriverInfo = driverInfo;
		ConformanceVersion = conformanceVersion;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceDriverPropertiesKHR s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceDriverPropertiesKHR>.Equals(VkPhysicalDeviceDriverPropertiesKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DriverID.GetHashCode() ^ DriverName.GetHashCode()
			^ DriverInfo.GetHashCode() ^ ConformanceVersion.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceDriverPropertiesKHR l, in VkPhysicalDeviceDriverPropertiesKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DriverID == r.DriverID) && (l.DriverName == r.DriverName)
			&& (l.DriverInfo == r.DriverInfo) && (l.ConformanceVersion == r.ConformanceVersion)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceDriverPropertiesKHR l, in VkPhysicalDeviceDriverPropertiesKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DriverID != r.DriverID) || (l.DriverName != r.DriverName)
			|| (l.DriverInfo != r.DriverInfo) || (l.ConformanceVersion != r.ConformanceVersion)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceDriverPropertiesKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPresentRegionsKHR : IEquatable<VkPresentRegionsKHR>
{
	public const VkStructureType TYPE = VkStructureType.PresentRegionsKhr;

	public VkStructureType sType;
	public void* pNext;
	public uint SwapchainCount;
	public VkPresentRegionKHR* Regions;

	public VkPresentRegionsKHR(
		uint swapchainCount = default,
		VkPresentRegionKHR* regions = default
	) {
		sType = TYPE;
		pNext = null;
		SwapchainCount = swapchainCount;
		Regions = regions;
	}

	public readonly override bool Equals(object? o) => (o is VkPresentRegionsKHR s) && (this == s);
	readonly bool IEquatable<VkPresentRegionsKHR>.Equals(VkPresentRegionsKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SwapchainCount.GetHashCode() ^ ((ulong)Regions).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPresentRegionsKHR l, in VkPresentRegionsKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SwapchainCount == r.SwapchainCount) && (l.Regions == r.Regions)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPresentRegionsKHR l, in VkPresentRegionsKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SwapchainCount != r.SwapchainCount) || (l.Regions != r.Regions)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPresentRegionsKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPresentRegionKHR : IEquatable<VkPresentRegionKHR>
{
	public uint RectangleCount;
	public VkRectLayerKHR* Rectangles;

	public VkPresentRegionKHR(
		uint rectangleCount = default,
		VkRectLayerKHR* rectangles = default
	) {
		RectangleCount = rectangleCount;
		Rectangles = rectangles;
	}

	public readonly override bool Equals(object? o) => (o is VkPresentRegionKHR s) && (this == s);
	readonly bool IEquatable<VkPresentRegionKHR>.Equals(VkPresentRegionKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			RectangleCount.GetHashCode() ^ ((ulong)Rectangles).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPresentRegionKHR l, in VkPresentRegionKHR r)
	{
		return
			(l.RectangleCount == r.RectangleCount) && (l.Rectangles == r.Rectangles)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPresentRegionKHR l, in VkPresentRegionKHR r)
	{
		return
			(l.RectangleCount != r.RectangleCount) || (l.Rectangles != r.Rectangles)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPresentRegionKHR s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkRectLayerKHR : IEquatable<VkRectLayerKHR>
{
	public VkOffset2D Offset;
	public VkExtent2D Extent;
	public uint Layer;

	public VkRectLayerKHR(
		VkOffset2D offset = default,
		VkExtent2D extent = default,
		uint layer = default
	) {
		Offset = offset;
		Extent = extent;
		Layer = layer;
	}

	public readonly override bool Equals(object? o) => (o is VkRectLayerKHR s) && (this == s);
	readonly bool IEquatable<VkRectLayerKHR>.Equals(VkRectLayerKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Offset.GetHashCode() ^ Extent.GetHashCode() ^ Layer.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkRectLayerKHR l, in VkRectLayerKHR r)
	{
		return
			(l.Offset == r.Offset) && (l.Extent == r.Extent) && (l.Layer == r.Layer)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkRectLayerKHR l, in VkRectLayerKHR r)
	{
		return
			(l.Offset != r.Offset) || (l.Extent != r.Extent) || (l.Layer != r.Layer)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkRectLayerKHR s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceVariablePointersFeaturesKHR : IEquatable<VkPhysicalDeviceVariablePointersFeaturesKHR>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceVariablePointersFeatures;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 VariablePointersStorageBuffer;
	public VkBool32 VariablePointers;

	public VkPhysicalDeviceVariablePointersFeaturesKHR(
		VkBool32 variablePointersStorageBuffer = default,
		VkBool32 variablePointers = default
	) {
		sType = TYPE;
		pNext = null;
		VariablePointersStorageBuffer = variablePointersStorageBuffer;
		VariablePointers = variablePointers;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceVariablePointersFeaturesKHR s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceVariablePointersFeaturesKHR>.Equals(VkPhysicalDeviceVariablePointersFeaturesKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ VariablePointersStorageBuffer.GetHashCode() ^ VariablePointers.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceVariablePointersFeaturesKHR l, in VkPhysicalDeviceVariablePointersFeaturesKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.VariablePointersStorageBuffer == r.VariablePointersStorageBuffer) && (l.VariablePointers == r.VariablePointers)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceVariablePointersFeaturesKHR l, in VkPhysicalDeviceVariablePointersFeaturesKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.VariablePointersStorageBuffer != r.VariablePointersStorageBuffer) || (l.VariablePointers != r.VariablePointers)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceVariablePointersFeaturesKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceVariablePointerFeaturesKHR : IEquatable<VkPhysicalDeviceVariablePointerFeaturesKHR>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceVariablePointersFeatures;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 VariablePointersStorageBuffer;
	public VkBool32 VariablePointers;

	public VkPhysicalDeviceVariablePointerFeaturesKHR(
		VkBool32 variablePointersStorageBuffer = default,
		VkBool32 variablePointers = default
	) {
		sType = TYPE;
		pNext = null;
		VariablePointersStorageBuffer = variablePointersStorageBuffer;
		VariablePointers = variablePointers;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceVariablePointerFeaturesKHR s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceVariablePointerFeaturesKHR>.Equals(VkPhysicalDeviceVariablePointerFeaturesKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ VariablePointersStorageBuffer.GetHashCode() ^ VariablePointers.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceVariablePointerFeaturesKHR l, in VkPhysicalDeviceVariablePointerFeaturesKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.VariablePointersStorageBuffer == r.VariablePointersStorageBuffer) && (l.VariablePointers == r.VariablePointers)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceVariablePointerFeaturesKHR l, in VkPhysicalDeviceVariablePointerFeaturesKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.VariablePointersStorageBuffer != r.VariablePointersStorageBuffer) || (l.VariablePointers != r.VariablePointers)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceVariablePointerFeaturesKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkExternalMemoryPropertiesKHR : IEquatable<VkExternalMemoryPropertiesKHR>
{
	public VkExternalMemoryFeatureFlags ExternalMemoryFeatures;
	public VkExternalMemoryHandleTypeFlags ExportFromImportedHandleTypes;
	public VkExternalMemoryHandleTypeFlags CompatibleHandleTypes;

	public VkExternalMemoryPropertiesKHR(
		VkExternalMemoryFeatureFlags externalMemoryFeatures = default,
		VkExternalMemoryHandleTypeFlags exportFromImportedHandleTypes = default,
		VkExternalMemoryHandleTypeFlags compatibleHandleTypes = default
	) {
		ExternalMemoryFeatures = externalMemoryFeatures;
		ExportFromImportedHandleTypes = exportFromImportedHandleTypes;
		CompatibleHandleTypes = compatibleHandleTypes;
	}

	public readonly override bool Equals(object? o) => (o is VkExternalMemoryPropertiesKHR s) && (this == s);
	readonly bool IEquatable<VkExternalMemoryPropertiesKHR>.Equals(VkExternalMemoryPropertiesKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			ExternalMemoryFeatures.GetHashCode() ^ ExportFromImportedHandleTypes.GetHashCode() ^ CompatibleHandleTypes.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkExternalMemoryPropertiesKHR l, in VkExternalMemoryPropertiesKHR r)
	{
		return
			(l.ExternalMemoryFeatures == r.ExternalMemoryFeatures) && (l.ExportFromImportedHandleTypes == r.ExportFromImportedHandleTypes) && (l.CompatibleHandleTypes == r.CompatibleHandleTypes)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkExternalMemoryPropertiesKHR l, in VkExternalMemoryPropertiesKHR r)
	{
		return
			(l.ExternalMemoryFeatures != r.ExternalMemoryFeatures) || (l.ExportFromImportedHandleTypes != r.ExportFromImportedHandleTypes) || (l.CompatibleHandleTypes != r.CompatibleHandleTypes)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkExternalMemoryPropertiesKHR s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceExternalImageFormatInfoKHR : IEquatable<VkPhysicalDeviceExternalImageFormatInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceExternalImageFormatInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkExternalMemoryHandleTypeFlags HandleType;

	public VkPhysicalDeviceExternalImageFormatInfoKHR(
		VkExternalMemoryHandleTypeFlags handleType = default
	) {
		sType = TYPE;
		pNext = null;
		HandleType = handleType;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceExternalImageFormatInfoKHR s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceExternalImageFormatInfoKHR>.Equals(VkPhysicalDeviceExternalImageFormatInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ HandleType.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceExternalImageFormatInfoKHR l, in VkPhysicalDeviceExternalImageFormatInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.HandleType == r.HandleType)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceExternalImageFormatInfoKHR l, in VkPhysicalDeviceExternalImageFormatInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.HandleType != r.HandleType)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceExternalImageFormatInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkExternalImageFormatPropertiesKHR : IEquatable<VkExternalImageFormatPropertiesKHR>
{
	public const VkStructureType TYPE = VkStructureType.ExternalImageFormatProperties;

	public VkStructureType sType;
	public void* pNext;
	public VkExternalMemoryProperties ExternalMemoryProperties;

	public VkExternalImageFormatPropertiesKHR(
		VkExternalMemoryProperties externalMemoryProperties = default
	) {
		sType = TYPE;
		pNext = null;
		ExternalMemoryProperties = externalMemoryProperties;
	}

	public readonly override bool Equals(object? o) => (o is VkExternalImageFormatPropertiesKHR s) && (this == s);
	readonly bool IEquatable<VkExternalImageFormatPropertiesKHR>.Equals(VkExternalImageFormatPropertiesKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ExternalMemoryProperties.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkExternalImageFormatPropertiesKHR l, in VkExternalImageFormatPropertiesKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ExternalMemoryProperties == r.ExternalMemoryProperties)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkExternalImageFormatPropertiesKHR l, in VkExternalImageFormatPropertiesKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ExternalMemoryProperties != r.ExternalMemoryProperties)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkExternalImageFormatPropertiesKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceExternalBufferInfoKHR : IEquatable<VkPhysicalDeviceExternalBufferInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceExternalBufferInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkBufferCreateFlags Flags;
	public VkBufferUsageFlags Usage;
	public VkExternalMemoryHandleTypeFlags HandleType;

	public VkPhysicalDeviceExternalBufferInfoKHR(
		VkBufferCreateFlags flags = default,
		VkBufferUsageFlags usage = default,
		VkExternalMemoryHandleTypeFlags handleType = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		Usage = usage;
		HandleType = handleType;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceExternalBufferInfoKHR s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceExternalBufferInfoKHR>.Equals(VkPhysicalDeviceExternalBufferInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ Usage.GetHashCode()
			^ HandleType.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceExternalBufferInfoKHR l, in VkPhysicalDeviceExternalBufferInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.Usage == r.Usage)
			&& (l.HandleType == r.HandleType)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceExternalBufferInfoKHR l, in VkPhysicalDeviceExternalBufferInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.Usage != r.Usage)
			|| (l.HandleType != r.HandleType)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceExternalBufferInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkExternalBufferPropertiesKHR : IEquatable<VkExternalBufferPropertiesKHR>
{
	public const VkStructureType TYPE = VkStructureType.ExternalBufferProperties;

	public VkStructureType sType;
	public void* pNext;
	public VkExternalMemoryProperties ExternalMemoryProperties;

	public VkExternalBufferPropertiesKHR(
		VkExternalMemoryProperties externalMemoryProperties = default
	) {
		sType = TYPE;
		pNext = null;
		ExternalMemoryProperties = externalMemoryProperties;
	}

	public readonly override bool Equals(object? o) => (o is VkExternalBufferPropertiesKHR s) && (this == s);
	readonly bool IEquatable<VkExternalBufferPropertiesKHR>.Equals(VkExternalBufferPropertiesKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ExternalMemoryProperties.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkExternalBufferPropertiesKHR l, in VkExternalBufferPropertiesKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ExternalMemoryProperties == r.ExternalMemoryProperties)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkExternalBufferPropertiesKHR l, in VkExternalBufferPropertiesKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ExternalMemoryProperties != r.ExternalMemoryProperties)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkExternalBufferPropertiesKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceIDPropertiesKHR : IEquatable<VkPhysicalDeviceIDPropertiesKHR>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceIdProperties;

	public VkStructureType sType;
	public void* pNext;
	public VVK.UUID DeviceUUID;
	public VVK.UUID DriverUUID;
	public VVK.LUID DeviceLUID;
	public uint DeviceNodeMask;
	public VkBool32 DeviceLUIDValid;

	public VkPhysicalDeviceIDPropertiesKHR(
		VVK.UUID deviceUUID = default,
		VVK.UUID driverUUID = default,
		VVK.LUID deviceLUID = default,
		uint deviceNodeMask = default,
		VkBool32 deviceLUIDValid = default
	) {
		sType = TYPE;
		pNext = null;
		DeviceUUID = deviceUUID;
		DriverUUID = driverUUID;
		DeviceLUID = deviceLUID;
		DeviceNodeMask = deviceNodeMask;
		DeviceLUIDValid = deviceLUIDValid;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceIDPropertiesKHR s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceIDPropertiesKHR>.Equals(VkPhysicalDeviceIDPropertiesKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DeviceUUID.GetHashCode() ^ DriverUUID.GetHashCode()
			^ DeviceLUID.GetHashCode() ^ DeviceNodeMask.GetHashCode() ^ DeviceLUIDValid.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceIDPropertiesKHR l, in VkPhysicalDeviceIDPropertiesKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DeviceUUID == r.DeviceUUID) && (l.DriverUUID == r.DriverUUID)
			&& (l.DeviceLUID == r.DeviceLUID) && (l.DeviceNodeMask == r.DeviceNodeMask) && (l.DeviceLUIDValid == r.DeviceLUIDValid)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceIDPropertiesKHR l, in VkPhysicalDeviceIDPropertiesKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DeviceUUID != r.DeviceUUID) || (l.DriverUUID != r.DriverUUID)
			|| (l.DeviceLUID != r.DeviceLUID) || (l.DeviceNodeMask != r.DeviceNodeMask) || (l.DeviceLUIDValid != r.DeviceLUIDValid)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceIDPropertiesKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkExternalMemoryImageCreateInfoKHR : IEquatable<VkExternalMemoryImageCreateInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.ExternalMemoryImageCreateInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkExternalMemoryHandleTypeFlags HandleTypes;

	public VkExternalMemoryImageCreateInfoKHR(
		VkExternalMemoryHandleTypeFlags handleTypes = default
	) {
		sType = TYPE;
		pNext = null;
		HandleTypes = handleTypes;
	}

	public readonly override bool Equals(object? o) => (o is VkExternalMemoryImageCreateInfoKHR s) && (this == s);
	readonly bool IEquatable<VkExternalMemoryImageCreateInfoKHR>.Equals(VkExternalMemoryImageCreateInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ HandleTypes.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkExternalMemoryImageCreateInfoKHR l, in VkExternalMemoryImageCreateInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.HandleTypes == r.HandleTypes)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkExternalMemoryImageCreateInfoKHR l, in VkExternalMemoryImageCreateInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.HandleTypes != r.HandleTypes)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkExternalMemoryImageCreateInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkExternalMemoryBufferCreateInfoKHR : IEquatable<VkExternalMemoryBufferCreateInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.ExternalMemoryBufferCreateInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkExternalMemoryHandleTypeFlags HandleTypes;

	public VkExternalMemoryBufferCreateInfoKHR(
		VkExternalMemoryHandleTypeFlags handleTypes = default
	) {
		sType = TYPE;
		pNext = null;
		HandleTypes = handleTypes;
	}

	public readonly override bool Equals(object? o) => (o is VkExternalMemoryBufferCreateInfoKHR s) && (this == s);
	readonly bool IEquatable<VkExternalMemoryBufferCreateInfoKHR>.Equals(VkExternalMemoryBufferCreateInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ HandleTypes.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkExternalMemoryBufferCreateInfoKHR l, in VkExternalMemoryBufferCreateInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.HandleTypes == r.HandleTypes)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkExternalMemoryBufferCreateInfoKHR l, in VkExternalMemoryBufferCreateInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.HandleTypes != r.HandleTypes)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkExternalMemoryBufferCreateInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkExportMemoryAllocateInfoKHR : IEquatable<VkExportMemoryAllocateInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.ExportMemoryAllocateInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkExternalMemoryHandleTypeFlags HandleTypes;

	public VkExportMemoryAllocateInfoKHR(
		VkExternalMemoryHandleTypeFlags handleTypes = default
	) {
		sType = TYPE;
		pNext = null;
		HandleTypes = handleTypes;
	}

	public readonly override bool Equals(object? o) => (o is VkExportMemoryAllocateInfoKHR s) && (this == s);
	readonly bool IEquatable<VkExportMemoryAllocateInfoKHR>.Equals(VkExportMemoryAllocateInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ HandleTypes.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkExportMemoryAllocateInfoKHR l, in VkExportMemoryAllocateInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.HandleTypes == r.HandleTypes)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkExportMemoryAllocateInfoKHR l, in VkExportMemoryAllocateInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.HandleTypes != r.HandleTypes)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkExportMemoryAllocateInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkImportMemoryWin32HandleInfoKHR : IEquatable<VkImportMemoryWin32HandleInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.ImportMemoryWin32HandleInfoKhr;

	public VkStructureType sType;
	public void* pNext;
	public VkExternalMemoryHandleTypeFlags HandleType;
	public void* Handle;
	public ushort* Name;

	public VkImportMemoryWin32HandleInfoKHR(
		VkExternalMemoryHandleTypeFlags handleType = default,
		void* handle = default,
		ushort* name = default
	) {
		sType = TYPE;
		pNext = null;
		HandleType = handleType;
		Handle = handle;
		Name = name;
	}

	public readonly override bool Equals(object? o) => (o is VkImportMemoryWin32HandleInfoKHR s) && (this == s);
	readonly bool IEquatable<VkImportMemoryWin32HandleInfoKHR>.Equals(VkImportMemoryWin32HandleInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ HandleType.GetHashCode() ^ ((ulong)Handle).GetHashCode()
			^ ((ulong)Name).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkImportMemoryWin32HandleInfoKHR l, in VkImportMemoryWin32HandleInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.HandleType == r.HandleType) && (l.Handle == r.Handle)
			&& (l.Name == r.Name)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkImportMemoryWin32HandleInfoKHR l, in VkImportMemoryWin32HandleInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.HandleType != r.HandleType) || (l.Handle != r.Handle)
			|| (l.Name != r.Name)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkImportMemoryWin32HandleInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkExportMemoryWin32HandleInfoKHR : IEquatable<VkExportMemoryWin32HandleInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.ExportMemoryWin32HandleInfoKhr;

	public VkStructureType sType;
	public void* pNext;
	public void* Attributes;
	public uint DwAccess;
	public ushort* Name;

	public VkExportMemoryWin32HandleInfoKHR(
		void* attributes = default,
		uint dwAccess = default,
		ushort* name = default
	) {
		sType = TYPE;
		pNext = null;
		Attributes = attributes;
		DwAccess = dwAccess;
		Name = name;
	}

	public readonly override bool Equals(object? o) => (o is VkExportMemoryWin32HandleInfoKHR s) && (this == s);
	readonly bool IEquatable<VkExportMemoryWin32HandleInfoKHR>.Equals(VkExportMemoryWin32HandleInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ((ulong)Attributes).GetHashCode() ^ DwAccess.GetHashCode()
			^ ((ulong)Name).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkExportMemoryWin32HandleInfoKHR l, in VkExportMemoryWin32HandleInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Attributes == r.Attributes) && (l.DwAccess == r.DwAccess)
			&& (l.Name == r.Name)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkExportMemoryWin32HandleInfoKHR l, in VkExportMemoryWin32HandleInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Attributes != r.Attributes) || (l.DwAccess != r.DwAccess)
			|| (l.Name != r.Name)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkExportMemoryWin32HandleInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkMemoryWin32HandlePropertiesKHR : IEquatable<VkMemoryWin32HandlePropertiesKHR>
{
	public const VkStructureType TYPE = VkStructureType.MemoryWin32HandlePropertiesKhr;

	public VkStructureType sType;
	public void* pNext;
	public uint MemoryTypeBits;

	public VkMemoryWin32HandlePropertiesKHR(
		uint memoryTypeBits = default
	) {
		sType = TYPE;
		pNext = null;
		MemoryTypeBits = memoryTypeBits;
	}

	public readonly override bool Equals(object? o) => (o is VkMemoryWin32HandlePropertiesKHR s) && (this == s);
	readonly bool IEquatable<VkMemoryWin32HandlePropertiesKHR>.Equals(VkMemoryWin32HandlePropertiesKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MemoryTypeBits.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkMemoryWin32HandlePropertiesKHR l, in VkMemoryWin32HandlePropertiesKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MemoryTypeBits == r.MemoryTypeBits)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkMemoryWin32HandlePropertiesKHR l, in VkMemoryWin32HandlePropertiesKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MemoryTypeBits != r.MemoryTypeBits)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkMemoryWin32HandlePropertiesKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkMemoryGetWin32HandleInfoKHR : IEquatable<VkMemoryGetWin32HandleInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.MemoryGetWin32HandleInfoKhr;

	public VkStructureType sType;
	public void* pNext;
	public VulkanHandle<VkDeviceMemory> Memory;
	public VkExternalMemoryHandleTypeFlags HandleType;

	public VkMemoryGetWin32HandleInfoKHR(
		VulkanHandle<VkDeviceMemory> memory = default,
		VkExternalMemoryHandleTypeFlags handleType = default
	) {
		sType = TYPE;
		pNext = null;
		Memory = memory;
		HandleType = handleType;
	}

	public readonly override bool Equals(object? o) => (o is VkMemoryGetWin32HandleInfoKHR s) && (this == s);
	readonly bool IEquatable<VkMemoryGetWin32HandleInfoKHR>.Equals(VkMemoryGetWin32HandleInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Memory.GetHashCode() ^ HandleType.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkMemoryGetWin32HandleInfoKHR l, in VkMemoryGetWin32HandleInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Memory == r.Memory) && (l.HandleType == r.HandleType)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkMemoryGetWin32HandleInfoKHR l, in VkMemoryGetWin32HandleInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Memory != r.Memory) || (l.HandleType != r.HandleType)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkMemoryGetWin32HandleInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkImportMemoryFdInfoKHR : IEquatable<VkImportMemoryFdInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.ImportMemoryFdInfoKhr;

	public VkStructureType sType;
	public void* pNext;
	public VkExternalMemoryHandleTypeFlags HandleType;
	public int Fd;

	public VkImportMemoryFdInfoKHR(
		VkExternalMemoryHandleTypeFlags handleType = default,
		int fd = default
	) {
		sType = TYPE;
		pNext = null;
		HandleType = handleType;
		Fd = fd;
	}

	public readonly override bool Equals(object? o) => (o is VkImportMemoryFdInfoKHR s) && (this == s);
	readonly bool IEquatable<VkImportMemoryFdInfoKHR>.Equals(VkImportMemoryFdInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ HandleType.GetHashCode() ^ Fd.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkImportMemoryFdInfoKHR l, in VkImportMemoryFdInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.HandleType == r.HandleType) && (l.Fd == r.Fd)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkImportMemoryFdInfoKHR l, in VkImportMemoryFdInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.HandleType != r.HandleType) || (l.Fd != r.Fd)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkImportMemoryFdInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkMemoryFdPropertiesKHR : IEquatable<VkMemoryFdPropertiesKHR>
{
	public const VkStructureType TYPE = VkStructureType.MemoryFdPropertiesKhr;

	public VkStructureType sType;
	public void* pNext;
	public uint MemoryTypeBits;

	public VkMemoryFdPropertiesKHR(
		uint memoryTypeBits = default
	) {
		sType = TYPE;
		pNext = null;
		MemoryTypeBits = memoryTypeBits;
	}

	public readonly override bool Equals(object? o) => (o is VkMemoryFdPropertiesKHR s) && (this == s);
	readonly bool IEquatable<VkMemoryFdPropertiesKHR>.Equals(VkMemoryFdPropertiesKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MemoryTypeBits.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkMemoryFdPropertiesKHR l, in VkMemoryFdPropertiesKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MemoryTypeBits == r.MemoryTypeBits)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkMemoryFdPropertiesKHR l, in VkMemoryFdPropertiesKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MemoryTypeBits != r.MemoryTypeBits)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkMemoryFdPropertiesKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkMemoryGetFdInfoKHR : IEquatable<VkMemoryGetFdInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.MemoryGetFdInfoKhr;

	public VkStructureType sType;
	public void* pNext;
	public VulkanHandle<VkDeviceMemory> Memory;
	public VkExternalMemoryHandleTypeFlags HandleType;

	public VkMemoryGetFdInfoKHR(
		VulkanHandle<VkDeviceMemory> memory = default,
		VkExternalMemoryHandleTypeFlags handleType = default
	) {
		sType = TYPE;
		pNext = null;
		Memory = memory;
		HandleType = handleType;
	}

	public readonly override bool Equals(object? o) => (o is VkMemoryGetFdInfoKHR s) && (this == s);
	readonly bool IEquatable<VkMemoryGetFdInfoKHR>.Equals(VkMemoryGetFdInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Memory.GetHashCode() ^ HandleType.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkMemoryGetFdInfoKHR l, in VkMemoryGetFdInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Memory == r.Memory) && (l.HandleType == r.HandleType)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkMemoryGetFdInfoKHR l, in VkMemoryGetFdInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Memory != r.Memory) || (l.HandleType != r.HandleType)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkMemoryGetFdInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkWin32KeyedMutexAcquireReleaseInfoKHR : IEquatable<VkWin32KeyedMutexAcquireReleaseInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.Win32KeyedMutexAcquireReleaseInfoKhr;

	public VkStructureType sType;
	public void* pNext;
	public uint AcquireCount;
	public VulkanHandle<VkDeviceMemory>* AcquireSyncs;
	public ulong* AcquireKeys;
	public uint* AcquireTimeouts;
	public uint ReleaseCount;
	public VulkanHandle<VkDeviceMemory>* ReleaseSyncs;
	public ulong* ReleaseKeys;

	public VkWin32KeyedMutexAcquireReleaseInfoKHR(
		uint acquireCount = default,
		VulkanHandle<VkDeviceMemory>* acquireSyncs = default,
		ulong* acquireKeys = default,
		uint* acquireTimeouts = default,
		uint releaseCount = default,
		VulkanHandle<VkDeviceMemory>* releaseSyncs = default,
		ulong* releaseKeys = default
	) {
		sType = TYPE;
		pNext = null;
		AcquireCount = acquireCount;
		AcquireSyncs = acquireSyncs;
		AcquireKeys = acquireKeys;
		AcquireTimeouts = acquireTimeouts;
		ReleaseCount = releaseCount;
		ReleaseSyncs = releaseSyncs;
		ReleaseKeys = releaseKeys;
	}

	public readonly override bool Equals(object? o) => (o is VkWin32KeyedMutexAcquireReleaseInfoKHR s) && (this == s);
	readonly bool IEquatable<VkWin32KeyedMutexAcquireReleaseInfoKHR>.Equals(VkWin32KeyedMutexAcquireReleaseInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ AcquireCount.GetHashCode() ^ ((ulong)AcquireSyncs).GetHashCode()
			^ ((ulong)AcquireKeys).GetHashCode() ^ ((ulong)AcquireTimeouts).GetHashCode() ^ ReleaseCount.GetHashCode() ^ ((ulong)ReleaseSyncs).GetHashCode()
			^ ((ulong)ReleaseKeys).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkWin32KeyedMutexAcquireReleaseInfoKHR l, in VkWin32KeyedMutexAcquireReleaseInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.AcquireCount == r.AcquireCount) && (l.AcquireSyncs == r.AcquireSyncs)
			&& (l.AcquireKeys == r.AcquireKeys) && (l.AcquireTimeouts == r.AcquireTimeouts) && (l.ReleaseCount == r.ReleaseCount) && (l.ReleaseSyncs == r.ReleaseSyncs)
			&& (l.ReleaseKeys == r.ReleaseKeys)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkWin32KeyedMutexAcquireReleaseInfoKHR l, in VkWin32KeyedMutexAcquireReleaseInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.AcquireCount != r.AcquireCount) || (l.AcquireSyncs != r.AcquireSyncs)
			|| (l.AcquireKeys != r.AcquireKeys) || (l.AcquireTimeouts != r.AcquireTimeouts) || (l.ReleaseCount != r.ReleaseCount) || (l.ReleaseSyncs != r.ReleaseSyncs)
			|| (l.ReleaseKeys != r.ReleaseKeys)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkWin32KeyedMutexAcquireReleaseInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceExternalSemaphoreInfoKHR : IEquatable<VkPhysicalDeviceExternalSemaphoreInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceExternalSemaphoreInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkExternalSemaphoreHandleTypeFlags HandleType;

	public VkPhysicalDeviceExternalSemaphoreInfoKHR(
		VkExternalSemaphoreHandleTypeFlags handleType = default
	) {
		sType = TYPE;
		pNext = null;
		HandleType = handleType;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceExternalSemaphoreInfoKHR s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceExternalSemaphoreInfoKHR>.Equals(VkPhysicalDeviceExternalSemaphoreInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ HandleType.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceExternalSemaphoreInfoKHR l, in VkPhysicalDeviceExternalSemaphoreInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.HandleType == r.HandleType)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceExternalSemaphoreInfoKHR l, in VkPhysicalDeviceExternalSemaphoreInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.HandleType != r.HandleType)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceExternalSemaphoreInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkExternalSemaphorePropertiesKHR : IEquatable<VkExternalSemaphorePropertiesKHR>
{
	public const VkStructureType TYPE = VkStructureType.ExternalSemaphoreProperties;

	public VkStructureType sType;
	public void* pNext;
	public VkExternalSemaphoreHandleTypeFlags ExportFromImportedHandleTypes;
	public VkExternalSemaphoreHandleTypeFlags CompatibleHandleTypes;
	public VkExternalSemaphoreFeatureFlags ExternalSemaphoreFeatures;

	public VkExternalSemaphorePropertiesKHR(
		VkExternalSemaphoreHandleTypeFlags exportFromImportedHandleTypes = default,
		VkExternalSemaphoreHandleTypeFlags compatibleHandleTypes = default,
		VkExternalSemaphoreFeatureFlags externalSemaphoreFeatures = default
	) {
		sType = TYPE;
		pNext = null;
		ExportFromImportedHandleTypes = exportFromImportedHandleTypes;
		CompatibleHandleTypes = compatibleHandleTypes;
		ExternalSemaphoreFeatures = externalSemaphoreFeatures;
	}

	public readonly override bool Equals(object? o) => (o is VkExternalSemaphorePropertiesKHR s) && (this == s);
	readonly bool IEquatable<VkExternalSemaphorePropertiesKHR>.Equals(VkExternalSemaphorePropertiesKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ExportFromImportedHandleTypes.GetHashCode() ^ CompatibleHandleTypes.GetHashCode()
			^ ExternalSemaphoreFeatures.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkExternalSemaphorePropertiesKHR l, in VkExternalSemaphorePropertiesKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ExportFromImportedHandleTypes == r.ExportFromImportedHandleTypes) && (l.CompatibleHandleTypes == r.CompatibleHandleTypes)
			&& (l.ExternalSemaphoreFeatures == r.ExternalSemaphoreFeatures)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkExternalSemaphorePropertiesKHR l, in VkExternalSemaphorePropertiesKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ExportFromImportedHandleTypes != r.ExportFromImportedHandleTypes) || (l.CompatibleHandleTypes != r.CompatibleHandleTypes)
			|| (l.ExternalSemaphoreFeatures != r.ExternalSemaphoreFeatures)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkExternalSemaphorePropertiesKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkExportSemaphoreCreateInfoKHR : IEquatable<VkExportSemaphoreCreateInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.ExportSemaphoreCreateInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkExternalSemaphoreHandleTypeFlags HandleTypes;

	public VkExportSemaphoreCreateInfoKHR(
		VkExternalSemaphoreHandleTypeFlags handleTypes = default
	) {
		sType = TYPE;
		pNext = null;
		HandleTypes = handleTypes;
	}

	public readonly override bool Equals(object? o) => (o is VkExportSemaphoreCreateInfoKHR s) && (this == s);
	readonly bool IEquatable<VkExportSemaphoreCreateInfoKHR>.Equals(VkExportSemaphoreCreateInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ HandleTypes.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkExportSemaphoreCreateInfoKHR l, in VkExportSemaphoreCreateInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.HandleTypes == r.HandleTypes)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkExportSemaphoreCreateInfoKHR l, in VkExportSemaphoreCreateInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.HandleTypes != r.HandleTypes)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkExportSemaphoreCreateInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkImportSemaphoreWin32HandleInfoKHR : IEquatable<VkImportSemaphoreWin32HandleInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.ImportSemaphoreWin32HandleInfoKhr;

	public VkStructureType sType;
	public void* pNext;
	public VulkanHandle<VkSemaphore> Semaphore;
	public VkSemaphoreImportFlags Flags;
	public VkExternalSemaphoreHandleTypeFlags HandleType;
	public void* Handle;
	public ushort* Name;

	public VkImportSemaphoreWin32HandleInfoKHR(
		VulkanHandle<VkSemaphore> semaphore = default,
		VkSemaphoreImportFlags flags = default,
		VkExternalSemaphoreHandleTypeFlags handleType = default,
		void* handle = default,
		ushort* name = default
	) {
		sType = TYPE;
		pNext = null;
		Semaphore = semaphore;
		Flags = flags;
		HandleType = handleType;
		Handle = handle;
		Name = name;
	}

	public readonly override bool Equals(object? o) => (o is VkImportSemaphoreWin32HandleInfoKHR s) && (this == s);
	readonly bool IEquatable<VkImportSemaphoreWin32HandleInfoKHR>.Equals(VkImportSemaphoreWin32HandleInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Semaphore.GetHashCode() ^ Flags.GetHashCode()
			^ HandleType.GetHashCode() ^ ((ulong)Handle).GetHashCode() ^ ((ulong)Name).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkImportSemaphoreWin32HandleInfoKHR l, in VkImportSemaphoreWin32HandleInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Semaphore == r.Semaphore) && (l.Flags == r.Flags)
			&& (l.HandleType == r.HandleType) && (l.Handle == r.Handle) && (l.Name == r.Name)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkImportSemaphoreWin32HandleInfoKHR l, in VkImportSemaphoreWin32HandleInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Semaphore != r.Semaphore) || (l.Flags != r.Flags)
			|| (l.HandleType != r.HandleType) || (l.Handle != r.Handle) || (l.Name != r.Name)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkImportSemaphoreWin32HandleInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkExportSemaphoreWin32HandleInfoKHR : IEquatable<VkExportSemaphoreWin32HandleInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.ExportSemaphoreWin32HandleInfoKhr;

	public VkStructureType sType;
	public void* pNext;
	public void* Attributes;
	public uint DwAccess;
	public ushort* Name;

	public VkExportSemaphoreWin32HandleInfoKHR(
		void* attributes = default,
		uint dwAccess = default,
		ushort* name = default
	) {
		sType = TYPE;
		pNext = null;
		Attributes = attributes;
		DwAccess = dwAccess;
		Name = name;
	}

	public readonly override bool Equals(object? o) => (o is VkExportSemaphoreWin32HandleInfoKHR s) && (this == s);
	readonly bool IEquatable<VkExportSemaphoreWin32HandleInfoKHR>.Equals(VkExportSemaphoreWin32HandleInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ((ulong)Attributes).GetHashCode() ^ DwAccess.GetHashCode()
			^ ((ulong)Name).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkExportSemaphoreWin32HandleInfoKHR l, in VkExportSemaphoreWin32HandleInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Attributes == r.Attributes) && (l.DwAccess == r.DwAccess)
			&& (l.Name == r.Name)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkExportSemaphoreWin32HandleInfoKHR l, in VkExportSemaphoreWin32HandleInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Attributes != r.Attributes) || (l.DwAccess != r.DwAccess)
			|| (l.Name != r.Name)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkExportSemaphoreWin32HandleInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkD3D12FenceSubmitInfoKHR : IEquatable<VkD3D12FenceSubmitInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.D3d12FenceSubmitInfoKhr;

	public VkStructureType sType;
	public void* pNext;
	public uint WaitSemaphoreValuesCount;
	public ulong* WaitSemaphoreValues;
	public uint SignalSemaphoreValuesCount;
	public ulong* SignalSemaphoreValues;

	public VkD3D12FenceSubmitInfoKHR(
		uint waitSemaphoreValuesCount = default,
		ulong* waitSemaphoreValues = default,
		uint signalSemaphoreValuesCount = default,
		ulong* signalSemaphoreValues = default
	) {
		sType = TYPE;
		pNext = null;
		WaitSemaphoreValuesCount = waitSemaphoreValuesCount;
		WaitSemaphoreValues = waitSemaphoreValues;
		SignalSemaphoreValuesCount = signalSemaphoreValuesCount;
		SignalSemaphoreValues = signalSemaphoreValues;
	}

	public readonly override bool Equals(object? o) => (o is VkD3D12FenceSubmitInfoKHR s) && (this == s);
	readonly bool IEquatable<VkD3D12FenceSubmitInfoKHR>.Equals(VkD3D12FenceSubmitInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ WaitSemaphoreValuesCount.GetHashCode() ^ ((ulong)WaitSemaphoreValues).GetHashCode()
			^ SignalSemaphoreValuesCount.GetHashCode() ^ ((ulong)SignalSemaphoreValues).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkD3D12FenceSubmitInfoKHR l, in VkD3D12FenceSubmitInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.WaitSemaphoreValuesCount == r.WaitSemaphoreValuesCount) && (l.WaitSemaphoreValues == r.WaitSemaphoreValues)
			&& (l.SignalSemaphoreValuesCount == r.SignalSemaphoreValuesCount) && (l.SignalSemaphoreValues == r.SignalSemaphoreValues)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkD3D12FenceSubmitInfoKHR l, in VkD3D12FenceSubmitInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.WaitSemaphoreValuesCount != r.WaitSemaphoreValuesCount) || (l.WaitSemaphoreValues != r.WaitSemaphoreValues)
			|| (l.SignalSemaphoreValuesCount != r.SignalSemaphoreValuesCount) || (l.SignalSemaphoreValues != r.SignalSemaphoreValues)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkD3D12FenceSubmitInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkSemaphoreGetWin32HandleInfoKHR : IEquatable<VkSemaphoreGetWin32HandleInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.SemaphoreGetWin32HandleInfoKhr;

	public VkStructureType sType;
	public void* pNext;
	public VulkanHandle<VkSemaphore> Semaphore;
	public VkExternalSemaphoreHandleTypeFlags HandleType;

	public VkSemaphoreGetWin32HandleInfoKHR(
		VulkanHandle<VkSemaphore> semaphore = default,
		VkExternalSemaphoreHandleTypeFlags handleType = default
	) {
		sType = TYPE;
		pNext = null;
		Semaphore = semaphore;
		HandleType = handleType;
	}

	public readonly override bool Equals(object? o) => (o is VkSemaphoreGetWin32HandleInfoKHR s) && (this == s);
	readonly bool IEquatable<VkSemaphoreGetWin32HandleInfoKHR>.Equals(VkSemaphoreGetWin32HandleInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Semaphore.GetHashCode() ^ HandleType.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkSemaphoreGetWin32HandleInfoKHR l, in VkSemaphoreGetWin32HandleInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Semaphore == r.Semaphore) && (l.HandleType == r.HandleType)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkSemaphoreGetWin32HandleInfoKHR l, in VkSemaphoreGetWin32HandleInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Semaphore != r.Semaphore) || (l.HandleType != r.HandleType)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkSemaphoreGetWin32HandleInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkImportSemaphoreFdInfoKHR : IEquatable<VkImportSemaphoreFdInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.ImportSemaphoreFdInfoKhr;

	public VkStructureType sType;
	public void* pNext;
	public VulkanHandle<VkSemaphore> Semaphore;
	public VkSemaphoreImportFlags Flags;
	public VkExternalSemaphoreHandleTypeFlags HandleType;
	public int Fd;

	public VkImportSemaphoreFdInfoKHR(
		VulkanHandle<VkSemaphore> semaphore = default,
		VkSemaphoreImportFlags flags = default,
		VkExternalSemaphoreHandleTypeFlags handleType = default,
		int fd = default
	) {
		sType = TYPE;
		pNext = null;
		Semaphore = semaphore;
		Flags = flags;
		HandleType = handleType;
		Fd = fd;
	}

	public readonly override bool Equals(object? o) => (o is VkImportSemaphoreFdInfoKHR s) && (this == s);
	readonly bool IEquatable<VkImportSemaphoreFdInfoKHR>.Equals(VkImportSemaphoreFdInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Semaphore.GetHashCode() ^ Flags.GetHashCode()
			^ HandleType.GetHashCode() ^ Fd.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkImportSemaphoreFdInfoKHR l, in VkImportSemaphoreFdInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Semaphore == r.Semaphore) && (l.Flags == r.Flags)
			&& (l.HandleType == r.HandleType) && (l.Fd == r.Fd)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkImportSemaphoreFdInfoKHR l, in VkImportSemaphoreFdInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Semaphore != r.Semaphore) || (l.Flags != r.Flags)
			|| (l.HandleType != r.HandleType) || (l.Fd != r.Fd)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkImportSemaphoreFdInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkSemaphoreGetFdInfoKHR : IEquatable<VkSemaphoreGetFdInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.SemaphoreGetFdInfoKhr;

	public VkStructureType sType;
	public void* pNext;
	public VulkanHandle<VkSemaphore> Semaphore;
	public VkExternalSemaphoreHandleTypeFlags HandleType;

	public VkSemaphoreGetFdInfoKHR(
		VulkanHandle<VkSemaphore> semaphore = default,
		VkExternalSemaphoreHandleTypeFlags handleType = default
	) {
		sType = TYPE;
		pNext = null;
		Semaphore = semaphore;
		HandleType = handleType;
	}

	public readonly override bool Equals(object? o) => (o is VkSemaphoreGetFdInfoKHR s) && (this == s);
	readonly bool IEquatable<VkSemaphoreGetFdInfoKHR>.Equals(VkSemaphoreGetFdInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Semaphore.GetHashCode() ^ HandleType.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkSemaphoreGetFdInfoKHR l, in VkSemaphoreGetFdInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Semaphore == r.Semaphore) && (l.HandleType == r.HandleType)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkSemaphoreGetFdInfoKHR l, in VkSemaphoreGetFdInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Semaphore != r.Semaphore) || (l.HandleType != r.HandleType)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkSemaphoreGetFdInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceExternalFenceInfoKHR : IEquatable<VkPhysicalDeviceExternalFenceInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceExternalFenceInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkExternalFenceHandleTypeFlags HandleType;

	public VkPhysicalDeviceExternalFenceInfoKHR(
		VkExternalFenceHandleTypeFlags handleType = default
	) {
		sType = TYPE;
		pNext = null;
		HandleType = handleType;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceExternalFenceInfoKHR s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceExternalFenceInfoKHR>.Equals(VkPhysicalDeviceExternalFenceInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ HandleType.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceExternalFenceInfoKHR l, in VkPhysicalDeviceExternalFenceInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.HandleType == r.HandleType)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceExternalFenceInfoKHR l, in VkPhysicalDeviceExternalFenceInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.HandleType != r.HandleType)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceExternalFenceInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkExternalFencePropertiesKHR : IEquatable<VkExternalFencePropertiesKHR>
{
	public const VkStructureType TYPE = VkStructureType.ExternalFenceProperties;

	public VkStructureType sType;
	public void* pNext;
	public VkExternalFenceHandleTypeFlags ExportFromImportedHandleTypes;
	public VkExternalFenceHandleTypeFlags CompatibleHandleTypes;
	public VkExternalFenceFeatureFlags ExternalFenceFeatures;

	public VkExternalFencePropertiesKHR(
		VkExternalFenceHandleTypeFlags exportFromImportedHandleTypes = default,
		VkExternalFenceHandleTypeFlags compatibleHandleTypes = default,
		VkExternalFenceFeatureFlags externalFenceFeatures = default
	) {
		sType = TYPE;
		pNext = null;
		ExportFromImportedHandleTypes = exportFromImportedHandleTypes;
		CompatibleHandleTypes = compatibleHandleTypes;
		ExternalFenceFeatures = externalFenceFeatures;
	}

	public readonly override bool Equals(object? o) => (o is VkExternalFencePropertiesKHR s) && (this == s);
	readonly bool IEquatable<VkExternalFencePropertiesKHR>.Equals(VkExternalFencePropertiesKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ExportFromImportedHandleTypes.GetHashCode() ^ CompatibleHandleTypes.GetHashCode()
			^ ExternalFenceFeatures.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkExternalFencePropertiesKHR l, in VkExternalFencePropertiesKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ExportFromImportedHandleTypes == r.ExportFromImportedHandleTypes) && (l.CompatibleHandleTypes == r.CompatibleHandleTypes)
			&& (l.ExternalFenceFeatures == r.ExternalFenceFeatures)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkExternalFencePropertiesKHR l, in VkExternalFencePropertiesKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ExportFromImportedHandleTypes != r.ExportFromImportedHandleTypes) || (l.CompatibleHandleTypes != r.CompatibleHandleTypes)
			|| (l.ExternalFenceFeatures != r.ExternalFenceFeatures)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkExternalFencePropertiesKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkExportFenceCreateInfoKHR : IEquatable<VkExportFenceCreateInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.ExportFenceCreateInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkExternalFenceHandleTypeFlags HandleTypes;

	public VkExportFenceCreateInfoKHR(
		VkExternalFenceHandleTypeFlags handleTypes = default
	) {
		sType = TYPE;
		pNext = null;
		HandleTypes = handleTypes;
	}

	public readonly override bool Equals(object? o) => (o is VkExportFenceCreateInfoKHR s) && (this == s);
	readonly bool IEquatable<VkExportFenceCreateInfoKHR>.Equals(VkExportFenceCreateInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ HandleTypes.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkExportFenceCreateInfoKHR l, in VkExportFenceCreateInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.HandleTypes == r.HandleTypes)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkExportFenceCreateInfoKHR l, in VkExportFenceCreateInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.HandleTypes != r.HandleTypes)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkExportFenceCreateInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkImportFenceWin32HandleInfoKHR : IEquatable<VkImportFenceWin32HandleInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.ImportFenceWin32HandleInfoKhr;

	public VkStructureType sType;
	public void* pNext;
	public VulkanHandle<VkFence> Fence;
	public VkFenceImportFlags Flags;
	public VkExternalFenceHandleTypeFlags HandleType;
	public void* Handle;
	public ushort* Name;

	public VkImportFenceWin32HandleInfoKHR(
		VulkanHandle<VkFence> fence = default,
		VkFenceImportFlags flags = default,
		VkExternalFenceHandleTypeFlags handleType = default,
		void* handle = default,
		ushort* name = default
	) {
		sType = TYPE;
		pNext = null;
		Fence = fence;
		Flags = flags;
		HandleType = handleType;
		Handle = handle;
		Name = name;
	}

	public readonly override bool Equals(object? o) => (o is VkImportFenceWin32HandleInfoKHR s) && (this == s);
	readonly bool IEquatable<VkImportFenceWin32HandleInfoKHR>.Equals(VkImportFenceWin32HandleInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Fence.GetHashCode() ^ Flags.GetHashCode()
			^ HandleType.GetHashCode() ^ ((ulong)Handle).GetHashCode() ^ ((ulong)Name).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkImportFenceWin32HandleInfoKHR l, in VkImportFenceWin32HandleInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Fence == r.Fence) && (l.Flags == r.Flags)
			&& (l.HandleType == r.HandleType) && (l.Handle == r.Handle) && (l.Name == r.Name)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkImportFenceWin32HandleInfoKHR l, in VkImportFenceWin32HandleInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Fence != r.Fence) || (l.Flags != r.Flags)
			|| (l.HandleType != r.HandleType) || (l.Handle != r.Handle) || (l.Name != r.Name)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkImportFenceWin32HandleInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkExportFenceWin32HandleInfoKHR : IEquatable<VkExportFenceWin32HandleInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.ExportFenceWin32HandleInfoKhr;

	public VkStructureType sType;
	public void* pNext;
	public void* Attributes;
	public uint DwAccess;
	public ushort* Name;

	public VkExportFenceWin32HandleInfoKHR(
		void* attributes = default,
		uint dwAccess = default,
		ushort* name = default
	) {
		sType = TYPE;
		pNext = null;
		Attributes = attributes;
		DwAccess = dwAccess;
		Name = name;
	}

	public readonly override bool Equals(object? o) => (o is VkExportFenceWin32HandleInfoKHR s) && (this == s);
	readonly bool IEquatable<VkExportFenceWin32HandleInfoKHR>.Equals(VkExportFenceWin32HandleInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ((ulong)Attributes).GetHashCode() ^ DwAccess.GetHashCode()
			^ ((ulong)Name).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkExportFenceWin32HandleInfoKHR l, in VkExportFenceWin32HandleInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Attributes == r.Attributes) && (l.DwAccess == r.DwAccess)
			&& (l.Name == r.Name)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkExportFenceWin32HandleInfoKHR l, in VkExportFenceWin32HandleInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Attributes != r.Attributes) || (l.DwAccess != r.DwAccess)
			|| (l.Name != r.Name)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkExportFenceWin32HandleInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkFenceGetWin32HandleInfoKHR : IEquatable<VkFenceGetWin32HandleInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.FenceGetWin32HandleInfoKhr;

	public VkStructureType sType;
	public void* pNext;
	public VulkanHandle<VkFence> Fence;
	public VkExternalFenceHandleTypeFlags HandleType;

	public VkFenceGetWin32HandleInfoKHR(
		VulkanHandle<VkFence> fence = default,
		VkExternalFenceHandleTypeFlags handleType = default
	) {
		sType = TYPE;
		pNext = null;
		Fence = fence;
		HandleType = handleType;
	}

	public readonly override bool Equals(object? o) => (o is VkFenceGetWin32HandleInfoKHR s) && (this == s);
	readonly bool IEquatable<VkFenceGetWin32HandleInfoKHR>.Equals(VkFenceGetWin32HandleInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Fence.GetHashCode() ^ HandleType.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkFenceGetWin32HandleInfoKHR l, in VkFenceGetWin32HandleInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Fence == r.Fence) && (l.HandleType == r.HandleType)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkFenceGetWin32HandleInfoKHR l, in VkFenceGetWin32HandleInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Fence != r.Fence) || (l.HandleType != r.HandleType)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkFenceGetWin32HandleInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkImportFenceFdInfoKHR : IEquatable<VkImportFenceFdInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.ImportFenceFdInfoKhr;

	public VkStructureType sType;
	public void* pNext;
	public VulkanHandle<VkFence> Fence;
	public VkFenceImportFlags Flags;
	public VkExternalFenceHandleTypeFlags HandleType;
	public int Fd;

	public VkImportFenceFdInfoKHR(
		VulkanHandle<VkFence> fence = default,
		VkFenceImportFlags flags = default,
		VkExternalFenceHandleTypeFlags handleType = default,
		int fd = default
	) {
		sType = TYPE;
		pNext = null;
		Fence = fence;
		Flags = flags;
		HandleType = handleType;
		Fd = fd;
	}

	public readonly override bool Equals(object? o) => (o is VkImportFenceFdInfoKHR s) && (this == s);
	readonly bool IEquatable<VkImportFenceFdInfoKHR>.Equals(VkImportFenceFdInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Fence.GetHashCode() ^ Flags.GetHashCode()
			^ HandleType.GetHashCode() ^ Fd.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkImportFenceFdInfoKHR l, in VkImportFenceFdInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Fence == r.Fence) && (l.Flags == r.Flags)
			&& (l.HandleType == r.HandleType) && (l.Fd == r.Fd)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkImportFenceFdInfoKHR l, in VkImportFenceFdInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Fence != r.Fence) || (l.Flags != r.Flags)
			|| (l.HandleType != r.HandleType) || (l.Fd != r.Fd)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkImportFenceFdInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkFenceGetFdInfoKHR : IEquatable<VkFenceGetFdInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.FenceGetFdInfoKhr;

	public VkStructureType sType;
	public void* pNext;
	public VulkanHandle<VkFence> Fence;
	public VkExternalFenceHandleTypeFlags HandleType;

	public VkFenceGetFdInfoKHR(
		VulkanHandle<VkFence> fence = default,
		VkExternalFenceHandleTypeFlags handleType = default
	) {
		sType = TYPE;
		pNext = null;
		Fence = fence;
		HandleType = handleType;
	}

	public readonly override bool Equals(object? o) => (o is VkFenceGetFdInfoKHR s) && (this == s);
	readonly bool IEquatable<VkFenceGetFdInfoKHR>.Equals(VkFenceGetFdInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Fence.GetHashCode() ^ HandleType.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkFenceGetFdInfoKHR l, in VkFenceGetFdInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Fence == r.Fence) && (l.HandleType == r.HandleType)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkFenceGetFdInfoKHR l, in VkFenceGetFdInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Fence != r.Fence) || (l.HandleType != r.HandleType)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkFenceGetFdInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceMultiviewFeaturesKHR : IEquatable<VkPhysicalDeviceMultiviewFeaturesKHR>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceMultiviewFeatures;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 Multiview;
	public VkBool32 MultiviewGeometryShader;
	public VkBool32 MultiviewTessellationShader;

	public VkPhysicalDeviceMultiviewFeaturesKHR(
		VkBool32 multiview = default,
		VkBool32 multiviewGeometryShader = default,
		VkBool32 multiviewTessellationShader = default
	) {
		sType = TYPE;
		pNext = null;
		Multiview = multiview;
		MultiviewGeometryShader = multiviewGeometryShader;
		MultiviewTessellationShader = multiviewTessellationShader;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceMultiviewFeaturesKHR s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceMultiviewFeaturesKHR>.Equals(VkPhysicalDeviceMultiviewFeaturesKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Multiview.GetHashCode() ^ MultiviewGeometryShader.GetHashCode()
			^ MultiviewTessellationShader.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceMultiviewFeaturesKHR l, in VkPhysicalDeviceMultiviewFeaturesKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Multiview == r.Multiview) && (l.MultiviewGeometryShader == r.MultiviewGeometryShader)
			&& (l.MultiviewTessellationShader == r.MultiviewTessellationShader)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceMultiviewFeaturesKHR l, in VkPhysicalDeviceMultiviewFeaturesKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Multiview != r.Multiview) || (l.MultiviewGeometryShader != r.MultiviewGeometryShader)
			|| (l.MultiviewTessellationShader != r.MultiviewTessellationShader)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceMultiviewFeaturesKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceMultiviewPropertiesKHR : IEquatable<VkPhysicalDeviceMultiviewPropertiesKHR>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceMultiviewProperties;

	public VkStructureType sType;
	public void* pNext;
	public uint MaxMultiviewViewCount;
	public uint MaxMultiviewInstanceIndex;

	public VkPhysicalDeviceMultiviewPropertiesKHR(
		uint maxMultiviewViewCount = default,
		uint maxMultiviewInstanceIndex = default
	) {
		sType = TYPE;
		pNext = null;
		MaxMultiviewViewCount = maxMultiviewViewCount;
		MaxMultiviewInstanceIndex = maxMultiviewInstanceIndex;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceMultiviewPropertiesKHR s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceMultiviewPropertiesKHR>.Equals(VkPhysicalDeviceMultiviewPropertiesKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MaxMultiviewViewCount.GetHashCode() ^ MaxMultiviewInstanceIndex.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceMultiviewPropertiesKHR l, in VkPhysicalDeviceMultiviewPropertiesKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MaxMultiviewViewCount == r.MaxMultiviewViewCount) && (l.MaxMultiviewInstanceIndex == r.MaxMultiviewInstanceIndex)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceMultiviewPropertiesKHR l, in VkPhysicalDeviceMultiviewPropertiesKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MaxMultiviewViewCount != r.MaxMultiviewViewCount) || (l.MaxMultiviewInstanceIndex != r.MaxMultiviewInstanceIndex)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceMultiviewPropertiesKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkRenderPassMultiviewCreateInfoKHR : IEquatable<VkRenderPassMultiviewCreateInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.RenderPassMultiviewCreateInfo;

	public VkStructureType sType;
	public void* pNext;
	public uint SubpassCount;
	public uint* ViewMasks;
	public uint DependencyCount;
	public int* ViewOffsets;
	public uint CorrelationMaskCount;
	public uint* CorrelationMasks;

	public VkRenderPassMultiviewCreateInfoKHR(
		uint subpassCount = default,
		uint* viewMasks = default,
		uint dependencyCount = default,
		int* viewOffsets = default,
		uint correlationMaskCount = default,
		uint* correlationMasks = default
	) {
		sType = TYPE;
		pNext = null;
		SubpassCount = subpassCount;
		ViewMasks = viewMasks;
		DependencyCount = dependencyCount;
		ViewOffsets = viewOffsets;
		CorrelationMaskCount = correlationMaskCount;
		CorrelationMasks = correlationMasks;
	}

	public readonly override bool Equals(object? o) => (o is VkRenderPassMultiviewCreateInfoKHR s) && (this == s);
	readonly bool IEquatable<VkRenderPassMultiviewCreateInfoKHR>.Equals(VkRenderPassMultiviewCreateInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SubpassCount.GetHashCode() ^ ((ulong)ViewMasks).GetHashCode()
			^ DependencyCount.GetHashCode() ^ ((ulong)ViewOffsets).GetHashCode() ^ CorrelationMaskCount.GetHashCode() ^ ((ulong)CorrelationMasks).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkRenderPassMultiviewCreateInfoKHR l, in VkRenderPassMultiviewCreateInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SubpassCount == r.SubpassCount) && (l.ViewMasks == r.ViewMasks)
			&& (l.DependencyCount == r.DependencyCount) && (l.ViewOffsets == r.ViewOffsets) && (l.CorrelationMaskCount == r.CorrelationMaskCount) && (l.CorrelationMasks == r.CorrelationMasks)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkRenderPassMultiviewCreateInfoKHR l, in VkRenderPassMultiviewCreateInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SubpassCount != r.SubpassCount) || (l.ViewMasks != r.ViewMasks)
			|| (l.DependencyCount != r.DependencyCount) || (l.ViewOffsets != r.ViewOffsets) || (l.CorrelationMaskCount != r.CorrelationMaskCount) || (l.CorrelationMasks != r.CorrelationMasks)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkRenderPassMultiviewCreateInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceGroupPropertiesKHR : IEquatable<VkPhysicalDeviceGroupPropertiesKHR>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceGroupProperties;

	public VkStructureType sType;
	public void* pNext;
	public uint PhysicalDeviceCount;
	public VulkanHandle<VkPhysicalDevice> PhysicalDevices_0;
	public VulkanHandle<VkPhysicalDevice> PhysicalDevices_1;
	public VulkanHandle<VkPhysicalDevice> PhysicalDevices_2;
	public VulkanHandle<VkPhysicalDevice> PhysicalDevices_3;
	public VulkanHandle<VkPhysicalDevice> PhysicalDevices_4;
	public VulkanHandle<VkPhysicalDevice> PhysicalDevices_5;
	public VulkanHandle<VkPhysicalDevice> PhysicalDevices_6;
	public VulkanHandle<VkPhysicalDevice> PhysicalDevices_7;
	public VulkanHandle<VkPhysicalDevice> PhysicalDevices_8;
	public VulkanHandle<VkPhysicalDevice> PhysicalDevices_9;
	public VulkanHandle<VkPhysicalDevice> PhysicalDevices_10;
	public VulkanHandle<VkPhysicalDevice> PhysicalDevices_11;
	public VulkanHandle<VkPhysicalDevice> PhysicalDevices_12;
	public VulkanHandle<VkPhysicalDevice> PhysicalDevices_13;
	public VulkanHandle<VkPhysicalDevice> PhysicalDevices_14;
	public VulkanHandle<VkPhysicalDevice> PhysicalDevices_15;
	public VulkanHandle<VkPhysicalDevice> PhysicalDevices_16;
	public VulkanHandle<VkPhysicalDevice> PhysicalDevices_17;
	public VulkanHandle<VkPhysicalDevice> PhysicalDevices_18;
	public VulkanHandle<VkPhysicalDevice> PhysicalDevices_19;
	public VulkanHandle<VkPhysicalDevice> PhysicalDevices_20;
	public VulkanHandle<VkPhysicalDevice> PhysicalDevices_21;
	public VulkanHandle<VkPhysicalDevice> PhysicalDevices_22;
	public VulkanHandle<VkPhysicalDevice> PhysicalDevices_23;
	public VulkanHandle<VkPhysicalDevice> PhysicalDevices_24;
	public VulkanHandle<VkPhysicalDevice> PhysicalDevices_25;
	public VulkanHandle<VkPhysicalDevice> PhysicalDevices_26;
	public VulkanHandle<VkPhysicalDevice> PhysicalDevices_27;
	public VulkanHandle<VkPhysicalDevice> PhysicalDevices_28;
	public VulkanHandle<VkPhysicalDevice> PhysicalDevices_29;
	public VulkanHandle<VkPhysicalDevice> PhysicalDevices_30;
	public VulkanHandle<VkPhysicalDevice> PhysicalDevices_31;
	public VkBool32 SubsetAllocation;

	public VkPhysicalDeviceGroupPropertiesKHR(
		uint physicalDeviceCount = default,
		VulkanHandle<VkPhysicalDevice> physicalDevices_0 = default,
		VulkanHandle<VkPhysicalDevice> physicalDevices_1 = default,
		VulkanHandle<VkPhysicalDevice> physicalDevices_2 = default,
		VulkanHandle<VkPhysicalDevice> physicalDevices_3 = default,
		VulkanHandle<VkPhysicalDevice> physicalDevices_4 = default,
		VulkanHandle<VkPhysicalDevice> physicalDevices_5 = default,
		VulkanHandle<VkPhysicalDevice> physicalDevices_6 = default,
		VulkanHandle<VkPhysicalDevice> physicalDevices_7 = default,
		VulkanHandle<VkPhysicalDevice> physicalDevices_8 = default,
		VulkanHandle<VkPhysicalDevice> physicalDevices_9 = default,
		VulkanHandle<VkPhysicalDevice> physicalDevices_10 = default,
		VulkanHandle<VkPhysicalDevice> physicalDevices_11 = default,
		VulkanHandle<VkPhysicalDevice> physicalDevices_12 = default,
		VulkanHandle<VkPhysicalDevice> physicalDevices_13 = default,
		VulkanHandle<VkPhysicalDevice> physicalDevices_14 = default,
		VulkanHandle<VkPhysicalDevice> physicalDevices_15 = default,
		VulkanHandle<VkPhysicalDevice> physicalDevices_16 = default,
		VulkanHandle<VkPhysicalDevice> physicalDevices_17 = default,
		VulkanHandle<VkPhysicalDevice> physicalDevices_18 = default,
		VulkanHandle<VkPhysicalDevice> physicalDevices_19 = default,
		VulkanHandle<VkPhysicalDevice> physicalDevices_20 = default,
		VulkanHandle<VkPhysicalDevice> physicalDevices_21 = default,
		VulkanHandle<VkPhysicalDevice> physicalDevices_22 = default,
		VulkanHandle<VkPhysicalDevice> physicalDevices_23 = default,
		VulkanHandle<VkPhysicalDevice> physicalDevices_24 = default,
		VulkanHandle<VkPhysicalDevice> physicalDevices_25 = default,
		VulkanHandle<VkPhysicalDevice> physicalDevices_26 = default,
		VulkanHandle<VkPhysicalDevice> physicalDevices_27 = default,
		VulkanHandle<VkPhysicalDevice> physicalDevices_28 = default,
		VulkanHandle<VkPhysicalDevice> physicalDevices_29 = default,
		VulkanHandle<VkPhysicalDevice> physicalDevices_30 = default,
		VulkanHandle<VkPhysicalDevice> physicalDevices_31 = default,
		VkBool32 subsetAllocation = default
	) {
		sType = TYPE;
		pNext = null;
		PhysicalDeviceCount = physicalDeviceCount;
		PhysicalDevices_0 = physicalDevices_0;
		PhysicalDevices_1 = physicalDevices_1;
		PhysicalDevices_2 = physicalDevices_2;
		PhysicalDevices_3 = physicalDevices_3;
		PhysicalDevices_4 = physicalDevices_4;
		PhysicalDevices_5 = physicalDevices_5;
		PhysicalDevices_6 = physicalDevices_6;
		PhysicalDevices_7 = physicalDevices_7;
		PhysicalDevices_8 = physicalDevices_8;
		PhysicalDevices_9 = physicalDevices_9;
		PhysicalDevices_10 = physicalDevices_10;
		PhysicalDevices_11 = physicalDevices_11;
		PhysicalDevices_12 = physicalDevices_12;
		PhysicalDevices_13 = physicalDevices_13;
		PhysicalDevices_14 = physicalDevices_14;
		PhysicalDevices_15 = physicalDevices_15;
		PhysicalDevices_16 = physicalDevices_16;
		PhysicalDevices_17 = physicalDevices_17;
		PhysicalDevices_18 = physicalDevices_18;
		PhysicalDevices_19 = physicalDevices_19;
		PhysicalDevices_20 = physicalDevices_20;
		PhysicalDevices_21 = physicalDevices_21;
		PhysicalDevices_22 = physicalDevices_22;
		PhysicalDevices_23 = physicalDevices_23;
		PhysicalDevices_24 = physicalDevices_24;
		PhysicalDevices_25 = physicalDevices_25;
		PhysicalDevices_26 = physicalDevices_26;
		PhysicalDevices_27 = physicalDevices_27;
		PhysicalDevices_28 = physicalDevices_28;
		PhysicalDevices_29 = physicalDevices_29;
		PhysicalDevices_30 = physicalDevices_30;
		PhysicalDevices_31 = physicalDevices_31;
		SubsetAllocation = subsetAllocation;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceGroupPropertiesKHR s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceGroupPropertiesKHR>.Equals(VkPhysicalDeviceGroupPropertiesKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ PhysicalDeviceCount.GetHashCode() ^ PhysicalDevices_0.GetHashCode()
			^ PhysicalDevices_1.GetHashCode() ^ PhysicalDevices_2.GetHashCode() ^ PhysicalDevices_3.GetHashCode() ^ PhysicalDevices_4.GetHashCode()
			^ PhysicalDevices_5.GetHashCode() ^ PhysicalDevices_6.GetHashCode() ^ PhysicalDevices_7.GetHashCode() ^ PhysicalDevices_8.GetHashCode()
			^ PhysicalDevices_9.GetHashCode() ^ PhysicalDevices_10.GetHashCode() ^ PhysicalDevices_11.GetHashCode() ^ PhysicalDevices_12.GetHashCode()
			^ PhysicalDevices_13.GetHashCode() ^ PhysicalDevices_14.GetHashCode() ^ PhysicalDevices_15.GetHashCode() ^ PhysicalDevices_16.GetHashCode()
			^ PhysicalDevices_17.GetHashCode() ^ PhysicalDevices_18.GetHashCode() ^ PhysicalDevices_19.GetHashCode() ^ PhysicalDevices_20.GetHashCode()
			^ PhysicalDevices_21.GetHashCode() ^ PhysicalDevices_22.GetHashCode() ^ PhysicalDevices_23.GetHashCode() ^ PhysicalDevices_24.GetHashCode()
			^ PhysicalDevices_25.GetHashCode() ^ PhysicalDevices_26.GetHashCode() ^ PhysicalDevices_27.GetHashCode() ^ PhysicalDevices_28.GetHashCode()
			^ PhysicalDevices_29.GetHashCode() ^ PhysicalDevices_30.GetHashCode() ^ PhysicalDevices_31.GetHashCode() ^ SubsetAllocation.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceGroupPropertiesKHR l, in VkPhysicalDeviceGroupPropertiesKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.PhysicalDeviceCount == r.PhysicalDeviceCount) && (l.PhysicalDevices_0 == r.PhysicalDevices_0)
			&& (l.PhysicalDevices_1 == r.PhysicalDevices_1) && (l.PhysicalDevices_2 == r.PhysicalDevices_2) && (l.PhysicalDevices_3 == r.PhysicalDevices_3) && (l.PhysicalDevices_4 == r.PhysicalDevices_4)
			&& (l.PhysicalDevices_5 == r.PhysicalDevices_5) && (l.PhysicalDevices_6 == r.PhysicalDevices_6) && (l.PhysicalDevices_7 == r.PhysicalDevices_7) && (l.PhysicalDevices_8 == r.PhysicalDevices_8)
			&& (l.PhysicalDevices_9 == r.PhysicalDevices_9) && (l.PhysicalDevices_10 == r.PhysicalDevices_10) && (l.PhysicalDevices_11 == r.PhysicalDevices_11) && (l.PhysicalDevices_12 == r.PhysicalDevices_12)
			&& (l.PhysicalDevices_13 == r.PhysicalDevices_13) && (l.PhysicalDevices_14 == r.PhysicalDevices_14) && (l.PhysicalDevices_15 == r.PhysicalDevices_15) && (l.PhysicalDevices_16 == r.PhysicalDevices_16)
			&& (l.PhysicalDevices_17 == r.PhysicalDevices_17) && (l.PhysicalDevices_18 == r.PhysicalDevices_18) && (l.PhysicalDevices_19 == r.PhysicalDevices_19) && (l.PhysicalDevices_20 == r.PhysicalDevices_20)
			&& (l.PhysicalDevices_21 == r.PhysicalDevices_21) && (l.PhysicalDevices_22 == r.PhysicalDevices_22) && (l.PhysicalDevices_23 == r.PhysicalDevices_23) && (l.PhysicalDevices_24 == r.PhysicalDevices_24)
			&& (l.PhysicalDevices_25 == r.PhysicalDevices_25) && (l.PhysicalDevices_26 == r.PhysicalDevices_26) && (l.PhysicalDevices_27 == r.PhysicalDevices_27) && (l.PhysicalDevices_28 == r.PhysicalDevices_28)
			&& (l.PhysicalDevices_29 == r.PhysicalDevices_29) && (l.PhysicalDevices_30 == r.PhysicalDevices_30) && (l.PhysicalDevices_31 == r.PhysicalDevices_31) && (l.SubsetAllocation == r.SubsetAllocation)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceGroupPropertiesKHR l, in VkPhysicalDeviceGroupPropertiesKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.PhysicalDeviceCount != r.PhysicalDeviceCount) || (l.PhysicalDevices_0 != r.PhysicalDevices_0)
			|| (l.PhysicalDevices_1 != r.PhysicalDevices_1) || (l.PhysicalDevices_2 != r.PhysicalDevices_2) || (l.PhysicalDevices_3 != r.PhysicalDevices_3) || (l.PhysicalDevices_4 != r.PhysicalDevices_4)
			|| (l.PhysicalDevices_5 != r.PhysicalDevices_5) || (l.PhysicalDevices_6 != r.PhysicalDevices_6) || (l.PhysicalDevices_7 != r.PhysicalDevices_7) || (l.PhysicalDevices_8 != r.PhysicalDevices_8)
			|| (l.PhysicalDevices_9 != r.PhysicalDevices_9) || (l.PhysicalDevices_10 != r.PhysicalDevices_10) || (l.PhysicalDevices_11 != r.PhysicalDevices_11) || (l.PhysicalDevices_12 != r.PhysicalDevices_12)
			|| (l.PhysicalDevices_13 != r.PhysicalDevices_13) || (l.PhysicalDevices_14 != r.PhysicalDevices_14) || (l.PhysicalDevices_15 != r.PhysicalDevices_15) || (l.PhysicalDevices_16 != r.PhysicalDevices_16)
			|| (l.PhysicalDevices_17 != r.PhysicalDevices_17) || (l.PhysicalDevices_18 != r.PhysicalDevices_18) || (l.PhysicalDevices_19 != r.PhysicalDevices_19) || (l.PhysicalDevices_20 != r.PhysicalDevices_20)
			|| (l.PhysicalDevices_21 != r.PhysicalDevices_21) || (l.PhysicalDevices_22 != r.PhysicalDevices_22) || (l.PhysicalDevices_23 != r.PhysicalDevices_23) || (l.PhysicalDevices_24 != r.PhysicalDevices_24)
			|| (l.PhysicalDevices_25 != r.PhysicalDevices_25) || (l.PhysicalDevices_26 != r.PhysicalDevices_26) || (l.PhysicalDevices_27 != r.PhysicalDevices_27) || (l.PhysicalDevices_28 != r.PhysicalDevices_28)
			|| (l.PhysicalDevices_29 != r.PhysicalDevices_29) || (l.PhysicalDevices_30 != r.PhysicalDevices_30) || (l.PhysicalDevices_31 != r.PhysicalDevices_31) || (l.SubsetAllocation != r.SubsetAllocation)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceGroupPropertiesKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkMemoryAllocateFlagsInfoKHR : IEquatable<VkMemoryAllocateFlagsInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.MemoryAllocateFlagsInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkMemoryAllocateFlags Flags;
	public uint DeviceMask;

	public VkMemoryAllocateFlagsInfoKHR(
		VkMemoryAllocateFlags flags = default,
		uint deviceMask = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		DeviceMask = deviceMask;
	}

	public readonly override bool Equals(object? o) => (o is VkMemoryAllocateFlagsInfoKHR s) && (this == s);
	readonly bool IEquatable<VkMemoryAllocateFlagsInfoKHR>.Equals(VkMemoryAllocateFlagsInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ DeviceMask.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkMemoryAllocateFlagsInfoKHR l, in VkMemoryAllocateFlagsInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.DeviceMask == r.DeviceMask)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkMemoryAllocateFlagsInfoKHR l, in VkMemoryAllocateFlagsInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.DeviceMask != r.DeviceMask)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkMemoryAllocateFlagsInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkBindBufferMemoryInfoKHR : IEquatable<VkBindBufferMemoryInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.BindBufferMemoryInfo;

	public VkStructureType sType;
	public void* pNext;
	public VulkanHandle<VkBuffer> Buffer;
	public VulkanHandle<VkDeviceMemory> Memory;
	public ulong MemoryOffset;

	public VkBindBufferMemoryInfoKHR(
		VulkanHandle<VkBuffer> buffer = default,
		VulkanHandle<VkDeviceMemory> memory = default,
		ulong memoryOffset = default
	) {
		sType = TYPE;
		pNext = null;
		Buffer = buffer;
		Memory = memory;
		MemoryOffset = memoryOffset;
	}

	public readonly override bool Equals(object? o) => (o is VkBindBufferMemoryInfoKHR s) && (this == s);
	readonly bool IEquatable<VkBindBufferMemoryInfoKHR>.Equals(VkBindBufferMemoryInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Buffer.GetHashCode() ^ Memory.GetHashCode()
			^ MemoryOffset.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkBindBufferMemoryInfoKHR l, in VkBindBufferMemoryInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Buffer == r.Buffer) && (l.Memory == r.Memory)
			&& (l.MemoryOffset == r.MemoryOffset)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkBindBufferMemoryInfoKHR l, in VkBindBufferMemoryInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Buffer != r.Buffer) || (l.Memory != r.Memory)
			|| (l.MemoryOffset != r.MemoryOffset)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkBindBufferMemoryInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkBindBufferMemoryDeviceGroupInfoKHR : IEquatable<VkBindBufferMemoryDeviceGroupInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.BindBufferMemoryDeviceGroupInfo;

	public VkStructureType sType;
	public void* pNext;
	public uint DeviceIndexCount;
	public uint* DeviceIndices;

	public VkBindBufferMemoryDeviceGroupInfoKHR(
		uint deviceIndexCount = default,
		uint* deviceIndices = default
	) {
		sType = TYPE;
		pNext = null;
		DeviceIndexCount = deviceIndexCount;
		DeviceIndices = deviceIndices;
	}

	public readonly override bool Equals(object? o) => (o is VkBindBufferMemoryDeviceGroupInfoKHR s) && (this == s);
	readonly bool IEquatable<VkBindBufferMemoryDeviceGroupInfoKHR>.Equals(VkBindBufferMemoryDeviceGroupInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DeviceIndexCount.GetHashCode() ^ ((ulong)DeviceIndices).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkBindBufferMemoryDeviceGroupInfoKHR l, in VkBindBufferMemoryDeviceGroupInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DeviceIndexCount == r.DeviceIndexCount) && (l.DeviceIndices == r.DeviceIndices)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkBindBufferMemoryDeviceGroupInfoKHR l, in VkBindBufferMemoryDeviceGroupInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DeviceIndexCount != r.DeviceIndexCount) || (l.DeviceIndices != r.DeviceIndices)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkBindBufferMemoryDeviceGroupInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkBindImageMemoryInfoKHR : IEquatable<VkBindImageMemoryInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.BindImageMemoryInfo;

	public VkStructureType sType;
	public void* pNext;
	public VulkanHandle<VkImage> Image;
	public VulkanHandle<VkDeviceMemory> Memory;
	public ulong MemoryOffset;

	public VkBindImageMemoryInfoKHR(
		VulkanHandle<VkImage> image = default,
		VulkanHandle<VkDeviceMemory> memory = default,
		ulong memoryOffset = default
	) {
		sType = TYPE;
		pNext = null;
		Image = image;
		Memory = memory;
		MemoryOffset = memoryOffset;
	}

	public readonly override bool Equals(object? o) => (o is VkBindImageMemoryInfoKHR s) && (this == s);
	readonly bool IEquatable<VkBindImageMemoryInfoKHR>.Equals(VkBindImageMemoryInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Image.GetHashCode() ^ Memory.GetHashCode()
			^ MemoryOffset.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkBindImageMemoryInfoKHR l, in VkBindImageMemoryInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Image == r.Image) && (l.Memory == r.Memory)
			&& (l.MemoryOffset == r.MemoryOffset)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkBindImageMemoryInfoKHR l, in VkBindImageMemoryInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Image != r.Image) || (l.Memory != r.Memory)
			|| (l.MemoryOffset != r.MemoryOffset)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkBindImageMemoryInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkBindImageMemoryDeviceGroupInfoKHR : IEquatable<VkBindImageMemoryDeviceGroupInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.BindImageMemoryDeviceGroupInfo;

	public VkStructureType sType;
	public void* pNext;
	public uint DeviceIndexCount;
	public uint* DeviceIndices;
	public uint SplitInstanceBindRegionCount;
	public VkRect2D* SplitInstanceBindRegions;

	public VkBindImageMemoryDeviceGroupInfoKHR(
		uint deviceIndexCount = default,
		uint* deviceIndices = default,
		uint splitInstanceBindRegionCount = default,
		VkRect2D* splitInstanceBindRegions = default
	) {
		sType = TYPE;
		pNext = null;
		DeviceIndexCount = deviceIndexCount;
		DeviceIndices = deviceIndices;
		SplitInstanceBindRegionCount = splitInstanceBindRegionCount;
		SplitInstanceBindRegions = splitInstanceBindRegions;
	}

	public readonly override bool Equals(object? o) => (o is VkBindImageMemoryDeviceGroupInfoKHR s) && (this == s);
	readonly bool IEquatable<VkBindImageMemoryDeviceGroupInfoKHR>.Equals(VkBindImageMemoryDeviceGroupInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DeviceIndexCount.GetHashCode() ^ ((ulong)DeviceIndices).GetHashCode()
			^ SplitInstanceBindRegionCount.GetHashCode() ^ ((ulong)SplitInstanceBindRegions).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkBindImageMemoryDeviceGroupInfoKHR l, in VkBindImageMemoryDeviceGroupInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DeviceIndexCount == r.DeviceIndexCount) && (l.DeviceIndices == r.DeviceIndices)
			&& (l.SplitInstanceBindRegionCount == r.SplitInstanceBindRegionCount) && (l.SplitInstanceBindRegions == r.SplitInstanceBindRegions)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkBindImageMemoryDeviceGroupInfoKHR l, in VkBindImageMemoryDeviceGroupInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DeviceIndexCount != r.DeviceIndexCount) || (l.DeviceIndices != r.DeviceIndices)
			|| (l.SplitInstanceBindRegionCount != r.SplitInstanceBindRegionCount) || (l.SplitInstanceBindRegions != r.SplitInstanceBindRegions)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkBindImageMemoryDeviceGroupInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDeviceGroupRenderPassBeginInfoKHR : IEquatable<VkDeviceGroupRenderPassBeginInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.DeviceGroupRenderPassBeginInfo;

	public VkStructureType sType;
	public void* pNext;
	public uint DeviceMask;
	public uint DeviceRenderAreaCount;
	public VkRect2D* DeviceRenderAreas;

	public VkDeviceGroupRenderPassBeginInfoKHR(
		uint deviceMask = default,
		uint deviceRenderAreaCount = default,
		VkRect2D* deviceRenderAreas = default
	) {
		sType = TYPE;
		pNext = null;
		DeviceMask = deviceMask;
		DeviceRenderAreaCount = deviceRenderAreaCount;
		DeviceRenderAreas = deviceRenderAreas;
	}

	public readonly override bool Equals(object? o) => (o is VkDeviceGroupRenderPassBeginInfoKHR s) && (this == s);
	readonly bool IEquatable<VkDeviceGroupRenderPassBeginInfoKHR>.Equals(VkDeviceGroupRenderPassBeginInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DeviceMask.GetHashCode() ^ DeviceRenderAreaCount.GetHashCode()
			^ ((ulong)DeviceRenderAreas).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDeviceGroupRenderPassBeginInfoKHR l, in VkDeviceGroupRenderPassBeginInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DeviceMask == r.DeviceMask) && (l.DeviceRenderAreaCount == r.DeviceRenderAreaCount)
			&& (l.DeviceRenderAreas == r.DeviceRenderAreas)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDeviceGroupRenderPassBeginInfoKHR l, in VkDeviceGroupRenderPassBeginInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DeviceMask != r.DeviceMask) || (l.DeviceRenderAreaCount != r.DeviceRenderAreaCount)
			|| (l.DeviceRenderAreas != r.DeviceRenderAreas)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDeviceGroupRenderPassBeginInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDeviceGroupCommandBufferBeginInfoKHR : IEquatable<VkDeviceGroupCommandBufferBeginInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.DeviceGroupCommandBufferBeginInfo;

	public VkStructureType sType;
	public void* pNext;
	public uint DeviceMask;

	public VkDeviceGroupCommandBufferBeginInfoKHR(
		uint deviceMask = default
	) {
		sType = TYPE;
		pNext = null;
		DeviceMask = deviceMask;
	}

	public readonly override bool Equals(object? o) => (o is VkDeviceGroupCommandBufferBeginInfoKHR s) && (this == s);
	readonly bool IEquatable<VkDeviceGroupCommandBufferBeginInfoKHR>.Equals(VkDeviceGroupCommandBufferBeginInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DeviceMask.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDeviceGroupCommandBufferBeginInfoKHR l, in VkDeviceGroupCommandBufferBeginInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DeviceMask == r.DeviceMask)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDeviceGroupCommandBufferBeginInfoKHR l, in VkDeviceGroupCommandBufferBeginInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DeviceMask != r.DeviceMask)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDeviceGroupCommandBufferBeginInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDeviceGroupSubmitInfoKHR : IEquatable<VkDeviceGroupSubmitInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.DeviceGroupSubmitInfo;

	public VkStructureType sType;
	public void* pNext;
	public uint WaitSemaphoreCount;
	public uint* WaitSemaphoreDeviceIndices;
	public uint CommandBufferCount;
	public uint* CommandBufferDeviceMasks;
	public uint SignalSemaphoreCount;
	public uint* SignalSemaphoreDeviceIndices;

	public VkDeviceGroupSubmitInfoKHR(
		uint waitSemaphoreCount = default,
		uint* waitSemaphoreDeviceIndices = default,
		uint commandBufferCount = default,
		uint* commandBufferDeviceMasks = default,
		uint signalSemaphoreCount = default,
		uint* signalSemaphoreDeviceIndices = default
	) {
		sType = TYPE;
		pNext = null;
		WaitSemaphoreCount = waitSemaphoreCount;
		WaitSemaphoreDeviceIndices = waitSemaphoreDeviceIndices;
		CommandBufferCount = commandBufferCount;
		CommandBufferDeviceMasks = commandBufferDeviceMasks;
		SignalSemaphoreCount = signalSemaphoreCount;
		SignalSemaphoreDeviceIndices = signalSemaphoreDeviceIndices;
	}

	public readonly override bool Equals(object? o) => (o is VkDeviceGroupSubmitInfoKHR s) && (this == s);
	readonly bool IEquatable<VkDeviceGroupSubmitInfoKHR>.Equals(VkDeviceGroupSubmitInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ WaitSemaphoreCount.GetHashCode() ^ ((ulong)WaitSemaphoreDeviceIndices).GetHashCode()
			^ CommandBufferCount.GetHashCode() ^ ((ulong)CommandBufferDeviceMasks).GetHashCode() ^ SignalSemaphoreCount.GetHashCode() ^ ((ulong)SignalSemaphoreDeviceIndices).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDeviceGroupSubmitInfoKHR l, in VkDeviceGroupSubmitInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.WaitSemaphoreCount == r.WaitSemaphoreCount) && (l.WaitSemaphoreDeviceIndices == r.WaitSemaphoreDeviceIndices)
			&& (l.CommandBufferCount == r.CommandBufferCount) && (l.CommandBufferDeviceMasks == r.CommandBufferDeviceMasks) && (l.SignalSemaphoreCount == r.SignalSemaphoreCount) && (l.SignalSemaphoreDeviceIndices == r.SignalSemaphoreDeviceIndices)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDeviceGroupSubmitInfoKHR l, in VkDeviceGroupSubmitInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.WaitSemaphoreCount != r.WaitSemaphoreCount) || (l.WaitSemaphoreDeviceIndices != r.WaitSemaphoreDeviceIndices)
			|| (l.CommandBufferCount != r.CommandBufferCount) || (l.CommandBufferDeviceMasks != r.CommandBufferDeviceMasks) || (l.SignalSemaphoreCount != r.SignalSemaphoreCount) || (l.SignalSemaphoreDeviceIndices != r.SignalSemaphoreDeviceIndices)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDeviceGroupSubmitInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDeviceGroupBindSparseInfoKHR : IEquatable<VkDeviceGroupBindSparseInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.DeviceGroupBindSparseInfo;

	public VkStructureType sType;
	public void* pNext;
	public uint ResourceDeviceIndex;
	public uint MemoryDeviceIndex;

	public VkDeviceGroupBindSparseInfoKHR(
		uint resourceDeviceIndex = default,
		uint memoryDeviceIndex = default
	) {
		sType = TYPE;
		pNext = null;
		ResourceDeviceIndex = resourceDeviceIndex;
		MemoryDeviceIndex = memoryDeviceIndex;
	}

	public readonly override bool Equals(object? o) => (o is VkDeviceGroupBindSparseInfoKHR s) && (this == s);
	readonly bool IEquatable<VkDeviceGroupBindSparseInfoKHR>.Equals(VkDeviceGroupBindSparseInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ResourceDeviceIndex.GetHashCode() ^ MemoryDeviceIndex.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDeviceGroupBindSparseInfoKHR l, in VkDeviceGroupBindSparseInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ResourceDeviceIndex == r.ResourceDeviceIndex) && (l.MemoryDeviceIndex == r.MemoryDeviceIndex)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDeviceGroupBindSparseInfoKHR l, in VkDeviceGroupBindSparseInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ResourceDeviceIndex != r.ResourceDeviceIndex) || (l.MemoryDeviceIndex != r.MemoryDeviceIndex)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDeviceGroupBindSparseInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDeviceGroupPresentCapabilitiesKHR : IEquatable<VkDeviceGroupPresentCapabilitiesKHR>
{
	public const VkStructureType TYPE = VkStructureType.DeviceGroupPresentCapabilitiesKhr;

	public VkStructureType sType;
	public void* pNext;
	public fixed uint PresentMask[32];
	public VkDeviceGroupPresentModeFlagsKHR Modes;

	public VkDeviceGroupPresentCapabilitiesKHR(
		uint presentMask_0 = default,
		uint presentMask_1 = default,
		uint presentMask_2 = default,
		uint presentMask_3 = default,
		uint presentMask_4 = default,
		uint presentMask_5 = default,
		uint presentMask_6 = default,
		uint presentMask_7 = default,
		uint presentMask_8 = default,
		uint presentMask_9 = default,
		uint presentMask_10 = default,
		uint presentMask_11 = default,
		uint presentMask_12 = default,
		uint presentMask_13 = default,
		uint presentMask_14 = default,
		uint presentMask_15 = default,
		uint presentMask_16 = default,
		uint presentMask_17 = default,
		uint presentMask_18 = default,
		uint presentMask_19 = default,
		uint presentMask_20 = default,
		uint presentMask_21 = default,
		uint presentMask_22 = default,
		uint presentMask_23 = default,
		uint presentMask_24 = default,
		uint presentMask_25 = default,
		uint presentMask_26 = default,
		uint presentMask_27 = default,
		uint presentMask_28 = default,
		uint presentMask_29 = default,
		uint presentMask_30 = default,
		uint presentMask_31 = default,
		VkDeviceGroupPresentModeFlagsKHR modes = default
	) {
		sType = TYPE;
		pNext = null;
		PresentMask[0] = presentMask_0;
		PresentMask[1] = presentMask_1;
		PresentMask[2] = presentMask_2;
		PresentMask[3] = presentMask_3;
		PresentMask[4] = presentMask_4;
		PresentMask[5] = presentMask_5;
		PresentMask[6] = presentMask_6;
		PresentMask[7] = presentMask_7;
		PresentMask[8] = presentMask_8;
		PresentMask[9] = presentMask_9;
		PresentMask[10] = presentMask_10;
		PresentMask[11] = presentMask_11;
		PresentMask[12] = presentMask_12;
		PresentMask[13] = presentMask_13;
		PresentMask[14] = presentMask_14;
		PresentMask[15] = presentMask_15;
		PresentMask[16] = presentMask_16;
		PresentMask[17] = presentMask_17;
		PresentMask[18] = presentMask_18;
		PresentMask[19] = presentMask_19;
		PresentMask[20] = presentMask_20;
		PresentMask[21] = presentMask_21;
		PresentMask[22] = presentMask_22;
		PresentMask[23] = presentMask_23;
		PresentMask[24] = presentMask_24;
		PresentMask[25] = presentMask_25;
		PresentMask[26] = presentMask_26;
		PresentMask[27] = presentMask_27;
		PresentMask[28] = presentMask_28;
		PresentMask[29] = presentMask_29;
		PresentMask[30] = presentMask_30;
		PresentMask[31] = presentMask_31;
		Modes = modes;
	}

	public readonly override bool Equals(object? o) => (o is VkDeviceGroupPresentCapabilitiesKHR s) && (this == s);
	readonly bool IEquatable<VkDeviceGroupPresentCapabilitiesKHR>.Equals(VkDeviceGroupPresentCapabilitiesKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ PresentMask[0].GetHashCode() ^ PresentMask[1].GetHashCode()
			^ PresentMask[2].GetHashCode() ^ PresentMask[3].GetHashCode() ^ PresentMask[4].GetHashCode() ^ PresentMask[5].GetHashCode()
			^ PresentMask[6].GetHashCode() ^ PresentMask[7].GetHashCode() ^ PresentMask[8].GetHashCode() ^ PresentMask[9].GetHashCode()
			^ PresentMask[10].GetHashCode() ^ PresentMask[11].GetHashCode() ^ PresentMask[12].GetHashCode() ^ PresentMask[13].GetHashCode()
			^ PresentMask[14].GetHashCode() ^ PresentMask[15].GetHashCode() ^ PresentMask[16].GetHashCode() ^ PresentMask[17].GetHashCode()
			^ PresentMask[18].GetHashCode() ^ PresentMask[19].GetHashCode() ^ PresentMask[20].GetHashCode() ^ PresentMask[21].GetHashCode()
			^ PresentMask[22].GetHashCode() ^ PresentMask[23].GetHashCode() ^ PresentMask[24].GetHashCode() ^ PresentMask[25].GetHashCode()
			^ PresentMask[26].GetHashCode() ^ PresentMask[27].GetHashCode() ^ PresentMask[28].GetHashCode() ^ PresentMask[29].GetHashCode()
			^ PresentMask[30].GetHashCode() ^ PresentMask[31].GetHashCode() ^ Modes.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDeviceGroupPresentCapabilitiesKHR l, in VkDeviceGroupPresentCapabilitiesKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.PresentMask[0] == r.PresentMask[0]) && (l.PresentMask[1] == r.PresentMask[1])
			&& (l.PresentMask[2] == r.PresentMask[2]) && (l.PresentMask[3] == r.PresentMask[3]) && (l.PresentMask[4] == r.PresentMask[4]) && (l.PresentMask[5] == r.PresentMask[5])
			&& (l.PresentMask[6] == r.PresentMask[6]) && (l.PresentMask[7] == r.PresentMask[7]) && (l.PresentMask[8] == r.PresentMask[8]) && (l.PresentMask[9] == r.PresentMask[9])
			&& (l.PresentMask[10] == r.PresentMask[10]) && (l.PresentMask[11] == r.PresentMask[11]) && (l.PresentMask[12] == r.PresentMask[12]) && (l.PresentMask[13] == r.PresentMask[13])
			&& (l.PresentMask[14] == r.PresentMask[14]) && (l.PresentMask[15] == r.PresentMask[15]) && (l.PresentMask[16] == r.PresentMask[16]) && (l.PresentMask[17] == r.PresentMask[17])
			&& (l.PresentMask[18] == r.PresentMask[18]) && (l.PresentMask[19] == r.PresentMask[19]) && (l.PresentMask[20] == r.PresentMask[20]) && (l.PresentMask[21] == r.PresentMask[21])
			&& (l.PresentMask[22] == r.PresentMask[22]) && (l.PresentMask[23] == r.PresentMask[23]) && (l.PresentMask[24] == r.PresentMask[24]) && (l.PresentMask[25] == r.PresentMask[25])
			&& (l.PresentMask[26] == r.PresentMask[26]) && (l.PresentMask[27] == r.PresentMask[27]) && (l.PresentMask[28] == r.PresentMask[28]) && (l.PresentMask[29] == r.PresentMask[29])
			&& (l.PresentMask[30] == r.PresentMask[30]) && (l.PresentMask[31] == r.PresentMask[31]) && (l.Modes == r.Modes)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDeviceGroupPresentCapabilitiesKHR l, in VkDeviceGroupPresentCapabilitiesKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.PresentMask[0] != r.PresentMask[0]) || (l.PresentMask[1] != r.PresentMask[1])
			|| (l.PresentMask[2] != r.PresentMask[2]) || (l.PresentMask[3] != r.PresentMask[3]) || (l.PresentMask[4] != r.PresentMask[4]) || (l.PresentMask[5] != r.PresentMask[5])
			|| (l.PresentMask[6] != r.PresentMask[6]) || (l.PresentMask[7] != r.PresentMask[7]) || (l.PresentMask[8] != r.PresentMask[8]) || (l.PresentMask[9] != r.PresentMask[9])
			|| (l.PresentMask[10] != r.PresentMask[10]) || (l.PresentMask[11] != r.PresentMask[11]) || (l.PresentMask[12] != r.PresentMask[12]) || (l.PresentMask[13] != r.PresentMask[13])
			|| (l.PresentMask[14] != r.PresentMask[14]) || (l.PresentMask[15] != r.PresentMask[15]) || (l.PresentMask[16] != r.PresentMask[16]) || (l.PresentMask[17] != r.PresentMask[17])
			|| (l.PresentMask[18] != r.PresentMask[18]) || (l.PresentMask[19] != r.PresentMask[19]) || (l.PresentMask[20] != r.PresentMask[20]) || (l.PresentMask[21] != r.PresentMask[21])
			|| (l.PresentMask[22] != r.PresentMask[22]) || (l.PresentMask[23] != r.PresentMask[23]) || (l.PresentMask[24] != r.PresentMask[24]) || (l.PresentMask[25] != r.PresentMask[25])
			|| (l.PresentMask[26] != r.PresentMask[26]) || (l.PresentMask[27] != r.PresentMask[27]) || (l.PresentMask[28] != r.PresentMask[28]) || (l.PresentMask[29] != r.PresentMask[29])
			|| (l.PresentMask[30] != r.PresentMask[30]) || (l.PresentMask[31] != r.PresentMask[31]) || (l.Modes != r.Modes)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDeviceGroupPresentCapabilitiesKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkImageSwapchainCreateInfoKHR : IEquatable<VkImageSwapchainCreateInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.ImageSwapchainCreateInfoKhr;

	public VkStructureType sType;
	public void* pNext;
	public VulkanHandle<VkSwapchainKHR> Swapchain;

	public VkImageSwapchainCreateInfoKHR(
		VulkanHandle<VkSwapchainKHR> swapchain = default
	) {
		sType = TYPE;
		pNext = null;
		Swapchain = swapchain;
	}

	public readonly override bool Equals(object? o) => (o is VkImageSwapchainCreateInfoKHR s) && (this == s);
	readonly bool IEquatable<VkImageSwapchainCreateInfoKHR>.Equals(VkImageSwapchainCreateInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Swapchain.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkImageSwapchainCreateInfoKHR l, in VkImageSwapchainCreateInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Swapchain == r.Swapchain)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkImageSwapchainCreateInfoKHR l, in VkImageSwapchainCreateInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Swapchain != r.Swapchain)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkImageSwapchainCreateInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkBindImageMemorySwapchainInfoKHR : IEquatable<VkBindImageMemorySwapchainInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.BindImageMemorySwapchainInfoKhr;

	public VkStructureType sType;
	public void* pNext;
	public VulkanHandle<VkSwapchainKHR> Swapchain;
	public uint ImageIndex;

	public VkBindImageMemorySwapchainInfoKHR(
		VulkanHandle<VkSwapchainKHR> swapchain = default,
		uint imageIndex = default
	) {
		sType = TYPE;
		pNext = null;
		Swapchain = swapchain;
		ImageIndex = imageIndex;
	}

	public readonly override bool Equals(object? o) => (o is VkBindImageMemorySwapchainInfoKHR s) && (this == s);
	readonly bool IEquatable<VkBindImageMemorySwapchainInfoKHR>.Equals(VkBindImageMemorySwapchainInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Swapchain.GetHashCode() ^ ImageIndex.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkBindImageMemorySwapchainInfoKHR l, in VkBindImageMemorySwapchainInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Swapchain == r.Swapchain) && (l.ImageIndex == r.ImageIndex)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkBindImageMemorySwapchainInfoKHR l, in VkBindImageMemorySwapchainInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Swapchain != r.Swapchain) || (l.ImageIndex != r.ImageIndex)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkBindImageMemorySwapchainInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkAcquireNextImageInfoKHR : IEquatable<VkAcquireNextImageInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.AcquireNextImageInfoKhr;

	public VkStructureType sType;
	public void* pNext;
	public VulkanHandle<VkSwapchainKHR> Swapchain;
	public ulong Timeout;
	public VulkanHandle<VkSemaphore> Semaphore;
	public VulkanHandle<VkFence> Fence;
	public uint DeviceMask;

	public VkAcquireNextImageInfoKHR(
		VulkanHandle<VkSwapchainKHR> swapchain = default,
		ulong timeout = default,
		VulkanHandle<VkSemaphore> semaphore = default,
		VulkanHandle<VkFence> fence = default,
		uint deviceMask = default
	) {
		sType = TYPE;
		pNext = null;
		Swapchain = swapchain;
		Timeout = timeout;
		Semaphore = semaphore;
		Fence = fence;
		DeviceMask = deviceMask;
	}

	public readonly override bool Equals(object? o) => (o is VkAcquireNextImageInfoKHR s) && (this == s);
	readonly bool IEquatable<VkAcquireNextImageInfoKHR>.Equals(VkAcquireNextImageInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Swapchain.GetHashCode() ^ Timeout.GetHashCode()
			^ Semaphore.GetHashCode() ^ Fence.GetHashCode() ^ DeviceMask.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkAcquireNextImageInfoKHR l, in VkAcquireNextImageInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Swapchain == r.Swapchain) && (l.Timeout == r.Timeout)
			&& (l.Semaphore == r.Semaphore) && (l.Fence == r.Fence) && (l.DeviceMask == r.DeviceMask)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkAcquireNextImageInfoKHR l, in VkAcquireNextImageInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Swapchain != r.Swapchain) || (l.Timeout != r.Timeout)
			|| (l.Semaphore != r.Semaphore) || (l.Fence != r.Fence) || (l.DeviceMask != r.DeviceMask)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkAcquireNextImageInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDeviceGroupPresentInfoKHR : IEquatable<VkDeviceGroupPresentInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.DeviceGroupPresentInfoKhr;

	public VkStructureType sType;
	public void* pNext;
	public uint SwapchainCount;
	public uint* DeviceMasks;
	public VkDeviceGroupPresentModeFlagsKHR Mode;

	public VkDeviceGroupPresentInfoKHR(
		uint swapchainCount = default,
		uint* deviceMasks = default,
		VkDeviceGroupPresentModeFlagsKHR mode = default
	) {
		sType = TYPE;
		pNext = null;
		SwapchainCount = swapchainCount;
		DeviceMasks = deviceMasks;
		Mode = mode;
	}

	public readonly override bool Equals(object? o) => (o is VkDeviceGroupPresentInfoKHR s) && (this == s);
	readonly bool IEquatable<VkDeviceGroupPresentInfoKHR>.Equals(VkDeviceGroupPresentInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SwapchainCount.GetHashCode() ^ ((ulong)DeviceMasks).GetHashCode()
			^ Mode.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDeviceGroupPresentInfoKHR l, in VkDeviceGroupPresentInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SwapchainCount == r.SwapchainCount) && (l.DeviceMasks == r.DeviceMasks)
			&& (l.Mode == r.Mode)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDeviceGroupPresentInfoKHR l, in VkDeviceGroupPresentInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SwapchainCount != r.SwapchainCount) || (l.DeviceMasks != r.DeviceMasks)
			|| (l.Mode != r.Mode)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDeviceGroupPresentInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDeviceGroupDeviceCreateInfoKHR : IEquatable<VkDeviceGroupDeviceCreateInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.DeviceGroupDeviceCreateInfo;

	public VkStructureType sType;
	public void* pNext;
	public uint PhysicalDeviceCount;
	public VulkanHandle<VkPhysicalDevice>* PhysicalDevices;

	public VkDeviceGroupDeviceCreateInfoKHR(
		uint physicalDeviceCount = default,
		VulkanHandle<VkPhysicalDevice>* physicalDevices = default
	) {
		sType = TYPE;
		pNext = null;
		PhysicalDeviceCount = physicalDeviceCount;
		PhysicalDevices = physicalDevices;
	}

	public readonly override bool Equals(object? o) => (o is VkDeviceGroupDeviceCreateInfoKHR s) && (this == s);
	readonly bool IEquatable<VkDeviceGroupDeviceCreateInfoKHR>.Equals(VkDeviceGroupDeviceCreateInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ PhysicalDeviceCount.GetHashCode() ^ ((ulong)PhysicalDevices).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDeviceGroupDeviceCreateInfoKHR l, in VkDeviceGroupDeviceCreateInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.PhysicalDeviceCount == r.PhysicalDeviceCount) && (l.PhysicalDevices == r.PhysicalDevices)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDeviceGroupDeviceCreateInfoKHR l, in VkDeviceGroupDeviceCreateInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.PhysicalDeviceCount != r.PhysicalDeviceCount) || (l.PhysicalDevices != r.PhysicalDevices)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDeviceGroupDeviceCreateInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDeviceGroupSwapchainCreateInfoKHR : IEquatable<VkDeviceGroupSwapchainCreateInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.DeviceGroupSwapchainCreateInfoKhr;

	public VkStructureType sType;
	public void* pNext;
	public VkDeviceGroupPresentModeFlagsKHR Modes;

	public VkDeviceGroupSwapchainCreateInfoKHR(
		VkDeviceGroupPresentModeFlagsKHR modes = default
	) {
		sType = TYPE;
		pNext = null;
		Modes = modes;
	}

	public readonly override bool Equals(object? o) => (o is VkDeviceGroupSwapchainCreateInfoKHR s) && (this == s);
	readonly bool IEquatable<VkDeviceGroupSwapchainCreateInfoKHR>.Equals(VkDeviceGroupSwapchainCreateInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Modes.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDeviceGroupSwapchainCreateInfoKHR l, in VkDeviceGroupSwapchainCreateInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Modes == r.Modes)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDeviceGroupSwapchainCreateInfoKHR l, in VkDeviceGroupSwapchainCreateInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Modes != r.Modes)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDeviceGroupSwapchainCreateInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDescriptorUpdateTemplateEntryKHR : IEquatable<VkDescriptorUpdateTemplateEntryKHR>
{
	public uint DstBinding;
	public uint DstArrayElement;
	public uint DescriptorCount;
	public VkDescriptorType DescriptorType;
	public ulong Offset;
	public ulong Stride;

	public VkDescriptorUpdateTemplateEntryKHR(
		uint dstBinding = default,
		uint dstArrayElement = default,
		uint descriptorCount = default,
		VkDescriptorType descriptorType = default,
		ulong offset = default,
		ulong stride = default
	) {
		DstBinding = dstBinding;
		DstArrayElement = dstArrayElement;
		DescriptorCount = descriptorCount;
		DescriptorType = descriptorType;
		Offset = offset;
		Stride = stride;
	}

	public readonly override bool Equals(object? o) => (o is VkDescriptorUpdateTemplateEntryKHR s) && (this == s);
	readonly bool IEquatable<VkDescriptorUpdateTemplateEntryKHR>.Equals(VkDescriptorUpdateTemplateEntryKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			DstBinding.GetHashCode() ^ DstArrayElement.GetHashCode() ^ DescriptorCount.GetHashCode() ^ DescriptorType.GetHashCode()
			^ Offset.GetHashCode() ^ Stride.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDescriptorUpdateTemplateEntryKHR l, in VkDescriptorUpdateTemplateEntryKHR r)
	{
		return
			(l.DstBinding == r.DstBinding) && (l.DstArrayElement == r.DstArrayElement) && (l.DescriptorCount == r.DescriptorCount) && (l.DescriptorType == r.DescriptorType)
			&& (l.Offset == r.Offset) && (l.Stride == r.Stride)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDescriptorUpdateTemplateEntryKHR l, in VkDescriptorUpdateTemplateEntryKHR r)
	{
		return
			(l.DstBinding != r.DstBinding) || (l.DstArrayElement != r.DstArrayElement) || (l.DescriptorCount != r.DescriptorCount) || (l.DescriptorType != r.DescriptorType)
			|| (l.Offset != r.Offset) || (l.Stride != r.Stride)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDescriptorUpdateTemplateEntryKHR s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDescriptorUpdateTemplateCreateInfoKHR : IEquatable<VkDescriptorUpdateTemplateCreateInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.DescriptorUpdateTemplateCreateInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkDescriptorUpdateTemplateCreateFlags Flags;
	public uint DescriptorUpdateEntryCount;
	public VkDescriptorUpdateTemplateEntry* DescriptorUpdateEntries;
	public VkDescriptorUpdateTemplateType TemplateType;
	public VulkanHandle<VkDescriptorSetLayout> DescriptorSetLayout;
	public VkPipelineBindPoint PipelineBindPoint;
	public VulkanHandle<VkPipelineLayout> PipelineLayout;
	public uint Set;

	public VkDescriptorUpdateTemplateCreateInfoKHR(
		VkDescriptorUpdateTemplateCreateFlags flags = default,
		uint descriptorUpdateEntryCount = default,
		VkDescriptorUpdateTemplateEntry* descriptorUpdateEntries = default,
		VkDescriptorUpdateTemplateType templateType = default,
		VulkanHandle<VkDescriptorSetLayout> descriptorSetLayout = default,
		VkPipelineBindPoint pipelineBindPoint = default,
		VulkanHandle<VkPipelineLayout> pipelineLayout = default,
		uint set = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		DescriptorUpdateEntryCount = descriptorUpdateEntryCount;
		DescriptorUpdateEntries = descriptorUpdateEntries;
		TemplateType = templateType;
		DescriptorSetLayout = descriptorSetLayout;
		PipelineBindPoint = pipelineBindPoint;
		PipelineLayout = pipelineLayout;
		Set = set;
	}

	public readonly override bool Equals(object? o) => (o is VkDescriptorUpdateTemplateCreateInfoKHR s) && (this == s);
	readonly bool IEquatable<VkDescriptorUpdateTemplateCreateInfoKHR>.Equals(VkDescriptorUpdateTemplateCreateInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ DescriptorUpdateEntryCount.GetHashCode()
			^ ((ulong)DescriptorUpdateEntries).GetHashCode() ^ TemplateType.GetHashCode() ^ DescriptorSetLayout.GetHashCode() ^ PipelineBindPoint.GetHashCode()
			^ PipelineLayout.GetHashCode() ^ Set.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDescriptorUpdateTemplateCreateInfoKHR l, in VkDescriptorUpdateTemplateCreateInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.DescriptorUpdateEntryCount == r.DescriptorUpdateEntryCount)
			&& (l.DescriptorUpdateEntries == r.DescriptorUpdateEntries) && (l.TemplateType == r.TemplateType) && (l.DescriptorSetLayout == r.DescriptorSetLayout) && (l.PipelineBindPoint == r.PipelineBindPoint)
			&& (l.PipelineLayout == r.PipelineLayout) && (l.Set == r.Set)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDescriptorUpdateTemplateCreateInfoKHR l, in VkDescriptorUpdateTemplateCreateInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.DescriptorUpdateEntryCount != r.DescriptorUpdateEntryCount)
			|| (l.DescriptorUpdateEntries != r.DescriptorUpdateEntries) || (l.TemplateType != r.TemplateType) || (l.DescriptorSetLayout != r.DescriptorSetLayout) || (l.PipelineBindPoint != r.PipelineBindPoint)
			|| (l.PipelineLayout != r.PipelineLayout) || (l.Set != r.Set)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDescriptorUpdateTemplateCreateInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkInputAttachmentAspectReferenceKHR : IEquatable<VkInputAttachmentAspectReferenceKHR>
{
	public uint Subpass;
	public uint InputAttachmentIndex;
	public VkImageAspectFlags AspectMask;

	public VkInputAttachmentAspectReferenceKHR(
		uint subpass = default,
		uint inputAttachmentIndex = default,
		VkImageAspectFlags aspectMask = default
	) {
		Subpass = subpass;
		InputAttachmentIndex = inputAttachmentIndex;
		AspectMask = aspectMask;
	}

	public readonly override bool Equals(object? o) => (o is VkInputAttachmentAspectReferenceKHR s) && (this == s);
	readonly bool IEquatable<VkInputAttachmentAspectReferenceKHR>.Equals(VkInputAttachmentAspectReferenceKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Subpass.GetHashCode() ^ InputAttachmentIndex.GetHashCode() ^ AspectMask.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkInputAttachmentAspectReferenceKHR l, in VkInputAttachmentAspectReferenceKHR r)
	{
		return
			(l.Subpass == r.Subpass) && (l.InputAttachmentIndex == r.InputAttachmentIndex) && (l.AspectMask == r.AspectMask)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkInputAttachmentAspectReferenceKHR l, in VkInputAttachmentAspectReferenceKHR r)
	{
		return
			(l.Subpass != r.Subpass) || (l.InputAttachmentIndex != r.InputAttachmentIndex) || (l.AspectMask != r.AspectMask)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkInputAttachmentAspectReferenceKHR s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkRenderPassInputAttachmentAspectCreateInfoKHR : IEquatable<VkRenderPassInputAttachmentAspectCreateInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.RenderPassInputAttachmentAspectCreateInfo;

	public VkStructureType sType;
	public void* pNext;
	public uint AspectReferenceCount;
	public VkInputAttachmentAspectReference* AspectReferences;

	public VkRenderPassInputAttachmentAspectCreateInfoKHR(
		uint aspectReferenceCount = default,
		VkInputAttachmentAspectReference* aspectReferences = default
	) {
		sType = TYPE;
		pNext = null;
		AspectReferenceCount = aspectReferenceCount;
		AspectReferences = aspectReferences;
	}

	public readonly override bool Equals(object? o) => (o is VkRenderPassInputAttachmentAspectCreateInfoKHR s) && (this == s);
	readonly bool IEquatable<VkRenderPassInputAttachmentAspectCreateInfoKHR>.Equals(VkRenderPassInputAttachmentAspectCreateInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ AspectReferenceCount.GetHashCode() ^ ((ulong)AspectReferences).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkRenderPassInputAttachmentAspectCreateInfoKHR l, in VkRenderPassInputAttachmentAspectCreateInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.AspectReferenceCount == r.AspectReferenceCount) && (l.AspectReferences == r.AspectReferences)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkRenderPassInputAttachmentAspectCreateInfoKHR l, in VkRenderPassInputAttachmentAspectCreateInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.AspectReferenceCount != r.AspectReferenceCount) || (l.AspectReferences != r.AspectReferences)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkRenderPassInputAttachmentAspectCreateInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceSurfaceInfo2KHR : IEquatable<VkPhysicalDeviceSurfaceInfo2KHR>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceSurfaceInfo2Khr;

	public VkStructureType sType;
	public void* pNext;
	public VulkanHandle<VkSurfaceKHR> Surface;

	public VkPhysicalDeviceSurfaceInfo2KHR(
		VulkanHandle<VkSurfaceKHR> surface = default
	) {
		sType = TYPE;
		pNext = null;
		Surface = surface;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceSurfaceInfo2KHR s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceSurfaceInfo2KHR>.Equals(VkPhysicalDeviceSurfaceInfo2KHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Surface.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceSurfaceInfo2KHR l, in VkPhysicalDeviceSurfaceInfo2KHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Surface == r.Surface)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceSurfaceInfo2KHR l, in VkPhysicalDeviceSurfaceInfo2KHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Surface != r.Surface)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceSurfaceInfo2KHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkSurfaceCapabilities2KHR : IEquatable<VkSurfaceCapabilities2KHR>
{
	public const VkStructureType TYPE = VkStructureType.SurfaceCapabilities2Khr;

	public VkStructureType sType;
	public void* pNext;
	public VkSurfaceCapabilitiesKHR SurfaceCapabilities;

	public VkSurfaceCapabilities2KHR(
		VkSurfaceCapabilitiesKHR surfaceCapabilities = default
	) {
		sType = TYPE;
		pNext = null;
		SurfaceCapabilities = surfaceCapabilities;
	}

	public readonly override bool Equals(object? o) => (o is VkSurfaceCapabilities2KHR s) && (this == s);
	readonly bool IEquatable<VkSurfaceCapabilities2KHR>.Equals(VkSurfaceCapabilities2KHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SurfaceCapabilities.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkSurfaceCapabilities2KHR l, in VkSurfaceCapabilities2KHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SurfaceCapabilities == r.SurfaceCapabilities)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkSurfaceCapabilities2KHR l, in VkSurfaceCapabilities2KHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SurfaceCapabilities != r.SurfaceCapabilities)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkSurfaceCapabilities2KHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkSurfaceFormat2KHR : IEquatable<VkSurfaceFormat2KHR>
{
	public const VkStructureType TYPE = VkStructureType.SurfaceFormat2Khr;

	public VkStructureType sType;
	public void* pNext;
	public VkSurfaceFormatKHR SurfaceFormat;

	public VkSurfaceFormat2KHR(
		VkSurfaceFormatKHR surfaceFormat = default
	) {
		sType = TYPE;
		pNext = null;
		SurfaceFormat = surfaceFormat;
	}

	public readonly override bool Equals(object? o) => (o is VkSurfaceFormat2KHR s) && (this == s);
	readonly bool IEquatable<VkSurfaceFormat2KHR>.Equals(VkSurfaceFormat2KHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SurfaceFormat.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkSurfaceFormat2KHR l, in VkSurfaceFormat2KHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SurfaceFormat == r.SurfaceFormat)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkSurfaceFormat2KHR l, in VkSurfaceFormat2KHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SurfaceFormat != r.SurfaceFormat)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkSurfaceFormat2KHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDisplayProperties2KHR : IEquatable<VkDisplayProperties2KHR>
{
	public const VkStructureType TYPE = VkStructureType.DisplayProperties2Khr;

	public VkStructureType sType;
	public void* pNext;
	public VkDisplayPropertiesKHR DisplayProperties;

	public VkDisplayProperties2KHR(
		VkDisplayPropertiesKHR displayProperties = default
	) {
		sType = TYPE;
		pNext = null;
		DisplayProperties = displayProperties;
	}

	public readonly override bool Equals(object? o) => (o is VkDisplayProperties2KHR s) && (this == s);
	readonly bool IEquatable<VkDisplayProperties2KHR>.Equals(VkDisplayProperties2KHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DisplayProperties.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDisplayProperties2KHR l, in VkDisplayProperties2KHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DisplayProperties == r.DisplayProperties)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDisplayProperties2KHR l, in VkDisplayProperties2KHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DisplayProperties != r.DisplayProperties)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDisplayProperties2KHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDisplayPlaneProperties2KHR : IEquatable<VkDisplayPlaneProperties2KHR>
{
	public const VkStructureType TYPE = VkStructureType.DisplayPlaneProperties2Khr;

	public VkStructureType sType;
	public void* pNext;
	public VkDisplayPlanePropertiesKHR DisplayPlaneProperties;

	public VkDisplayPlaneProperties2KHR(
		VkDisplayPlanePropertiesKHR displayPlaneProperties = default
	) {
		sType = TYPE;
		pNext = null;
		DisplayPlaneProperties = displayPlaneProperties;
	}

	public readonly override bool Equals(object? o) => (o is VkDisplayPlaneProperties2KHR s) && (this == s);
	readonly bool IEquatable<VkDisplayPlaneProperties2KHR>.Equals(VkDisplayPlaneProperties2KHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DisplayPlaneProperties.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDisplayPlaneProperties2KHR l, in VkDisplayPlaneProperties2KHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DisplayPlaneProperties == r.DisplayPlaneProperties)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDisplayPlaneProperties2KHR l, in VkDisplayPlaneProperties2KHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DisplayPlaneProperties != r.DisplayPlaneProperties)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDisplayPlaneProperties2KHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDisplayModeProperties2KHR : IEquatable<VkDisplayModeProperties2KHR>
{
	public const VkStructureType TYPE = VkStructureType.DisplayModeProperties2Khr;

	public VkStructureType sType;
	public void* pNext;
	public VkDisplayModePropertiesKHR DisplayModeProperties;

	public VkDisplayModeProperties2KHR(
		VkDisplayModePropertiesKHR displayModeProperties = default
	) {
		sType = TYPE;
		pNext = null;
		DisplayModeProperties = displayModeProperties;
	}

	public readonly override bool Equals(object? o) => (o is VkDisplayModeProperties2KHR s) && (this == s);
	readonly bool IEquatable<VkDisplayModeProperties2KHR>.Equals(VkDisplayModeProperties2KHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DisplayModeProperties.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDisplayModeProperties2KHR l, in VkDisplayModeProperties2KHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DisplayModeProperties == r.DisplayModeProperties)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDisplayModeProperties2KHR l, in VkDisplayModeProperties2KHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DisplayModeProperties != r.DisplayModeProperties)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDisplayModeProperties2KHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDisplayPlaneInfo2KHR : IEquatable<VkDisplayPlaneInfo2KHR>
{
	public const VkStructureType TYPE = VkStructureType.DisplayPlaneInfo2Khr;

	public VkStructureType sType;
	public void* pNext;
	public VulkanHandle<VkDisplayModeKHR> Mode;
	public uint PlaneIndex;

	public VkDisplayPlaneInfo2KHR(
		VulkanHandle<VkDisplayModeKHR> mode = default,
		uint planeIndex = default
	) {
		sType = TYPE;
		pNext = null;
		Mode = mode;
		PlaneIndex = planeIndex;
	}

	public readonly override bool Equals(object? o) => (o is VkDisplayPlaneInfo2KHR s) && (this == s);
	readonly bool IEquatable<VkDisplayPlaneInfo2KHR>.Equals(VkDisplayPlaneInfo2KHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Mode.GetHashCode() ^ PlaneIndex.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDisplayPlaneInfo2KHR l, in VkDisplayPlaneInfo2KHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Mode == r.Mode) && (l.PlaneIndex == r.PlaneIndex)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDisplayPlaneInfo2KHR l, in VkDisplayPlaneInfo2KHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Mode != r.Mode) || (l.PlaneIndex != r.PlaneIndex)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDisplayPlaneInfo2KHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDisplayPlaneCapabilities2KHR : IEquatable<VkDisplayPlaneCapabilities2KHR>
{
	public const VkStructureType TYPE = VkStructureType.DisplayPlaneCapabilities2Khr;

	public VkStructureType sType;
	public void* pNext;
	public VkDisplayPlaneCapabilitiesKHR Capabilities;

	public VkDisplayPlaneCapabilities2KHR(
		VkDisplayPlaneCapabilitiesKHR capabilities = default
	) {
		sType = TYPE;
		pNext = null;
		Capabilities = capabilities;
	}

	public readonly override bool Equals(object? o) => (o is VkDisplayPlaneCapabilities2KHR s) && (this == s);
	readonly bool IEquatable<VkDisplayPlaneCapabilities2KHR>.Equals(VkDisplayPlaneCapabilities2KHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Capabilities.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDisplayPlaneCapabilities2KHR l, in VkDisplayPlaneCapabilities2KHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Capabilities == r.Capabilities)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDisplayPlaneCapabilities2KHR l, in VkDisplayPlaneCapabilities2KHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Capabilities != r.Capabilities)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDisplayPlaneCapabilities2KHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkSharedPresentSurfaceCapabilitiesKHR : IEquatable<VkSharedPresentSurfaceCapabilitiesKHR>
{
	public const VkStructureType TYPE = VkStructureType.SharedPresentSurfaceCapabilitiesKhr;

	public VkStructureType sType;
	public void* pNext;
	public VkImageUsageFlags SharedPresentSupportedUsageFlags;

	public VkSharedPresentSurfaceCapabilitiesKHR(
		VkImageUsageFlags sharedPresentSupportedUsageFlags = default
	) {
		sType = TYPE;
		pNext = null;
		SharedPresentSupportedUsageFlags = sharedPresentSupportedUsageFlags;
	}

	public readonly override bool Equals(object? o) => (o is VkSharedPresentSurfaceCapabilitiesKHR s) && (this == s);
	readonly bool IEquatable<VkSharedPresentSurfaceCapabilitiesKHR>.Equals(VkSharedPresentSurfaceCapabilitiesKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SharedPresentSupportedUsageFlags.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkSharedPresentSurfaceCapabilitiesKHR l, in VkSharedPresentSurfaceCapabilitiesKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SharedPresentSupportedUsageFlags == r.SharedPresentSupportedUsageFlags)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkSharedPresentSurfaceCapabilitiesKHR l, in VkSharedPresentSurfaceCapabilitiesKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SharedPresentSupportedUsageFlags != r.SharedPresentSupportedUsageFlags)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkSharedPresentSurfaceCapabilitiesKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDevice16BitStorageFeaturesKHR : IEquatable<VkPhysicalDevice16BitStorageFeaturesKHR>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDevice16BitStorageFeatures;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 StorageBuffer16BitAccess;
	public VkBool32 UniformAndStorageBuffer16BitAccess;
	public VkBool32 StoragePushConstant16;
	public VkBool32 StorageInputOutput16;

	public VkPhysicalDevice16BitStorageFeaturesKHR(
		VkBool32 storageBuffer16BitAccess = default,
		VkBool32 uniformAndStorageBuffer16BitAccess = default,
		VkBool32 storagePushConstant16 = default,
		VkBool32 storageInputOutput16 = default
	) {
		sType = TYPE;
		pNext = null;
		StorageBuffer16BitAccess = storageBuffer16BitAccess;
		UniformAndStorageBuffer16BitAccess = uniformAndStorageBuffer16BitAccess;
		StoragePushConstant16 = storagePushConstant16;
		StorageInputOutput16 = storageInputOutput16;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDevice16BitStorageFeaturesKHR s) && (this == s);
	readonly bool IEquatable<VkPhysicalDevice16BitStorageFeaturesKHR>.Equals(VkPhysicalDevice16BitStorageFeaturesKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ StorageBuffer16BitAccess.GetHashCode() ^ UniformAndStorageBuffer16BitAccess.GetHashCode()
			^ StoragePushConstant16.GetHashCode() ^ StorageInputOutput16.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDevice16BitStorageFeaturesKHR l, in VkPhysicalDevice16BitStorageFeaturesKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.StorageBuffer16BitAccess == r.StorageBuffer16BitAccess) && (l.UniformAndStorageBuffer16BitAccess == r.UniformAndStorageBuffer16BitAccess)
			&& (l.StoragePushConstant16 == r.StoragePushConstant16) && (l.StorageInputOutput16 == r.StorageInputOutput16)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDevice16BitStorageFeaturesKHR l, in VkPhysicalDevice16BitStorageFeaturesKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.StorageBuffer16BitAccess != r.StorageBuffer16BitAccess) || (l.UniformAndStorageBuffer16BitAccess != r.UniformAndStorageBuffer16BitAccess)
			|| (l.StoragePushConstant16 != r.StoragePushConstant16) || (l.StorageInputOutput16 != r.StorageInputOutput16)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDevice16BitStorageFeaturesKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR : IEquatable<VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceShaderSubgroupExtendedTypesFeatures;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 ShaderSubgroupExtendedTypes;

	public VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR(
		VkBool32 shaderSubgroupExtendedTypes = default
	) {
		sType = TYPE;
		pNext = null;
		ShaderSubgroupExtendedTypes = shaderSubgroupExtendedTypes;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR>.Equals(VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ShaderSubgroupExtendedTypes.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR l, in VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ShaderSubgroupExtendedTypes == r.ShaderSubgroupExtendedTypes)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR l, in VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ShaderSubgroupExtendedTypes != r.ShaderSubgroupExtendedTypes)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkBufferMemoryRequirementsInfo2KHR : IEquatable<VkBufferMemoryRequirementsInfo2KHR>
{
	public const VkStructureType TYPE = VkStructureType.BufferMemoryRequirementsInfo2;

	public VkStructureType sType;
	public void* pNext;
	public VulkanHandle<VkBuffer> Buffer;

	public VkBufferMemoryRequirementsInfo2KHR(
		VulkanHandle<VkBuffer> buffer = default
	) {
		sType = TYPE;
		pNext = null;
		Buffer = buffer;
	}

	public readonly override bool Equals(object? o) => (o is VkBufferMemoryRequirementsInfo2KHR s) && (this == s);
	readonly bool IEquatable<VkBufferMemoryRequirementsInfo2KHR>.Equals(VkBufferMemoryRequirementsInfo2KHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Buffer.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkBufferMemoryRequirementsInfo2KHR l, in VkBufferMemoryRequirementsInfo2KHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Buffer == r.Buffer)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkBufferMemoryRequirementsInfo2KHR l, in VkBufferMemoryRequirementsInfo2KHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Buffer != r.Buffer)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkBufferMemoryRequirementsInfo2KHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkImageMemoryRequirementsInfo2KHR : IEquatable<VkImageMemoryRequirementsInfo2KHR>
{
	public const VkStructureType TYPE = VkStructureType.ImageMemoryRequirementsInfo2;

	public VkStructureType sType;
	public void* pNext;
	public VulkanHandle<VkImage> Image;

	public VkImageMemoryRequirementsInfo2KHR(
		VulkanHandle<VkImage> image = default
	) {
		sType = TYPE;
		pNext = null;
		Image = image;
	}

	public readonly override bool Equals(object? o) => (o is VkImageMemoryRequirementsInfo2KHR s) && (this == s);
	readonly bool IEquatable<VkImageMemoryRequirementsInfo2KHR>.Equals(VkImageMemoryRequirementsInfo2KHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Image.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkImageMemoryRequirementsInfo2KHR l, in VkImageMemoryRequirementsInfo2KHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Image == r.Image)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkImageMemoryRequirementsInfo2KHR l, in VkImageMemoryRequirementsInfo2KHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Image != r.Image)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkImageMemoryRequirementsInfo2KHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkImageSparseMemoryRequirementsInfo2KHR : IEquatable<VkImageSparseMemoryRequirementsInfo2KHR>
{
	public const VkStructureType TYPE = VkStructureType.ImageSparseMemoryRequirementsInfo2;

	public VkStructureType sType;
	public void* pNext;
	public VulkanHandle<VkImage> Image;

	public VkImageSparseMemoryRequirementsInfo2KHR(
		VulkanHandle<VkImage> image = default
	) {
		sType = TYPE;
		pNext = null;
		Image = image;
	}

	public readonly override bool Equals(object? o) => (o is VkImageSparseMemoryRequirementsInfo2KHR s) && (this == s);
	readonly bool IEquatable<VkImageSparseMemoryRequirementsInfo2KHR>.Equals(VkImageSparseMemoryRequirementsInfo2KHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Image.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkImageSparseMemoryRequirementsInfo2KHR l, in VkImageSparseMemoryRequirementsInfo2KHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Image == r.Image)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkImageSparseMemoryRequirementsInfo2KHR l, in VkImageSparseMemoryRequirementsInfo2KHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Image != r.Image)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkImageSparseMemoryRequirementsInfo2KHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkMemoryRequirements2KHR : IEquatable<VkMemoryRequirements2KHR>
{
	public const VkStructureType TYPE = VkStructureType.MemoryRequirements2;

	public VkStructureType sType;
	public void* pNext;
	public VkMemoryRequirements MemoryRequirements;

	public VkMemoryRequirements2KHR(
		VkMemoryRequirements memoryRequirements = default
	) {
		sType = TYPE;
		pNext = null;
		MemoryRequirements = memoryRequirements;
	}

	public readonly override bool Equals(object? o) => (o is VkMemoryRequirements2KHR s) && (this == s);
	readonly bool IEquatable<VkMemoryRequirements2KHR>.Equals(VkMemoryRequirements2KHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MemoryRequirements.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkMemoryRequirements2KHR l, in VkMemoryRequirements2KHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MemoryRequirements == r.MemoryRequirements)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkMemoryRequirements2KHR l, in VkMemoryRequirements2KHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MemoryRequirements != r.MemoryRequirements)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkMemoryRequirements2KHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkSparseImageMemoryRequirements2KHR : IEquatable<VkSparseImageMemoryRequirements2KHR>
{
	public const VkStructureType TYPE = VkStructureType.SparseImageMemoryRequirements2;

	public VkStructureType sType;
	public void* pNext;
	public VkSparseImageMemoryRequirements MemoryRequirements;

	public VkSparseImageMemoryRequirements2KHR(
		VkSparseImageMemoryRequirements memoryRequirements = default
	) {
		sType = TYPE;
		pNext = null;
		MemoryRequirements = memoryRequirements;
	}

	public readonly override bool Equals(object? o) => (o is VkSparseImageMemoryRequirements2KHR s) && (this == s);
	readonly bool IEquatable<VkSparseImageMemoryRequirements2KHR>.Equals(VkSparseImageMemoryRequirements2KHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MemoryRequirements.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkSparseImageMemoryRequirements2KHR l, in VkSparseImageMemoryRequirements2KHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MemoryRequirements == r.MemoryRequirements)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkSparseImageMemoryRequirements2KHR l, in VkSparseImageMemoryRequirements2KHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MemoryRequirements != r.MemoryRequirements)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkSparseImageMemoryRequirements2KHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDevicePointClippingPropertiesKHR : IEquatable<VkPhysicalDevicePointClippingPropertiesKHR>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDevicePointClippingProperties;

	public VkStructureType sType;
	public void* pNext;
	public VkPointClippingBehavior PointClippingBehavior;

	public VkPhysicalDevicePointClippingPropertiesKHR(
		VkPointClippingBehavior pointClippingBehavior = default
	) {
		sType = TYPE;
		pNext = null;
		PointClippingBehavior = pointClippingBehavior;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDevicePointClippingPropertiesKHR s) && (this == s);
	readonly bool IEquatable<VkPhysicalDevicePointClippingPropertiesKHR>.Equals(VkPhysicalDevicePointClippingPropertiesKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ PointClippingBehavior.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDevicePointClippingPropertiesKHR l, in VkPhysicalDevicePointClippingPropertiesKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.PointClippingBehavior == r.PointClippingBehavior)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDevicePointClippingPropertiesKHR l, in VkPhysicalDevicePointClippingPropertiesKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.PointClippingBehavior != r.PointClippingBehavior)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDevicePointClippingPropertiesKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkMemoryDedicatedRequirementsKHR : IEquatable<VkMemoryDedicatedRequirementsKHR>
{
	public const VkStructureType TYPE = VkStructureType.MemoryDedicatedRequirements;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 PrefersDedicatedAllocation;
	public VkBool32 RequiresDedicatedAllocation;

	public VkMemoryDedicatedRequirementsKHR(
		VkBool32 prefersDedicatedAllocation = default,
		VkBool32 requiresDedicatedAllocation = default
	) {
		sType = TYPE;
		pNext = null;
		PrefersDedicatedAllocation = prefersDedicatedAllocation;
		RequiresDedicatedAllocation = requiresDedicatedAllocation;
	}

	public readonly override bool Equals(object? o) => (o is VkMemoryDedicatedRequirementsKHR s) && (this == s);
	readonly bool IEquatable<VkMemoryDedicatedRequirementsKHR>.Equals(VkMemoryDedicatedRequirementsKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ PrefersDedicatedAllocation.GetHashCode() ^ RequiresDedicatedAllocation.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkMemoryDedicatedRequirementsKHR l, in VkMemoryDedicatedRequirementsKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.PrefersDedicatedAllocation == r.PrefersDedicatedAllocation) && (l.RequiresDedicatedAllocation == r.RequiresDedicatedAllocation)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkMemoryDedicatedRequirementsKHR l, in VkMemoryDedicatedRequirementsKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.PrefersDedicatedAllocation != r.PrefersDedicatedAllocation) || (l.RequiresDedicatedAllocation != r.RequiresDedicatedAllocation)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkMemoryDedicatedRequirementsKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkMemoryDedicatedAllocateInfoKHR : IEquatable<VkMemoryDedicatedAllocateInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.MemoryDedicatedAllocateInfo;

	public VkStructureType sType;
	public void* pNext;
	public VulkanHandle<VkImage> Image;
	public VulkanHandle<VkBuffer> Buffer;

	public VkMemoryDedicatedAllocateInfoKHR(
		VulkanHandle<VkImage> image = default,
		VulkanHandle<VkBuffer> buffer = default
	) {
		sType = TYPE;
		pNext = null;
		Image = image;
		Buffer = buffer;
	}

	public readonly override bool Equals(object? o) => (o is VkMemoryDedicatedAllocateInfoKHR s) && (this == s);
	readonly bool IEquatable<VkMemoryDedicatedAllocateInfoKHR>.Equals(VkMemoryDedicatedAllocateInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Image.GetHashCode() ^ Buffer.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkMemoryDedicatedAllocateInfoKHR l, in VkMemoryDedicatedAllocateInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Image == r.Image) && (l.Buffer == r.Buffer)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkMemoryDedicatedAllocateInfoKHR l, in VkMemoryDedicatedAllocateInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Image != r.Image) || (l.Buffer != r.Buffer)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkMemoryDedicatedAllocateInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkImageViewUsageCreateInfoKHR : IEquatable<VkImageViewUsageCreateInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.ImageViewUsageCreateInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkImageUsageFlags Usage;

	public VkImageViewUsageCreateInfoKHR(
		VkImageUsageFlags usage = default
	) {
		sType = TYPE;
		pNext = null;
		Usage = usage;
	}

	public readonly override bool Equals(object? o) => (o is VkImageViewUsageCreateInfoKHR s) && (this == s);
	readonly bool IEquatable<VkImageViewUsageCreateInfoKHR>.Equals(VkImageViewUsageCreateInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Usage.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkImageViewUsageCreateInfoKHR l, in VkImageViewUsageCreateInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Usage == r.Usage)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkImageViewUsageCreateInfoKHR l, in VkImageViewUsageCreateInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Usage != r.Usage)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkImageViewUsageCreateInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPipelineTessellationDomainOriginStateCreateInfoKHR : IEquatable<VkPipelineTessellationDomainOriginStateCreateInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.PipelineTessellationDomainOriginStateCreateInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkTessellationDomainOrigin DomainOrigin;

	public VkPipelineTessellationDomainOriginStateCreateInfoKHR(
		VkTessellationDomainOrigin domainOrigin = default
	) {
		sType = TYPE;
		pNext = null;
		DomainOrigin = domainOrigin;
	}

	public readonly override bool Equals(object? o) => (o is VkPipelineTessellationDomainOriginStateCreateInfoKHR s) && (this == s);
	readonly bool IEquatable<VkPipelineTessellationDomainOriginStateCreateInfoKHR>.Equals(VkPipelineTessellationDomainOriginStateCreateInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DomainOrigin.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPipelineTessellationDomainOriginStateCreateInfoKHR l, in VkPipelineTessellationDomainOriginStateCreateInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DomainOrigin == r.DomainOrigin)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPipelineTessellationDomainOriginStateCreateInfoKHR l, in VkPipelineTessellationDomainOriginStateCreateInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DomainOrigin != r.DomainOrigin)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPipelineTessellationDomainOriginStateCreateInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkSamplerYcbcrConversionInfoKHR : IEquatable<VkSamplerYcbcrConversionInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.SamplerYcbcrConversionInfo;

	public VkStructureType sType;
	public void* pNext;
	public VulkanHandle<VkSamplerYcbcrConversion> Conversion;

	public VkSamplerYcbcrConversionInfoKHR(
		VulkanHandle<VkSamplerYcbcrConversion> conversion = default
	) {
		sType = TYPE;
		pNext = null;
		Conversion = conversion;
	}

	public readonly override bool Equals(object? o) => (o is VkSamplerYcbcrConversionInfoKHR s) && (this == s);
	readonly bool IEquatable<VkSamplerYcbcrConversionInfoKHR>.Equals(VkSamplerYcbcrConversionInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Conversion.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkSamplerYcbcrConversionInfoKHR l, in VkSamplerYcbcrConversionInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Conversion == r.Conversion)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkSamplerYcbcrConversionInfoKHR l, in VkSamplerYcbcrConversionInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Conversion != r.Conversion)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkSamplerYcbcrConversionInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkSamplerYcbcrConversionCreateInfoKHR : IEquatable<VkSamplerYcbcrConversionCreateInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.SamplerYcbcrConversionCreateInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkFormat Format;
	public VkSamplerYcbcrModelConversion YcbcrModel;
	public VkSamplerYcbcrRange YcbcrRange;
	public VkComponentMapping Components;
	public VkChromaLocation XChromaOffset;
	public VkChromaLocation YChromaOffset;
	public VkFilter ChromaFilter;
	public VkBool32 ForceExplicitReconstruction;

	public VkSamplerYcbcrConversionCreateInfoKHR(
		VkFormat format = default,
		VkSamplerYcbcrModelConversion ycbcrModel = default,
		VkSamplerYcbcrRange ycbcrRange = default,
		VkComponentMapping components = default,
		VkChromaLocation xChromaOffset = default,
		VkChromaLocation yChromaOffset = default,
		VkFilter chromaFilter = default,
		VkBool32 forceExplicitReconstruction = default
	) {
		sType = TYPE;
		pNext = null;
		Format = format;
		YcbcrModel = ycbcrModel;
		YcbcrRange = ycbcrRange;
		Components = components;
		XChromaOffset = xChromaOffset;
		YChromaOffset = yChromaOffset;
		ChromaFilter = chromaFilter;
		ForceExplicitReconstruction = forceExplicitReconstruction;
	}

	public readonly override bool Equals(object? o) => (o is VkSamplerYcbcrConversionCreateInfoKHR s) && (this == s);
	readonly bool IEquatable<VkSamplerYcbcrConversionCreateInfoKHR>.Equals(VkSamplerYcbcrConversionCreateInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Format.GetHashCode() ^ YcbcrModel.GetHashCode()
			^ YcbcrRange.GetHashCode() ^ Components.GetHashCode() ^ XChromaOffset.GetHashCode() ^ YChromaOffset.GetHashCode()
			^ ChromaFilter.GetHashCode() ^ ForceExplicitReconstruction.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkSamplerYcbcrConversionCreateInfoKHR l, in VkSamplerYcbcrConversionCreateInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Format == r.Format) && (l.YcbcrModel == r.YcbcrModel)
			&& (l.YcbcrRange == r.YcbcrRange) && (l.Components == r.Components) && (l.XChromaOffset == r.XChromaOffset) && (l.YChromaOffset == r.YChromaOffset)
			&& (l.ChromaFilter == r.ChromaFilter) && (l.ForceExplicitReconstruction == r.ForceExplicitReconstruction)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkSamplerYcbcrConversionCreateInfoKHR l, in VkSamplerYcbcrConversionCreateInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Format != r.Format) || (l.YcbcrModel != r.YcbcrModel)
			|| (l.YcbcrRange != r.YcbcrRange) || (l.Components != r.Components) || (l.XChromaOffset != r.XChromaOffset) || (l.YChromaOffset != r.YChromaOffset)
			|| (l.ChromaFilter != r.ChromaFilter) || (l.ForceExplicitReconstruction != r.ForceExplicitReconstruction)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkSamplerYcbcrConversionCreateInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkBindImagePlaneMemoryInfoKHR : IEquatable<VkBindImagePlaneMemoryInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.BindImagePlaneMemoryInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkImageAspectFlags PlaneAspect;

	public VkBindImagePlaneMemoryInfoKHR(
		VkImageAspectFlags planeAspect = default
	) {
		sType = TYPE;
		pNext = null;
		PlaneAspect = planeAspect;
	}

	public readonly override bool Equals(object? o) => (o is VkBindImagePlaneMemoryInfoKHR s) && (this == s);
	readonly bool IEquatable<VkBindImagePlaneMemoryInfoKHR>.Equals(VkBindImagePlaneMemoryInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ PlaneAspect.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkBindImagePlaneMemoryInfoKHR l, in VkBindImagePlaneMemoryInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.PlaneAspect == r.PlaneAspect)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkBindImagePlaneMemoryInfoKHR l, in VkBindImagePlaneMemoryInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.PlaneAspect != r.PlaneAspect)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkBindImagePlaneMemoryInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkImagePlaneMemoryRequirementsInfoKHR : IEquatable<VkImagePlaneMemoryRequirementsInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.ImagePlaneMemoryRequirementsInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkImageAspectFlags PlaneAspect;

	public VkImagePlaneMemoryRequirementsInfoKHR(
		VkImageAspectFlags planeAspect = default
	) {
		sType = TYPE;
		pNext = null;
		PlaneAspect = planeAspect;
	}

	public readonly override bool Equals(object? o) => (o is VkImagePlaneMemoryRequirementsInfoKHR s) && (this == s);
	readonly bool IEquatable<VkImagePlaneMemoryRequirementsInfoKHR>.Equals(VkImagePlaneMemoryRequirementsInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ PlaneAspect.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkImagePlaneMemoryRequirementsInfoKHR l, in VkImagePlaneMemoryRequirementsInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.PlaneAspect == r.PlaneAspect)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkImagePlaneMemoryRequirementsInfoKHR l, in VkImagePlaneMemoryRequirementsInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.PlaneAspect != r.PlaneAspect)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkImagePlaneMemoryRequirementsInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR : IEquatable<VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceSamplerYcbcrConversionFeatures;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 SamplerYcbcrConversion;

	public VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR(
		VkBool32 samplerYcbcrConversion = default
	) {
		sType = TYPE;
		pNext = null;
		SamplerYcbcrConversion = samplerYcbcrConversion;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR>.Equals(VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SamplerYcbcrConversion.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR l, in VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SamplerYcbcrConversion == r.SamplerYcbcrConversion)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR l, in VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SamplerYcbcrConversion != r.SamplerYcbcrConversion)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkSamplerYcbcrConversionImageFormatPropertiesKHR : IEquatable<VkSamplerYcbcrConversionImageFormatPropertiesKHR>
{
	public const VkStructureType TYPE = VkStructureType.SamplerYcbcrConversionImageFormatProperties;

	public VkStructureType sType;
	public void* pNext;
	public uint CombinedImageSamplerDescriptorCount;

	public VkSamplerYcbcrConversionImageFormatPropertiesKHR(
		uint combinedImageSamplerDescriptorCount = default
	) {
		sType = TYPE;
		pNext = null;
		CombinedImageSamplerDescriptorCount = combinedImageSamplerDescriptorCount;
	}

	public readonly override bool Equals(object? o) => (o is VkSamplerYcbcrConversionImageFormatPropertiesKHR s) && (this == s);
	readonly bool IEquatable<VkSamplerYcbcrConversionImageFormatPropertiesKHR>.Equals(VkSamplerYcbcrConversionImageFormatPropertiesKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ CombinedImageSamplerDescriptorCount.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkSamplerYcbcrConversionImageFormatPropertiesKHR l, in VkSamplerYcbcrConversionImageFormatPropertiesKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.CombinedImageSamplerDescriptorCount == r.CombinedImageSamplerDescriptorCount)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkSamplerYcbcrConversionImageFormatPropertiesKHR l, in VkSamplerYcbcrConversionImageFormatPropertiesKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.CombinedImageSamplerDescriptorCount != r.CombinedImageSamplerDescriptorCount)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkSamplerYcbcrConversionImageFormatPropertiesKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkImageFormatListCreateInfoKHR : IEquatable<VkImageFormatListCreateInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.ImageFormatListCreateInfo;

	public VkStructureType sType;
	public void* pNext;
	public uint ViewFormatCount;
	public VkFormat* ViewFormats;

	public VkImageFormatListCreateInfoKHR(
		uint viewFormatCount = default,
		VkFormat* viewFormats = default
	) {
		sType = TYPE;
		pNext = null;
		ViewFormatCount = viewFormatCount;
		ViewFormats = viewFormats;
	}

	public readonly override bool Equals(object? o) => (o is VkImageFormatListCreateInfoKHR s) && (this == s);
	readonly bool IEquatable<VkImageFormatListCreateInfoKHR>.Equals(VkImageFormatListCreateInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ViewFormatCount.GetHashCode() ^ ((ulong)ViewFormats).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkImageFormatListCreateInfoKHR l, in VkImageFormatListCreateInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ViewFormatCount == r.ViewFormatCount) && (l.ViewFormats == r.ViewFormats)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkImageFormatListCreateInfoKHR l, in VkImageFormatListCreateInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ViewFormatCount != r.ViewFormatCount) || (l.ViewFormats != r.ViewFormats)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkImageFormatListCreateInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceMaintenance3PropertiesKHR : IEquatable<VkPhysicalDeviceMaintenance3PropertiesKHR>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceMaintenance3Properties;

	public VkStructureType sType;
	public void* pNext;
	public uint MaxPerSetDescriptors;
	public ulong MaxMemoryAllocationSize;

	public VkPhysicalDeviceMaintenance3PropertiesKHR(
		uint maxPerSetDescriptors = default,
		ulong maxMemoryAllocationSize = default
	) {
		sType = TYPE;
		pNext = null;
		MaxPerSetDescriptors = maxPerSetDescriptors;
		MaxMemoryAllocationSize = maxMemoryAllocationSize;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceMaintenance3PropertiesKHR s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceMaintenance3PropertiesKHR>.Equals(VkPhysicalDeviceMaintenance3PropertiesKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MaxPerSetDescriptors.GetHashCode() ^ MaxMemoryAllocationSize.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceMaintenance3PropertiesKHR l, in VkPhysicalDeviceMaintenance3PropertiesKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MaxPerSetDescriptors == r.MaxPerSetDescriptors) && (l.MaxMemoryAllocationSize == r.MaxMemoryAllocationSize)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceMaintenance3PropertiesKHR l, in VkPhysicalDeviceMaintenance3PropertiesKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MaxPerSetDescriptors != r.MaxPerSetDescriptors) || (l.MaxMemoryAllocationSize != r.MaxMemoryAllocationSize)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceMaintenance3PropertiesKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDescriptorSetLayoutSupportKHR : IEquatable<VkDescriptorSetLayoutSupportKHR>
{
	public const VkStructureType TYPE = VkStructureType.DescriptorSetLayoutSupport;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 Supported;

	public VkDescriptorSetLayoutSupportKHR(
		VkBool32 supported = default
	) {
		sType = TYPE;
		pNext = null;
		Supported = supported;
	}

	public readonly override bool Equals(object? o) => (o is VkDescriptorSetLayoutSupportKHR s) && (this == s);
	readonly bool IEquatable<VkDescriptorSetLayoutSupportKHR>.Equals(VkDescriptorSetLayoutSupportKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Supported.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDescriptorSetLayoutSupportKHR l, in VkDescriptorSetLayoutSupportKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Supported == r.Supported)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDescriptorSetLayoutSupportKHR l, in VkDescriptorSetLayoutSupportKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Supported != r.Supported)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDescriptorSetLayoutSupportKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceShaderFloat16Int8FeaturesKHR : IEquatable<VkPhysicalDeviceShaderFloat16Int8FeaturesKHR>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceShaderFloat16Int8Features;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 ShaderFloat16;
	public VkBool32 ShaderInt8;

	public VkPhysicalDeviceShaderFloat16Int8FeaturesKHR(
		VkBool32 shaderFloat16 = default,
		VkBool32 shaderInt8 = default
	) {
		sType = TYPE;
		pNext = null;
		ShaderFloat16 = shaderFloat16;
		ShaderInt8 = shaderInt8;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceShaderFloat16Int8FeaturesKHR s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceShaderFloat16Int8FeaturesKHR>.Equals(VkPhysicalDeviceShaderFloat16Int8FeaturesKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ShaderFloat16.GetHashCode() ^ ShaderInt8.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceShaderFloat16Int8FeaturesKHR l, in VkPhysicalDeviceShaderFloat16Int8FeaturesKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ShaderFloat16 == r.ShaderFloat16) && (l.ShaderInt8 == r.ShaderInt8)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceShaderFloat16Int8FeaturesKHR l, in VkPhysicalDeviceShaderFloat16Int8FeaturesKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ShaderFloat16 != r.ShaderFloat16) || (l.ShaderInt8 != r.ShaderInt8)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceShaderFloat16Int8FeaturesKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceFloat16Int8FeaturesKHR : IEquatable<VkPhysicalDeviceFloat16Int8FeaturesKHR>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceShaderFloat16Int8Features;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 ShaderFloat16;
	public VkBool32 ShaderInt8;

	public VkPhysicalDeviceFloat16Int8FeaturesKHR(
		VkBool32 shaderFloat16 = default,
		VkBool32 shaderInt8 = default
	) {
		sType = TYPE;
		pNext = null;
		ShaderFloat16 = shaderFloat16;
		ShaderInt8 = shaderInt8;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceFloat16Int8FeaturesKHR s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceFloat16Int8FeaturesKHR>.Equals(VkPhysicalDeviceFloat16Int8FeaturesKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ShaderFloat16.GetHashCode() ^ ShaderInt8.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceFloat16Int8FeaturesKHR l, in VkPhysicalDeviceFloat16Int8FeaturesKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ShaderFloat16 == r.ShaderFloat16) && (l.ShaderInt8 == r.ShaderInt8)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceFloat16Int8FeaturesKHR l, in VkPhysicalDeviceFloat16Int8FeaturesKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ShaderFloat16 != r.ShaderFloat16) || (l.ShaderInt8 != r.ShaderInt8)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceFloat16Int8FeaturesKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceFloatControlsPropertiesKHR : IEquatable<VkPhysicalDeviceFloatControlsPropertiesKHR>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceFloatControlsProperties;

	public VkStructureType sType;
	public void* pNext;
	public VkShaderFloatControlsIndependence DenormBehaviorIndependence;
	public VkShaderFloatControlsIndependence RoundingModeIndependence;
	public VkBool32 ShaderSignedZeroInfNanPreserveFloat16;
	public VkBool32 ShaderSignedZeroInfNanPreserveFloat32;
	public VkBool32 ShaderSignedZeroInfNanPreserveFloat64;
	public VkBool32 ShaderDenormPreserveFloat16;
	public VkBool32 ShaderDenormPreserveFloat32;
	public VkBool32 ShaderDenormPreserveFloat64;
	public VkBool32 ShaderDenormFlushToZeroFloat16;
	public VkBool32 ShaderDenormFlushToZeroFloat32;
	public VkBool32 ShaderDenormFlushToZeroFloat64;
	public VkBool32 ShaderRoundingModeRTEFloat16;
	public VkBool32 ShaderRoundingModeRTEFloat32;
	public VkBool32 ShaderRoundingModeRTEFloat64;
	public VkBool32 ShaderRoundingModeRTZFloat16;
	public VkBool32 ShaderRoundingModeRTZFloat32;
	public VkBool32 ShaderRoundingModeRTZFloat64;

	public VkPhysicalDeviceFloatControlsPropertiesKHR(
		VkShaderFloatControlsIndependence denormBehaviorIndependence = default,
		VkShaderFloatControlsIndependence roundingModeIndependence = default,
		VkBool32 shaderSignedZeroInfNanPreserveFloat16 = default,
		VkBool32 shaderSignedZeroInfNanPreserveFloat32 = default,
		VkBool32 shaderSignedZeroInfNanPreserveFloat64 = default,
		VkBool32 shaderDenormPreserveFloat16 = default,
		VkBool32 shaderDenormPreserveFloat32 = default,
		VkBool32 shaderDenormPreserveFloat64 = default,
		VkBool32 shaderDenormFlushToZeroFloat16 = default,
		VkBool32 shaderDenormFlushToZeroFloat32 = default,
		VkBool32 shaderDenormFlushToZeroFloat64 = default,
		VkBool32 shaderRoundingModeRTEFloat16 = default,
		VkBool32 shaderRoundingModeRTEFloat32 = default,
		VkBool32 shaderRoundingModeRTEFloat64 = default,
		VkBool32 shaderRoundingModeRTZFloat16 = default,
		VkBool32 shaderRoundingModeRTZFloat32 = default,
		VkBool32 shaderRoundingModeRTZFloat64 = default
	) {
		sType = TYPE;
		pNext = null;
		DenormBehaviorIndependence = denormBehaviorIndependence;
		RoundingModeIndependence = roundingModeIndependence;
		ShaderSignedZeroInfNanPreserveFloat16 = shaderSignedZeroInfNanPreserveFloat16;
		ShaderSignedZeroInfNanPreserveFloat32 = shaderSignedZeroInfNanPreserveFloat32;
		ShaderSignedZeroInfNanPreserveFloat64 = shaderSignedZeroInfNanPreserveFloat64;
		ShaderDenormPreserveFloat16 = shaderDenormPreserveFloat16;
		ShaderDenormPreserveFloat32 = shaderDenormPreserveFloat32;
		ShaderDenormPreserveFloat64 = shaderDenormPreserveFloat64;
		ShaderDenormFlushToZeroFloat16 = shaderDenormFlushToZeroFloat16;
		ShaderDenormFlushToZeroFloat32 = shaderDenormFlushToZeroFloat32;
		ShaderDenormFlushToZeroFloat64 = shaderDenormFlushToZeroFloat64;
		ShaderRoundingModeRTEFloat16 = shaderRoundingModeRTEFloat16;
		ShaderRoundingModeRTEFloat32 = shaderRoundingModeRTEFloat32;
		ShaderRoundingModeRTEFloat64 = shaderRoundingModeRTEFloat64;
		ShaderRoundingModeRTZFloat16 = shaderRoundingModeRTZFloat16;
		ShaderRoundingModeRTZFloat32 = shaderRoundingModeRTZFloat32;
		ShaderRoundingModeRTZFloat64 = shaderRoundingModeRTZFloat64;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceFloatControlsPropertiesKHR s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceFloatControlsPropertiesKHR>.Equals(VkPhysicalDeviceFloatControlsPropertiesKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DenormBehaviorIndependence.GetHashCode() ^ RoundingModeIndependence.GetHashCode()
			^ ShaderSignedZeroInfNanPreserveFloat16.GetHashCode() ^ ShaderSignedZeroInfNanPreserveFloat32.GetHashCode() ^ ShaderSignedZeroInfNanPreserveFloat64.GetHashCode() ^ ShaderDenormPreserveFloat16.GetHashCode()
			^ ShaderDenormPreserveFloat32.GetHashCode() ^ ShaderDenormPreserveFloat64.GetHashCode() ^ ShaderDenormFlushToZeroFloat16.GetHashCode() ^ ShaderDenormFlushToZeroFloat32.GetHashCode()
			^ ShaderDenormFlushToZeroFloat64.GetHashCode() ^ ShaderRoundingModeRTEFloat16.GetHashCode() ^ ShaderRoundingModeRTEFloat32.GetHashCode() ^ ShaderRoundingModeRTEFloat64.GetHashCode()
			^ ShaderRoundingModeRTZFloat16.GetHashCode() ^ ShaderRoundingModeRTZFloat32.GetHashCode() ^ ShaderRoundingModeRTZFloat64.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceFloatControlsPropertiesKHR l, in VkPhysicalDeviceFloatControlsPropertiesKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DenormBehaviorIndependence == r.DenormBehaviorIndependence) && (l.RoundingModeIndependence == r.RoundingModeIndependence)
			&& (l.ShaderSignedZeroInfNanPreserveFloat16 == r.ShaderSignedZeroInfNanPreserveFloat16) && (l.ShaderSignedZeroInfNanPreserveFloat32 == r.ShaderSignedZeroInfNanPreserveFloat32) && (l.ShaderSignedZeroInfNanPreserveFloat64 == r.ShaderSignedZeroInfNanPreserveFloat64) && (l.ShaderDenormPreserveFloat16 == r.ShaderDenormPreserveFloat16)
			&& (l.ShaderDenormPreserveFloat32 == r.ShaderDenormPreserveFloat32) && (l.ShaderDenormPreserveFloat64 == r.ShaderDenormPreserveFloat64) && (l.ShaderDenormFlushToZeroFloat16 == r.ShaderDenormFlushToZeroFloat16) && (l.ShaderDenormFlushToZeroFloat32 == r.ShaderDenormFlushToZeroFloat32)
			&& (l.ShaderDenormFlushToZeroFloat64 == r.ShaderDenormFlushToZeroFloat64) && (l.ShaderRoundingModeRTEFloat16 == r.ShaderRoundingModeRTEFloat16) && (l.ShaderRoundingModeRTEFloat32 == r.ShaderRoundingModeRTEFloat32) && (l.ShaderRoundingModeRTEFloat64 == r.ShaderRoundingModeRTEFloat64)
			&& (l.ShaderRoundingModeRTZFloat16 == r.ShaderRoundingModeRTZFloat16) && (l.ShaderRoundingModeRTZFloat32 == r.ShaderRoundingModeRTZFloat32) && (l.ShaderRoundingModeRTZFloat64 == r.ShaderRoundingModeRTZFloat64)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceFloatControlsPropertiesKHR l, in VkPhysicalDeviceFloatControlsPropertiesKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DenormBehaviorIndependence != r.DenormBehaviorIndependence) || (l.RoundingModeIndependence != r.RoundingModeIndependence)
			|| (l.ShaderSignedZeroInfNanPreserveFloat16 != r.ShaderSignedZeroInfNanPreserveFloat16) || (l.ShaderSignedZeroInfNanPreserveFloat32 != r.ShaderSignedZeroInfNanPreserveFloat32) || (l.ShaderSignedZeroInfNanPreserveFloat64 != r.ShaderSignedZeroInfNanPreserveFloat64) || (l.ShaderDenormPreserveFloat16 != r.ShaderDenormPreserveFloat16)
			|| (l.ShaderDenormPreserveFloat32 != r.ShaderDenormPreserveFloat32) || (l.ShaderDenormPreserveFloat64 != r.ShaderDenormPreserveFloat64) || (l.ShaderDenormFlushToZeroFloat16 != r.ShaderDenormFlushToZeroFloat16) || (l.ShaderDenormFlushToZeroFloat32 != r.ShaderDenormFlushToZeroFloat32)
			|| (l.ShaderDenormFlushToZeroFloat64 != r.ShaderDenormFlushToZeroFloat64) || (l.ShaderRoundingModeRTEFloat16 != r.ShaderRoundingModeRTEFloat16) || (l.ShaderRoundingModeRTEFloat32 != r.ShaderRoundingModeRTEFloat32) || (l.ShaderRoundingModeRTEFloat64 != r.ShaderRoundingModeRTEFloat64)
			|| (l.ShaderRoundingModeRTZFloat16 != r.ShaderRoundingModeRTZFloat16) || (l.ShaderRoundingModeRTZFloat32 != r.ShaderRoundingModeRTZFloat32) || (l.ShaderRoundingModeRTZFloat64 != r.ShaderRoundingModeRTZFloat64)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceFloatControlsPropertiesKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkAttachmentDescription2KHR : IEquatable<VkAttachmentDescription2KHR>
{
	public const VkStructureType TYPE = VkStructureType.AttachmentDescription2;

	public VkStructureType sType;
	public void* pNext;
	public VkAttachmentDescriptionFlags Flags;
	public VkFormat Format;
	public VkSampleCountFlags Samples;
	public VkAttachmentLoadOp LoadOp;
	public VkAttachmentStoreOp StoreOp;
	public VkAttachmentLoadOp StencilLoadOp;
	public VkAttachmentStoreOp StencilStoreOp;
	public VkImageLayout InitialLayout;
	public VkImageLayout FinalLayout;

	public VkAttachmentDescription2KHR(
		VkAttachmentDescriptionFlags flags = default,
		VkFormat format = default,
		VkSampleCountFlags samples = default,
		VkAttachmentLoadOp loadOp = default,
		VkAttachmentStoreOp storeOp = default,
		VkAttachmentLoadOp stencilLoadOp = default,
		VkAttachmentStoreOp stencilStoreOp = default,
		VkImageLayout initialLayout = default,
		VkImageLayout finalLayout = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		Format = format;
		Samples = samples;
		LoadOp = loadOp;
		StoreOp = storeOp;
		StencilLoadOp = stencilLoadOp;
		StencilStoreOp = stencilStoreOp;
		InitialLayout = initialLayout;
		FinalLayout = finalLayout;
	}

	public readonly override bool Equals(object? o) => (o is VkAttachmentDescription2KHR s) && (this == s);
	readonly bool IEquatable<VkAttachmentDescription2KHR>.Equals(VkAttachmentDescription2KHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ Format.GetHashCode()
			^ Samples.GetHashCode() ^ LoadOp.GetHashCode() ^ StoreOp.GetHashCode() ^ StencilLoadOp.GetHashCode()
			^ StencilStoreOp.GetHashCode() ^ InitialLayout.GetHashCode() ^ FinalLayout.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkAttachmentDescription2KHR l, in VkAttachmentDescription2KHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.Format == r.Format)
			&& (l.Samples == r.Samples) && (l.LoadOp == r.LoadOp) && (l.StoreOp == r.StoreOp) && (l.StencilLoadOp == r.StencilLoadOp)
			&& (l.StencilStoreOp == r.StencilStoreOp) && (l.InitialLayout == r.InitialLayout) && (l.FinalLayout == r.FinalLayout)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkAttachmentDescription2KHR l, in VkAttachmentDescription2KHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.Format != r.Format)
			|| (l.Samples != r.Samples) || (l.LoadOp != r.LoadOp) || (l.StoreOp != r.StoreOp) || (l.StencilLoadOp != r.StencilLoadOp)
			|| (l.StencilStoreOp != r.StencilStoreOp) || (l.InitialLayout != r.InitialLayout) || (l.FinalLayout != r.FinalLayout)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkAttachmentDescription2KHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkAttachmentReference2KHR : IEquatable<VkAttachmentReference2KHR>
{
	public const VkStructureType TYPE = VkStructureType.AttachmentReference2;

	public VkStructureType sType;
	public void* pNext;
	public uint Attachment;
	public VkImageLayout Layout;
	public VkImageAspectFlags AspectMask;

	public VkAttachmentReference2KHR(
		uint attachment = default,
		VkImageLayout layout = default,
		VkImageAspectFlags aspectMask = default
	) {
		sType = TYPE;
		pNext = null;
		Attachment = attachment;
		Layout = layout;
		AspectMask = aspectMask;
	}

	public readonly override bool Equals(object? o) => (o is VkAttachmentReference2KHR s) && (this == s);
	readonly bool IEquatable<VkAttachmentReference2KHR>.Equals(VkAttachmentReference2KHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Attachment.GetHashCode() ^ Layout.GetHashCode()
			^ AspectMask.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkAttachmentReference2KHR l, in VkAttachmentReference2KHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Attachment == r.Attachment) && (l.Layout == r.Layout)
			&& (l.AspectMask == r.AspectMask)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkAttachmentReference2KHR l, in VkAttachmentReference2KHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Attachment != r.Attachment) || (l.Layout != r.Layout)
			|| (l.AspectMask != r.AspectMask)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkAttachmentReference2KHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkSubpassDescription2KHR : IEquatable<VkSubpassDescription2KHR>
{
	public const VkStructureType TYPE = VkStructureType.SubpassDescription2;

	public VkStructureType sType;
	public void* pNext;
	public VkSubpassDescriptionFlags Flags;
	public VkPipelineBindPoint PipelineBindPoint;
	public uint ViewMask;
	public uint InputAttachmentCount;
	public VkAttachmentReference2* InputAttachments;
	public uint ColorAttachmentCount;
	public VkAttachmentReference2* ColorAttachments;
	public VkAttachmentReference2* ResolveAttachments;
	public VkAttachmentReference2* DepthStencilAttachment;
	public uint PreserveAttachmentCount;
	public uint* PreserveAttachments;

	public VkSubpassDescription2KHR(
		VkSubpassDescriptionFlags flags = default,
		VkPipelineBindPoint pipelineBindPoint = default,
		uint viewMask = default,
		uint inputAttachmentCount = default,
		VkAttachmentReference2* inputAttachments = default,
		uint colorAttachmentCount = default,
		VkAttachmentReference2* colorAttachments = default,
		VkAttachmentReference2* resolveAttachments = default,
		VkAttachmentReference2* depthStencilAttachment = default,
		uint preserveAttachmentCount = default,
		uint* preserveAttachments = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		PipelineBindPoint = pipelineBindPoint;
		ViewMask = viewMask;
		InputAttachmentCount = inputAttachmentCount;
		InputAttachments = inputAttachments;
		ColorAttachmentCount = colorAttachmentCount;
		ColorAttachments = colorAttachments;
		ResolveAttachments = resolveAttachments;
		DepthStencilAttachment = depthStencilAttachment;
		PreserveAttachmentCount = preserveAttachmentCount;
		PreserveAttachments = preserveAttachments;
	}

	public readonly override bool Equals(object? o) => (o is VkSubpassDescription2KHR s) && (this == s);
	readonly bool IEquatable<VkSubpassDescription2KHR>.Equals(VkSubpassDescription2KHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ PipelineBindPoint.GetHashCode()
			^ ViewMask.GetHashCode() ^ InputAttachmentCount.GetHashCode() ^ ((ulong)InputAttachments).GetHashCode() ^ ColorAttachmentCount.GetHashCode()
			^ ((ulong)ColorAttachments).GetHashCode() ^ ((ulong)ResolveAttachments).GetHashCode() ^ ((ulong)DepthStencilAttachment).GetHashCode() ^ PreserveAttachmentCount.GetHashCode()
			^ ((ulong)PreserveAttachments).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkSubpassDescription2KHR l, in VkSubpassDescription2KHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.PipelineBindPoint == r.PipelineBindPoint)
			&& (l.ViewMask == r.ViewMask) && (l.InputAttachmentCount == r.InputAttachmentCount) && (l.InputAttachments == r.InputAttachments) && (l.ColorAttachmentCount == r.ColorAttachmentCount)
			&& (l.ColorAttachments == r.ColorAttachments) && (l.ResolveAttachments == r.ResolveAttachments) && (l.DepthStencilAttachment == r.DepthStencilAttachment) && (l.PreserveAttachmentCount == r.PreserveAttachmentCount)
			&& (l.PreserveAttachments == r.PreserveAttachments)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkSubpassDescription2KHR l, in VkSubpassDescription2KHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.PipelineBindPoint != r.PipelineBindPoint)
			|| (l.ViewMask != r.ViewMask) || (l.InputAttachmentCount != r.InputAttachmentCount) || (l.InputAttachments != r.InputAttachments) || (l.ColorAttachmentCount != r.ColorAttachmentCount)
			|| (l.ColorAttachments != r.ColorAttachments) || (l.ResolveAttachments != r.ResolveAttachments) || (l.DepthStencilAttachment != r.DepthStencilAttachment) || (l.PreserveAttachmentCount != r.PreserveAttachmentCount)
			|| (l.PreserveAttachments != r.PreserveAttachments)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkSubpassDescription2KHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkSubpassDependency2KHR : IEquatable<VkSubpassDependency2KHR>
{
	public const VkStructureType TYPE = VkStructureType.SubpassDependency2;

	public VkStructureType sType;
	public void* pNext;
	public uint SrcSubpass;
	public uint DstSubpass;
	public VkPipelineStageFlags SrcStageMask;
	public VkPipelineStageFlags DstStageMask;
	public VkAccessFlags SrcAccessMask;
	public VkAccessFlags DstAccessMask;
	public VkDependencyFlags DependencyFlags;
	public int ViewOffset;

	public VkSubpassDependency2KHR(
		uint srcSubpass = default,
		uint dstSubpass = default,
		VkPipelineStageFlags srcStageMask = default,
		VkPipelineStageFlags dstStageMask = default,
		VkAccessFlags srcAccessMask = default,
		VkAccessFlags dstAccessMask = default,
		VkDependencyFlags dependencyFlags = default,
		int viewOffset = default
	) {
		sType = TYPE;
		pNext = null;
		SrcSubpass = srcSubpass;
		DstSubpass = dstSubpass;
		SrcStageMask = srcStageMask;
		DstStageMask = dstStageMask;
		SrcAccessMask = srcAccessMask;
		DstAccessMask = dstAccessMask;
		DependencyFlags = dependencyFlags;
		ViewOffset = viewOffset;
	}

	public readonly override bool Equals(object? o) => (o is VkSubpassDependency2KHR s) && (this == s);
	readonly bool IEquatable<VkSubpassDependency2KHR>.Equals(VkSubpassDependency2KHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SrcSubpass.GetHashCode() ^ DstSubpass.GetHashCode()
			^ SrcStageMask.GetHashCode() ^ DstStageMask.GetHashCode() ^ SrcAccessMask.GetHashCode() ^ DstAccessMask.GetHashCode()
			^ DependencyFlags.GetHashCode() ^ ViewOffset.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkSubpassDependency2KHR l, in VkSubpassDependency2KHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SrcSubpass == r.SrcSubpass) && (l.DstSubpass == r.DstSubpass)
			&& (l.SrcStageMask == r.SrcStageMask) && (l.DstStageMask == r.DstStageMask) && (l.SrcAccessMask == r.SrcAccessMask) && (l.DstAccessMask == r.DstAccessMask)
			&& (l.DependencyFlags == r.DependencyFlags) && (l.ViewOffset == r.ViewOffset)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkSubpassDependency2KHR l, in VkSubpassDependency2KHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SrcSubpass != r.SrcSubpass) || (l.DstSubpass != r.DstSubpass)
			|| (l.SrcStageMask != r.SrcStageMask) || (l.DstStageMask != r.DstStageMask) || (l.SrcAccessMask != r.SrcAccessMask) || (l.DstAccessMask != r.DstAccessMask)
			|| (l.DependencyFlags != r.DependencyFlags) || (l.ViewOffset != r.ViewOffset)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkSubpassDependency2KHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkRenderPassCreateInfo2KHR : IEquatable<VkRenderPassCreateInfo2KHR>
{
	public const VkStructureType TYPE = VkStructureType.RenderPassCreateInfo2;

	public VkStructureType sType;
	public void* pNext;
	public VkRenderPassCreateFlags Flags;
	public uint AttachmentCount;
	public VkAttachmentDescription2* Attachments;
	public uint SubpassCount;
	public VkSubpassDescription2* Subpasses;
	public uint DependencyCount;
	public VkSubpassDependency2* Dependencies;
	public uint CorrelatedViewMaskCount;
	public uint* CorrelatedViewMasks;

	public VkRenderPassCreateInfo2KHR(
		VkRenderPassCreateFlags flags = default,
		uint attachmentCount = default,
		VkAttachmentDescription2* attachments = default,
		uint subpassCount = default,
		VkSubpassDescription2* subpasses = default,
		uint dependencyCount = default,
		VkSubpassDependency2* dependencies = default,
		uint correlatedViewMaskCount = default,
		uint* correlatedViewMasks = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		AttachmentCount = attachmentCount;
		Attachments = attachments;
		SubpassCount = subpassCount;
		Subpasses = subpasses;
		DependencyCount = dependencyCount;
		Dependencies = dependencies;
		CorrelatedViewMaskCount = correlatedViewMaskCount;
		CorrelatedViewMasks = correlatedViewMasks;
	}

	public readonly override bool Equals(object? o) => (o is VkRenderPassCreateInfo2KHR s) && (this == s);
	readonly bool IEquatable<VkRenderPassCreateInfo2KHR>.Equals(VkRenderPassCreateInfo2KHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ AttachmentCount.GetHashCode()
			^ ((ulong)Attachments).GetHashCode() ^ SubpassCount.GetHashCode() ^ ((ulong)Subpasses).GetHashCode() ^ DependencyCount.GetHashCode()
			^ ((ulong)Dependencies).GetHashCode() ^ CorrelatedViewMaskCount.GetHashCode() ^ ((ulong)CorrelatedViewMasks).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkRenderPassCreateInfo2KHR l, in VkRenderPassCreateInfo2KHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.AttachmentCount == r.AttachmentCount)
			&& (l.Attachments == r.Attachments) && (l.SubpassCount == r.SubpassCount) && (l.Subpasses == r.Subpasses) && (l.DependencyCount == r.DependencyCount)
			&& (l.Dependencies == r.Dependencies) && (l.CorrelatedViewMaskCount == r.CorrelatedViewMaskCount) && (l.CorrelatedViewMasks == r.CorrelatedViewMasks)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkRenderPassCreateInfo2KHR l, in VkRenderPassCreateInfo2KHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.AttachmentCount != r.AttachmentCount)
			|| (l.Attachments != r.Attachments) || (l.SubpassCount != r.SubpassCount) || (l.Subpasses != r.Subpasses) || (l.DependencyCount != r.DependencyCount)
			|| (l.Dependencies != r.Dependencies) || (l.CorrelatedViewMaskCount != r.CorrelatedViewMaskCount) || (l.CorrelatedViewMasks != r.CorrelatedViewMasks)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkRenderPassCreateInfo2KHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkSubpassBeginInfoKHR : IEquatable<VkSubpassBeginInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.SubpassBeginInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkSubpassContents Contents;

	public VkSubpassBeginInfoKHR(
		VkSubpassContents contents = default
	) {
		sType = TYPE;
		pNext = null;
		Contents = contents;
	}

	public readonly override bool Equals(object? o) => (o is VkSubpassBeginInfoKHR s) && (this == s);
	readonly bool IEquatable<VkSubpassBeginInfoKHR>.Equals(VkSubpassBeginInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Contents.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkSubpassBeginInfoKHR l, in VkSubpassBeginInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Contents == r.Contents)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkSubpassBeginInfoKHR l, in VkSubpassBeginInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Contents != r.Contents)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkSubpassBeginInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkSubpassEndInfoKHR : IEquatable<VkSubpassEndInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.SubpassEndInfo;

	public VkStructureType sType;
	public void* pNext;

	public readonly override bool Equals(object? o) => (o is VkSubpassEndInfoKHR s) && (this == s);
	readonly bool IEquatable<VkSubpassEndInfoKHR>.Equals(VkSubpassEndInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkSubpassEndInfoKHR l, in VkSubpassEndInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkSubpassEndInfoKHR l, in VkSubpassEndInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkSubpassEndInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceTimelineSemaphoreFeaturesKHR : IEquatable<VkPhysicalDeviceTimelineSemaphoreFeaturesKHR>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceTimelineSemaphoreFeatures;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 TimelineSemaphore;

	public VkPhysicalDeviceTimelineSemaphoreFeaturesKHR(
		VkBool32 timelineSemaphore = default
	) {
		sType = TYPE;
		pNext = null;
		TimelineSemaphore = timelineSemaphore;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceTimelineSemaphoreFeaturesKHR s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceTimelineSemaphoreFeaturesKHR>.Equals(VkPhysicalDeviceTimelineSemaphoreFeaturesKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ TimelineSemaphore.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceTimelineSemaphoreFeaturesKHR l, in VkPhysicalDeviceTimelineSemaphoreFeaturesKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.TimelineSemaphore == r.TimelineSemaphore)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceTimelineSemaphoreFeaturesKHR l, in VkPhysicalDeviceTimelineSemaphoreFeaturesKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.TimelineSemaphore != r.TimelineSemaphore)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceTimelineSemaphoreFeaturesKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceTimelineSemaphorePropertiesKHR : IEquatable<VkPhysicalDeviceTimelineSemaphorePropertiesKHR>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceTimelineSemaphoreProperties;

	public VkStructureType sType;
	public void* pNext;
	public ulong MaxTimelineSemaphoreValueDifference;

	public VkPhysicalDeviceTimelineSemaphorePropertiesKHR(
		ulong maxTimelineSemaphoreValueDifference = default
	) {
		sType = TYPE;
		pNext = null;
		MaxTimelineSemaphoreValueDifference = maxTimelineSemaphoreValueDifference;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceTimelineSemaphorePropertiesKHR s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceTimelineSemaphorePropertiesKHR>.Equals(VkPhysicalDeviceTimelineSemaphorePropertiesKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MaxTimelineSemaphoreValueDifference.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceTimelineSemaphorePropertiesKHR l, in VkPhysicalDeviceTimelineSemaphorePropertiesKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MaxTimelineSemaphoreValueDifference == r.MaxTimelineSemaphoreValueDifference)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceTimelineSemaphorePropertiesKHR l, in VkPhysicalDeviceTimelineSemaphorePropertiesKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MaxTimelineSemaphoreValueDifference != r.MaxTimelineSemaphoreValueDifference)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceTimelineSemaphorePropertiesKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkSemaphoreTypeCreateInfoKHR : IEquatable<VkSemaphoreTypeCreateInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.SemaphoreTypeCreateInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkSemaphoreType SemaphoreType;
	public ulong InitialValue;

	public VkSemaphoreTypeCreateInfoKHR(
		VkSemaphoreType semaphoreType = default,
		ulong initialValue = default
	) {
		sType = TYPE;
		pNext = null;
		SemaphoreType = semaphoreType;
		InitialValue = initialValue;
	}

	public readonly override bool Equals(object? o) => (o is VkSemaphoreTypeCreateInfoKHR s) && (this == s);
	readonly bool IEquatable<VkSemaphoreTypeCreateInfoKHR>.Equals(VkSemaphoreTypeCreateInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SemaphoreType.GetHashCode() ^ InitialValue.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkSemaphoreTypeCreateInfoKHR l, in VkSemaphoreTypeCreateInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SemaphoreType == r.SemaphoreType) && (l.InitialValue == r.InitialValue)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkSemaphoreTypeCreateInfoKHR l, in VkSemaphoreTypeCreateInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SemaphoreType != r.SemaphoreType) || (l.InitialValue != r.InitialValue)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkSemaphoreTypeCreateInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkTimelineSemaphoreSubmitInfoKHR : IEquatable<VkTimelineSemaphoreSubmitInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.TimelineSemaphoreSubmitInfo;

	public VkStructureType sType;
	public void* pNext;
	public uint WaitSemaphoreValueCount;
	public ulong* WaitSemaphoreValues;
	public uint SignalSemaphoreValueCount;
	public ulong* SignalSemaphoreValues;

	public VkTimelineSemaphoreSubmitInfoKHR(
		uint waitSemaphoreValueCount = default,
		ulong* waitSemaphoreValues = default,
		uint signalSemaphoreValueCount = default,
		ulong* signalSemaphoreValues = default
	) {
		sType = TYPE;
		pNext = null;
		WaitSemaphoreValueCount = waitSemaphoreValueCount;
		WaitSemaphoreValues = waitSemaphoreValues;
		SignalSemaphoreValueCount = signalSemaphoreValueCount;
		SignalSemaphoreValues = signalSemaphoreValues;
	}

	public readonly override bool Equals(object? o) => (o is VkTimelineSemaphoreSubmitInfoKHR s) && (this == s);
	readonly bool IEquatable<VkTimelineSemaphoreSubmitInfoKHR>.Equals(VkTimelineSemaphoreSubmitInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ WaitSemaphoreValueCount.GetHashCode() ^ ((ulong)WaitSemaphoreValues).GetHashCode()
			^ SignalSemaphoreValueCount.GetHashCode() ^ ((ulong)SignalSemaphoreValues).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkTimelineSemaphoreSubmitInfoKHR l, in VkTimelineSemaphoreSubmitInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.WaitSemaphoreValueCount == r.WaitSemaphoreValueCount) && (l.WaitSemaphoreValues == r.WaitSemaphoreValues)
			&& (l.SignalSemaphoreValueCount == r.SignalSemaphoreValueCount) && (l.SignalSemaphoreValues == r.SignalSemaphoreValues)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkTimelineSemaphoreSubmitInfoKHR l, in VkTimelineSemaphoreSubmitInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.WaitSemaphoreValueCount != r.WaitSemaphoreValueCount) || (l.WaitSemaphoreValues != r.WaitSemaphoreValues)
			|| (l.SignalSemaphoreValueCount != r.SignalSemaphoreValueCount) || (l.SignalSemaphoreValues != r.SignalSemaphoreValues)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkTimelineSemaphoreSubmitInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkSemaphoreWaitInfoKHR : IEquatable<VkSemaphoreWaitInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.SemaphoreWaitInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkSemaphoreWaitFlags Flags;
	public uint SemaphoreCount;
	public VulkanHandle<VkSemaphore>* Semaphores;
	public ulong* Values;

	public VkSemaphoreWaitInfoKHR(
		VkSemaphoreWaitFlags flags = default,
		uint semaphoreCount = default,
		VulkanHandle<VkSemaphore>* semaphores = default,
		ulong* values = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		SemaphoreCount = semaphoreCount;
		Semaphores = semaphores;
		Values = values;
	}

	public readonly override bool Equals(object? o) => (o is VkSemaphoreWaitInfoKHR s) && (this == s);
	readonly bool IEquatable<VkSemaphoreWaitInfoKHR>.Equals(VkSemaphoreWaitInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ SemaphoreCount.GetHashCode()
			^ ((ulong)Semaphores).GetHashCode() ^ ((ulong)Values).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkSemaphoreWaitInfoKHR l, in VkSemaphoreWaitInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.SemaphoreCount == r.SemaphoreCount)
			&& (l.Semaphores == r.Semaphores) && (l.Values == r.Values)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkSemaphoreWaitInfoKHR l, in VkSemaphoreWaitInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.SemaphoreCount != r.SemaphoreCount)
			|| (l.Semaphores != r.Semaphores) || (l.Values != r.Values)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkSemaphoreWaitInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkSemaphoreSignalInfoKHR : IEquatable<VkSemaphoreSignalInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.SemaphoreSignalInfo;

	public VkStructureType sType;
	public void* pNext;
	public VulkanHandle<VkSemaphore> Semaphore;
	public ulong Value;

	public VkSemaphoreSignalInfoKHR(
		VulkanHandle<VkSemaphore> semaphore = default,
		ulong value = default
	) {
		sType = TYPE;
		pNext = null;
		Semaphore = semaphore;
		Value = value;
	}

	public readonly override bool Equals(object? o) => (o is VkSemaphoreSignalInfoKHR s) && (this == s);
	readonly bool IEquatable<VkSemaphoreSignalInfoKHR>.Equals(VkSemaphoreSignalInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Semaphore.GetHashCode() ^ Value.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkSemaphoreSignalInfoKHR l, in VkSemaphoreSignalInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Semaphore == r.Semaphore) && (l.Value == r.Value)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkSemaphoreSignalInfoKHR l, in VkSemaphoreSignalInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Semaphore != r.Semaphore) || (l.Value != r.Value)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkSemaphoreSignalInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDevice8BitStorageFeaturesKHR : IEquatable<VkPhysicalDevice8BitStorageFeaturesKHR>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDevice8BitStorageFeatures;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 StorageBuffer8BitAccess;
	public VkBool32 UniformAndStorageBuffer8BitAccess;
	public VkBool32 StoragePushConstant8;

	public VkPhysicalDevice8BitStorageFeaturesKHR(
		VkBool32 storageBuffer8BitAccess = default,
		VkBool32 uniformAndStorageBuffer8BitAccess = default,
		VkBool32 storagePushConstant8 = default
	) {
		sType = TYPE;
		pNext = null;
		StorageBuffer8BitAccess = storageBuffer8BitAccess;
		UniformAndStorageBuffer8BitAccess = uniformAndStorageBuffer8BitAccess;
		StoragePushConstant8 = storagePushConstant8;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDevice8BitStorageFeaturesKHR s) && (this == s);
	readonly bool IEquatable<VkPhysicalDevice8BitStorageFeaturesKHR>.Equals(VkPhysicalDevice8BitStorageFeaturesKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ StorageBuffer8BitAccess.GetHashCode() ^ UniformAndStorageBuffer8BitAccess.GetHashCode()
			^ StoragePushConstant8.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDevice8BitStorageFeaturesKHR l, in VkPhysicalDevice8BitStorageFeaturesKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.StorageBuffer8BitAccess == r.StorageBuffer8BitAccess) && (l.UniformAndStorageBuffer8BitAccess == r.UniformAndStorageBuffer8BitAccess)
			&& (l.StoragePushConstant8 == r.StoragePushConstant8)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDevice8BitStorageFeaturesKHR l, in VkPhysicalDevice8BitStorageFeaturesKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.StorageBuffer8BitAccess != r.StorageBuffer8BitAccess) || (l.UniformAndStorageBuffer8BitAccess != r.UniformAndStorageBuffer8BitAccess)
			|| (l.StoragePushConstant8 != r.StoragePushConstant8)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDevice8BitStorageFeaturesKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceVulkanMemoryModelFeaturesKHR : IEquatable<VkPhysicalDeviceVulkanMemoryModelFeaturesKHR>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceVulkanMemoryModelFeatures;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 VulkanMemoryModel;
	public VkBool32 VulkanMemoryModelDeviceScope;
	public VkBool32 VulkanMemoryModelAvailabilityVisibilityChains;

	public VkPhysicalDeviceVulkanMemoryModelFeaturesKHR(
		VkBool32 vulkanMemoryModel = default,
		VkBool32 vulkanMemoryModelDeviceScope = default,
		VkBool32 vulkanMemoryModelAvailabilityVisibilityChains = default
	) {
		sType = TYPE;
		pNext = null;
		VulkanMemoryModel = vulkanMemoryModel;
		VulkanMemoryModelDeviceScope = vulkanMemoryModelDeviceScope;
		VulkanMemoryModelAvailabilityVisibilityChains = vulkanMemoryModelAvailabilityVisibilityChains;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceVulkanMemoryModelFeaturesKHR s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceVulkanMemoryModelFeaturesKHR>.Equals(VkPhysicalDeviceVulkanMemoryModelFeaturesKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ VulkanMemoryModel.GetHashCode() ^ VulkanMemoryModelDeviceScope.GetHashCode()
			^ VulkanMemoryModelAvailabilityVisibilityChains.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceVulkanMemoryModelFeaturesKHR l, in VkPhysicalDeviceVulkanMemoryModelFeaturesKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.VulkanMemoryModel == r.VulkanMemoryModel) && (l.VulkanMemoryModelDeviceScope == r.VulkanMemoryModelDeviceScope)
			&& (l.VulkanMemoryModelAvailabilityVisibilityChains == r.VulkanMemoryModelAvailabilityVisibilityChains)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceVulkanMemoryModelFeaturesKHR l, in VkPhysicalDeviceVulkanMemoryModelFeaturesKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.VulkanMemoryModel != r.VulkanMemoryModel) || (l.VulkanMemoryModelDeviceScope != r.VulkanMemoryModelDeviceScope)
			|| (l.VulkanMemoryModelAvailabilityVisibilityChains != r.VulkanMemoryModelAvailabilityVisibilityChains)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceVulkanMemoryModelFeaturesKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceShaderAtomicInt64FeaturesKHR : IEquatable<VkPhysicalDeviceShaderAtomicInt64FeaturesKHR>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceShaderAtomicInt64Features;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 ShaderBufferInt64Atomics;
	public VkBool32 ShaderSharedInt64Atomics;

	public VkPhysicalDeviceShaderAtomicInt64FeaturesKHR(
		VkBool32 shaderBufferInt64Atomics = default,
		VkBool32 shaderSharedInt64Atomics = default
	) {
		sType = TYPE;
		pNext = null;
		ShaderBufferInt64Atomics = shaderBufferInt64Atomics;
		ShaderSharedInt64Atomics = shaderSharedInt64Atomics;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceShaderAtomicInt64FeaturesKHR s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceShaderAtomicInt64FeaturesKHR>.Equals(VkPhysicalDeviceShaderAtomicInt64FeaturesKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ShaderBufferInt64Atomics.GetHashCode() ^ ShaderSharedInt64Atomics.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceShaderAtomicInt64FeaturesKHR l, in VkPhysicalDeviceShaderAtomicInt64FeaturesKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ShaderBufferInt64Atomics == r.ShaderBufferInt64Atomics) && (l.ShaderSharedInt64Atomics == r.ShaderSharedInt64Atomics)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceShaderAtomicInt64FeaturesKHR l, in VkPhysicalDeviceShaderAtomicInt64FeaturesKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ShaderBufferInt64Atomics != r.ShaderBufferInt64Atomics) || (l.ShaderSharedInt64Atomics != r.ShaderSharedInt64Atomics)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceShaderAtomicInt64FeaturesKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceDepthStencilResolvePropertiesKHR : IEquatable<VkPhysicalDeviceDepthStencilResolvePropertiesKHR>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceDepthStencilResolveProperties;

	public VkStructureType sType;
	public void* pNext;
	public VkResolveModeFlags SupportedDepthResolveModes;
	public VkResolveModeFlags SupportedStencilResolveModes;
	public VkBool32 IndependentResolveNone;
	public VkBool32 IndependentResolve;

	public VkPhysicalDeviceDepthStencilResolvePropertiesKHR(
		VkResolveModeFlags supportedDepthResolveModes = default,
		VkResolveModeFlags supportedStencilResolveModes = default,
		VkBool32 independentResolveNone = default,
		VkBool32 independentResolve = default
	) {
		sType = TYPE;
		pNext = null;
		SupportedDepthResolveModes = supportedDepthResolveModes;
		SupportedStencilResolveModes = supportedStencilResolveModes;
		IndependentResolveNone = independentResolveNone;
		IndependentResolve = independentResolve;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceDepthStencilResolvePropertiesKHR s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceDepthStencilResolvePropertiesKHR>.Equals(VkPhysicalDeviceDepthStencilResolvePropertiesKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SupportedDepthResolveModes.GetHashCode() ^ SupportedStencilResolveModes.GetHashCode()
			^ IndependentResolveNone.GetHashCode() ^ IndependentResolve.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceDepthStencilResolvePropertiesKHR l, in VkPhysicalDeviceDepthStencilResolvePropertiesKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SupportedDepthResolveModes == r.SupportedDepthResolveModes) && (l.SupportedStencilResolveModes == r.SupportedStencilResolveModes)
			&& (l.IndependentResolveNone == r.IndependentResolveNone) && (l.IndependentResolve == r.IndependentResolve)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceDepthStencilResolvePropertiesKHR l, in VkPhysicalDeviceDepthStencilResolvePropertiesKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SupportedDepthResolveModes != r.SupportedDepthResolveModes) || (l.SupportedStencilResolveModes != r.SupportedStencilResolveModes)
			|| (l.IndependentResolveNone != r.IndependentResolveNone) || (l.IndependentResolve != r.IndependentResolve)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceDepthStencilResolvePropertiesKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkSubpassDescriptionDepthStencilResolveKHR : IEquatable<VkSubpassDescriptionDepthStencilResolveKHR>
{
	public const VkStructureType TYPE = VkStructureType.SubpassDescriptionDepthStencilResolve;

	public VkStructureType sType;
	public void* pNext;
	public VkResolveModeFlags DepthResolveMode;
	public VkResolveModeFlags StencilResolveMode;
	public VkAttachmentReference2* DepthStencilResolveAttachment;

	public VkSubpassDescriptionDepthStencilResolveKHR(
		VkResolveModeFlags depthResolveMode = default,
		VkResolveModeFlags stencilResolveMode = default,
		VkAttachmentReference2* depthStencilResolveAttachment = default
	) {
		sType = TYPE;
		pNext = null;
		DepthResolveMode = depthResolveMode;
		StencilResolveMode = stencilResolveMode;
		DepthStencilResolveAttachment = depthStencilResolveAttachment;
	}

	public readonly override bool Equals(object? o) => (o is VkSubpassDescriptionDepthStencilResolveKHR s) && (this == s);
	readonly bool IEquatable<VkSubpassDescriptionDepthStencilResolveKHR>.Equals(VkSubpassDescriptionDepthStencilResolveKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DepthResolveMode.GetHashCode() ^ StencilResolveMode.GetHashCode()
			^ ((ulong)DepthStencilResolveAttachment).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkSubpassDescriptionDepthStencilResolveKHR l, in VkSubpassDescriptionDepthStencilResolveKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DepthResolveMode == r.DepthResolveMode) && (l.StencilResolveMode == r.StencilResolveMode)
			&& (l.DepthStencilResolveAttachment == r.DepthStencilResolveAttachment)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkSubpassDescriptionDepthStencilResolveKHR l, in VkSubpassDescriptionDepthStencilResolveKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DepthResolveMode != r.DepthResolveMode) || (l.StencilResolveMode != r.StencilResolveMode)
			|| (l.DepthStencilResolveAttachment != r.DepthStencilResolveAttachment)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkSubpassDescriptionDepthStencilResolveKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkRayTracingShaderGroupCreateInfoKHR : IEquatable<VkRayTracingShaderGroupCreateInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.RayTracingShaderGroupCreateInfoKhr;

	public VkStructureType sType;
	public void* pNext;
	public VkRayTracingShaderGroupTypeKHR Type;
	public uint GeneralShader;
	public uint ClosestHitShader;
	public uint AnyHitShader;
	public uint IntersectionShader;
	public void* ShaderGroupCaptureReplayHandle;

	public VkRayTracingShaderGroupCreateInfoKHR(
		VkRayTracingShaderGroupTypeKHR type = default,
		uint generalShader = default,
		uint closestHitShader = default,
		uint anyHitShader = default,
		uint intersectionShader = default,
		void* shaderGroupCaptureReplayHandle = default
	) {
		sType = TYPE;
		pNext = null;
		Type = type;
		GeneralShader = generalShader;
		ClosestHitShader = closestHitShader;
		AnyHitShader = anyHitShader;
		IntersectionShader = intersectionShader;
		ShaderGroupCaptureReplayHandle = shaderGroupCaptureReplayHandle;
	}

	public readonly override bool Equals(object? o) => (o is VkRayTracingShaderGroupCreateInfoKHR s) && (this == s);
	readonly bool IEquatable<VkRayTracingShaderGroupCreateInfoKHR>.Equals(VkRayTracingShaderGroupCreateInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Type.GetHashCode() ^ GeneralShader.GetHashCode()
			^ ClosestHitShader.GetHashCode() ^ AnyHitShader.GetHashCode() ^ IntersectionShader.GetHashCode() ^ ((ulong)ShaderGroupCaptureReplayHandle).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkRayTracingShaderGroupCreateInfoKHR l, in VkRayTracingShaderGroupCreateInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Type == r.Type) && (l.GeneralShader == r.GeneralShader)
			&& (l.ClosestHitShader == r.ClosestHitShader) && (l.AnyHitShader == r.AnyHitShader) && (l.IntersectionShader == r.IntersectionShader) && (l.ShaderGroupCaptureReplayHandle == r.ShaderGroupCaptureReplayHandle)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkRayTracingShaderGroupCreateInfoKHR l, in VkRayTracingShaderGroupCreateInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Type != r.Type) || (l.GeneralShader != r.GeneralShader)
			|| (l.ClosestHitShader != r.ClosestHitShader) || (l.AnyHitShader != r.AnyHitShader) || (l.IntersectionShader != r.IntersectionShader) || (l.ShaderGroupCaptureReplayHandle != r.ShaderGroupCaptureReplayHandle)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkRayTracingShaderGroupCreateInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkRayTracingPipelineCreateInfoKHR : IEquatable<VkRayTracingPipelineCreateInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.RayTracingPipelineCreateInfoKhr;

	public VkStructureType sType;
	public void* pNext;
	public VkPipelineCreateFlags Flags;
	public uint StageCount;
	public VkPipelineShaderStageCreateInfo* Stages;
	public uint GroupCount;
	public VkRayTracingShaderGroupCreateInfoKHR* Groups;
	public uint MaxPipelineRayRecursionDepth;
	public VkPipelineLibraryCreateInfoKHR* LibraryInfo;
	public VkRayTracingPipelineInterfaceCreateInfoKHR* LibraryInterface;
	public VkPipelineDynamicStateCreateInfo* DynamicState;
	public VulkanHandle<VkPipelineLayout> Layout;
	public VulkanHandle<VkPipeline> BasePipelineHandle;
	public int BasePipelineIndex;

	public VkRayTracingPipelineCreateInfoKHR(
		VkPipelineCreateFlags flags = default,
		uint stageCount = default,
		VkPipelineShaderStageCreateInfo* stages = default,
		uint groupCount = default,
		VkRayTracingShaderGroupCreateInfoKHR* groups = default,
		uint maxPipelineRayRecursionDepth = default,
		VkPipelineLibraryCreateInfoKHR* libraryInfo = default,
		VkRayTracingPipelineInterfaceCreateInfoKHR* libraryInterface = default,
		VkPipelineDynamicStateCreateInfo* dynamicState = default,
		VulkanHandle<VkPipelineLayout> layout = default,
		VulkanHandle<VkPipeline> basePipelineHandle = default,
		int basePipelineIndex = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		StageCount = stageCount;
		Stages = stages;
		GroupCount = groupCount;
		Groups = groups;
		MaxPipelineRayRecursionDepth = maxPipelineRayRecursionDepth;
		LibraryInfo = libraryInfo;
		LibraryInterface = libraryInterface;
		DynamicState = dynamicState;
		Layout = layout;
		BasePipelineHandle = basePipelineHandle;
		BasePipelineIndex = basePipelineIndex;
	}

	public readonly override bool Equals(object? o) => (o is VkRayTracingPipelineCreateInfoKHR s) && (this == s);
	readonly bool IEquatable<VkRayTracingPipelineCreateInfoKHR>.Equals(VkRayTracingPipelineCreateInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ StageCount.GetHashCode()
			^ ((ulong)Stages).GetHashCode() ^ GroupCount.GetHashCode() ^ ((ulong)Groups).GetHashCode() ^ MaxPipelineRayRecursionDepth.GetHashCode()
			^ ((ulong)LibraryInfo).GetHashCode() ^ ((ulong)LibraryInterface).GetHashCode() ^ ((ulong)DynamicState).GetHashCode() ^ Layout.GetHashCode()
			^ BasePipelineHandle.GetHashCode() ^ BasePipelineIndex.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkRayTracingPipelineCreateInfoKHR l, in VkRayTracingPipelineCreateInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.StageCount == r.StageCount)
			&& (l.Stages == r.Stages) && (l.GroupCount == r.GroupCount) && (l.Groups == r.Groups) && (l.MaxPipelineRayRecursionDepth == r.MaxPipelineRayRecursionDepth)
			&& (l.LibraryInfo == r.LibraryInfo) && (l.LibraryInterface == r.LibraryInterface) && (l.DynamicState == r.DynamicState) && (l.Layout == r.Layout)
			&& (l.BasePipelineHandle == r.BasePipelineHandle) && (l.BasePipelineIndex == r.BasePipelineIndex)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkRayTracingPipelineCreateInfoKHR l, in VkRayTracingPipelineCreateInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.StageCount != r.StageCount)
			|| (l.Stages != r.Stages) || (l.GroupCount != r.GroupCount) || (l.Groups != r.Groups) || (l.MaxPipelineRayRecursionDepth != r.MaxPipelineRayRecursionDepth)
			|| (l.LibraryInfo != r.LibraryInfo) || (l.LibraryInterface != r.LibraryInterface) || (l.DynamicState != r.DynamicState) || (l.Layout != r.Layout)
			|| (l.BasePipelineHandle != r.BasePipelineHandle) || (l.BasePipelineIndex != r.BasePipelineIndex)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkRayTracingPipelineCreateInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkWriteDescriptorSetAccelerationStructureKHR : IEquatable<VkWriteDescriptorSetAccelerationStructureKHR>
{
	public const VkStructureType TYPE = VkStructureType.WriteDescriptorSetAccelerationStructureKhr;

	public VkStructureType sType;
	public void* pNext;
	public uint AccelerationStructureCount;
	public VulkanHandle<VkAccelerationStructureKHR>* AccelerationStructures;

	public VkWriteDescriptorSetAccelerationStructureKHR(
		uint accelerationStructureCount = default,
		VulkanHandle<VkAccelerationStructureKHR>* accelerationStructures = default
	) {
		sType = TYPE;
		pNext = null;
		AccelerationStructureCount = accelerationStructureCount;
		AccelerationStructures = accelerationStructures;
	}

	public readonly override bool Equals(object? o) => (o is VkWriteDescriptorSetAccelerationStructureKHR s) && (this == s);
	readonly bool IEquatable<VkWriteDescriptorSetAccelerationStructureKHR>.Equals(VkWriteDescriptorSetAccelerationStructureKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ AccelerationStructureCount.GetHashCode() ^ ((ulong)AccelerationStructures).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkWriteDescriptorSetAccelerationStructureKHR l, in VkWriteDescriptorSetAccelerationStructureKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.AccelerationStructureCount == r.AccelerationStructureCount) && (l.AccelerationStructures == r.AccelerationStructures)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkWriteDescriptorSetAccelerationStructureKHR l, in VkWriteDescriptorSetAccelerationStructureKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.AccelerationStructureCount != r.AccelerationStructureCount) || (l.AccelerationStructures != r.AccelerationStructures)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkWriteDescriptorSetAccelerationStructureKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceAccelerationStructureFeaturesKHR : IEquatable<VkPhysicalDeviceAccelerationStructureFeaturesKHR>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceAccelerationStructureFeaturesKhr;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 AccelerationStructure;
	public VkBool32 AccelerationStructureCaptureReplay;
	public VkBool32 AccelerationStructureIndirectBuild;
	public VkBool32 AccelerationStructureHostCommands;
	public VkBool32 DescriptorBindingAccelerationStructureUpdateAfterBind;

	public VkPhysicalDeviceAccelerationStructureFeaturesKHR(
		VkBool32 accelerationStructure = default,
		VkBool32 accelerationStructureCaptureReplay = default,
		VkBool32 accelerationStructureIndirectBuild = default,
		VkBool32 accelerationStructureHostCommands = default,
		VkBool32 descriptorBindingAccelerationStructureUpdateAfterBind = default
	) {
		sType = TYPE;
		pNext = null;
		AccelerationStructure = accelerationStructure;
		AccelerationStructureCaptureReplay = accelerationStructureCaptureReplay;
		AccelerationStructureIndirectBuild = accelerationStructureIndirectBuild;
		AccelerationStructureHostCommands = accelerationStructureHostCommands;
		DescriptorBindingAccelerationStructureUpdateAfterBind = descriptorBindingAccelerationStructureUpdateAfterBind;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceAccelerationStructureFeaturesKHR s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceAccelerationStructureFeaturesKHR>.Equals(VkPhysicalDeviceAccelerationStructureFeaturesKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ AccelerationStructure.GetHashCode() ^ AccelerationStructureCaptureReplay.GetHashCode()
			^ AccelerationStructureIndirectBuild.GetHashCode() ^ AccelerationStructureHostCommands.GetHashCode() ^ DescriptorBindingAccelerationStructureUpdateAfterBind.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceAccelerationStructureFeaturesKHR l, in VkPhysicalDeviceAccelerationStructureFeaturesKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.AccelerationStructure == r.AccelerationStructure) && (l.AccelerationStructureCaptureReplay == r.AccelerationStructureCaptureReplay)
			&& (l.AccelerationStructureIndirectBuild == r.AccelerationStructureIndirectBuild) && (l.AccelerationStructureHostCommands == r.AccelerationStructureHostCommands) && (l.DescriptorBindingAccelerationStructureUpdateAfterBind == r.DescriptorBindingAccelerationStructureUpdateAfterBind)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceAccelerationStructureFeaturesKHR l, in VkPhysicalDeviceAccelerationStructureFeaturesKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.AccelerationStructure != r.AccelerationStructure) || (l.AccelerationStructureCaptureReplay != r.AccelerationStructureCaptureReplay)
			|| (l.AccelerationStructureIndirectBuild != r.AccelerationStructureIndirectBuild) || (l.AccelerationStructureHostCommands != r.AccelerationStructureHostCommands) || (l.DescriptorBindingAccelerationStructureUpdateAfterBind != r.DescriptorBindingAccelerationStructureUpdateAfterBind)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceAccelerationStructureFeaturesKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceRayTracingPipelineFeaturesKHR : IEquatable<VkPhysicalDeviceRayTracingPipelineFeaturesKHR>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceRayTracingPipelineFeaturesKhr;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 RayTracingPipeline;
	public VkBool32 RayTracingPipelineShaderGroupHandleCaptureReplay;
	public VkBool32 RayTracingPipelineShaderGroupHandleCaptureReplayMixed;
	public VkBool32 RayTracingPipelineTraceRaysIndirect;
	public VkBool32 RayTraversalPrimitiveCulling;

	public VkPhysicalDeviceRayTracingPipelineFeaturesKHR(
		VkBool32 rayTracingPipeline = default,
		VkBool32 rayTracingPipelineShaderGroupHandleCaptureReplay = default,
		VkBool32 rayTracingPipelineShaderGroupHandleCaptureReplayMixed = default,
		VkBool32 rayTracingPipelineTraceRaysIndirect = default,
		VkBool32 rayTraversalPrimitiveCulling = default
	) {
		sType = TYPE;
		pNext = null;
		RayTracingPipeline = rayTracingPipeline;
		RayTracingPipelineShaderGroupHandleCaptureReplay = rayTracingPipelineShaderGroupHandleCaptureReplay;
		RayTracingPipelineShaderGroupHandleCaptureReplayMixed = rayTracingPipelineShaderGroupHandleCaptureReplayMixed;
		RayTracingPipelineTraceRaysIndirect = rayTracingPipelineTraceRaysIndirect;
		RayTraversalPrimitiveCulling = rayTraversalPrimitiveCulling;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceRayTracingPipelineFeaturesKHR s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceRayTracingPipelineFeaturesKHR>.Equals(VkPhysicalDeviceRayTracingPipelineFeaturesKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ RayTracingPipeline.GetHashCode() ^ RayTracingPipelineShaderGroupHandleCaptureReplay.GetHashCode()
			^ RayTracingPipelineShaderGroupHandleCaptureReplayMixed.GetHashCode() ^ RayTracingPipelineTraceRaysIndirect.GetHashCode() ^ RayTraversalPrimitiveCulling.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceRayTracingPipelineFeaturesKHR l, in VkPhysicalDeviceRayTracingPipelineFeaturesKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.RayTracingPipeline == r.RayTracingPipeline) && (l.RayTracingPipelineShaderGroupHandleCaptureReplay == r.RayTracingPipelineShaderGroupHandleCaptureReplay)
			&& (l.RayTracingPipelineShaderGroupHandleCaptureReplayMixed == r.RayTracingPipelineShaderGroupHandleCaptureReplayMixed) && (l.RayTracingPipelineTraceRaysIndirect == r.RayTracingPipelineTraceRaysIndirect) && (l.RayTraversalPrimitiveCulling == r.RayTraversalPrimitiveCulling)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceRayTracingPipelineFeaturesKHR l, in VkPhysicalDeviceRayTracingPipelineFeaturesKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.RayTracingPipeline != r.RayTracingPipeline) || (l.RayTracingPipelineShaderGroupHandleCaptureReplay != r.RayTracingPipelineShaderGroupHandleCaptureReplay)
			|| (l.RayTracingPipelineShaderGroupHandleCaptureReplayMixed != r.RayTracingPipelineShaderGroupHandleCaptureReplayMixed) || (l.RayTracingPipelineTraceRaysIndirect != r.RayTracingPipelineTraceRaysIndirect) || (l.RayTraversalPrimitiveCulling != r.RayTraversalPrimitiveCulling)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceRayTracingPipelineFeaturesKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceRayQueryFeaturesKHR : IEquatable<VkPhysicalDeviceRayQueryFeaturesKHR>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceRayQueryFeaturesKhr;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 RayQuery;

	public VkPhysicalDeviceRayQueryFeaturesKHR(
		VkBool32 rayQuery = default
	) {
		sType = TYPE;
		pNext = null;
		RayQuery = rayQuery;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceRayQueryFeaturesKHR s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceRayQueryFeaturesKHR>.Equals(VkPhysicalDeviceRayQueryFeaturesKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ RayQuery.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceRayQueryFeaturesKHR l, in VkPhysicalDeviceRayQueryFeaturesKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.RayQuery == r.RayQuery)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceRayQueryFeaturesKHR l, in VkPhysicalDeviceRayQueryFeaturesKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.RayQuery != r.RayQuery)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceRayQueryFeaturesKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceAccelerationStructurePropertiesKHR : IEquatable<VkPhysicalDeviceAccelerationStructurePropertiesKHR>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceAccelerationStructurePropertiesKhr;

	public VkStructureType sType;
	public void* pNext;
	public ulong MaxGeometryCount;
	public ulong MaxInstanceCount;
	public ulong MaxPrimitiveCount;
	public uint MaxPerStageDescriptorAccelerationStructures;
	public uint MaxPerStageDescriptorUpdateAfterBindAccelerationStructures;
	public uint MaxDescriptorSetAccelerationStructures;
	public uint MaxDescriptorSetUpdateAfterBindAccelerationStructures;
	public uint MinAccelerationStructureScratchOffsetAlignment;

	public VkPhysicalDeviceAccelerationStructurePropertiesKHR(
		ulong maxGeometryCount = default,
		ulong maxInstanceCount = default,
		ulong maxPrimitiveCount = default,
		uint maxPerStageDescriptorAccelerationStructures = default,
		uint maxPerStageDescriptorUpdateAfterBindAccelerationStructures = default,
		uint maxDescriptorSetAccelerationStructures = default,
		uint maxDescriptorSetUpdateAfterBindAccelerationStructures = default,
		uint minAccelerationStructureScratchOffsetAlignment = default
	) {
		sType = TYPE;
		pNext = null;
		MaxGeometryCount = maxGeometryCount;
		MaxInstanceCount = maxInstanceCount;
		MaxPrimitiveCount = maxPrimitiveCount;
		MaxPerStageDescriptorAccelerationStructures = maxPerStageDescriptorAccelerationStructures;
		MaxPerStageDescriptorUpdateAfterBindAccelerationStructures = maxPerStageDescriptorUpdateAfterBindAccelerationStructures;
		MaxDescriptorSetAccelerationStructures = maxDescriptorSetAccelerationStructures;
		MaxDescriptorSetUpdateAfterBindAccelerationStructures = maxDescriptorSetUpdateAfterBindAccelerationStructures;
		MinAccelerationStructureScratchOffsetAlignment = minAccelerationStructureScratchOffsetAlignment;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceAccelerationStructurePropertiesKHR s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceAccelerationStructurePropertiesKHR>.Equals(VkPhysicalDeviceAccelerationStructurePropertiesKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MaxGeometryCount.GetHashCode() ^ MaxInstanceCount.GetHashCode()
			^ MaxPrimitiveCount.GetHashCode() ^ MaxPerStageDescriptorAccelerationStructures.GetHashCode() ^ MaxPerStageDescriptorUpdateAfterBindAccelerationStructures.GetHashCode() ^ MaxDescriptorSetAccelerationStructures.GetHashCode()
			^ MaxDescriptorSetUpdateAfterBindAccelerationStructures.GetHashCode() ^ MinAccelerationStructureScratchOffsetAlignment.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceAccelerationStructurePropertiesKHR l, in VkPhysicalDeviceAccelerationStructurePropertiesKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MaxGeometryCount == r.MaxGeometryCount) && (l.MaxInstanceCount == r.MaxInstanceCount)
			&& (l.MaxPrimitiveCount == r.MaxPrimitiveCount) && (l.MaxPerStageDescriptorAccelerationStructures == r.MaxPerStageDescriptorAccelerationStructures) && (l.MaxPerStageDescriptorUpdateAfterBindAccelerationStructures == r.MaxPerStageDescriptorUpdateAfterBindAccelerationStructures) && (l.MaxDescriptorSetAccelerationStructures == r.MaxDescriptorSetAccelerationStructures)
			&& (l.MaxDescriptorSetUpdateAfterBindAccelerationStructures == r.MaxDescriptorSetUpdateAfterBindAccelerationStructures) && (l.MinAccelerationStructureScratchOffsetAlignment == r.MinAccelerationStructureScratchOffsetAlignment)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceAccelerationStructurePropertiesKHR l, in VkPhysicalDeviceAccelerationStructurePropertiesKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MaxGeometryCount != r.MaxGeometryCount) || (l.MaxInstanceCount != r.MaxInstanceCount)
			|| (l.MaxPrimitiveCount != r.MaxPrimitiveCount) || (l.MaxPerStageDescriptorAccelerationStructures != r.MaxPerStageDescriptorAccelerationStructures) || (l.MaxPerStageDescriptorUpdateAfterBindAccelerationStructures != r.MaxPerStageDescriptorUpdateAfterBindAccelerationStructures) || (l.MaxDescriptorSetAccelerationStructures != r.MaxDescriptorSetAccelerationStructures)
			|| (l.MaxDescriptorSetUpdateAfterBindAccelerationStructures != r.MaxDescriptorSetUpdateAfterBindAccelerationStructures) || (l.MinAccelerationStructureScratchOffsetAlignment != r.MinAccelerationStructureScratchOffsetAlignment)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceAccelerationStructurePropertiesKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceRayTracingPipelinePropertiesKHR : IEquatable<VkPhysicalDeviceRayTracingPipelinePropertiesKHR>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceRayTracingPipelinePropertiesKhr;

	public VkStructureType sType;
	public void* pNext;
	public uint ShaderGroupHandleSize;
	public uint MaxRayRecursionDepth;
	public uint MaxShaderGroupStride;
	public uint ShaderGroupBaseAlignment;
	public uint ShaderGroupHandleCaptureReplaySize;
	public uint MaxRayDispatchInvocationCount;
	public uint ShaderGroupHandleAlignment;
	public uint MaxRayHitAttributeSize;

	public VkPhysicalDeviceRayTracingPipelinePropertiesKHR(
		uint shaderGroupHandleSize = default,
		uint maxRayRecursionDepth = default,
		uint maxShaderGroupStride = default,
		uint shaderGroupBaseAlignment = default,
		uint shaderGroupHandleCaptureReplaySize = default,
		uint maxRayDispatchInvocationCount = default,
		uint shaderGroupHandleAlignment = default,
		uint maxRayHitAttributeSize = default
	) {
		sType = TYPE;
		pNext = null;
		ShaderGroupHandleSize = shaderGroupHandleSize;
		MaxRayRecursionDepth = maxRayRecursionDepth;
		MaxShaderGroupStride = maxShaderGroupStride;
		ShaderGroupBaseAlignment = shaderGroupBaseAlignment;
		ShaderGroupHandleCaptureReplaySize = shaderGroupHandleCaptureReplaySize;
		MaxRayDispatchInvocationCount = maxRayDispatchInvocationCount;
		ShaderGroupHandleAlignment = shaderGroupHandleAlignment;
		MaxRayHitAttributeSize = maxRayHitAttributeSize;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceRayTracingPipelinePropertiesKHR s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceRayTracingPipelinePropertiesKHR>.Equals(VkPhysicalDeviceRayTracingPipelinePropertiesKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ShaderGroupHandleSize.GetHashCode() ^ MaxRayRecursionDepth.GetHashCode()
			^ MaxShaderGroupStride.GetHashCode() ^ ShaderGroupBaseAlignment.GetHashCode() ^ ShaderGroupHandleCaptureReplaySize.GetHashCode() ^ MaxRayDispatchInvocationCount.GetHashCode()
			^ ShaderGroupHandleAlignment.GetHashCode() ^ MaxRayHitAttributeSize.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceRayTracingPipelinePropertiesKHR l, in VkPhysicalDeviceRayTracingPipelinePropertiesKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ShaderGroupHandleSize == r.ShaderGroupHandleSize) && (l.MaxRayRecursionDepth == r.MaxRayRecursionDepth)
			&& (l.MaxShaderGroupStride == r.MaxShaderGroupStride) && (l.ShaderGroupBaseAlignment == r.ShaderGroupBaseAlignment) && (l.ShaderGroupHandleCaptureReplaySize == r.ShaderGroupHandleCaptureReplaySize) && (l.MaxRayDispatchInvocationCount == r.MaxRayDispatchInvocationCount)
			&& (l.ShaderGroupHandleAlignment == r.ShaderGroupHandleAlignment) && (l.MaxRayHitAttributeSize == r.MaxRayHitAttributeSize)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceRayTracingPipelinePropertiesKHR l, in VkPhysicalDeviceRayTracingPipelinePropertiesKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ShaderGroupHandleSize != r.ShaderGroupHandleSize) || (l.MaxRayRecursionDepth != r.MaxRayRecursionDepth)
			|| (l.MaxShaderGroupStride != r.MaxShaderGroupStride) || (l.ShaderGroupBaseAlignment != r.ShaderGroupBaseAlignment) || (l.ShaderGroupHandleCaptureReplaySize != r.ShaderGroupHandleCaptureReplaySize) || (l.MaxRayDispatchInvocationCount != r.MaxRayDispatchInvocationCount)
			|| (l.ShaderGroupHandleAlignment != r.ShaderGroupHandleAlignment) || (l.MaxRayHitAttributeSize != r.MaxRayHitAttributeSize)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceRayTracingPipelinePropertiesKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkStridedDeviceAddressRegionKHR : IEquatable<VkStridedDeviceAddressRegionKHR>
{
	public ulong DeviceAddress;
	public ulong Stride;
	public ulong Size;

	public VkStridedDeviceAddressRegionKHR(
		ulong deviceAddress = default,
		ulong stride = default,
		ulong size = default
	) {
		DeviceAddress = deviceAddress;
		Stride = stride;
		Size = size;
	}

	public readonly override bool Equals(object? o) => (o is VkStridedDeviceAddressRegionKHR s) && (this == s);
	readonly bool IEquatable<VkStridedDeviceAddressRegionKHR>.Equals(VkStridedDeviceAddressRegionKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			DeviceAddress.GetHashCode() ^ Stride.GetHashCode() ^ Size.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkStridedDeviceAddressRegionKHR l, in VkStridedDeviceAddressRegionKHR r)
	{
		return
			(l.DeviceAddress == r.DeviceAddress) && (l.Stride == r.Stride) && (l.Size == r.Size)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkStridedDeviceAddressRegionKHR l, in VkStridedDeviceAddressRegionKHR r)
	{
		return
			(l.DeviceAddress != r.DeviceAddress) || (l.Stride != r.Stride) || (l.Size != r.Size)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkStridedDeviceAddressRegionKHR s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkTraceRaysIndirectCommandKHR : IEquatable<VkTraceRaysIndirectCommandKHR>
{
	public uint Width;
	public uint Height;
	public uint Depth;

	public VkTraceRaysIndirectCommandKHR(
		uint width = default,
		uint height = default,
		uint depth = default
	) {
		Width = width;
		Height = height;
		Depth = depth;
	}

	public readonly override bool Equals(object? o) => (o is VkTraceRaysIndirectCommandKHR s) && (this == s);
	readonly bool IEquatable<VkTraceRaysIndirectCommandKHR>.Equals(VkTraceRaysIndirectCommandKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Width.GetHashCode() ^ Height.GetHashCode() ^ Depth.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkTraceRaysIndirectCommandKHR l, in VkTraceRaysIndirectCommandKHR r)
	{
		return
			(l.Width == r.Width) && (l.Height == r.Height) && (l.Depth == r.Depth)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkTraceRaysIndirectCommandKHR l, in VkTraceRaysIndirectCommandKHR r)
	{
		return
			(l.Width != r.Width) || (l.Height != r.Height) || (l.Depth != r.Depth)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkTraceRaysIndirectCommandKHR s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkSurfaceProtectedCapabilitiesKHR : IEquatable<VkSurfaceProtectedCapabilitiesKHR>
{
	public const VkStructureType TYPE = VkStructureType.SurfaceProtectedCapabilitiesKhr;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 SupportsProtected;

	public VkSurfaceProtectedCapabilitiesKHR(
		VkBool32 supportsProtected = default
	) {
		sType = TYPE;
		pNext = null;
		SupportsProtected = supportsProtected;
	}

	public readonly override bool Equals(object? o) => (o is VkSurfaceProtectedCapabilitiesKHR s) && (this == s);
	readonly bool IEquatable<VkSurfaceProtectedCapabilitiesKHR>.Equals(VkSurfaceProtectedCapabilitiesKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SupportsProtected.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkSurfaceProtectedCapabilitiesKHR l, in VkSurfaceProtectedCapabilitiesKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SupportsProtected == r.SupportsProtected)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkSurfaceProtectedCapabilitiesKHR l, in VkSurfaceProtectedCapabilitiesKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SupportsProtected != r.SupportsProtected)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkSurfaceProtectedCapabilitiesKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR : IEquatable<VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceUniformBufferStandardLayoutFeatures;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 UniformBufferStandardLayout;

	public VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR(
		VkBool32 uniformBufferStandardLayout = default
	) {
		sType = TYPE;
		pNext = null;
		UniformBufferStandardLayout = uniformBufferStandardLayout;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR>.Equals(VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ UniformBufferStandardLayout.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR l, in VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.UniformBufferStandardLayout == r.UniformBufferStandardLayout)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR l, in VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.UniformBufferStandardLayout != r.UniformBufferStandardLayout)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceBufferDeviceAddressFeaturesKHR : IEquatable<VkPhysicalDeviceBufferDeviceAddressFeaturesKHR>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceBufferDeviceAddressFeatures;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 BufferDeviceAddress;
	public VkBool32 BufferDeviceAddressCaptureReplay;
	public VkBool32 BufferDeviceAddressMultiDevice;

	public VkPhysicalDeviceBufferDeviceAddressFeaturesKHR(
		VkBool32 bufferDeviceAddress = default,
		VkBool32 bufferDeviceAddressCaptureReplay = default,
		VkBool32 bufferDeviceAddressMultiDevice = default
	) {
		sType = TYPE;
		pNext = null;
		BufferDeviceAddress = bufferDeviceAddress;
		BufferDeviceAddressCaptureReplay = bufferDeviceAddressCaptureReplay;
		BufferDeviceAddressMultiDevice = bufferDeviceAddressMultiDevice;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceBufferDeviceAddressFeaturesKHR s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceBufferDeviceAddressFeaturesKHR>.Equals(VkPhysicalDeviceBufferDeviceAddressFeaturesKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ BufferDeviceAddress.GetHashCode() ^ BufferDeviceAddressCaptureReplay.GetHashCode()
			^ BufferDeviceAddressMultiDevice.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceBufferDeviceAddressFeaturesKHR l, in VkPhysicalDeviceBufferDeviceAddressFeaturesKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.BufferDeviceAddress == r.BufferDeviceAddress) && (l.BufferDeviceAddressCaptureReplay == r.BufferDeviceAddressCaptureReplay)
			&& (l.BufferDeviceAddressMultiDevice == r.BufferDeviceAddressMultiDevice)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceBufferDeviceAddressFeaturesKHR l, in VkPhysicalDeviceBufferDeviceAddressFeaturesKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.BufferDeviceAddress != r.BufferDeviceAddress) || (l.BufferDeviceAddressCaptureReplay != r.BufferDeviceAddressCaptureReplay)
			|| (l.BufferDeviceAddressMultiDevice != r.BufferDeviceAddressMultiDevice)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceBufferDeviceAddressFeaturesKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkBufferDeviceAddressInfoKHR : IEquatable<VkBufferDeviceAddressInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.BufferDeviceAddressInfo;

	public VkStructureType sType;
	public void* pNext;
	public VulkanHandle<VkBuffer> Buffer;

	public VkBufferDeviceAddressInfoKHR(
		VulkanHandle<VkBuffer> buffer = default
	) {
		sType = TYPE;
		pNext = null;
		Buffer = buffer;
	}

	public readonly override bool Equals(object? o) => (o is VkBufferDeviceAddressInfoKHR s) && (this == s);
	readonly bool IEquatable<VkBufferDeviceAddressInfoKHR>.Equals(VkBufferDeviceAddressInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Buffer.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkBufferDeviceAddressInfoKHR l, in VkBufferDeviceAddressInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Buffer == r.Buffer)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkBufferDeviceAddressInfoKHR l, in VkBufferDeviceAddressInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Buffer != r.Buffer)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkBufferDeviceAddressInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkBufferOpaqueCaptureAddressCreateInfoKHR : IEquatable<VkBufferOpaqueCaptureAddressCreateInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.BufferOpaqueCaptureAddressCreateInfo;

	public VkStructureType sType;
	public void* pNext;
	public ulong OpaqueCaptureAddress;

	public VkBufferOpaqueCaptureAddressCreateInfoKHR(
		ulong opaqueCaptureAddress = default
	) {
		sType = TYPE;
		pNext = null;
		OpaqueCaptureAddress = opaqueCaptureAddress;
	}

	public readonly override bool Equals(object? o) => (o is VkBufferOpaqueCaptureAddressCreateInfoKHR s) && (this == s);
	readonly bool IEquatable<VkBufferOpaqueCaptureAddressCreateInfoKHR>.Equals(VkBufferOpaqueCaptureAddressCreateInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ OpaqueCaptureAddress.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkBufferOpaqueCaptureAddressCreateInfoKHR l, in VkBufferOpaqueCaptureAddressCreateInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.OpaqueCaptureAddress == r.OpaqueCaptureAddress)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkBufferOpaqueCaptureAddressCreateInfoKHR l, in VkBufferOpaqueCaptureAddressCreateInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.OpaqueCaptureAddress != r.OpaqueCaptureAddress)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkBufferOpaqueCaptureAddressCreateInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceImagelessFramebufferFeaturesKHR : IEquatable<VkPhysicalDeviceImagelessFramebufferFeaturesKHR>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceImagelessFramebufferFeatures;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 ImagelessFramebuffer;

	public VkPhysicalDeviceImagelessFramebufferFeaturesKHR(
		VkBool32 imagelessFramebuffer = default
	) {
		sType = TYPE;
		pNext = null;
		ImagelessFramebuffer = imagelessFramebuffer;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceImagelessFramebufferFeaturesKHR s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceImagelessFramebufferFeaturesKHR>.Equals(VkPhysicalDeviceImagelessFramebufferFeaturesKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ImagelessFramebuffer.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceImagelessFramebufferFeaturesKHR l, in VkPhysicalDeviceImagelessFramebufferFeaturesKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ImagelessFramebuffer == r.ImagelessFramebuffer)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceImagelessFramebufferFeaturesKHR l, in VkPhysicalDeviceImagelessFramebufferFeaturesKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ImagelessFramebuffer != r.ImagelessFramebuffer)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceImagelessFramebufferFeaturesKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkFramebufferAttachmentsCreateInfoKHR : IEquatable<VkFramebufferAttachmentsCreateInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.FramebufferAttachmentsCreateInfo;

	public VkStructureType sType;
	public void* pNext;
	public uint AttachmentImageInfoCount;
	public VkFramebufferAttachmentImageInfo* AttachmentImageInfos;

	public VkFramebufferAttachmentsCreateInfoKHR(
		uint attachmentImageInfoCount = default,
		VkFramebufferAttachmentImageInfo* attachmentImageInfos = default
	) {
		sType = TYPE;
		pNext = null;
		AttachmentImageInfoCount = attachmentImageInfoCount;
		AttachmentImageInfos = attachmentImageInfos;
	}

	public readonly override bool Equals(object? o) => (o is VkFramebufferAttachmentsCreateInfoKHR s) && (this == s);
	readonly bool IEquatable<VkFramebufferAttachmentsCreateInfoKHR>.Equals(VkFramebufferAttachmentsCreateInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ AttachmentImageInfoCount.GetHashCode() ^ ((ulong)AttachmentImageInfos).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkFramebufferAttachmentsCreateInfoKHR l, in VkFramebufferAttachmentsCreateInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.AttachmentImageInfoCount == r.AttachmentImageInfoCount) && (l.AttachmentImageInfos == r.AttachmentImageInfos)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkFramebufferAttachmentsCreateInfoKHR l, in VkFramebufferAttachmentsCreateInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.AttachmentImageInfoCount != r.AttachmentImageInfoCount) || (l.AttachmentImageInfos != r.AttachmentImageInfos)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkFramebufferAttachmentsCreateInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkFramebufferAttachmentImageInfoKHR : IEquatable<VkFramebufferAttachmentImageInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.FramebufferAttachmentImageInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkImageCreateFlags Flags;
	public VkImageUsageFlags Usage;
	public uint Width;
	public uint Height;
	public uint LayerCount;
	public uint ViewFormatCount;
	public VkFormat* ViewFormats;

	public VkFramebufferAttachmentImageInfoKHR(
		VkImageCreateFlags flags = default,
		VkImageUsageFlags usage = default,
		uint width = default,
		uint height = default,
		uint layerCount = default,
		uint viewFormatCount = default,
		VkFormat* viewFormats = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		Usage = usage;
		Width = width;
		Height = height;
		LayerCount = layerCount;
		ViewFormatCount = viewFormatCount;
		ViewFormats = viewFormats;
	}

	public readonly override bool Equals(object? o) => (o is VkFramebufferAttachmentImageInfoKHR s) && (this == s);
	readonly bool IEquatable<VkFramebufferAttachmentImageInfoKHR>.Equals(VkFramebufferAttachmentImageInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ Usage.GetHashCode()
			^ Width.GetHashCode() ^ Height.GetHashCode() ^ LayerCount.GetHashCode() ^ ViewFormatCount.GetHashCode()
			^ ((ulong)ViewFormats).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkFramebufferAttachmentImageInfoKHR l, in VkFramebufferAttachmentImageInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.Usage == r.Usage)
			&& (l.Width == r.Width) && (l.Height == r.Height) && (l.LayerCount == r.LayerCount) && (l.ViewFormatCount == r.ViewFormatCount)
			&& (l.ViewFormats == r.ViewFormats)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkFramebufferAttachmentImageInfoKHR l, in VkFramebufferAttachmentImageInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.Usage != r.Usage)
			|| (l.Width != r.Width) || (l.Height != r.Height) || (l.LayerCount != r.LayerCount) || (l.ViewFormatCount != r.ViewFormatCount)
			|| (l.ViewFormats != r.ViewFormats)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkFramebufferAttachmentImageInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkRenderPassAttachmentBeginInfoKHR : IEquatable<VkRenderPassAttachmentBeginInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.RenderPassAttachmentBeginInfo;

	public VkStructureType sType;
	public void* pNext;
	public uint AttachmentCount;
	public VulkanHandle<VkImageView>* Attachments;

	public VkRenderPassAttachmentBeginInfoKHR(
		uint attachmentCount = default,
		VulkanHandle<VkImageView>* attachments = default
	) {
		sType = TYPE;
		pNext = null;
		AttachmentCount = attachmentCount;
		Attachments = attachments;
	}

	public readonly override bool Equals(object? o) => (o is VkRenderPassAttachmentBeginInfoKHR s) && (this == s);
	readonly bool IEquatable<VkRenderPassAttachmentBeginInfoKHR>.Equals(VkRenderPassAttachmentBeginInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ AttachmentCount.GetHashCode() ^ ((ulong)Attachments).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkRenderPassAttachmentBeginInfoKHR l, in VkRenderPassAttachmentBeginInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.AttachmentCount == r.AttachmentCount) && (l.Attachments == r.Attachments)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkRenderPassAttachmentBeginInfoKHR l, in VkRenderPassAttachmentBeginInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.AttachmentCount != r.AttachmentCount) || (l.Attachments != r.Attachments)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkRenderPassAttachmentBeginInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDevicePerformanceQueryFeaturesKHR : IEquatable<VkPhysicalDevicePerformanceQueryFeaturesKHR>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDevicePerformanceQueryFeaturesKhr;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 PerformanceCounterQueryPools;
	public VkBool32 PerformanceCounterMultipleQueryPools;

	public VkPhysicalDevicePerformanceQueryFeaturesKHR(
		VkBool32 performanceCounterQueryPools = default,
		VkBool32 performanceCounterMultipleQueryPools = default
	) {
		sType = TYPE;
		pNext = null;
		PerformanceCounterQueryPools = performanceCounterQueryPools;
		PerformanceCounterMultipleQueryPools = performanceCounterMultipleQueryPools;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDevicePerformanceQueryFeaturesKHR s) && (this == s);
	readonly bool IEquatable<VkPhysicalDevicePerformanceQueryFeaturesKHR>.Equals(VkPhysicalDevicePerformanceQueryFeaturesKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ PerformanceCounterQueryPools.GetHashCode() ^ PerformanceCounterMultipleQueryPools.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDevicePerformanceQueryFeaturesKHR l, in VkPhysicalDevicePerformanceQueryFeaturesKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.PerformanceCounterQueryPools == r.PerformanceCounterQueryPools) && (l.PerformanceCounterMultipleQueryPools == r.PerformanceCounterMultipleQueryPools)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDevicePerformanceQueryFeaturesKHR l, in VkPhysicalDevicePerformanceQueryFeaturesKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.PerformanceCounterQueryPools != r.PerformanceCounterQueryPools) || (l.PerformanceCounterMultipleQueryPools != r.PerformanceCounterMultipleQueryPools)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDevicePerformanceQueryFeaturesKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDevicePerformanceQueryPropertiesKHR : IEquatable<VkPhysicalDevicePerformanceQueryPropertiesKHR>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDevicePerformanceQueryPropertiesKhr;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 AllowCommandBufferQueryCopies;

	public VkPhysicalDevicePerformanceQueryPropertiesKHR(
		VkBool32 allowCommandBufferQueryCopies = default
	) {
		sType = TYPE;
		pNext = null;
		AllowCommandBufferQueryCopies = allowCommandBufferQueryCopies;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDevicePerformanceQueryPropertiesKHR s) && (this == s);
	readonly bool IEquatable<VkPhysicalDevicePerformanceQueryPropertiesKHR>.Equals(VkPhysicalDevicePerformanceQueryPropertiesKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ AllowCommandBufferQueryCopies.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDevicePerformanceQueryPropertiesKHR l, in VkPhysicalDevicePerformanceQueryPropertiesKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.AllowCommandBufferQueryCopies == r.AllowCommandBufferQueryCopies)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDevicePerformanceQueryPropertiesKHR l, in VkPhysicalDevicePerformanceQueryPropertiesKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.AllowCommandBufferQueryCopies != r.AllowCommandBufferQueryCopies)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDevicePerformanceQueryPropertiesKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPerformanceCounterKHR : IEquatable<VkPerformanceCounterKHR>
{
	public const VkStructureType TYPE = VkStructureType.PerformanceCounterKhr;

	public VkStructureType sType;
	public void* pNext;
	public VkPerformanceCounterUnitKHR Unit;
	public VkPerformanceCounterScopeKHR Scope;
	public VkPerformanceCounterStorageKHR Storage;
	public VVK.UUID Uuid;

	public VkPerformanceCounterKHR(
		VkPerformanceCounterUnitKHR unit = default,
		VkPerformanceCounterScopeKHR scope = default,
		VkPerformanceCounterStorageKHR storage = default,
		VVK.UUID uuid = default
	) {
		sType = TYPE;
		pNext = null;
		Unit = unit;
		Scope = scope;
		Storage = storage;
		Uuid = uuid;
	}

	public readonly override bool Equals(object? o) => (o is VkPerformanceCounterKHR s) && (this == s);
	readonly bool IEquatable<VkPerformanceCounterKHR>.Equals(VkPerformanceCounterKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Unit.GetHashCode() ^ Scope.GetHashCode()
			^ Storage.GetHashCode() ^ Uuid.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPerformanceCounterKHR l, in VkPerformanceCounterKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Unit == r.Unit) && (l.Scope == r.Scope)
			&& (l.Storage == r.Storage) && (l.Uuid == r.Uuid)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPerformanceCounterKHR l, in VkPerformanceCounterKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Unit != r.Unit) || (l.Scope != r.Scope)
			|| (l.Storage != r.Storage) || (l.Uuid != r.Uuid)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPerformanceCounterKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPerformanceCounterDescriptionKHR : IEquatable<VkPerformanceCounterDescriptionKHR>
{
	public const VkStructureType TYPE = VkStructureType.PerformanceCounterDescriptionKhr;

	public VkStructureType sType;
	public void* pNext;
	public VkPerformanceCounterDescriptionFlagsKHR Flags;
	public VVK.Description Name;
	public VVK.Description Category;
	public VVK.Description Description;

	public VkPerformanceCounterDescriptionKHR(
		VkPerformanceCounterDescriptionFlagsKHR flags = default,
		VVK.Description name = default,
		VVK.Description category = default,
		VVK.Description description = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		Name = name;
		Category = category;
		Description = description;
	}

	public readonly override bool Equals(object? o) => (o is VkPerformanceCounterDescriptionKHR s) && (this == s);
	readonly bool IEquatable<VkPerformanceCounterDescriptionKHR>.Equals(VkPerformanceCounterDescriptionKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ Name.GetHashCode()
			^ Category.GetHashCode() ^ Description.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPerformanceCounterDescriptionKHR l, in VkPerformanceCounterDescriptionKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.Name == r.Name)
			&& (l.Category == r.Category) && (l.Description == r.Description)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPerformanceCounterDescriptionKHR l, in VkPerformanceCounterDescriptionKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.Name != r.Name)
			|| (l.Category != r.Category) || (l.Description != r.Description)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPerformanceCounterDescriptionKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkQueryPoolPerformanceCreateInfoKHR : IEquatable<VkQueryPoolPerformanceCreateInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.QueryPoolPerformanceCreateInfoKhr;

	public VkStructureType sType;
	public void* pNext;
	public uint QueueFamilyIndex;
	public uint CounterIndexCount;
	public uint* CounterIndices;

	public VkQueryPoolPerformanceCreateInfoKHR(
		uint queueFamilyIndex = default,
		uint counterIndexCount = default,
		uint* counterIndices = default
	) {
		sType = TYPE;
		pNext = null;
		QueueFamilyIndex = queueFamilyIndex;
		CounterIndexCount = counterIndexCount;
		CounterIndices = counterIndices;
	}

	public readonly override bool Equals(object? o) => (o is VkQueryPoolPerformanceCreateInfoKHR s) && (this == s);
	readonly bool IEquatable<VkQueryPoolPerformanceCreateInfoKHR>.Equals(VkQueryPoolPerformanceCreateInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ QueueFamilyIndex.GetHashCode() ^ CounterIndexCount.GetHashCode()
			^ ((ulong)CounterIndices).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkQueryPoolPerformanceCreateInfoKHR l, in VkQueryPoolPerformanceCreateInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.QueueFamilyIndex == r.QueueFamilyIndex) && (l.CounterIndexCount == r.CounterIndexCount)
			&& (l.CounterIndices == r.CounterIndices)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkQueryPoolPerformanceCreateInfoKHR l, in VkQueryPoolPerformanceCreateInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.QueueFamilyIndex != r.QueueFamilyIndex) || (l.CounterIndexCount != r.CounterIndexCount)
			|| (l.CounterIndices != r.CounterIndices)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkQueryPoolPerformanceCreateInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Explicit)]
public unsafe partial struct VkPerformanceCounterResultKHR : IEquatable<VkPerformanceCounterResultKHR>
{
	[FieldOffset(0)]
	public int Int32;
	[FieldOffset(0)]
	public long Int64;
	[FieldOffset(0)]
	public uint Uint32;
	[FieldOffset(0)]
	public ulong Uint64;
	[FieldOffset(0)]
	public float Float32;
	[FieldOffset(0)]
	public double Float64;

	public VkPerformanceCounterResultKHR(in int int32) : this() => Int32 = int32;

	public VkPerformanceCounterResultKHR(in long int64) : this() => Int64 = int64;

	public VkPerformanceCounterResultKHR(in uint uint32) : this() => Uint32 = uint32;

	public VkPerformanceCounterResultKHR(in ulong uint64) : this() => Uint64 = uint64;

	public VkPerformanceCounterResultKHR(in float float32) : this() => Float32 = float32;

	public VkPerformanceCounterResultKHR(in double float64) : this() => Float64 = float64;

	public readonly override bool Equals(object? o) => (o is VkPerformanceCounterResultKHR s) && (this == s);
	readonly bool IEquatable<VkPerformanceCounterResultKHR>.Equals(VkPerformanceCounterResultKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Int32.GetHashCode() ^ Int64.GetHashCode() ^ Uint32.GetHashCode() ^ Uint64.GetHashCode()
			^ Float32.GetHashCode() ^ Float64.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPerformanceCounterResultKHR l, in VkPerformanceCounterResultKHR r)
	{
		return
			(l.Int32 == r.Int32) && (l.Int64 == r.Int64) && (l.Uint32 == r.Uint32) && (l.Uint64 == r.Uint64)
			&& (l.Float32 == r.Float32) && (l.Float64 == r.Float64)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPerformanceCounterResultKHR l, in VkPerformanceCounterResultKHR r)
	{
		return
			(l.Int32 != r.Int32) || (l.Int64 != r.Int64) || (l.Uint32 != r.Uint32) || (l.Uint64 != r.Uint64)
			|| (l.Float32 != r.Float32) || (l.Float64 != r.Float64)
			;
	}

}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkAcquireProfilingLockInfoKHR : IEquatable<VkAcquireProfilingLockInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.AcquireProfilingLockInfoKhr;

	public VkStructureType sType;
	public void* pNext;
	public VkAcquireProfilingLockFlagsKHR Flags;
	public ulong Timeout;

	public VkAcquireProfilingLockInfoKHR(
		VkAcquireProfilingLockFlagsKHR flags = default,
		ulong timeout = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		Timeout = timeout;
	}

	public readonly override bool Equals(object? o) => (o is VkAcquireProfilingLockInfoKHR s) && (this == s);
	readonly bool IEquatable<VkAcquireProfilingLockInfoKHR>.Equals(VkAcquireProfilingLockInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ Timeout.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkAcquireProfilingLockInfoKHR l, in VkAcquireProfilingLockInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.Timeout == r.Timeout)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkAcquireProfilingLockInfoKHR l, in VkAcquireProfilingLockInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.Timeout != r.Timeout)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkAcquireProfilingLockInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPerformanceQuerySubmitInfoKHR : IEquatable<VkPerformanceQuerySubmitInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.PerformanceQuerySubmitInfoKhr;

	public VkStructureType sType;
	public void* pNext;
	public uint CounterPassIndex;

	public VkPerformanceQuerySubmitInfoKHR(
		uint counterPassIndex = default
	) {
		sType = TYPE;
		pNext = null;
		CounterPassIndex = counterPassIndex;
	}

	public readonly override bool Equals(object? o) => (o is VkPerformanceQuerySubmitInfoKHR s) && (this == s);
	readonly bool IEquatable<VkPerformanceQuerySubmitInfoKHR>.Equals(VkPerformanceQuerySubmitInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ CounterPassIndex.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPerformanceQuerySubmitInfoKHR l, in VkPerformanceQuerySubmitInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.CounterPassIndex == r.CounterPassIndex)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPerformanceQuerySubmitInfoKHR l, in VkPerformanceQuerySubmitInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.CounterPassIndex != r.CounterPassIndex)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPerformanceQuerySubmitInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceShaderClockFeaturesKHR : IEquatable<VkPhysicalDeviceShaderClockFeaturesKHR>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceShaderClockFeaturesKhr;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 ShaderSubgroupClock;
	public VkBool32 ShaderDeviceClock;

	public VkPhysicalDeviceShaderClockFeaturesKHR(
		VkBool32 shaderSubgroupClock = default,
		VkBool32 shaderDeviceClock = default
	) {
		sType = TYPE;
		pNext = null;
		ShaderSubgroupClock = shaderSubgroupClock;
		ShaderDeviceClock = shaderDeviceClock;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceShaderClockFeaturesKHR s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceShaderClockFeaturesKHR>.Equals(VkPhysicalDeviceShaderClockFeaturesKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ShaderSubgroupClock.GetHashCode() ^ ShaderDeviceClock.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceShaderClockFeaturesKHR l, in VkPhysicalDeviceShaderClockFeaturesKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ShaderSubgroupClock == r.ShaderSubgroupClock) && (l.ShaderDeviceClock == r.ShaderDeviceClock)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceShaderClockFeaturesKHR l, in VkPhysicalDeviceShaderClockFeaturesKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ShaderSubgroupClock != r.ShaderSubgroupClock) || (l.ShaderDeviceClock != r.ShaderDeviceClock)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceShaderClockFeaturesKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR : IEquatable<VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceSeparateDepthStencilLayoutsFeatures;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 SeparateDepthStencilLayouts;

	public VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR(
		VkBool32 separateDepthStencilLayouts = default
	) {
		sType = TYPE;
		pNext = null;
		SeparateDepthStencilLayouts = separateDepthStencilLayouts;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR>.Equals(VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SeparateDepthStencilLayouts.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR l, in VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SeparateDepthStencilLayouts == r.SeparateDepthStencilLayouts)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR l, in VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SeparateDepthStencilLayouts != r.SeparateDepthStencilLayouts)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkAttachmentReferenceStencilLayoutKHR : IEquatable<VkAttachmentReferenceStencilLayoutKHR>
{
	public const VkStructureType TYPE = VkStructureType.AttachmentReferenceStencilLayout;

	public VkStructureType sType;
	public void* pNext;
	public VkImageLayout StencilLayout;

	public VkAttachmentReferenceStencilLayoutKHR(
		VkImageLayout stencilLayout = default
	) {
		sType = TYPE;
		pNext = null;
		StencilLayout = stencilLayout;
	}

	public readonly override bool Equals(object? o) => (o is VkAttachmentReferenceStencilLayoutKHR s) && (this == s);
	readonly bool IEquatable<VkAttachmentReferenceStencilLayoutKHR>.Equals(VkAttachmentReferenceStencilLayoutKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ StencilLayout.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkAttachmentReferenceStencilLayoutKHR l, in VkAttachmentReferenceStencilLayoutKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.StencilLayout == r.StencilLayout)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkAttachmentReferenceStencilLayoutKHR l, in VkAttachmentReferenceStencilLayoutKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.StencilLayout != r.StencilLayout)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkAttachmentReferenceStencilLayoutKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkAttachmentDescriptionStencilLayoutKHR : IEquatable<VkAttachmentDescriptionStencilLayoutKHR>
{
	public const VkStructureType TYPE = VkStructureType.AttachmentDescriptionStencilLayout;

	public VkStructureType sType;
	public void* pNext;
	public VkImageLayout StencilInitialLayout;
	public VkImageLayout StencilFinalLayout;

	public VkAttachmentDescriptionStencilLayoutKHR(
		VkImageLayout stencilInitialLayout = default,
		VkImageLayout stencilFinalLayout = default
	) {
		sType = TYPE;
		pNext = null;
		StencilInitialLayout = stencilInitialLayout;
		StencilFinalLayout = stencilFinalLayout;
	}

	public readonly override bool Equals(object? o) => (o is VkAttachmentDescriptionStencilLayoutKHR s) && (this == s);
	readonly bool IEquatable<VkAttachmentDescriptionStencilLayoutKHR>.Equals(VkAttachmentDescriptionStencilLayoutKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ StencilInitialLayout.GetHashCode() ^ StencilFinalLayout.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkAttachmentDescriptionStencilLayoutKHR l, in VkAttachmentDescriptionStencilLayoutKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.StencilInitialLayout == r.StencilInitialLayout) && (l.StencilFinalLayout == r.StencilFinalLayout)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkAttachmentDescriptionStencilLayoutKHR l, in VkAttachmentDescriptionStencilLayoutKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.StencilInitialLayout != r.StencilInitialLayout) || (l.StencilFinalLayout != r.StencilFinalLayout)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkAttachmentDescriptionStencilLayoutKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR : IEquatable<VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDevicePipelineExecutablePropertiesFeaturesKhr;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 PipelineExecutableInfo;

	public VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR(
		VkBool32 pipelineExecutableInfo = default
	) {
		sType = TYPE;
		pNext = null;
		PipelineExecutableInfo = pipelineExecutableInfo;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR s) && (this == s);
	readonly bool IEquatable<VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR>.Equals(VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ PipelineExecutableInfo.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR l, in VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.PipelineExecutableInfo == r.PipelineExecutableInfo)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR l, in VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.PipelineExecutableInfo != r.PipelineExecutableInfo)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPipelineInfoKHR : IEquatable<VkPipelineInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.PipelineInfoKhr;

	public VkStructureType sType;
	public void* pNext;
	public VulkanHandle<VkPipeline> Pipeline;

	public VkPipelineInfoKHR(
		VulkanHandle<VkPipeline> pipeline = default
	) {
		sType = TYPE;
		pNext = null;
		Pipeline = pipeline;
	}

	public readonly override bool Equals(object? o) => (o is VkPipelineInfoKHR s) && (this == s);
	readonly bool IEquatable<VkPipelineInfoKHR>.Equals(VkPipelineInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Pipeline.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPipelineInfoKHR l, in VkPipelineInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Pipeline == r.Pipeline)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPipelineInfoKHR l, in VkPipelineInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Pipeline != r.Pipeline)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPipelineInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPipelineExecutablePropertiesKHR : IEquatable<VkPipelineExecutablePropertiesKHR>
{
	public const VkStructureType TYPE = VkStructureType.PipelineExecutablePropertiesKhr;

	public VkStructureType sType;
	public void* pNext;
	public VkShaderStageFlags Stages;
	public VVK.Description Name;
	public VVK.Description Description;
	public uint SubgroupSize;

	public VkPipelineExecutablePropertiesKHR(
		VkShaderStageFlags stages = default,
		VVK.Description name = default,
		VVK.Description description = default,
		uint subgroupSize = default
	) {
		sType = TYPE;
		pNext = null;
		Stages = stages;
		Name = name;
		Description = description;
		SubgroupSize = subgroupSize;
	}

	public readonly override bool Equals(object? o) => (o is VkPipelineExecutablePropertiesKHR s) && (this == s);
	readonly bool IEquatable<VkPipelineExecutablePropertiesKHR>.Equals(VkPipelineExecutablePropertiesKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Stages.GetHashCode() ^ Name.GetHashCode()
			^ Description.GetHashCode() ^ SubgroupSize.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPipelineExecutablePropertiesKHR l, in VkPipelineExecutablePropertiesKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Stages == r.Stages) && (l.Name == r.Name)
			&& (l.Description == r.Description) && (l.SubgroupSize == r.SubgroupSize)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPipelineExecutablePropertiesKHR l, in VkPipelineExecutablePropertiesKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Stages != r.Stages) || (l.Name != r.Name)
			|| (l.Description != r.Description) || (l.SubgroupSize != r.SubgroupSize)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPipelineExecutablePropertiesKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPipelineExecutableInfoKHR : IEquatable<VkPipelineExecutableInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.PipelineExecutableInfoKhr;

	public VkStructureType sType;
	public void* pNext;
	public VulkanHandle<VkPipeline> Pipeline;
	public uint ExecutableIndex;

	public VkPipelineExecutableInfoKHR(
		VulkanHandle<VkPipeline> pipeline = default,
		uint executableIndex = default
	) {
		sType = TYPE;
		pNext = null;
		Pipeline = pipeline;
		ExecutableIndex = executableIndex;
	}

	public readonly override bool Equals(object? o) => (o is VkPipelineExecutableInfoKHR s) && (this == s);
	readonly bool IEquatable<VkPipelineExecutableInfoKHR>.Equals(VkPipelineExecutableInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Pipeline.GetHashCode() ^ ExecutableIndex.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPipelineExecutableInfoKHR l, in VkPipelineExecutableInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Pipeline == r.Pipeline) && (l.ExecutableIndex == r.ExecutableIndex)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPipelineExecutableInfoKHR l, in VkPipelineExecutableInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Pipeline != r.Pipeline) || (l.ExecutableIndex != r.ExecutableIndex)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPipelineExecutableInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Explicit)]
public unsafe partial struct VkPipelineExecutableStatisticValueKHR : IEquatable<VkPipelineExecutableStatisticValueKHR>
{
	[FieldOffset(0)]
	public VkBool32 B32;
	[FieldOffset(0)]
	public long I64;
	[FieldOffset(0)]
	public ulong U64;
	[FieldOffset(0)]
	public double F64;

	public VkPipelineExecutableStatisticValueKHR(in VkBool32 b32) : this() => B32 = b32;

	public VkPipelineExecutableStatisticValueKHR(in long i64) : this() => I64 = i64;

	public VkPipelineExecutableStatisticValueKHR(in ulong u64) : this() => U64 = u64;

	public VkPipelineExecutableStatisticValueKHR(in double f64) : this() => F64 = f64;

	public readonly override bool Equals(object? o) => (o is VkPipelineExecutableStatisticValueKHR s) && (this == s);
	readonly bool IEquatable<VkPipelineExecutableStatisticValueKHR>.Equals(VkPipelineExecutableStatisticValueKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			B32.GetHashCode() ^ I64.GetHashCode() ^ U64.GetHashCode() ^ F64.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPipelineExecutableStatisticValueKHR l, in VkPipelineExecutableStatisticValueKHR r)
	{
		return
			(l.B32 == r.B32) && (l.I64 == r.I64) && (l.U64 == r.U64) && (l.F64 == r.F64)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPipelineExecutableStatisticValueKHR l, in VkPipelineExecutableStatisticValueKHR r)
	{
		return
			(l.B32 != r.B32) || (l.I64 != r.I64) || (l.U64 != r.U64) || (l.F64 != r.F64)
			;
	}

}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPipelineExecutableStatisticKHR : IEquatable<VkPipelineExecutableStatisticKHR>
{
	public const VkStructureType TYPE = VkStructureType.PipelineExecutableStatisticKhr;

	public VkStructureType sType;
	public void* pNext;
	public VVK.Description Name;
	public VVK.Description Description;
	public VkPipelineExecutableStatisticFormatKHR Format;
	public VkPipelineExecutableStatisticValueKHR Value;

	public VkPipelineExecutableStatisticKHR(
		VVK.Description name = default,
		VVK.Description description = default,
		VkPipelineExecutableStatisticFormatKHR format = default,
		VkPipelineExecutableStatisticValueKHR value = default
	) {
		sType = TYPE;
		pNext = null;
		Name = name;
		Description = description;
		Format = format;
		Value = value;
	}

	public readonly override bool Equals(object? o) => (o is VkPipelineExecutableStatisticKHR s) && (this == s);
	readonly bool IEquatable<VkPipelineExecutableStatisticKHR>.Equals(VkPipelineExecutableStatisticKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Name.GetHashCode() ^ Description.GetHashCode()
			^ Format.GetHashCode() ^ Value.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPipelineExecutableStatisticKHR l, in VkPipelineExecutableStatisticKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Name == r.Name) && (l.Description == r.Description)
			&& (l.Format == r.Format) && (l.Value == r.Value)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPipelineExecutableStatisticKHR l, in VkPipelineExecutableStatisticKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Name != r.Name) || (l.Description != r.Description)
			|| (l.Format != r.Format) || (l.Value != r.Value)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPipelineExecutableStatisticKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPipelineExecutableInternalRepresentationKHR : IEquatable<VkPipelineExecutableInternalRepresentationKHR>
{
	public const VkStructureType TYPE = VkStructureType.PipelineExecutableInternalRepresentationKhr;

	public VkStructureType sType;
	public void* pNext;
	public VVK.Description Name;
	public VVK.Description Description;
	public VkBool32 IsText;
	public ulong DataSize;
	public void* Data;

	public VkPipelineExecutableInternalRepresentationKHR(
		VVK.Description name = default,
		VVK.Description description = default,
		VkBool32 isText = default,
		ulong dataSize = default,
		void* data = default
	) {
		sType = TYPE;
		pNext = null;
		Name = name;
		Description = description;
		IsText = isText;
		DataSize = dataSize;
		Data = data;
	}

	public readonly override bool Equals(object? o) => (o is VkPipelineExecutableInternalRepresentationKHR s) && (this == s);
	readonly bool IEquatable<VkPipelineExecutableInternalRepresentationKHR>.Equals(VkPipelineExecutableInternalRepresentationKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Name.GetHashCode() ^ Description.GetHashCode()
			^ IsText.GetHashCode() ^ DataSize.GetHashCode() ^ ((ulong)Data).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPipelineExecutableInternalRepresentationKHR l, in VkPipelineExecutableInternalRepresentationKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Name == r.Name) && (l.Description == r.Description)
			&& (l.IsText == r.IsText) && (l.DataSize == r.DataSize) && (l.Data == r.Data)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPipelineExecutableInternalRepresentationKHR l, in VkPipelineExecutableInternalRepresentationKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Name != r.Name) || (l.Description != r.Description)
			|| (l.IsText != r.IsText) || (l.DataSize != r.DataSize) || (l.Data != r.Data)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPipelineExecutableInternalRepresentationKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkMemoryOpaqueCaptureAddressAllocateInfoKHR : IEquatable<VkMemoryOpaqueCaptureAddressAllocateInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.MemoryOpaqueCaptureAddressAllocateInfo;

	public VkStructureType sType;
	public void* pNext;
	public ulong OpaqueCaptureAddress;

	public VkMemoryOpaqueCaptureAddressAllocateInfoKHR(
		ulong opaqueCaptureAddress = default
	) {
		sType = TYPE;
		pNext = null;
		OpaqueCaptureAddress = opaqueCaptureAddress;
	}

	public readonly override bool Equals(object? o) => (o is VkMemoryOpaqueCaptureAddressAllocateInfoKHR s) && (this == s);
	readonly bool IEquatable<VkMemoryOpaqueCaptureAddressAllocateInfoKHR>.Equals(VkMemoryOpaqueCaptureAddressAllocateInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ OpaqueCaptureAddress.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkMemoryOpaqueCaptureAddressAllocateInfoKHR l, in VkMemoryOpaqueCaptureAddressAllocateInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.OpaqueCaptureAddress == r.OpaqueCaptureAddress)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkMemoryOpaqueCaptureAddressAllocateInfoKHR l, in VkMemoryOpaqueCaptureAddressAllocateInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.OpaqueCaptureAddress != r.OpaqueCaptureAddress)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkMemoryOpaqueCaptureAddressAllocateInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDeviceMemoryOpaqueCaptureAddressInfoKHR : IEquatable<VkDeviceMemoryOpaqueCaptureAddressInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.DeviceMemoryOpaqueCaptureAddressInfo;

	public VkStructureType sType;
	public void* pNext;
	public VulkanHandle<VkDeviceMemory> Memory;

	public VkDeviceMemoryOpaqueCaptureAddressInfoKHR(
		VulkanHandle<VkDeviceMemory> memory = default
	) {
		sType = TYPE;
		pNext = null;
		Memory = memory;
	}

	public readonly override bool Equals(object? o) => (o is VkDeviceMemoryOpaqueCaptureAddressInfoKHR s) && (this == s);
	readonly bool IEquatable<VkDeviceMemoryOpaqueCaptureAddressInfoKHR>.Equals(VkDeviceMemoryOpaqueCaptureAddressInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Memory.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDeviceMemoryOpaqueCaptureAddressInfoKHR l, in VkDeviceMemoryOpaqueCaptureAddressInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Memory == r.Memory)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDeviceMemoryOpaqueCaptureAddressInfoKHR l, in VkDeviceMemoryOpaqueCaptureAddressInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Memory != r.Memory)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDeviceMemoryOpaqueCaptureAddressInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Explicit)]
public unsafe partial struct VkDeviceOrHostAddressKHR : IEquatable<VkDeviceOrHostAddressKHR>
{
	[FieldOffset(0)]
	public ulong DeviceAddress;
	[FieldOffset(0)]
	public void* HostAddress;

	public VkDeviceOrHostAddressKHR(in ulong deviceAddress) : this() => DeviceAddress = deviceAddress;

	public VkDeviceOrHostAddressKHR(in void* hostAddress) : this() => HostAddress = hostAddress;

	public readonly override bool Equals(object? o) => (o is VkDeviceOrHostAddressKHR s) && (this == s);
	readonly bool IEquatable<VkDeviceOrHostAddressKHR>.Equals(VkDeviceOrHostAddressKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			DeviceAddress.GetHashCode() ^ ((ulong)HostAddress).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDeviceOrHostAddressKHR l, in VkDeviceOrHostAddressKHR r)
	{
		return
			(l.DeviceAddress == r.DeviceAddress) && (l.HostAddress == r.HostAddress)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDeviceOrHostAddressKHR l, in VkDeviceOrHostAddressKHR r)
	{
		return
			(l.DeviceAddress != r.DeviceAddress) || (l.HostAddress != r.HostAddress)
			;
	}

}

[StructLayout(LayoutKind.Explicit)]
public unsafe partial struct VkDeviceOrHostAddressConstKHR : IEquatable<VkDeviceOrHostAddressConstKHR>
{
	[FieldOffset(0)]
	public ulong DeviceAddress;
	[FieldOffset(0)]
	public void* HostAddress;

	public VkDeviceOrHostAddressConstKHR(in ulong deviceAddress) : this() => DeviceAddress = deviceAddress;

	public VkDeviceOrHostAddressConstKHR(in void* hostAddress) : this() => HostAddress = hostAddress;

	public readonly override bool Equals(object? o) => (o is VkDeviceOrHostAddressConstKHR s) && (this == s);
	readonly bool IEquatable<VkDeviceOrHostAddressConstKHR>.Equals(VkDeviceOrHostAddressConstKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			DeviceAddress.GetHashCode() ^ ((ulong)HostAddress).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDeviceOrHostAddressConstKHR l, in VkDeviceOrHostAddressConstKHR r)
	{
		return
			(l.DeviceAddress == r.DeviceAddress) && (l.HostAddress == r.HostAddress)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDeviceOrHostAddressConstKHR l, in VkDeviceOrHostAddressConstKHR r)
	{
		return
			(l.DeviceAddress != r.DeviceAddress) || (l.HostAddress != r.HostAddress)
			;
	}

}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkAccelerationStructureGeometryTrianglesDataKHR : IEquatable<VkAccelerationStructureGeometryTrianglesDataKHR>
{
	public const VkStructureType TYPE = VkStructureType.AccelerationStructureGeometryTrianglesDataKhr;

	public VkStructureType sType;
	public void* pNext;
	public VkFormat VertexFormat;
	public VkDeviceOrHostAddressConstKHR VertexData;
	public ulong VertexStride;
	public uint MaxVertex;
	public VkIndexType IndexType;
	public VkDeviceOrHostAddressConstKHR IndexData;
	public VkDeviceOrHostAddressConstKHR TransformData;

	public VkAccelerationStructureGeometryTrianglesDataKHR(
		VkFormat vertexFormat = default,
		VkDeviceOrHostAddressConstKHR vertexData = default,
		ulong vertexStride = default,
		uint maxVertex = default,
		VkIndexType indexType = default,
		VkDeviceOrHostAddressConstKHR indexData = default,
		VkDeviceOrHostAddressConstKHR transformData = default
	) {
		sType = TYPE;
		pNext = null;
		VertexFormat = vertexFormat;
		VertexData = vertexData;
		VertexStride = vertexStride;
		MaxVertex = maxVertex;
		IndexType = indexType;
		IndexData = indexData;
		TransformData = transformData;
	}

	public readonly override bool Equals(object? o) => (o is VkAccelerationStructureGeometryTrianglesDataKHR s) && (this == s);
	readonly bool IEquatable<VkAccelerationStructureGeometryTrianglesDataKHR>.Equals(VkAccelerationStructureGeometryTrianglesDataKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ VertexFormat.GetHashCode() ^ VertexData.GetHashCode()
			^ VertexStride.GetHashCode() ^ MaxVertex.GetHashCode() ^ IndexType.GetHashCode() ^ IndexData.GetHashCode()
			^ TransformData.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkAccelerationStructureGeometryTrianglesDataKHR l, in VkAccelerationStructureGeometryTrianglesDataKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.VertexFormat == r.VertexFormat) && (l.VertexData == r.VertexData)
			&& (l.VertexStride == r.VertexStride) && (l.MaxVertex == r.MaxVertex) && (l.IndexType == r.IndexType) && (l.IndexData == r.IndexData)
			&& (l.TransformData == r.TransformData)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkAccelerationStructureGeometryTrianglesDataKHR l, in VkAccelerationStructureGeometryTrianglesDataKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.VertexFormat != r.VertexFormat) || (l.VertexData != r.VertexData)
			|| (l.VertexStride != r.VertexStride) || (l.MaxVertex != r.MaxVertex) || (l.IndexType != r.IndexType) || (l.IndexData != r.IndexData)
			|| (l.TransformData != r.TransformData)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkAccelerationStructureGeometryTrianglesDataKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkAccelerationStructureGeometryAabbsDataKHR : IEquatable<VkAccelerationStructureGeometryAabbsDataKHR>
{
	public const VkStructureType TYPE = VkStructureType.AccelerationStructureGeometryAabbsDataKhr;

	public VkStructureType sType;
	public void* pNext;
	public VkDeviceOrHostAddressConstKHR Data;
	public ulong Stride;

	public VkAccelerationStructureGeometryAabbsDataKHR(
		VkDeviceOrHostAddressConstKHR data = default,
		ulong stride = default
	) {
		sType = TYPE;
		pNext = null;
		Data = data;
		Stride = stride;
	}

	public readonly override bool Equals(object? o) => (o is VkAccelerationStructureGeometryAabbsDataKHR s) && (this == s);
	readonly bool IEquatable<VkAccelerationStructureGeometryAabbsDataKHR>.Equals(VkAccelerationStructureGeometryAabbsDataKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Data.GetHashCode() ^ Stride.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkAccelerationStructureGeometryAabbsDataKHR l, in VkAccelerationStructureGeometryAabbsDataKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Data == r.Data) && (l.Stride == r.Stride)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkAccelerationStructureGeometryAabbsDataKHR l, in VkAccelerationStructureGeometryAabbsDataKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Data != r.Data) || (l.Stride != r.Stride)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkAccelerationStructureGeometryAabbsDataKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkAccelerationStructureGeometryInstancesDataKHR : IEquatable<VkAccelerationStructureGeometryInstancesDataKHR>
{
	public const VkStructureType TYPE = VkStructureType.AccelerationStructureGeometryInstancesDataKhr;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 ArrayOfPointers;
	public VkDeviceOrHostAddressConstKHR Data;

	public VkAccelerationStructureGeometryInstancesDataKHR(
		VkBool32 arrayOfPointers = default,
		VkDeviceOrHostAddressConstKHR data = default
	) {
		sType = TYPE;
		pNext = null;
		ArrayOfPointers = arrayOfPointers;
		Data = data;
	}

	public readonly override bool Equals(object? o) => (o is VkAccelerationStructureGeometryInstancesDataKHR s) && (this == s);
	readonly bool IEquatable<VkAccelerationStructureGeometryInstancesDataKHR>.Equals(VkAccelerationStructureGeometryInstancesDataKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ArrayOfPointers.GetHashCode() ^ Data.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkAccelerationStructureGeometryInstancesDataKHR l, in VkAccelerationStructureGeometryInstancesDataKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ArrayOfPointers == r.ArrayOfPointers) && (l.Data == r.Data)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkAccelerationStructureGeometryInstancesDataKHR l, in VkAccelerationStructureGeometryInstancesDataKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ArrayOfPointers != r.ArrayOfPointers) || (l.Data != r.Data)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkAccelerationStructureGeometryInstancesDataKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Explicit)]
public unsafe partial struct VkAccelerationStructureGeometryDataKHR : IEquatable<VkAccelerationStructureGeometryDataKHR>
{
	[FieldOffset(0)]
	public VkAccelerationStructureGeometryTrianglesDataKHR Triangles;
	[FieldOffset(0)]
	public VkAccelerationStructureGeometryAabbsDataKHR Aabbs;
	[FieldOffset(0)]
	public VkAccelerationStructureGeometryInstancesDataKHR Instances;

	public VkAccelerationStructureGeometryDataKHR(in VkAccelerationStructureGeometryTrianglesDataKHR triangles) : this() => Triangles = triangles;

	public VkAccelerationStructureGeometryDataKHR(in VkAccelerationStructureGeometryAabbsDataKHR aabbs) : this() => Aabbs = aabbs;

	public VkAccelerationStructureGeometryDataKHR(in VkAccelerationStructureGeometryInstancesDataKHR instances) : this() => Instances = instances;

	public readonly override bool Equals(object? o) => (o is VkAccelerationStructureGeometryDataKHR s) && (this == s);
	readonly bool IEquatable<VkAccelerationStructureGeometryDataKHR>.Equals(VkAccelerationStructureGeometryDataKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Triangles.GetHashCode() ^ Aabbs.GetHashCode() ^ Instances.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkAccelerationStructureGeometryDataKHR l, in VkAccelerationStructureGeometryDataKHR r)
	{
		return
			(l.Triangles == r.Triangles) && (l.Aabbs == r.Aabbs) && (l.Instances == r.Instances)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkAccelerationStructureGeometryDataKHR l, in VkAccelerationStructureGeometryDataKHR r)
	{
		return
			(l.Triangles != r.Triangles) || (l.Aabbs != r.Aabbs) || (l.Instances != r.Instances)
			;
	}

}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkAccelerationStructureGeometryKHR : IEquatable<VkAccelerationStructureGeometryKHR>
{
	public const VkStructureType TYPE = VkStructureType.AccelerationStructureGeometryKhr;

	public VkStructureType sType;
	public void* pNext;
	public VkGeometryTypeKHR GeometryType;
	public VkAccelerationStructureGeometryDataKHR Geometry;
	public VkGeometryFlagsKHR Flags;

	public VkAccelerationStructureGeometryKHR(
		VkGeometryTypeKHR geometryType = default,
		VkAccelerationStructureGeometryDataKHR geometry = default,
		VkGeometryFlagsKHR flags = default
	) {
		sType = TYPE;
		pNext = null;
		GeometryType = geometryType;
		Geometry = geometry;
		Flags = flags;
	}

	public readonly override bool Equals(object? o) => (o is VkAccelerationStructureGeometryKHR s) && (this == s);
	readonly bool IEquatable<VkAccelerationStructureGeometryKHR>.Equals(VkAccelerationStructureGeometryKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ GeometryType.GetHashCode() ^ Geometry.GetHashCode()
			^ Flags.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkAccelerationStructureGeometryKHR l, in VkAccelerationStructureGeometryKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.GeometryType == r.GeometryType) && (l.Geometry == r.Geometry)
			&& (l.Flags == r.Flags)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkAccelerationStructureGeometryKHR l, in VkAccelerationStructureGeometryKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.GeometryType != r.GeometryType) || (l.Geometry != r.Geometry)
			|| (l.Flags != r.Flags)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkAccelerationStructureGeometryKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkAccelerationStructureBuildGeometryInfoKHR : IEquatable<VkAccelerationStructureBuildGeometryInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.AccelerationStructureBuildGeometryInfoKhr;

	public VkStructureType sType;
	public void* pNext;
	public VkAccelerationStructureTypeKHR Type;
	public VkBuildAccelerationStructureFlagsKHR Flags;
	public VkBuildAccelerationStructureModeKHR Mode;
	public VulkanHandle<VkAccelerationStructureKHR> SrcAccelerationStructure;
	public VulkanHandle<VkAccelerationStructureKHR> DstAccelerationStructure;
	public uint GeometryCount;
	public VkAccelerationStructureGeometryKHR* Geometries;
	public VkAccelerationStructureGeometryKHR** GeometriesPtr;
	public VkDeviceOrHostAddressKHR ScratchData;

	public VkAccelerationStructureBuildGeometryInfoKHR(
		VkAccelerationStructureTypeKHR type = default,
		VkBuildAccelerationStructureFlagsKHR flags = default,
		VkBuildAccelerationStructureModeKHR mode = default,
		VulkanHandle<VkAccelerationStructureKHR> srcAccelerationStructure = default,
		VulkanHandle<VkAccelerationStructureKHR> dstAccelerationStructure = default,
		uint geometryCount = default,
		VkAccelerationStructureGeometryKHR* geometries = default,
		VkAccelerationStructureGeometryKHR** geometriesPtr = default,
		VkDeviceOrHostAddressKHR scratchData = default
	) {
		sType = TYPE;
		pNext = null;
		Type = type;
		Flags = flags;
		Mode = mode;
		SrcAccelerationStructure = srcAccelerationStructure;
		DstAccelerationStructure = dstAccelerationStructure;
		GeometryCount = geometryCount;
		Geometries = geometries;
		GeometriesPtr = geometriesPtr;
		ScratchData = scratchData;
	}

	public readonly override bool Equals(object? o) => (o is VkAccelerationStructureBuildGeometryInfoKHR s) && (this == s);
	readonly bool IEquatable<VkAccelerationStructureBuildGeometryInfoKHR>.Equals(VkAccelerationStructureBuildGeometryInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Type.GetHashCode() ^ Flags.GetHashCode()
			^ Mode.GetHashCode() ^ SrcAccelerationStructure.GetHashCode() ^ DstAccelerationStructure.GetHashCode() ^ GeometryCount.GetHashCode()
			^ ((ulong)Geometries).GetHashCode() ^ ((ulong)GeometriesPtr).GetHashCode() ^ ScratchData.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkAccelerationStructureBuildGeometryInfoKHR l, in VkAccelerationStructureBuildGeometryInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Type == r.Type) && (l.Flags == r.Flags)
			&& (l.Mode == r.Mode) && (l.SrcAccelerationStructure == r.SrcAccelerationStructure) && (l.DstAccelerationStructure == r.DstAccelerationStructure) && (l.GeometryCount == r.GeometryCount)
			&& (l.Geometries == r.Geometries) && (l.GeometriesPtr == r.GeometriesPtr) && (l.ScratchData == r.ScratchData)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkAccelerationStructureBuildGeometryInfoKHR l, in VkAccelerationStructureBuildGeometryInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Type != r.Type) || (l.Flags != r.Flags)
			|| (l.Mode != r.Mode) || (l.SrcAccelerationStructure != r.SrcAccelerationStructure) || (l.DstAccelerationStructure != r.DstAccelerationStructure) || (l.GeometryCount != r.GeometryCount)
			|| (l.Geometries != r.Geometries) || (l.GeometriesPtr != r.GeometriesPtr) || (l.ScratchData != r.ScratchData)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkAccelerationStructureBuildGeometryInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkAccelerationStructureBuildRangeInfoKHR : IEquatable<VkAccelerationStructureBuildRangeInfoKHR>
{
	public uint PrimitiveCount;
	public uint PrimitiveOffset;
	public uint FirstVertex;
	public uint TransformOffset;

	public VkAccelerationStructureBuildRangeInfoKHR(
		uint primitiveCount = default,
		uint primitiveOffset = default,
		uint firstVertex = default,
		uint transformOffset = default
	) {
		PrimitiveCount = primitiveCount;
		PrimitiveOffset = primitiveOffset;
		FirstVertex = firstVertex;
		TransformOffset = transformOffset;
	}

	public readonly override bool Equals(object? o) => (o is VkAccelerationStructureBuildRangeInfoKHR s) && (this == s);
	readonly bool IEquatable<VkAccelerationStructureBuildRangeInfoKHR>.Equals(VkAccelerationStructureBuildRangeInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			PrimitiveCount.GetHashCode() ^ PrimitiveOffset.GetHashCode() ^ FirstVertex.GetHashCode() ^ TransformOffset.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkAccelerationStructureBuildRangeInfoKHR l, in VkAccelerationStructureBuildRangeInfoKHR r)
	{
		return
			(l.PrimitiveCount == r.PrimitiveCount) && (l.PrimitiveOffset == r.PrimitiveOffset) && (l.FirstVertex == r.FirstVertex) && (l.TransformOffset == r.TransformOffset)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkAccelerationStructureBuildRangeInfoKHR l, in VkAccelerationStructureBuildRangeInfoKHR r)
	{
		return
			(l.PrimitiveCount != r.PrimitiveCount) || (l.PrimitiveOffset != r.PrimitiveOffset) || (l.FirstVertex != r.FirstVertex) || (l.TransformOffset != r.TransformOffset)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkAccelerationStructureBuildRangeInfoKHR s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkAccelerationStructureCreateInfoKHR : IEquatable<VkAccelerationStructureCreateInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.AccelerationStructureCreateInfoKhr;

	public VkStructureType sType;
	public void* pNext;
	public VkAccelerationStructureCreateFlagsKHR CreateFlags;
	public VulkanHandle<VkBuffer> Buffer;
	public ulong Offset;
	public ulong Size;
	public VkAccelerationStructureTypeKHR Type;
	public ulong DeviceAddress;

	public VkAccelerationStructureCreateInfoKHR(
		VkAccelerationStructureCreateFlagsKHR createFlags = default,
		VulkanHandle<VkBuffer> buffer = default,
		ulong offset = default,
		ulong size = default,
		VkAccelerationStructureTypeKHR type = default,
		ulong deviceAddress = default
	) {
		sType = TYPE;
		pNext = null;
		CreateFlags = createFlags;
		Buffer = buffer;
		Offset = offset;
		Size = size;
		Type = type;
		DeviceAddress = deviceAddress;
	}

	public readonly override bool Equals(object? o) => (o is VkAccelerationStructureCreateInfoKHR s) && (this == s);
	readonly bool IEquatable<VkAccelerationStructureCreateInfoKHR>.Equals(VkAccelerationStructureCreateInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ CreateFlags.GetHashCode() ^ Buffer.GetHashCode()
			^ Offset.GetHashCode() ^ Size.GetHashCode() ^ Type.GetHashCode() ^ DeviceAddress.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkAccelerationStructureCreateInfoKHR l, in VkAccelerationStructureCreateInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.CreateFlags == r.CreateFlags) && (l.Buffer == r.Buffer)
			&& (l.Offset == r.Offset) && (l.Size == r.Size) && (l.Type == r.Type) && (l.DeviceAddress == r.DeviceAddress)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkAccelerationStructureCreateInfoKHR l, in VkAccelerationStructureCreateInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.CreateFlags != r.CreateFlags) || (l.Buffer != r.Buffer)
			|| (l.Offset != r.Offset) || (l.Size != r.Size) || (l.Type != r.Type) || (l.DeviceAddress != r.DeviceAddress)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkAccelerationStructureCreateInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkAabbPositionsKHR : IEquatable<VkAabbPositionsKHR>
{
	public float MinX;
	public float MinY;
	public float MinZ;
	public float MaxX;
	public float MaxY;
	public float MaxZ;

	public VkAabbPositionsKHR(
		float minX = default,
		float minY = default,
		float minZ = default,
		float maxX = default,
		float maxY = default,
		float maxZ = default
	) {
		MinX = minX;
		MinY = minY;
		MinZ = minZ;
		MaxX = maxX;
		MaxY = maxY;
		MaxZ = maxZ;
	}

	public readonly override bool Equals(object? o) => (o is VkAabbPositionsKHR s) && (this == s);
	readonly bool IEquatable<VkAabbPositionsKHR>.Equals(VkAabbPositionsKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			MinX.GetHashCode() ^ MinY.GetHashCode() ^ MinZ.GetHashCode() ^ MaxX.GetHashCode()
			^ MaxY.GetHashCode() ^ MaxZ.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkAabbPositionsKHR l, in VkAabbPositionsKHR r)
	{
		return
			(l.MinX == r.MinX) && (l.MinY == r.MinY) && (l.MinZ == r.MinZ) && (l.MaxX == r.MaxX)
			&& (l.MaxY == r.MaxY) && (l.MaxZ == r.MaxZ)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkAabbPositionsKHR l, in VkAabbPositionsKHR r)
	{
		return
			(l.MinX != r.MinX) || (l.MinY != r.MinY) || (l.MinZ != r.MinZ) || (l.MaxX != r.MaxX)
			|| (l.MaxY != r.MaxY) || (l.MaxZ != r.MaxZ)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkAabbPositionsKHR s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkTransformMatrixKHR : IEquatable<VkTransformMatrixKHR>
{
	public fixed float Matrix[12];

	public VkTransformMatrixKHR(
		float matrix_0 = default,
		float matrix_1 = default,
		float matrix_2 = default,
		float matrix_3 = default,
		float matrix_4 = default,
		float matrix_5 = default,
		float matrix_6 = default,
		float matrix_7 = default,
		float matrix_8 = default,
		float matrix_9 = default,
		float matrix_10 = default,
		float matrix_11 = default
	) {
		Matrix[0] = matrix_0;
		Matrix[1] = matrix_1;
		Matrix[2] = matrix_2;
		Matrix[3] = matrix_3;
		Matrix[4] = matrix_4;
		Matrix[5] = matrix_5;
		Matrix[6] = matrix_6;
		Matrix[7] = matrix_7;
		Matrix[8] = matrix_8;
		Matrix[9] = matrix_9;
		Matrix[10] = matrix_10;
		Matrix[11] = matrix_11;
	}

	public readonly override bool Equals(object? o) => (o is VkTransformMatrixKHR s) && (this == s);
	readonly bool IEquatable<VkTransformMatrixKHR>.Equals(VkTransformMatrixKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Matrix[0].GetHashCode() ^ Matrix[1].GetHashCode() ^ Matrix[2].GetHashCode() ^ Matrix[3].GetHashCode()
			^ Matrix[4].GetHashCode() ^ Matrix[5].GetHashCode() ^ Matrix[6].GetHashCode() ^ Matrix[7].GetHashCode()
			^ Matrix[8].GetHashCode() ^ Matrix[9].GetHashCode() ^ Matrix[10].GetHashCode() ^ Matrix[11].GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkTransformMatrixKHR l, in VkTransformMatrixKHR r)
	{
		return
			(l.Matrix[0] == r.Matrix[0]) && (l.Matrix[1] == r.Matrix[1]) && (l.Matrix[2] == r.Matrix[2]) && (l.Matrix[3] == r.Matrix[3])
			&& (l.Matrix[4] == r.Matrix[4]) && (l.Matrix[5] == r.Matrix[5]) && (l.Matrix[6] == r.Matrix[6]) && (l.Matrix[7] == r.Matrix[7])
			&& (l.Matrix[8] == r.Matrix[8]) && (l.Matrix[9] == r.Matrix[9]) && (l.Matrix[10] == r.Matrix[10]) && (l.Matrix[11] == r.Matrix[11])
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkTransformMatrixKHR l, in VkTransformMatrixKHR r)
	{
		return
			(l.Matrix[0] != r.Matrix[0]) || (l.Matrix[1] != r.Matrix[1]) || (l.Matrix[2] != r.Matrix[2]) || (l.Matrix[3] != r.Matrix[3])
			|| (l.Matrix[4] != r.Matrix[4]) || (l.Matrix[5] != r.Matrix[5]) || (l.Matrix[6] != r.Matrix[6]) || (l.Matrix[7] != r.Matrix[7])
			|| (l.Matrix[8] != r.Matrix[8]) || (l.Matrix[9] != r.Matrix[9]) || (l.Matrix[10] != r.Matrix[10]) || (l.Matrix[11] != r.Matrix[11])
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkTransformMatrixKHR s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkAccelerationStructureInstanceKHR : IEquatable<VkAccelerationStructureInstanceKHR>
{
	public VkTransformMatrixKHR Transform;
	public uint InstanceCustomIndex;
	public uint Mask;
	public uint InstanceShaderBindingTableRecordOffset;
	public VkGeometryInstanceFlagsKHR Flags;
	public ulong AccelerationStructureReference;

	public VkAccelerationStructureInstanceKHR(
		VkTransformMatrixKHR transform = default,
		uint instanceCustomIndex = default,
		uint mask = default,
		uint instanceShaderBindingTableRecordOffset = default,
		VkGeometryInstanceFlagsKHR flags = default,
		ulong accelerationStructureReference = default
	) {
		Transform = transform;
		InstanceCustomIndex = instanceCustomIndex;
		Mask = mask;
		InstanceShaderBindingTableRecordOffset = instanceShaderBindingTableRecordOffset;
		Flags = flags;
		AccelerationStructureReference = accelerationStructureReference;
	}

	public readonly override bool Equals(object? o) => (o is VkAccelerationStructureInstanceKHR s) && (this == s);
	readonly bool IEquatable<VkAccelerationStructureInstanceKHR>.Equals(VkAccelerationStructureInstanceKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Transform.GetHashCode() ^ InstanceCustomIndex.GetHashCode() ^ Mask.GetHashCode() ^ InstanceShaderBindingTableRecordOffset.GetHashCode()
			^ Flags.GetHashCode() ^ AccelerationStructureReference.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkAccelerationStructureInstanceKHR l, in VkAccelerationStructureInstanceKHR r)
	{
		return
			(l.Transform == r.Transform) && (l.InstanceCustomIndex == r.InstanceCustomIndex) && (l.Mask == r.Mask) && (l.InstanceShaderBindingTableRecordOffset == r.InstanceShaderBindingTableRecordOffset)
			&& (l.Flags == r.Flags) && (l.AccelerationStructureReference == r.AccelerationStructureReference)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkAccelerationStructureInstanceKHR l, in VkAccelerationStructureInstanceKHR r)
	{
		return
			(l.Transform != r.Transform) || (l.InstanceCustomIndex != r.InstanceCustomIndex) || (l.Mask != r.Mask) || (l.InstanceShaderBindingTableRecordOffset != r.InstanceShaderBindingTableRecordOffset)
			|| (l.Flags != r.Flags) || (l.AccelerationStructureReference != r.AccelerationStructureReference)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkAccelerationStructureInstanceKHR s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkAccelerationStructureDeviceAddressInfoKHR : IEquatable<VkAccelerationStructureDeviceAddressInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.AccelerationStructureDeviceAddressInfoKhr;

	public VkStructureType sType;
	public void* pNext;
	public VulkanHandle<VkAccelerationStructureKHR> AccelerationStructure;

	public VkAccelerationStructureDeviceAddressInfoKHR(
		VulkanHandle<VkAccelerationStructureKHR> accelerationStructure = default
	) {
		sType = TYPE;
		pNext = null;
		AccelerationStructure = accelerationStructure;
	}

	public readonly override bool Equals(object? o) => (o is VkAccelerationStructureDeviceAddressInfoKHR s) && (this == s);
	readonly bool IEquatable<VkAccelerationStructureDeviceAddressInfoKHR>.Equals(VkAccelerationStructureDeviceAddressInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ AccelerationStructure.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkAccelerationStructureDeviceAddressInfoKHR l, in VkAccelerationStructureDeviceAddressInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.AccelerationStructure == r.AccelerationStructure)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkAccelerationStructureDeviceAddressInfoKHR l, in VkAccelerationStructureDeviceAddressInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.AccelerationStructure != r.AccelerationStructure)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkAccelerationStructureDeviceAddressInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkAccelerationStructureVersionInfoKHR : IEquatable<VkAccelerationStructureVersionInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.AccelerationStructureVersionInfoKhr;

	public VkStructureType sType;
	public void* pNext;
	public byte* VersionData;

	public VkAccelerationStructureVersionInfoKHR(
		byte* versionData = default
	) {
		sType = TYPE;
		pNext = null;
		VersionData = versionData;
	}

	public readonly override bool Equals(object? o) => (o is VkAccelerationStructureVersionInfoKHR s) && (this == s);
	readonly bool IEquatable<VkAccelerationStructureVersionInfoKHR>.Equals(VkAccelerationStructureVersionInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ((ulong)VersionData).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkAccelerationStructureVersionInfoKHR l, in VkAccelerationStructureVersionInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.VersionData == r.VersionData)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkAccelerationStructureVersionInfoKHR l, in VkAccelerationStructureVersionInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.VersionData != r.VersionData)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkAccelerationStructureVersionInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkCopyAccelerationStructureInfoKHR : IEquatable<VkCopyAccelerationStructureInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.CopyAccelerationStructureInfoKhr;

	public VkStructureType sType;
	public void* pNext;
	public VulkanHandle<VkAccelerationStructureKHR> Src;
	public VulkanHandle<VkAccelerationStructureKHR> Dst;
	public VkCopyAccelerationStructureModeKHR Mode;

	public VkCopyAccelerationStructureInfoKHR(
		VulkanHandle<VkAccelerationStructureKHR> src = default,
		VulkanHandle<VkAccelerationStructureKHR> dst = default,
		VkCopyAccelerationStructureModeKHR mode = default
	) {
		sType = TYPE;
		pNext = null;
		Src = src;
		Dst = dst;
		Mode = mode;
	}

	public readonly override bool Equals(object? o) => (o is VkCopyAccelerationStructureInfoKHR s) && (this == s);
	readonly bool IEquatable<VkCopyAccelerationStructureInfoKHR>.Equals(VkCopyAccelerationStructureInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Src.GetHashCode() ^ Dst.GetHashCode()
			^ Mode.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkCopyAccelerationStructureInfoKHR l, in VkCopyAccelerationStructureInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Src == r.Src) && (l.Dst == r.Dst)
			&& (l.Mode == r.Mode)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkCopyAccelerationStructureInfoKHR l, in VkCopyAccelerationStructureInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Src != r.Src) || (l.Dst != r.Dst)
			|| (l.Mode != r.Mode)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkCopyAccelerationStructureInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkCopyAccelerationStructureToMemoryInfoKHR : IEquatable<VkCopyAccelerationStructureToMemoryInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.CopyAccelerationStructureToMemoryInfoKhr;

	public VkStructureType sType;
	public void* pNext;
	public VulkanHandle<VkAccelerationStructureKHR> Src;
	public VkDeviceOrHostAddressKHR Dst;
	public VkCopyAccelerationStructureModeKHR Mode;

	public VkCopyAccelerationStructureToMemoryInfoKHR(
		VulkanHandle<VkAccelerationStructureKHR> src = default,
		VkDeviceOrHostAddressKHR dst = default,
		VkCopyAccelerationStructureModeKHR mode = default
	) {
		sType = TYPE;
		pNext = null;
		Src = src;
		Dst = dst;
		Mode = mode;
	}

	public readonly override bool Equals(object? o) => (o is VkCopyAccelerationStructureToMemoryInfoKHR s) && (this == s);
	readonly bool IEquatable<VkCopyAccelerationStructureToMemoryInfoKHR>.Equals(VkCopyAccelerationStructureToMemoryInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Src.GetHashCode() ^ Dst.GetHashCode()
			^ Mode.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkCopyAccelerationStructureToMemoryInfoKHR l, in VkCopyAccelerationStructureToMemoryInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Src == r.Src) && (l.Dst == r.Dst)
			&& (l.Mode == r.Mode)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkCopyAccelerationStructureToMemoryInfoKHR l, in VkCopyAccelerationStructureToMemoryInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Src != r.Src) || (l.Dst != r.Dst)
			|| (l.Mode != r.Mode)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkCopyAccelerationStructureToMemoryInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkCopyMemoryToAccelerationStructureInfoKHR : IEquatable<VkCopyMemoryToAccelerationStructureInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.CopyMemoryToAccelerationStructureInfoKhr;

	public VkStructureType sType;
	public void* pNext;
	public VkDeviceOrHostAddressConstKHR Src;
	public VulkanHandle<VkAccelerationStructureKHR> Dst;
	public VkCopyAccelerationStructureModeKHR Mode;

	public VkCopyMemoryToAccelerationStructureInfoKHR(
		VkDeviceOrHostAddressConstKHR src = default,
		VulkanHandle<VkAccelerationStructureKHR> dst = default,
		VkCopyAccelerationStructureModeKHR mode = default
	) {
		sType = TYPE;
		pNext = null;
		Src = src;
		Dst = dst;
		Mode = mode;
	}

	public readonly override bool Equals(object? o) => (o is VkCopyMemoryToAccelerationStructureInfoKHR s) && (this == s);
	readonly bool IEquatable<VkCopyMemoryToAccelerationStructureInfoKHR>.Equals(VkCopyMemoryToAccelerationStructureInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Src.GetHashCode() ^ Dst.GetHashCode()
			^ Mode.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkCopyMemoryToAccelerationStructureInfoKHR l, in VkCopyMemoryToAccelerationStructureInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Src == r.Src) && (l.Dst == r.Dst)
			&& (l.Mode == r.Mode)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkCopyMemoryToAccelerationStructureInfoKHR l, in VkCopyMemoryToAccelerationStructureInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Src != r.Src) || (l.Dst != r.Dst)
			|| (l.Mode != r.Mode)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkCopyMemoryToAccelerationStructureInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkRayTracingPipelineInterfaceCreateInfoKHR : IEquatable<VkRayTracingPipelineInterfaceCreateInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.RayTracingPipelineInterfaceCreateInfoKhr;

	public VkStructureType sType;
	public void* pNext;
	public uint MaxPipelineRayPayloadSize;
	public uint MaxPipelineRayHitAttributeSize;

	public VkRayTracingPipelineInterfaceCreateInfoKHR(
		uint maxPipelineRayPayloadSize = default,
		uint maxPipelineRayHitAttributeSize = default
	) {
		sType = TYPE;
		pNext = null;
		MaxPipelineRayPayloadSize = maxPipelineRayPayloadSize;
		MaxPipelineRayHitAttributeSize = maxPipelineRayHitAttributeSize;
	}

	public readonly override bool Equals(object? o) => (o is VkRayTracingPipelineInterfaceCreateInfoKHR s) && (this == s);
	readonly bool IEquatable<VkRayTracingPipelineInterfaceCreateInfoKHR>.Equals(VkRayTracingPipelineInterfaceCreateInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MaxPipelineRayPayloadSize.GetHashCode() ^ MaxPipelineRayHitAttributeSize.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkRayTracingPipelineInterfaceCreateInfoKHR l, in VkRayTracingPipelineInterfaceCreateInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MaxPipelineRayPayloadSize == r.MaxPipelineRayPayloadSize) && (l.MaxPipelineRayHitAttributeSize == r.MaxPipelineRayHitAttributeSize)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkRayTracingPipelineInterfaceCreateInfoKHR l, in VkRayTracingPipelineInterfaceCreateInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MaxPipelineRayPayloadSize != r.MaxPipelineRayPayloadSize) || (l.MaxPipelineRayHitAttributeSize != r.MaxPipelineRayHitAttributeSize)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkRayTracingPipelineInterfaceCreateInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPipelineLibraryCreateInfoKHR : IEquatable<VkPipelineLibraryCreateInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.PipelineLibraryCreateInfoKhr;

	public VkStructureType sType;
	public void* pNext;
	public uint LibraryCount;
	public VulkanHandle<VkPipeline>* Libraries;

	public VkPipelineLibraryCreateInfoKHR(
		uint libraryCount = default,
		VulkanHandle<VkPipeline>* libraries = default
	) {
		sType = TYPE;
		pNext = null;
		LibraryCount = libraryCount;
		Libraries = libraries;
	}

	public readonly override bool Equals(object? o) => (o is VkPipelineLibraryCreateInfoKHR s) && (this == s);
	readonly bool IEquatable<VkPipelineLibraryCreateInfoKHR>.Equals(VkPipelineLibraryCreateInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ LibraryCount.GetHashCode() ^ ((ulong)Libraries).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPipelineLibraryCreateInfoKHR l, in VkPipelineLibraryCreateInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.LibraryCount == r.LibraryCount) && (l.Libraries == r.Libraries)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPipelineLibraryCreateInfoKHR l, in VkPipelineLibraryCreateInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.LibraryCount != r.LibraryCount) || (l.Libraries != r.Libraries)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPipelineLibraryCreateInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDevicePortabilitySubsetFeaturesKHR : IEquatable<VkPhysicalDevicePortabilitySubsetFeaturesKHR>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDevicePortabilitySubsetFeaturesKhr;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 ConstantAlphaColorBlendFactors;
	public VkBool32 Events;
	public VkBool32 ImageViewFormatReinterpretation;
	public VkBool32 ImageViewFormatSwizzle;
	public VkBool32 ImageView2DOn3DImage;
	public VkBool32 MultisampleArrayImage;
	public VkBool32 MutableComparisonSamplers;
	public VkBool32 PointPolygons;
	public VkBool32 SamplerMipLodBias;
	public VkBool32 SeparateStencilMaskRef;
	public VkBool32 ShaderSampleRateInterpolationFunctions;
	public VkBool32 TessellationIsolines;
	public VkBool32 TessellationPointMode;
	public VkBool32 TriangleFans;
	public VkBool32 VertexAttributeAccessBeyondStride;

	public VkPhysicalDevicePortabilitySubsetFeaturesKHR(
		VkBool32 constantAlphaColorBlendFactors = default,
		VkBool32 events = default,
		VkBool32 imageViewFormatReinterpretation = default,
		VkBool32 imageViewFormatSwizzle = default,
		VkBool32 imageView2DOn3DImage = default,
		VkBool32 multisampleArrayImage = default,
		VkBool32 mutableComparisonSamplers = default,
		VkBool32 pointPolygons = default,
		VkBool32 samplerMipLodBias = default,
		VkBool32 separateStencilMaskRef = default,
		VkBool32 shaderSampleRateInterpolationFunctions = default,
		VkBool32 tessellationIsolines = default,
		VkBool32 tessellationPointMode = default,
		VkBool32 triangleFans = default,
		VkBool32 vertexAttributeAccessBeyondStride = default
	) {
		sType = TYPE;
		pNext = null;
		ConstantAlphaColorBlendFactors = constantAlphaColorBlendFactors;
		Events = events;
		ImageViewFormatReinterpretation = imageViewFormatReinterpretation;
		ImageViewFormatSwizzle = imageViewFormatSwizzle;
		ImageView2DOn3DImage = imageView2DOn3DImage;
		MultisampleArrayImage = multisampleArrayImage;
		MutableComparisonSamplers = mutableComparisonSamplers;
		PointPolygons = pointPolygons;
		SamplerMipLodBias = samplerMipLodBias;
		SeparateStencilMaskRef = separateStencilMaskRef;
		ShaderSampleRateInterpolationFunctions = shaderSampleRateInterpolationFunctions;
		TessellationIsolines = tessellationIsolines;
		TessellationPointMode = tessellationPointMode;
		TriangleFans = triangleFans;
		VertexAttributeAccessBeyondStride = vertexAttributeAccessBeyondStride;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDevicePortabilitySubsetFeaturesKHR s) && (this == s);
	readonly bool IEquatable<VkPhysicalDevicePortabilitySubsetFeaturesKHR>.Equals(VkPhysicalDevicePortabilitySubsetFeaturesKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ConstantAlphaColorBlendFactors.GetHashCode() ^ Events.GetHashCode()
			^ ImageViewFormatReinterpretation.GetHashCode() ^ ImageViewFormatSwizzle.GetHashCode() ^ ImageView2DOn3DImage.GetHashCode() ^ MultisampleArrayImage.GetHashCode()
			^ MutableComparisonSamplers.GetHashCode() ^ PointPolygons.GetHashCode() ^ SamplerMipLodBias.GetHashCode() ^ SeparateStencilMaskRef.GetHashCode()
			^ ShaderSampleRateInterpolationFunctions.GetHashCode() ^ TessellationIsolines.GetHashCode() ^ TessellationPointMode.GetHashCode() ^ TriangleFans.GetHashCode()
			^ VertexAttributeAccessBeyondStride.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDevicePortabilitySubsetFeaturesKHR l, in VkPhysicalDevicePortabilitySubsetFeaturesKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ConstantAlphaColorBlendFactors == r.ConstantAlphaColorBlendFactors) && (l.Events == r.Events)
			&& (l.ImageViewFormatReinterpretation == r.ImageViewFormatReinterpretation) && (l.ImageViewFormatSwizzle == r.ImageViewFormatSwizzle) && (l.ImageView2DOn3DImage == r.ImageView2DOn3DImage) && (l.MultisampleArrayImage == r.MultisampleArrayImage)
			&& (l.MutableComparisonSamplers == r.MutableComparisonSamplers) && (l.PointPolygons == r.PointPolygons) && (l.SamplerMipLodBias == r.SamplerMipLodBias) && (l.SeparateStencilMaskRef == r.SeparateStencilMaskRef)
			&& (l.ShaderSampleRateInterpolationFunctions == r.ShaderSampleRateInterpolationFunctions) && (l.TessellationIsolines == r.TessellationIsolines) && (l.TessellationPointMode == r.TessellationPointMode) && (l.TriangleFans == r.TriangleFans)
			&& (l.VertexAttributeAccessBeyondStride == r.VertexAttributeAccessBeyondStride)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDevicePortabilitySubsetFeaturesKHR l, in VkPhysicalDevicePortabilitySubsetFeaturesKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ConstantAlphaColorBlendFactors != r.ConstantAlphaColorBlendFactors) || (l.Events != r.Events)
			|| (l.ImageViewFormatReinterpretation != r.ImageViewFormatReinterpretation) || (l.ImageViewFormatSwizzle != r.ImageViewFormatSwizzle) || (l.ImageView2DOn3DImage != r.ImageView2DOn3DImage) || (l.MultisampleArrayImage != r.MultisampleArrayImage)
			|| (l.MutableComparisonSamplers != r.MutableComparisonSamplers) || (l.PointPolygons != r.PointPolygons) || (l.SamplerMipLodBias != r.SamplerMipLodBias) || (l.SeparateStencilMaskRef != r.SeparateStencilMaskRef)
			|| (l.ShaderSampleRateInterpolationFunctions != r.ShaderSampleRateInterpolationFunctions) || (l.TessellationIsolines != r.TessellationIsolines) || (l.TessellationPointMode != r.TessellationPointMode) || (l.TriangleFans != r.TriangleFans)
			|| (l.VertexAttributeAccessBeyondStride != r.VertexAttributeAccessBeyondStride)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDevicePortabilitySubsetFeaturesKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDevicePortabilitySubsetPropertiesKHR : IEquatable<VkPhysicalDevicePortabilitySubsetPropertiesKHR>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDevicePortabilitySubsetPropertiesKhr;

	public VkStructureType sType;
	public void* pNext;
	public uint MinVertexInputBindingStrideAlignment;

	public VkPhysicalDevicePortabilitySubsetPropertiesKHR(
		uint minVertexInputBindingStrideAlignment = default
	) {
		sType = TYPE;
		pNext = null;
		MinVertexInputBindingStrideAlignment = minVertexInputBindingStrideAlignment;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDevicePortabilitySubsetPropertiesKHR s) && (this == s);
	readonly bool IEquatable<VkPhysicalDevicePortabilitySubsetPropertiesKHR>.Equals(VkPhysicalDevicePortabilitySubsetPropertiesKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MinVertexInputBindingStrideAlignment.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDevicePortabilitySubsetPropertiesKHR l, in VkPhysicalDevicePortabilitySubsetPropertiesKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MinVertexInputBindingStrideAlignment == r.MinVertexInputBindingStrideAlignment)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDevicePortabilitySubsetPropertiesKHR l, in VkPhysicalDevicePortabilitySubsetPropertiesKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MinVertexInputBindingStrideAlignment != r.MinVertexInputBindingStrideAlignment)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDevicePortabilitySubsetPropertiesKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkBufferCopy2KHR : IEquatable<VkBufferCopy2KHR>
{
	public const VkStructureType TYPE = VkStructureType.BufferCopy2Khr;

	public VkStructureType sType;
	public void* pNext;
	public ulong SrcOffset;
	public ulong DstOffset;
	public ulong Size;

	public VkBufferCopy2KHR(
		ulong srcOffset = default,
		ulong dstOffset = default,
		ulong size = default
	) {
		sType = TYPE;
		pNext = null;
		SrcOffset = srcOffset;
		DstOffset = dstOffset;
		Size = size;
	}

	public readonly override bool Equals(object? o) => (o is VkBufferCopy2KHR s) && (this == s);
	readonly bool IEquatable<VkBufferCopy2KHR>.Equals(VkBufferCopy2KHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SrcOffset.GetHashCode() ^ DstOffset.GetHashCode()
			^ Size.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkBufferCopy2KHR l, in VkBufferCopy2KHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SrcOffset == r.SrcOffset) && (l.DstOffset == r.DstOffset)
			&& (l.Size == r.Size)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkBufferCopy2KHR l, in VkBufferCopy2KHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SrcOffset != r.SrcOffset) || (l.DstOffset != r.DstOffset)
			|| (l.Size != r.Size)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkBufferCopy2KHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkImageCopy2KHR : IEquatable<VkImageCopy2KHR>
{
	public const VkStructureType TYPE = VkStructureType.ImageCopy2Khr;

	public VkStructureType sType;
	public void* pNext;
	public VkImageSubresourceLayers SrcSubresource;
	public VkOffset3D SrcOffset;
	public VkImageSubresourceLayers DstSubresource;
	public VkOffset3D DstOffset;
	public VkExtent3D Extent;

	public VkImageCopy2KHR(
		VkImageSubresourceLayers srcSubresource = default,
		VkOffset3D srcOffset = default,
		VkImageSubresourceLayers dstSubresource = default,
		VkOffset3D dstOffset = default,
		VkExtent3D extent = default
	) {
		sType = TYPE;
		pNext = null;
		SrcSubresource = srcSubresource;
		SrcOffset = srcOffset;
		DstSubresource = dstSubresource;
		DstOffset = dstOffset;
		Extent = extent;
	}

	public readonly override bool Equals(object? o) => (o is VkImageCopy2KHR s) && (this == s);
	readonly bool IEquatable<VkImageCopy2KHR>.Equals(VkImageCopy2KHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SrcSubresource.GetHashCode() ^ SrcOffset.GetHashCode()
			^ DstSubresource.GetHashCode() ^ DstOffset.GetHashCode() ^ Extent.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkImageCopy2KHR l, in VkImageCopy2KHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SrcSubresource == r.SrcSubresource) && (l.SrcOffset == r.SrcOffset)
			&& (l.DstSubresource == r.DstSubresource) && (l.DstOffset == r.DstOffset) && (l.Extent == r.Extent)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkImageCopy2KHR l, in VkImageCopy2KHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SrcSubresource != r.SrcSubresource) || (l.SrcOffset != r.SrcOffset)
			|| (l.DstSubresource != r.DstSubresource) || (l.DstOffset != r.DstOffset) || (l.Extent != r.Extent)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkImageCopy2KHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkImageBlit2KHR : IEquatable<VkImageBlit2KHR>
{
	public const VkStructureType TYPE = VkStructureType.ImageBlit2Khr;

	public VkStructureType sType;
	public void* pNext;
	public VkImageSubresourceLayers SrcSubresource;
	public VkOffset3D SrcOffsets_0;
	public VkOffset3D SrcOffsets_1;
	public VkImageSubresourceLayers DstSubresource;
	public VkOffset3D DstOffsets_0;
	public VkOffset3D DstOffsets_1;

	public VkImageBlit2KHR(
		VkImageSubresourceLayers srcSubresource = default,
		VkOffset3D srcOffsets_0 = default,
		VkOffset3D srcOffsets_1 = default,
		VkImageSubresourceLayers dstSubresource = default,
		VkOffset3D dstOffsets_0 = default,
		VkOffset3D dstOffsets_1 = default
	) {
		sType = TYPE;
		pNext = null;
		SrcSubresource = srcSubresource;
		SrcOffsets_0 = srcOffsets_0;
		SrcOffsets_1 = srcOffsets_1;
		DstSubresource = dstSubresource;
		DstOffsets_0 = dstOffsets_0;
		DstOffsets_1 = dstOffsets_1;
	}

	public readonly override bool Equals(object? o) => (o is VkImageBlit2KHR s) && (this == s);
	readonly bool IEquatable<VkImageBlit2KHR>.Equals(VkImageBlit2KHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SrcSubresource.GetHashCode() ^ SrcOffsets_0.GetHashCode()
			^ SrcOffsets_1.GetHashCode() ^ DstSubresource.GetHashCode() ^ DstOffsets_0.GetHashCode() ^ DstOffsets_1.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkImageBlit2KHR l, in VkImageBlit2KHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SrcSubresource == r.SrcSubresource) && (l.SrcOffsets_0 == r.SrcOffsets_0)
			&& (l.SrcOffsets_1 == r.SrcOffsets_1) && (l.DstSubresource == r.DstSubresource) && (l.DstOffsets_0 == r.DstOffsets_0) && (l.DstOffsets_1 == r.DstOffsets_1)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkImageBlit2KHR l, in VkImageBlit2KHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SrcSubresource != r.SrcSubresource) || (l.SrcOffsets_0 != r.SrcOffsets_0)
			|| (l.SrcOffsets_1 != r.SrcOffsets_1) || (l.DstSubresource != r.DstSubresource) || (l.DstOffsets_0 != r.DstOffsets_0) || (l.DstOffsets_1 != r.DstOffsets_1)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkImageBlit2KHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkBufferImageCopy2KHR : IEquatable<VkBufferImageCopy2KHR>
{
	public const VkStructureType TYPE = VkStructureType.BufferImageCopy2Khr;

	public VkStructureType sType;
	public void* pNext;
	public ulong BufferOffset;
	public uint BufferRowLength;
	public uint BufferImageHeight;
	public VkImageSubresourceLayers ImageSubresource;
	public VkOffset3D ImageOffset;
	public VkExtent3D ImageExtent;

	public VkBufferImageCopy2KHR(
		ulong bufferOffset = default,
		uint bufferRowLength = default,
		uint bufferImageHeight = default,
		VkImageSubresourceLayers imageSubresource = default,
		VkOffset3D imageOffset = default,
		VkExtent3D imageExtent = default
	) {
		sType = TYPE;
		pNext = null;
		BufferOffset = bufferOffset;
		BufferRowLength = bufferRowLength;
		BufferImageHeight = bufferImageHeight;
		ImageSubresource = imageSubresource;
		ImageOffset = imageOffset;
		ImageExtent = imageExtent;
	}

	public readonly override bool Equals(object? o) => (o is VkBufferImageCopy2KHR s) && (this == s);
	readonly bool IEquatable<VkBufferImageCopy2KHR>.Equals(VkBufferImageCopy2KHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ BufferOffset.GetHashCode() ^ BufferRowLength.GetHashCode()
			^ BufferImageHeight.GetHashCode() ^ ImageSubresource.GetHashCode() ^ ImageOffset.GetHashCode() ^ ImageExtent.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkBufferImageCopy2KHR l, in VkBufferImageCopy2KHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.BufferOffset == r.BufferOffset) && (l.BufferRowLength == r.BufferRowLength)
			&& (l.BufferImageHeight == r.BufferImageHeight) && (l.ImageSubresource == r.ImageSubresource) && (l.ImageOffset == r.ImageOffset) && (l.ImageExtent == r.ImageExtent)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkBufferImageCopy2KHR l, in VkBufferImageCopy2KHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.BufferOffset != r.BufferOffset) || (l.BufferRowLength != r.BufferRowLength)
			|| (l.BufferImageHeight != r.BufferImageHeight) || (l.ImageSubresource != r.ImageSubresource) || (l.ImageOffset != r.ImageOffset) || (l.ImageExtent != r.ImageExtent)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkBufferImageCopy2KHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkImageResolve2KHR : IEquatable<VkImageResolve2KHR>
{
	public const VkStructureType TYPE = VkStructureType.ImageResolve2Khr;

	public VkStructureType sType;
	public void* pNext;
	public VkImageSubresourceLayers SrcSubresource;
	public VkOffset3D SrcOffset;
	public VkImageSubresourceLayers DstSubresource;
	public VkOffset3D DstOffset;
	public VkExtent3D Extent;

	public VkImageResolve2KHR(
		VkImageSubresourceLayers srcSubresource = default,
		VkOffset3D srcOffset = default,
		VkImageSubresourceLayers dstSubresource = default,
		VkOffset3D dstOffset = default,
		VkExtent3D extent = default
	) {
		sType = TYPE;
		pNext = null;
		SrcSubresource = srcSubresource;
		SrcOffset = srcOffset;
		DstSubresource = dstSubresource;
		DstOffset = dstOffset;
		Extent = extent;
	}

	public readonly override bool Equals(object? o) => (o is VkImageResolve2KHR s) && (this == s);
	readonly bool IEquatable<VkImageResolve2KHR>.Equals(VkImageResolve2KHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SrcSubresource.GetHashCode() ^ SrcOffset.GetHashCode()
			^ DstSubresource.GetHashCode() ^ DstOffset.GetHashCode() ^ Extent.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkImageResolve2KHR l, in VkImageResolve2KHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SrcSubresource == r.SrcSubresource) && (l.SrcOffset == r.SrcOffset)
			&& (l.DstSubresource == r.DstSubresource) && (l.DstOffset == r.DstOffset) && (l.Extent == r.Extent)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkImageResolve2KHR l, in VkImageResolve2KHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SrcSubresource != r.SrcSubresource) || (l.SrcOffset != r.SrcOffset)
			|| (l.DstSubresource != r.DstSubresource) || (l.DstOffset != r.DstOffset) || (l.Extent != r.Extent)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkImageResolve2KHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkCopyBufferInfo2KHR : IEquatable<VkCopyBufferInfo2KHR>
{
	public const VkStructureType TYPE = VkStructureType.CopyBufferInfo2Khr;

	public VkStructureType sType;
	public void* pNext;
	public VulkanHandle<VkBuffer> SrcBuffer;
	public VulkanHandle<VkBuffer> DstBuffer;
	public uint RegionCount;
	public VkBufferCopy2KHR* Regions;

	public VkCopyBufferInfo2KHR(
		VulkanHandle<VkBuffer> srcBuffer = default,
		VulkanHandle<VkBuffer> dstBuffer = default,
		uint regionCount = default,
		VkBufferCopy2KHR* regions = default
	) {
		sType = TYPE;
		pNext = null;
		SrcBuffer = srcBuffer;
		DstBuffer = dstBuffer;
		RegionCount = regionCount;
		Regions = regions;
	}

	public readonly override bool Equals(object? o) => (o is VkCopyBufferInfo2KHR s) && (this == s);
	readonly bool IEquatable<VkCopyBufferInfo2KHR>.Equals(VkCopyBufferInfo2KHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SrcBuffer.GetHashCode() ^ DstBuffer.GetHashCode()
			^ RegionCount.GetHashCode() ^ ((ulong)Regions).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkCopyBufferInfo2KHR l, in VkCopyBufferInfo2KHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SrcBuffer == r.SrcBuffer) && (l.DstBuffer == r.DstBuffer)
			&& (l.RegionCount == r.RegionCount) && (l.Regions == r.Regions)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkCopyBufferInfo2KHR l, in VkCopyBufferInfo2KHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SrcBuffer != r.SrcBuffer) || (l.DstBuffer != r.DstBuffer)
			|| (l.RegionCount != r.RegionCount) || (l.Regions != r.Regions)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkCopyBufferInfo2KHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkCopyImageInfo2KHR : IEquatable<VkCopyImageInfo2KHR>
{
	public const VkStructureType TYPE = VkStructureType.CopyImageInfo2Khr;

	public VkStructureType sType;
	public void* pNext;
	public VulkanHandle<VkImage> SrcImage;
	public VkImageLayout SrcImageLayout;
	public VulkanHandle<VkImage> DstImage;
	public VkImageLayout DstImageLayout;
	public uint RegionCount;
	public VkImageCopy2KHR* Regions;

	public VkCopyImageInfo2KHR(
		VulkanHandle<VkImage> srcImage = default,
		VkImageLayout srcImageLayout = default,
		VulkanHandle<VkImage> dstImage = default,
		VkImageLayout dstImageLayout = default,
		uint regionCount = default,
		VkImageCopy2KHR* regions = default
	) {
		sType = TYPE;
		pNext = null;
		SrcImage = srcImage;
		SrcImageLayout = srcImageLayout;
		DstImage = dstImage;
		DstImageLayout = dstImageLayout;
		RegionCount = regionCount;
		Regions = regions;
	}

	public readonly override bool Equals(object? o) => (o is VkCopyImageInfo2KHR s) && (this == s);
	readonly bool IEquatable<VkCopyImageInfo2KHR>.Equals(VkCopyImageInfo2KHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SrcImage.GetHashCode() ^ SrcImageLayout.GetHashCode()
			^ DstImage.GetHashCode() ^ DstImageLayout.GetHashCode() ^ RegionCount.GetHashCode() ^ ((ulong)Regions).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkCopyImageInfo2KHR l, in VkCopyImageInfo2KHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SrcImage == r.SrcImage) && (l.SrcImageLayout == r.SrcImageLayout)
			&& (l.DstImage == r.DstImage) && (l.DstImageLayout == r.DstImageLayout) && (l.RegionCount == r.RegionCount) && (l.Regions == r.Regions)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkCopyImageInfo2KHR l, in VkCopyImageInfo2KHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SrcImage != r.SrcImage) || (l.SrcImageLayout != r.SrcImageLayout)
			|| (l.DstImage != r.DstImage) || (l.DstImageLayout != r.DstImageLayout) || (l.RegionCount != r.RegionCount) || (l.Regions != r.Regions)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkCopyImageInfo2KHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkBlitImageInfo2KHR : IEquatable<VkBlitImageInfo2KHR>
{
	public const VkStructureType TYPE = VkStructureType.BlitImageInfo2Khr;

	public VkStructureType sType;
	public void* pNext;
	public VulkanHandle<VkImage> SrcImage;
	public VkImageLayout SrcImageLayout;
	public VulkanHandle<VkImage> DstImage;
	public VkImageLayout DstImageLayout;
	public uint RegionCount;
	public VkImageBlit2KHR* Regions;
	public VkFilter Filter;

	public VkBlitImageInfo2KHR(
		VulkanHandle<VkImage> srcImage = default,
		VkImageLayout srcImageLayout = default,
		VulkanHandle<VkImage> dstImage = default,
		VkImageLayout dstImageLayout = default,
		uint regionCount = default,
		VkImageBlit2KHR* regions = default,
		VkFilter filter = default
	) {
		sType = TYPE;
		pNext = null;
		SrcImage = srcImage;
		SrcImageLayout = srcImageLayout;
		DstImage = dstImage;
		DstImageLayout = dstImageLayout;
		RegionCount = regionCount;
		Regions = regions;
		Filter = filter;
	}

	public readonly override bool Equals(object? o) => (o is VkBlitImageInfo2KHR s) && (this == s);
	readonly bool IEquatable<VkBlitImageInfo2KHR>.Equals(VkBlitImageInfo2KHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SrcImage.GetHashCode() ^ SrcImageLayout.GetHashCode()
			^ DstImage.GetHashCode() ^ DstImageLayout.GetHashCode() ^ RegionCount.GetHashCode() ^ ((ulong)Regions).GetHashCode()
			^ Filter.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkBlitImageInfo2KHR l, in VkBlitImageInfo2KHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SrcImage == r.SrcImage) && (l.SrcImageLayout == r.SrcImageLayout)
			&& (l.DstImage == r.DstImage) && (l.DstImageLayout == r.DstImageLayout) && (l.RegionCount == r.RegionCount) && (l.Regions == r.Regions)
			&& (l.Filter == r.Filter)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkBlitImageInfo2KHR l, in VkBlitImageInfo2KHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SrcImage != r.SrcImage) || (l.SrcImageLayout != r.SrcImageLayout)
			|| (l.DstImage != r.DstImage) || (l.DstImageLayout != r.DstImageLayout) || (l.RegionCount != r.RegionCount) || (l.Regions != r.Regions)
			|| (l.Filter != r.Filter)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkBlitImageInfo2KHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkCopyBufferToImageInfo2KHR : IEquatable<VkCopyBufferToImageInfo2KHR>
{
	public const VkStructureType TYPE = VkStructureType.CopyBufferToImageInfo2Khr;

	public VkStructureType sType;
	public void* pNext;
	public VulkanHandle<VkBuffer> SrcBuffer;
	public VulkanHandle<VkImage> DstImage;
	public VkImageLayout DstImageLayout;
	public uint RegionCount;
	public VkBufferImageCopy2KHR* Regions;

	public VkCopyBufferToImageInfo2KHR(
		VulkanHandle<VkBuffer> srcBuffer = default,
		VulkanHandle<VkImage> dstImage = default,
		VkImageLayout dstImageLayout = default,
		uint regionCount = default,
		VkBufferImageCopy2KHR* regions = default
	) {
		sType = TYPE;
		pNext = null;
		SrcBuffer = srcBuffer;
		DstImage = dstImage;
		DstImageLayout = dstImageLayout;
		RegionCount = regionCount;
		Regions = regions;
	}

	public readonly override bool Equals(object? o) => (o is VkCopyBufferToImageInfo2KHR s) && (this == s);
	readonly bool IEquatable<VkCopyBufferToImageInfo2KHR>.Equals(VkCopyBufferToImageInfo2KHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SrcBuffer.GetHashCode() ^ DstImage.GetHashCode()
			^ DstImageLayout.GetHashCode() ^ RegionCount.GetHashCode() ^ ((ulong)Regions).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkCopyBufferToImageInfo2KHR l, in VkCopyBufferToImageInfo2KHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SrcBuffer == r.SrcBuffer) && (l.DstImage == r.DstImage)
			&& (l.DstImageLayout == r.DstImageLayout) && (l.RegionCount == r.RegionCount) && (l.Regions == r.Regions)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkCopyBufferToImageInfo2KHR l, in VkCopyBufferToImageInfo2KHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SrcBuffer != r.SrcBuffer) || (l.DstImage != r.DstImage)
			|| (l.DstImageLayout != r.DstImageLayout) || (l.RegionCount != r.RegionCount) || (l.Regions != r.Regions)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkCopyBufferToImageInfo2KHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkCopyImageToBufferInfo2KHR : IEquatable<VkCopyImageToBufferInfo2KHR>
{
	public const VkStructureType TYPE = VkStructureType.CopyImageToBufferInfo2Khr;

	public VkStructureType sType;
	public void* pNext;
	public VulkanHandle<VkImage> SrcImage;
	public VkImageLayout SrcImageLayout;
	public VulkanHandle<VkBuffer> DstBuffer;
	public uint RegionCount;
	public VkBufferImageCopy2KHR* Regions;

	public VkCopyImageToBufferInfo2KHR(
		VulkanHandle<VkImage> srcImage = default,
		VkImageLayout srcImageLayout = default,
		VulkanHandle<VkBuffer> dstBuffer = default,
		uint regionCount = default,
		VkBufferImageCopy2KHR* regions = default
	) {
		sType = TYPE;
		pNext = null;
		SrcImage = srcImage;
		SrcImageLayout = srcImageLayout;
		DstBuffer = dstBuffer;
		RegionCount = regionCount;
		Regions = regions;
	}

	public readonly override bool Equals(object? o) => (o is VkCopyImageToBufferInfo2KHR s) && (this == s);
	readonly bool IEquatable<VkCopyImageToBufferInfo2KHR>.Equals(VkCopyImageToBufferInfo2KHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SrcImage.GetHashCode() ^ SrcImageLayout.GetHashCode()
			^ DstBuffer.GetHashCode() ^ RegionCount.GetHashCode() ^ ((ulong)Regions).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkCopyImageToBufferInfo2KHR l, in VkCopyImageToBufferInfo2KHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SrcImage == r.SrcImage) && (l.SrcImageLayout == r.SrcImageLayout)
			&& (l.DstBuffer == r.DstBuffer) && (l.RegionCount == r.RegionCount) && (l.Regions == r.Regions)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkCopyImageToBufferInfo2KHR l, in VkCopyImageToBufferInfo2KHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SrcImage != r.SrcImage) || (l.SrcImageLayout != r.SrcImageLayout)
			|| (l.DstBuffer != r.DstBuffer) || (l.RegionCount != r.RegionCount) || (l.Regions != r.Regions)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkCopyImageToBufferInfo2KHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkResolveImageInfo2KHR : IEquatable<VkResolveImageInfo2KHR>
{
	public const VkStructureType TYPE = VkStructureType.ResolveImageInfo2Khr;

	public VkStructureType sType;
	public void* pNext;
	public VulkanHandle<VkImage> SrcImage;
	public VkImageLayout SrcImageLayout;
	public VulkanHandle<VkImage> DstImage;
	public VkImageLayout DstImageLayout;
	public uint RegionCount;
	public VkImageResolve2KHR* Regions;

	public VkResolveImageInfo2KHR(
		VulkanHandle<VkImage> srcImage = default,
		VkImageLayout srcImageLayout = default,
		VulkanHandle<VkImage> dstImage = default,
		VkImageLayout dstImageLayout = default,
		uint regionCount = default,
		VkImageResolve2KHR* regions = default
	) {
		sType = TYPE;
		pNext = null;
		SrcImage = srcImage;
		SrcImageLayout = srcImageLayout;
		DstImage = dstImage;
		DstImageLayout = dstImageLayout;
		RegionCount = regionCount;
		Regions = regions;
	}

	public readonly override bool Equals(object? o) => (o is VkResolveImageInfo2KHR s) && (this == s);
	readonly bool IEquatable<VkResolveImageInfo2KHR>.Equals(VkResolveImageInfo2KHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SrcImage.GetHashCode() ^ SrcImageLayout.GetHashCode()
			^ DstImage.GetHashCode() ^ DstImageLayout.GetHashCode() ^ RegionCount.GetHashCode() ^ ((ulong)Regions).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkResolveImageInfo2KHR l, in VkResolveImageInfo2KHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SrcImage == r.SrcImage) && (l.SrcImageLayout == r.SrcImageLayout)
			&& (l.DstImage == r.DstImage) && (l.DstImageLayout == r.DstImageLayout) && (l.RegionCount == r.RegionCount) && (l.Regions == r.Regions)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkResolveImageInfo2KHR l, in VkResolveImageInfo2KHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SrcImage != r.SrcImage) || (l.SrcImageLayout != r.SrcImageLayout)
			|| (l.DstImage != r.DstImage) || (l.DstImageLayout != r.DstImageLayout) || (l.RegionCount != r.RegionCount) || (l.Regions != r.Regions)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkResolveImageInfo2KHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkFragmentShadingRateAttachmentInfoKHR : IEquatable<VkFragmentShadingRateAttachmentInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.FragmentShadingRateAttachmentInfoKhr;

	public VkStructureType sType;
	public void* pNext;
	public VkAttachmentReference2* FragmentShadingRateAttachment;
	public VkExtent2D ShadingRateAttachmentTexelSize;

	public VkFragmentShadingRateAttachmentInfoKHR(
		VkAttachmentReference2* fragmentShadingRateAttachment = default,
		VkExtent2D shadingRateAttachmentTexelSize = default
	) {
		sType = TYPE;
		pNext = null;
		FragmentShadingRateAttachment = fragmentShadingRateAttachment;
		ShadingRateAttachmentTexelSize = shadingRateAttachmentTexelSize;
	}

	public readonly override bool Equals(object? o) => (o is VkFragmentShadingRateAttachmentInfoKHR s) && (this == s);
	readonly bool IEquatable<VkFragmentShadingRateAttachmentInfoKHR>.Equals(VkFragmentShadingRateAttachmentInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ((ulong)FragmentShadingRateAttachment).GetHashCode() ^ ShadingRateAttachmentTexelSize.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkFragmentShadingRateAttachmentInfoKHR l, in VkFragmentShadingRateAttachmentInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.FragmentShadingRateAttachment == r.FragmentShadingRateAttachment) && (l.ShadingRateAttachmentTexelSize == r.ShadingRateAttachmentTexelSize)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkFragmentShadingRateAttachmentInfoKHR l, in VkFragmentShadingRateAttachmentInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.FragmentShadingRateAttachment != r.FragmentShadingRateAttachment) || (l.ShadingRateAttachmentTexelSize != r.ShadingRateAttachmentTexelSize)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkFragmentShadingRateAttachmentInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPipelineFragmentShadingRateStateCreateInfoKHR : IEquatable<VkPipelineFragmentShadingRateStateCreateInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.PipelineFragmentShadingRateStateCreateInfoKhr;

	public VkStructureType sType;
	public void* pNext;
	public VkExtent2D FragmentSize;
	public VkFragmentShadingRateCombinerOpKHR CombinerOps_0;
	public VkFragmentShadingRateCombinerOpKHR CombinerOps_1;

	public VkPipelineFragmentShadingRateStateCreateInfoKHR(
		VkExtent2D fragmentSize = default,
		VkFragmentShadingRateCombinerOpKHR combinerOps_0 = default,
		VkFragmentShadingRateCombinerOpKHR combinerOps_1 = default
	) {
		sType = TYPE;
		pNext = null;
		FragmentSize = fragmentSize;
		CombinerOps_0 = combinerOps_0;
		CombinerOps_1 = combinerOps_1;
	}

	public readonly override bool Equals(object? o) => (o is VkPipelineFragmentShadingRateStateCreateInfoKHR s) && (this == s);
	readonly bool IEquatable<VkPipelineFragmentShadingRateStateCreateInfoKHR>.Equals(VkPipelineFragmentShadingRateStateCreateInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ FragmentSize.GetHashCode() ^ CombinerOps_0.GetHashCode()
			^ CombinerOps_1.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPipelineFragmentShadingRateStateCreateInfoKHR l, in VkPipelineFragmentShadingRateStateCreateInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.FragmentSize == r.FragmentSize) && (l.CombinerOps_0 == r.CombinerOps_0)
			&& (l.CombinerOps_1 == r.CombinerOps_1)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPipelineFragmentShadingRateStateCreateInfoKHR l, in VkPipelineFragmentShadingRateStateCreateInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.FragmentSize != r.FragmentSize) || (l.CombinerOps_0 != r.CombinerOps_0)
			|| (l.CombinerOps_1 != r.CombinerOps_1)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPipelineFragmentShadingRateStateCreateInfoKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceFragmentShadingRateFeaturesKHR : IEquatable<VkPhysicalDeviceFragmentShadingRateFeaturesKHR>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceFragmentShadingRateFeaturesKhr;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 PipelineFragmentShadingRate;
	public VkBool32 PrimitiveFragmentShadingRate;
	public VkBool32 AttachmentFragmentShadingRate;

	public VkPhysicalDeviceFragmentShadingRateFeaturesKHR(
		VkBool32 pipelineFragmentShadingRate = default,
		VkBool32 primitiveFragmentShadingRate = default,
		VkBool32 attachmentFragmentShadingRate = default
	) {
		sType = TYPE;
		pNext = null;
		PipelineFragmentShadingRate = pipelineFragmentShadingRate;
		PrimitiveFragmentShadingRate = primitiveFragmentShadingRate;
		AttachmentFragmentShadingRate = attachmentFragmentShadingRate;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceFragmentShadingRateFeaturesKHR s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceFragmentShadingRateFeaturesKHR>.Equals(VkPhysicalDeviceFragmentShadingRateFeaturesKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ PipelineFragmentShadingRate.GetHashCode() ^ PrimitiveFragmentShadingRate.GetHashCode()
			^ AttachmentFragmentShadingRate.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceFragmentShadingRateFeaturesKHR l, in VkPhysicalDeviceFragmentShadingRateFeaturesKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.PipelineFragmentShadingRate == r.PipelineFragmentShadingRate) && (l.PrimitiveFragmentShadingRate == r.PrimitiveFragmentShadingRate)
			&& (l.AttachmentFragmentShadingRate == r.AttachmentFragmentShadingRate)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceFragmentShadingRateFeaturesKHR l, in VkPhysicalDeviceFragmentShadingRateFeaturesKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.PipelineFragmentShadingRate != r.PipelineFragmentShadingRate) || (l.PrimitiveFragmentShadingRate != r.PrimitiveFragmentShadingRate)
			|| (l.AttachmentFragmentShadingRate != r.AttachmentFragmentShadingRate)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceFragmentShadingRateFeaturesKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceFragmentShadingRatePropertiesKHR : IEquatable<VkPhysicalDeviceFragmentShadingRatePropertiesKHR>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceFragmentShadingRatePropertiesKhr;

	public VkStructureType sType;
	public void* pNext;
	public VkExtent2D MinFragmentShadingRateAttachmentTexelSize;
	public VkExtent2D MaxFragmentShadingRateAttachmentTexelSize;
	public uint MaxFragmentShadingRateAttachmentTexelSizeAspectRatio;
	public VkBool32 PrimitiveFragmentShadingRateWithMultipleViewports;
	public VkBool32 LayeredShadingRateAttachments;
	public VkBool32 FragmentShadingRateNonTrivialCombinerOps;
	public VkExtent2D MaxFragmentSize;
	public uint MaxFragmentSizeAspectRatio;
	public uint MaxFragmentShadingRateCoverageSamples;
	public VkSampleCountFlags MaxFragmentShadingRateRasterizationSamples;
	public VkBool32 FragmentShadingRateWithShaderDepthStencilWrites;
	public VkBool32 FragmentShadingRateWithSampleMask;
	public VkBool32 FragmentShadingRateWithShaderSampleMask;
	public VkBool32 FragmentShadingRateWithConservativeRasterization;
	public VkBool32 FragmentShadingRateWithFragmentShaderInterlock;
	public VkBool32 FragmentShadingRateWithCustomSampleLocations;
	public VkBool32 FragmentShadingRateStrictMultiplyCombiner;

	public VkPhysicalDeviceFragmentShadingRatePropertiesKHR(
		VkExtent2D minFragmentShadingRateAttachmentTexelSize = default,
		VkExtent2D maxFragmentShadingRateAttachmentTexelSize = default,
		uint maxFragmentShadingRateAttachmentTexelSizeAspectRatio = default,
		VkBool32 primitiveFragmentShadingRateWithMultipleViewports = default,
		VkBool32 layeredShadingRateAttachments = default,
		VkBool32 fragmentShadingRateNonTrivialCombinerOps = default,
		VkExtent2D maxFragmentSize = default,
		uint maxFragmentSizeAspectRatio = default,
		uint maxFragmentShadingRateCoverageSamples = default,
		VkSampleCountFlags maxFragmentShadingRateRasterizationSamples = default,
		VkBool32 fragmentShadingRateWithShaderDepthStencilWrites = default,
		VkBool32 fragmentShadingRateWithSampleMask = default,
		VkBool32 fragmentShadingRateWithShaderSampleMask = default,
		VkBool32 fragmentShadingRateWithConservativeRasterization = default,
		VkBool32 fragmentShadingRateWithFragmentShaderInterlock = default,
		VkBool32 fragmentShadingRateWithCustomSampleLocations = default,
		VkBool32 fragmentShadingRateStrictMultiplyCombiner = default
	) {
		sType = TYPE;
		pNext = null;
		MinFragmentShadingRateAttachmentTexelSize = minFragmentShadingRateAttachmentTexelSize;
		MaxFragmentShadingRateAttachmentTexelSize = maxFragmentShadingRateAttachmentTexelSize;
		MaxFragmentShadingRateAttachmentTexelSizeAspectRatio = maxFragmentShadingRateAttachmentTexelSizeAspectRatio;
		PrimitiveFragmentShadingRateWithMultipleViewports = primitiveFragmentShadingRateWithMultipleViewports;
		LayeredShadingRateAttachments = layeredShadingRateAttachments;
		FragmentShadingRateNonTrivialCombinerOps = fragmentShadingRateNonTrivialCombinerOps;
		MaxFragmentSize = maxFragmentSize;
		MaxFragmentSizeAspectRatio = maxFragmentSizeAspectRatio;
		MaxFragmentShadingRateCoverageSamples = maxFragmentShadingRateCoverageSamples;
		MaxFragmentShadingRateRasterizationSamples = maxFragmentShadingRateRasterizationSamples;
		FragmentShadingRateWithShaderDepthStencilWrites = fragmentShadingRateWithShaderDepthStencilWrites;
		FragmentShadingRateWithSampleMask = fragmentShadingRateWithSampleMask;
		FragmentShadingRateWithShaderSampleMask = fragmentShadingRateWithShaderSampleMask;
		FragmentShadingRateWithConservativeRasterization = fragmentShadingRateWithConservativeRasterization;
		FragmentShadingRateWithFragmentShaderInterlock = fragmentShadingRateWithFragmentShaderInterlock;
		FragmentShadingRateWithCustomSampleLocations = fragmentShadingRateWithCustomSampleLocations;
		FragmentShadingRateStrictMultiplyCombiner = fragmentShadingRateStrictMultiplyCombiner;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceFragmentShadingRatePropertiesKHR s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceFragmentShadingRatePropertiesKHR>.Equals(VkPhysicalDeviceFragmentShadingRatePropertiesKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MinFragmentShadingRateAttachmentTexelSize.GetHashCode() ^ MaxFragmentShadingRateAttachmentTexelSize.GetHashCode()
			^ MaxFragmentShadingRateAttachmentTexelSizeAspectRatio.GetHashCode() ^ PrimitiveFragmentShadingRateWithMultipleViewports.GetHashCode() ^ LayeredShadingRateAttachments.GetHashCode() ^ FragmentShadingRateNonTrivialCombinerOps.GetHashCode()
			^ MaxFragmentSize.GetHashCode() ^ MaxFragmentSizeAspectRatio.GetHashCode() ^ MaxFragmentShadingRateCoverageSamples.GetHashCode() ^ MaxFragmentShadingRateRasterizationSamples.GetHashCode()
			^ FragmentShadingRateWithShaderDepthStencilWrites.GetHashCode() ^ FragmentShadingRateWithSampleMask.GetHashCode() ^ FragmentShadingRateWithShaderSampleMask.GetHashCode() ^ FragmentShadingRateWithConservativeRasterization.GetHashCode()
			^ FragmentShadingRateWithFragmentShaderInterlock.GetHashCode() ^ FragmentShadingRateWithCustomSampleLocations.GetHashCode() ^ FragmentShadingRateStrictMultiplyCombiner.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceFragmentShadingRatePropertiesKHR l, in VkPhysicalDeviceFragmentShadingRatePropertiesKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MinFragmentShadingRateAttachmentTexelSize == r.MinFragmentShadingRateAttachmentTexelSize) && (l.MaxFragmentShadingRateAttachmentTexelSize == r.MaxFragmentShadingRateAttachmentTexelSize)
			&& (l.MaxFragmentShadingRateAttachmentTexelSizeAspectRatio == r.MaxFragmentShadingRateAttachmentTexelSizeAspectRatio) && (l.PrimitiveFragmentShadingRateWithMultipleViewports == r.PrimitiveFragmentShadingRateWithMultipleViewports) && (l.LayeredShadingRateAttachments == r.LayeredShadingRateAttachments) && (l.FragmentShadingRateNonTrivialCombinerOps == r.FragmentShadingRateNonTrivialCombinerOps)
			&& (l.MaxFragmentSize == r.MaxFragmentSize) && (l.MaxFragmentSizeAspectRatio == r.MaxFragmentSizeAspectRatio) && (l.MaxFragmentShadingRateCoverageSamples == r.MaxFragmentShadingRateCoverageSamples) && (l.MaxFragmentShadingRateRasterizationSamples == r.MaxFragmentShadingRateRasterizationSamples)
			&& (l.FragmentShadingRateWithShaderDepthStencilWrites == r.FragmentShadingRateWithShaderDepthStencilWrites) && (l.FragmentShadingRateWithSampleMask == r.FragmentShadingRateWithSampleMask) && (l.FragmentShadingRateWithShaderSampleMask == r.FragmentShadingRateWithShaderSampleMask) && (l.FragmentShadingRateWithConservativeRasterization == r.FragmentShadingRateWithConservativeRasterization)
			&& (l.FragmentShadingRateWithFragmentShaderInterlock == r.FragmentShadingRateWithFragmentShaderInterlock) && (l.FragmentShadingRateWithCustomSampleLocations == r.FragmentShadingRateWithCustomSampleLocations) && (l.FragmentShadingRateStrictMultiplyCombiner == r.FragmentShadingRateStrictMultiplyCombiner)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceFragmentShadingRatePropertiesKHR l, in VkPhysicalDeviceFragmentShadingRatePropertiesKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MinFragmentShadingRateAttachmentTexelSize != r.MinFragmentShadingRateAttachmentTexelSize) || (l.MaxFragmentShadingRateAttachmentTexelSize != r.MaxFragmentShadingRateAttachmentTexelSize)
			|| (l.MaxFragmentShadingRateAttachmentTexelSizeAspectRatio != r.MaxFragmentShadingRateAttachmentTexelSizeAspectRatio) || (l.PrimitiveFragmentShadingRateWithMultipleViewports != r.PrimitiveFragmentShadingRateWithMultipleViewports) || (l.LayeredShadingRateAttachments != r.LayeredShadingRateAttachments) || (l.FragmentShadingRateNonTrivialCombinerOps != r.FragmentShadingRateNonTrivialCombinerOps)
			|| (l.MaxFragmentSize != r.MaxFragmentSize) || (l.MaxFragmentSizeAspectRatio != r.MaxFragmentSizeAspectRatio) || (l.MaxFragmentShadingRateCoverageSamples != r.MaxFragmentShadingRateCoverageSamples) || (l.MaxFragmentShadingRateRasterizationSamples != r.MaxFragmentShadingRateRasterizationSamples)
			|| (l.FragmentShadingRateWithShaderDepthStencilWrites != r.FragmentShadingRateWithShaderDepthStencilWrites) || (l.FragmentShadingRateWithSampleMask != r.FragmentShadingRateWithSampleMask) || (l.FragmentShadingRateWithShaderSampleMask != r.FragmentShadingRateWithShaderSampleMask) || (l.FragmentShadingRateWithConservativeRasterization != r.FragmentShadingRateWithConservativeRasterization)
			|| (l.FragmentShadingRateWithFragmentShaderInterlock != r.FragmentShadingRateWithFragmentShaderInterlock) || (l.FragmentShadingRateWithCustomSampleLocations != r.FragmentShadingRateWithCustomSampleLocations) || (l.FragmentShadingRateStrictMultiplyCombiner != r.FragmentShadingRateStrictMultiplyCombiner)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceFragmentShadingRatePropertiesKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceFragmentShadingRateKHR : IEquatable<VkPhysicalDeviceFragmentShadingRateKHR>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceFragmentShadingRateKhr;

	public VkStructureType sType;
	public void* pNext;
	public VkSampleCountFlags SampleCounts;
	public VkExtent2D FragmentSize;

	public VkPhysicalDeviceFragmentShadingRateKHR(
		VkSampleCountFlags sampleCounts = default,
		VkExtent2D fragmentSize = default
	) {
		sType = TYPE;
		pNext = null;
		SampleCounts = sampleCounts;
		FragmentSize = fragmentSize;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceFragmentShadingRateKHR s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceFragmentShadingRateKHR>.Equals(VkPhysicalDeviceFragmentShadingRateKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SampleCounts.GetHashCode() ^ FragmentSize.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceFragmentShadingRateKHR l, in VkPhysicalDeviceFragmentShadingRateKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SampleCounts == r.SampleCounts) && (l.FragmentSize == r.FragmentSize)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceFragmentShadingRateKHR l, in VkPhysicalDeviceFragmentShadingRateKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SampleCounts != r.SampleCounts) || (l.FragmentSize != r.FragmentSize)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceFragmentShadingRateKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR : IEquatable<VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceShaderTerminateInvocationFeaturesKhr;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 ShaderTerminateInvocation;

	public VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR(
		VkBool32 shaderTerminateInvocation = default
	) {
		sType = TYPE;
		pNext = null;
		ShaderTerminateInvocation = shaderTerminateInvocation;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR>.Equals(VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ShaderTerminateInvocation.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR l, in VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ShaderTerminateInvocation == r.ShaderTerminateInvocation)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR l, in VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ShaderTerminateInvocation != r.ShaderTerminateInvocation)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkAccelerationStructureBuildSizesInfoKHR : IEquatable<VkAccelerationStructureBuildSizesInfoKHR>
{
	public const VkStructureType TYPE = VkStructureType.AccelerationStructureBuildSizesInfoKhr;

	public VkStructureType sType;
	public void* pNext;
	public ulong AccelerationStructureSize;
	public ulong UpdateScratchSize;
	public ulong BuildScratchSize;

	public VkAccelerationStructureBuildSizesInfoKHR(
		ulong accelerationStructureSize = default,
		ulong updateScratchSize = default,
		ulong buildScratchSize = default
	) {
		sType = TYPE;
		pNext = null;
		AccelerationStructureSize = accelerationStructureSize;
		UpdateScratchSize = updateScratchSize;
		BuildScratchSize = buildScratchSize;
	}

	public readonly override bool Equals(object? o) => (o is VkAccelerationStructureBuildSizesInfoKHR s) && (this == s);
	readonly bool IEquatable<VkAccelerationStructureBuildSizesInfoKHR>.Equals(VkAccelerationStructureBuildSizesInfoKHR o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ AccelerationStructureSize.GetHashCode() ^ UpdateScratchSize.GetHashCode()
			^ BuildScratchSize.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkAccelerationStructureBuildSizesInfoKHR l, in VkAccelerationStructureBuildSizesInfoKHR r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.AccelerationStructureSize == r.AccelerationStructureSize) && (l.UpdateScratchSize == r.UpdateScratchSize)
			&& (l.BuildScratchSize == r.BuildScratchSize)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkAccelerationStructureBuildSizesInfoKHR l, in VkAccelerationStructureBuildSizesInfoKHR r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.AccelerationStructureSize != r.AccelerationStructureSize) || (l.UpdateScratchSize != r.UpdateScratchSize)
			|| (l.BuildScratchSize != r.BuildScratchSize)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkAccelerationStructureBuildSizesInfoKHR s) => s = new() { sType = TYPE };
}


} // namespace Vulkan

