/*
 * MIT License - Copyright(c) 2020 Sean Moss
 * This file is subject to the terms and conditions of the MIT License, the text of which can be found in the 'LICENSE'
 * file at the root of this repository, or online at<https://opensource.org/licenses/MIT>.
 */

/// This file was generated by VVKGen. Edits to this file will be lost on next generation.

using System;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;


namespace Vk.KHR
{

public unsafe partial class DescriptorUpdateTemplate : IHandleType<DescriptorUpdateTemplate>
{
	public static readonly DescriptorUpdateTemplate Null = new(Device.Null, Vk.Handle<DescriptorUpdateTemplate>.Null);

	public readonly Vk.Device Parent;
	public readonly Vk.DeviceFunctionTable Functions;
	public readonly Vk.Instance Instance;
	public readonly Vk.Device Device;
	public readonly Handle<DescriptorUpdateTemplate> Handle;
	public bool IsValid => Handle.IsValid;

	public DescriptorUpdateTemplate(in Vk.Device parent, Vk.Handle<DescriptorUpdateTemplate> handle)
	{
		Parent = parent;
		Functions = parent.Functions;
		Instance = parent.Instance;
		Device = parent;
		Handle = handle;
	}

	public override int GetHashCode() => Handle.GetHashCode();
	public override string? ToString() => $"[DescriptorUpdateTemplate 0x{(ulong)Handle:X16}]";
	public override bool Equals(object? o) => (o is DescriptorUpdateTemplate t) && (t.Handle == Handle);
	bool IEquatable<DescriptorUpdateTemplate>.Equals(DescriptorUpdateTemplate? other) => (other?.Handle ?? new()) == Handle;

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static implicit operator Vk.Handle<DescriptorUpdateTemplate> (DescriptorUpdateTemplate? handle) => handle?.Handle ?? new();
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (DescriptorUpdateTemplate? l, DescriptorUpdateTemplate? r) => (l?.Handle ?? new()) == (r?.Handle ?? new());
	public static bool operator != (DescriptorUpdateTemplate? l, DescriptorUpdateTemplate? r) => (l?.Handle ?? new()) == (r?.Handle ?? new());
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static implicit operator bool (DescriptorUpdateTemplate? handle) => handle?.Handle.IsValid ?? false;

}

public unsafe partial class SamplerYcbcrConversion : IHandleType<SamplerYcbcrConversion>
{
	public static readonly SamplerYcbcrConversion Null = new(Device.Null, Vk.Handle<SamplerYcbcrConversion>.Null);

	public readonly Vk.Device Parent;
	public readonly Vk.DeviceFunctionTable Functions;
	public readonly Vk.Instance Instance;
	public readonly Vk.Device Device;
	public readonly Handle<SamplerYcbcrConversion> Handle;
	public bool IsValid => Handle.IsValid;

	public SamplerYcbcrConversion(in Vk.Device parent, Vk.Handle<SamplerYcbcrConversion> handle)
	{
		Parent = parent;
		Functions = parent.Functions;
		Instance = parent.Instance;
		Device = parent;
		Handle = handle;
	}

	public override int GetHashCode() => Handle.GetHashCode();
	public override string? ToString() => $"[SamplerYcbcrConversion 0x{(ulong)Handle:X16}]";
	public override bool Equals(object? o) => (o is SamplerYcbcrConversion t) && (t.Handle == Handle);
	bool IEquatable<SamplerYcbcrConversion>.Equals(SamplerYcbcrConversion? other) => (other?.Handle ?? new()) == Handle;

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static implicit operator Vk.Handle<SamplerYcbcrConversion> (SamplerYcbcrConversion? handle) => handle?.Handle ?? new();
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (SamplerYcbcrConversion? l, SamplerYcbcrConversion? r) => (l?.Handle ?? new()) == (r?.Handle ?? new());
	public static bool operator != (SamplerYcbcrConversion? l, SamplerYcbcrConversion? r) => (l?.Handle ?? new()) == (r?.Handle ?? new());
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static implicit operator bool (SamplerYcbcrConversion? handle) => handle?.Handle.IsValid ?? false;

}

public unsafe partial class AccelerationStructure : IHandleType<AccelerationStructure>
{
	public static readonly AccelerationStructure Null = new(Device.Null, Vk.Handle<AccelerationStructure>.Null);

	public readonly Vk.Device Parent;
	public readonly Vk.DeviceFunctionTable Functions;
	public readonly Vk.Instance Instance;
	public readonly Vk.Device Device;
	public readonly Handle<AccelerationStructure> Handle;
	public bool IsValid => Handle.IsValid;

	public AccelerationStructure(in Vk.Device parent, Vk.Handle<AccelerationStructure> handle)
	{
		Parent = parent;
		Functions = parent.Functions;
		Instance = parent.Instance;
		Device = parent;
		Handle = handle;
	}

	public override int GetHashCode() => Handle.GetHashCode();
	public override string? ToString() => $"[AccelerationStructure 0x{(ulong)Handle:X16}]";
	public override bool Equals(object? o) => (o is AccelerationStructure t) && (t.Handle == Handle);
	bool IEquatable<AccelerationStructure>.Equals(AccelerationStructure? other) => (other?.Handle ?? new()) == Handle;

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static implicit operator Vk.Handle<AccelerationStructure> (AccelerationStructure? handle) => handle?.Handle ?? new();
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (AccelerationStructure? l, AccelerationStructure? r) => (l?.Handle ?? new()) == (r?.Handle ?? new());
	public static bool operator != (AccelerationStructure? l, AccelerationStructure? r) => (l?.Handle ?? new()) == (r?.Handle ?? new());
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static implicit operator bool (AccelerationStructure? handle) => handle?.Handle.IsValid ?? false;

	/// <summary>vkDestroyAccelerationStructureKHR</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void DestroyAccelerationStructureKHR(Vk.AllocationCallbacks* pAllocator)
	{
		if (Functions.vkDestroyAccelerationStructureKHR == null) throw new Vk.Extras.FunctionNotLoadedException("vkDestroyAccelerationStructureKHR");
		Functions.vkDestroyAccelerationStructureKHR(Device.Handle, Handle, pAllocator);
	}

	/// <summary>vkDestroyAccelerationStructureKHR</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void DestroyAccelerationStructureKHR(in Vk.AllocationCallbacks allocator)
	{
		if (Functions.vkDestroyAccelerationStructureKHR == null) throw new Vk.Extras.FunctionNotLoadedException("vkDestroyAccelerationStructureKHR");
		Functions.DestroyAccelerationStructureKHR(Device.Handle, Handle, allocator);
	}

	/// <summary>vkDestroyAccelerationStructureNV</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void DestroyAccelerationStructureNV(Vk.AllocationCallbacks* pAllocator)
	{
		if (Functions.vkDestroyAccelerationStructureNV == null) throw new Vk.Extras.FunctionNotLoadedException("vkDestroyAccelerationStructureNV");
		Functions.vkDestroyAccelerationStructureNV(Device.Handle, Handle, pAllocator);
	}

	/// <summary>vkDestroyAccelerationStructureNV</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void DestroyAccelerationStructureNV(in Vk.AllocationCallbacks allocator)
	{
		if (Functions.vkDestroyAccelerationStructureNV == null) throw new Vk.Extras.FunctionNotLoadedException("vkDestroyAccelerationStructureNV");
		Functions.DestroyAccelerationStructureNV(Device.Handle, Handle, allocator);
	}

	/// <summary>vkGetAccelerationStructureHandleNV</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Vk.Result GetAccelerationStructureHandleNV(ulong dataSize, void* pData)
	{
		if (Functions.vkGetAccelerationStructureHandleNV == null) throw new Vk.Extras.FunctionNotLoadedException("vkGetAccelerationStructureHandleNV");
		return Functions.vkGetAccelerationStructureHandleNV(Device.Handle, Handle, dataSize, pData);
	}

}

public unsafe partial class DeferredOperation : IHandleType<DeferredOperation>
{
	public static readonly DeferredOperation Null = new(Device.Null, Vk.Handle<DeferredOperation>.Null);

	public readonly Vk.Device Parent;
	public readonly Vk.DeviceFunctionTable Functions;
	public readonly Vk.Instance Instance;
	public readonly Vk.Device Device;
	public readonly Handle<DeferredOperation> Handle;
	public bool IsValid => Handle.IsValid;

	public DeferredOperation(in Vk.Device parent, Vk.Handle<DeferredOperation> handle)
	{
		Parent = parent;
		Functions = parent.Functions;
		Instance = parent.Instance;
		Device = parent;
		Handle = handle;
	}

	public override int GetHashCode() => Handle.GetHashCode();
	public override string? ToString() => $"[DeferredOperation 0x{(ulong)Handle:X16}]";
	public override bool Equals(object? o) => (o is DeferredOperation t) && (t.Handle == Handle);
	bool IEquatable<DeferredOperation>.Equals(DeferredOperation? other) => (other?.Handle ?? new()) == Handle;

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static implicit operator Vk.Handle<DeferredOperation> (DeferredOperation? handle) => handle?.Handle ?? new();
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (DeferredOperation? l, DeferredOperation? r) => (l?.Handle ?? new()) == (r?.Handle ?? new());
	public static bool operator != (DeferredOperation? l, DeferredOperation? r) => (l?.Handle ?? new()) == (r?.Handle ?? new());
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static implicit operator bool (DeferredOperation? handle) => handle?.Handle.IsValid ?? false;

	/// <summary>vkDestroyDeferredOperationKHR</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void DestroyDeferredOperationKHR(Vk.AllocationCallbacks* pAllocator)
	{
		if (Functions.vkDestroyDeferredOperationKHR == null) throw new Vk.Extras.FunctionNotLoadedException("vkDestroyDeferredOperationKHR");
		Functions.vkDestroyDeferredOperationKHR(Device.Handle, Handle, pAllocator);
	}

	/// <summary>vkDestroyDeferredOperationKHR</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void DestroyDeferredOperationKHR(in Vk.AllocationCallbacks allocator)
	{
		if (Functions.vkDestroyDeferredOperationKHR == null) throw new Vk.Extras.FunctionNotLoadedException("vkDestroyDeferredOperationKHR");
		Functions.DestroyDeferredOperationKHR(Device.Handle, Handle, allocator);
	}

	/// <summary>vkGetDeferredOperationMaxConcurrencyKHR</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public uint GetDeferredOperationMaxConcurrencyKHR()
	{
		if (Functions.vkGetDeferredOperationMaxConcurrencyKHR == null) throw new Vk.Extras.FunctionNotLoadedException("vkGetDeferredOperationMaxConcurrencyKHR");
		return Functions.vkGetDeferredOperationMaxConcurrencyKHR(Device.Handle, Handle);
	}

	/// <summary>vkGetDeferredOperationResultKHR</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Vk.Result GetDeferredOperationResultKHR()
	{
		if (Functions.vkGetDeferredOperationResultKHR == null) throw new Vk.Extras.FunctionNotLoadedException("vkGetDeferredOperationResultKHR");
		return Functions.vkGetDeferredOperationResultKHR(Device.Handle, Handle);
	}

	/// <summary>vkDeferredOperationJoinKHR</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Vk.Result DeferredOperationJoinKHR()
	{
		if (Functions.vkDeferredOperationJoinKHR == null) throw new Vk.Extras.FunctionNotLoadedException("vkDeferredOperationJoinKHR");
		return Functions.vkDeferredOperationJoinKHR(Device.Handle, Handle);
	}

}

public unsafe partial class Display : IHandleType<Display>
{
	public static readonly Display Null = new(PhysicalDevice.Null, Vk.Handle<Display>.Null);

	public readonly Vk.PhysicalDevice Parent;
	public readonly Vk.InstanceFunctionTable Functions;
	public readonly Vk.Instance Instance;
	public readonly Handle<Display> Handle;
	public bool IsValid => Handle.IsValid;

	public Display(in Vk.PhysicalDevice parent, Vk.Handle<Display> handle)
	{
		Parent = parent;
		Functions = parent.Functions;
		Instance = parent.Instance;
		Handle = handle;
	}

	public override int GetHashCode() => Handle.GetHashCode();
	public override string? ToString() => $"[Display 0x{(ulong)Handle:X16}]";
	public override bool Equals(object? o) => (o is Display t) && (t.Handle == Handle);
	bool IEquatable<Display>.Equals(Display? other) => (other?.Handle ?? new()) == Handle;

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static implicit operator Vk.Handle<Display> (Display? handle) => handle?.Handle ?? new();
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (Display? l, Display? r) => (l?.Handle ?? new()) == (r?.Handle ?? new());
	public static bool operator != (Display? l, Display? r) => (l?.Handle ?? new()) == (r?.Handle ?? new());
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static implicit operator bool (Display? handle) => handle?.Handle.IsValid ?? false;

	/// <summary>vkGetDisplayModePropertiesKHR</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Vk.Result GetDisplayModePropertiesKHR(uint* pPropertyCount, Vk.KHR.DisplayModeProperties* pProperties)
	{
		if (Functions.vkGetDisplayModePropertiesKHR == null) throw new Vk.Extras.FunctionNotLoadedException("vkGetDisplayModePropertiesKHR");
		return Functions.vkGetDisplayModePropertiesKHR(Parent.Handle, Handle, pPropertyCount, pProperties);
	}

	/// <summary>vkGetDisplayModePropertiesKHR</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Vk.Result GetDisplayModePropertiesKHR(out uint propertyCount, in Span<Vk.KHR.DisplayModeProperties> properties)
	{
		if (Functions.vkGetDisplayModePropertiesKHR == null) throw new Vk.Extras.FunctionNotLoadedException("vkGetDisplayModePropertiesKHR");
		return Functions.GetDisplayModePropertiesKHR(Parent.Handle, Handle, out propertyCount, properties);
	}

	/// <summary>vkCreateDisplayModeKHR</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Vk.Result CreateDisplayModeKHR(Vk.KHR.DisplayModeCreateInfo* pCreateInfo, Vk.AllocationCallbacks* pAllocator, Vk.Handle<Vk.KHR.DisplayMode>* pMode)
	{
		if (Functions.vkCreateDisplayModeKHR == null) throw new Vk.Extras.FunctionNotLoadedException("vkCreateDisplayModeKHR");
		return Functions.vkCreateDisplayModeKHR(Parent.Handle, Handle, pCreateInfo, pAllocator, pMode);
	}

	/// <summary>vkCreateDisplayModeKHR</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Vk.Result CreateDisplayModeKHR(Vk.KHR.DisplayModeCreateInfo* pCreateInfo, Vk.AllocationCallbacks* pAllocator, out Vk.KHR.DisplayMode pMode)
	{
		if (Functions.vkCreateDisplayModeKHR == null) throw new Vk.Extras.FunctionNotLoadedException("vkCreateDisplayModeKHR");
		Vk.Handle<Vk.KHR.DisplayMode> HANDLE;
		var RESULT = Functions.vkCreateDisplayModeKHR(Parent.Handle, Handle, pCreateInfo, pAllocator, &HANDLE);
		pMode = (RESULT == Result.Success) ? new(this, HANDLE) : Vk.KHR.DisplayMode.Null;
		return RESULT;
	}

	/// <summary>vkCreateDisplayModeKHR</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Vk.Result CreateDisplayModeKHR(in Vk.KHR.DisplayModeCreateInfo createInfo, in Vk.AllocationCallbacks allocator, out Vk.Handle<Vk.KHR.DisplayMode> mode)
	{
		if (Functions.vkCreateDisplayModeKHR == null) throw new Vk.Extras.FunctionNotLoadedException("vkCreateDisplayModeKHR");
		return Functions.CreateDisplayModeKHR(Parent.Handle, Handle, createInfo, allocator, out mode);
	}

	/// <summary>vkCreateDisplayModeKHR</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Vk.Result CreateDisplayModeKHR(in Vk.KHR.DisplayModeCreateInfo createInfo, in Vk.AllocationCallbacks allocator, out Vk.KHR.DisplayMode pMode)
	{
		if (Functions.vkCreateDisplayModeKHR == null) throw new Vk.Extras.FunctionNotLoadedException("vkCreateDisplayModeKHR");
		Vk.Handle<Vk.KHR.DisplayMode> HANDLE;
		var RESULT = Functions.CreateDisplayModeKHR(Parent.Handle, Handle, createInfo, allocator, out HANDLE);
		pMode = (RESULT == Result.Success) ? new(this, HANDLE) : Vk.KHR.DisplayMode.Null;
		return RESULT;
	}

	/// <summary>vkReleaseDisplayEXT</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Vk.Result ReleaseDisplayEXT()
	{
		if (Functions.vkReleaseDisplayEXT == null) throw new Vk.Extras.FunctionNotLoadedException("vkReleaseDisplayEXT");
		return Functions.vkReleaseDisplayEXT(Parent.Handle, Handle);
	}

	/// <summary>vkGetDisplayModeProperties2KHR</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Vk.Result GetDisplayModeProperties2KHR(uint* pPropertyCount, Vk.KHR.DisplayModeProperties2* pProperties)
	{
		if (Functions.vkGetDisplayModeProperties2KHR == null) throw new Vk.Extras.FunctionNotLoadedException("vkGetDisplayModeProperties2KHR");
		return Functions.vkGetDisplayModeProperties2KHR(Parent.Handle, Handle, pPropertyCount, pProperties);
	}

	/// <summary>vkGetDisplayModeProperties2KHR</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Vk.Result GetDisplayModeProperties2KHR(out uint propertyCount, in Span<Vk.KHR.DisplayModeProperties2> properties)
	{
		if (Functions.vkGetDisplayModeProperties2KHR == null) throw new Vk.Extras.FunctionNotLoadedException("vkGetDisplayModeProperties2KHR");
		return Functions.GetDisplayModeProperties2KHR(Parent.Handle, Handle, out propertyCount, properties);
	}

}

public unsafe partial class DisplayMode : IHandleType<DisplayMode>
{
	public static readonly DisplayMode Null = new(Display.Null, Vk.Handle<DisplayMode>.Null);

	public readonly Vk.KHR.Display Parent;
	public readonly Vk.InstanceFunctionTable Functions;
	public readonly Vk.Instance Instance;
	public readonly Handle<DisplayMode> Handle;
	public bool IsValid => Handle.IsValid;

	public DisplayMode(in Vk.KHR.Display parent, Vk.Handle<DisplayMode> handle)
	{
		Parent = parent;
		Functions = parent.Functions;
		Instance = parent.Instance;
		Handle = handle;
	}

	public override int GetHashCode() => Handle.GetHashCode();
	public override string? ToString() => $"[DisplayMode 0x{(ulong)Handle:X16}]";
	public override bool Equals(object? o) => (o is DisplayMode t) && (t.Handle == Handle);
	bool IEquatable<DisplayMode>.Equals(DisplayMode? other) => (other?.Handle ?? new()) == Handle;

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static implicit operator Vk.Handle<DisplayMode> (DisplayMode? handle) => handle?.Handle ?? new();
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (DisplayMode? l, DisplayMode? r) => (l?.Handle ?? new()) == (r?.Handle ?? new());
	public static bool operator != (DisplayMode? l, DisplayMode? r) => (l?.Handle ?? new()) == (r?.Handle ?? new());
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static implicit operator bool (DisplayMode? handle) => handle?.Handle.IsValid ?? false;

}

public unsafe partial class Surface : IHandleType<Surface>
{
	public static readonly Surface Null = new(Instance.Null, Vk.Handle<Surface>.Null);

	public readonly Vk.Instance Parent;
	public readonly Vk.InstanceFunctionTable Functions;
	public readonly Vk.Instance Instance;
	public readonly Handle<Surface> Handle;
	public bool IsValid => Handle.IsValid;

	public Surface(in Vk.Instance parent, Vk.Handle<Surface> handle)
	{
		Parent = parent;
		Functions = parent.Functions;
		Instance = parent;
		Handle = handle;
	}

	public override int GetHashCode() => Handle.GetHashCode();
	public override string? ToString() => $"[Surface 0x{(ulong)Handle:X16}]";
	public override bool Equals(object? o) => (o is Surface t) && (t.Handle == Handle);
	bool IEquatable<Surface>.Equals(Surface? other) => (other?.Handle ?? new()) == Handle;

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static implicit operator Vk.Handle<Surface> (Surface? handle) => handle?.Handle ?? new();
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (Surface? l, Surface? r) => (l?.Handle ?? new()) == (r?.Handle ?? new());
	public static bool operator != (Surface? l, Surface? r) => (l?.Handle ?? new()) == (r?.Handle ?? new());
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static implicit operator bool (Surface? handle) => handle?.Handle.IsValid ?? false;

	/// <summary>vkDestroySurfaceKHR</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void DestroySurfaceKHR(Vk.AllocationCallbacks* pAllocator)
	{
		if (Functions.vkDestroySurfaceKHR == null) throw new Vk.Extras.FunctionNotLoadedException("vkDestroySurfaceKHR");
		Functions.vkDestroySurfaceKHR(Instance.Handle, Handle, pAllocator);
	}

	/// <summary>vkDestroySurfaceKHR</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void DestroySurfaceKHR(in Vk.AllocationCallbacks allocator)
	{
		if (Functions.vkDestroySurfaceKHR == null) throw new Vk.Extras.FunctionNotLoadedException("vkDestroySurfaceKHR");
		Functions.DestroySurfaceKHR(Instance.Handle, Handle, allocator);
	}

}

public unsafe partial class Swapchain : IHandleType<Swapchain>
{
	public static readonly Swapchain Null = new(Device.Null, Vk.Handle<Swapchain>.Null);

	public readonly Vk.Device Parent;
	public readonly Vk.DeviceFunctionTable Functions;
	public readonly Vk.Instance Instance;
	public readonly Vk.Device Device;
	public readonly Handle<Swapchain> Handle;
	public bool IsValid => Handle.IsValid;

	public Swapchain(in Vk.Device parent, Vk.Handle<Swapchain> handle)
	{
		Parent = parent;
		Functions = parent.Functions;
		Instance = parent.Instance;
		Device = parent;
		Handle = handle;
	}

	public override int GetHashCode() => Handle.GetHashCode();
	public override string? ToString() => $"[Swapchain 0x{(ulong)Handle:X16}]";
	public override bool Equals(object? o) => (o is Swapchain t) && (t.Handle == Handle);
	bool IEquatable<Swapchain>.Equals(Swapchain? other) => (other?.Handle ?? new()) == Handle;

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static implicit operator Vk.Handle<Swapchain> (Swapchain? handle) => handle?.Handle ?? new();
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (Swapchain? l, Swapchain? r) => (l?.Handle ?? new()) == (r?.Handle ?? new());
	public static bool operator != (Swapchain? l, Swapchain? r) => (l?.Handle ?? new()) == (r?.Handle ?? new());
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static implicit operator bool (Swapchain? handle) => handle?.Handle.IsValid ?? false;

	/// <summary>vkDestroySwapchainKHR</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void DestroySwapchainKHR(Vk.AllocationCallbacks* pAllocator)
	{
		if (Functions.vkDestroySwapchainKHR == null) throw new Vk.Extras.FunctionNotLoadedException("vkDestroySwapchainKHR");
		Functions.vkDestroySwapchainKHR(Device.Handle, Handle, pAllocator);
	}

	/// <summary>vkDestroySwapchainKHR</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void DestroySwapchainKHR(in Vk.AllocationCallbacks allocator)
	{
		if (Functions.vkDestroySwapchainKHR == null) throw new Vk.Extras.FunctionNotLoadedException("vkDestroySwapchainKHR");
		Functions.DestroySwapchainKHR(Device.Handle, Handle, allocator);
	}

	/// <summary>vkGetSwapchainImagesKHR</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Vk.Result GetSwapchainImagesKHR(uint* pSwapchainImageCount, Vk.Handle<Vk.Image>* pSwapchainImages)
	{
		if (Functions.vkGetSwapchainImagesKHR == null) throw new Vk.Extras.FunctionNotLoadedException("vkGetSwapchainImagesKHR");
		return Functions.vkGetSwapchainImagesKHR(Device.Handle, Handle, pSwapchainImageCount, pSwapchainImages);
	}

	/// <summary>vkGetSwapchainImagesKHR</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Vk.Result GetSwapchainImagesKHR(out uint swapchainImageCount, in Span<Vk.Handle<Vk.Image>> swapchainImages)
	{
		if (Functions.vkGetSwapchainImagesKHR == null) throw new Vk.Extras.FunctionNotLoadedException("vkGetSwapchainImagesKHR");
		return Functions.GetSwapchainImagesKHR(Device.Handle, Handle, out swapchainImageCount, swapchainImages);
	}

	/// <summary>vkAcquireNextImageKHR</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Vk.Result AcquireNextImageKHR(ulong timeout, Vk.Handle<Vk.Semaphore> semaphore, Vk.Handle<Vk.Fence> fence, uint* pImageIndex)
	{
		if (Functions.vkAcquireNextImageKHR == null) throw new Vk.Extras.FunctionNotLoadedException("vkAcquireNextImageKHR");
		return Functions.vkAcquireNextImageKHR(Device.Handle, Handle, timeout, semaphore, fence, pImageIndex);
	}

	/// <summary>vkAcquireNextImageKHR</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Vk.Result AcquireNextImageKHR(ulong timeout, Vk.Handle<Vk.Semaphore> semaphore, Vk.Handle<Vk.Fence> fence, out uint imageIndex)
	{
		if (Functions.vkAcquireNextImageKHR == null) throw new Vk.Extras.FunctionNotLoadedException("vkAcquireNextImageKHR");
		return Functions.AcquireNextImageKHR(Device.Handle, Handle, timeout, semaphore, fence, out imageIndex);
	}

	/// <summary>vkGetSwapchainCounterEXT</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Vk.Result GetSwapchainCounterEXT(Vk.EXT.SurfaceCounterFlags counter, ulong* pCounterValue)
	{
		if (Functions.vkGetSwapchainCounterEXT == null) throw new Vk.Extras.FunctionNotLoadedException("vkGetSwapchainCounterEXT");
		return Functions.vkGetSwapchainCounterEXT(Device.Handle, Handle, counter, pCounterValue);
	}

	/// <summary>vkGetSwapchainCounterEXT</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Vk.Result GetSwapchainCounterEXT(Vk.EXT.SurfaceCounterFlags counter, out ulong counterValue)
	{
		if (Functions.vkGetSwapchainCounterEXT == null) throw new Vk.Extras.FunctionNotLoadedException("vkGetSwapchainCounterEXT");
		return Functions.GetSwapchainCounterEXT(Device.Handle, Handle, counter, out counterValue);
	}

	/// <summary>vkGetSwapchainStatusKHR</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Vk.Result GetSwapchainStatusKHR()
	{
		if (Functions.vkGetSwapchainStatusKHR == null) throw new Vk.Extras.FunctionNotLoadedException("vkGetSwapchainStatusKHR");
		return Functions.vkGetSwapchainStatusKHR(Device.Handle, Handle);
	}

	/// <summary>vkGetRefreshCycleDurationGOOGLE</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Vk.Result GetRefreshCycleDurationGOOGLE(Vk.GOOGLE.RefreshCycleDuration* pDisplayTimingProperties)
	{
		if (Functions.vkGetRefreshCycleDurationGOOGLE == null) throw new Vk.Extras.FunctionNotLoadedException("vkGetRefreshCycleDurationGOOGLE");
		return Functions.vkGetRefreshCycleDurationGOOGLE(Device.Handle, Handle, pDisplayTimingProperties);
	}

	/// <summary>vkGetRefreshCycleDurationGOOGLE</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Vk.Result GetRefreshCycleDurationGOOGLE(out Vk.GOOGLE.RefreshCycleDuration displayTimingProperties)
	{
		if (Functions.vkGetRefreshCycleDurationGOOGLE == null) throw new Vk.Extras.FunctionNotLoadedException("vkGetRefreshCycleDurationGOOGLE");
		return Functions.GetRefreshCycleDurationGOOGLE(Device.Handle, Handle, out displayTimingProperties);
	}

	/// <summary>vkGetPastPresentationTimingGOOGLE</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Vk.Result GetPastPresentationTimingGOOGLE(uint* pPresentationTimingCount, Vk.GOOGLE.PastPresentationTiming* pPresentationTimings)
	{
		if (Functions.vkGetPastPresentationTimingGOOGLE == null) throw new Vk.Extras.FunctionNotLoadedException("vkGetPastPresentationTimingGOOGLE");
		return Functions.vkGetPastPresentationTimingGOOGLE(Device.Handle, Handle, pPresentationTimingCount, pPresentationTimings);
	}

	/// <summary>vkGetPastPresentationTimingGOOGLE</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Vk.Result GetPastPresentationTimingGOOGLE(out uint presentationTimingCount, in Span<Vk.GOOGLE.PastPresentationTiming> presentationTimings)
	{
		if (Functions.vkGetPastPresentationTimingGOOGLE == null) throw new Vk.Extras.FunctionNotLoadedException("vkGetPastPresentationTimingGOOGLE");
		return Functions.GetPastPresentationTimingGOOGLE(Device.Handle, Handle, out presentationTimingCount, presentationTimings);
	}

	/// <summary>vkSetLocalDimmingAMD</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void SetLocalDimmingAMD(Vk.Bool32 localDimmingEnable)
	{
		if (Functions.vkSetLocalDimmingAMD == null) throw new Vk.Extras.FunctionNotLoadedException("vkSetLocalDimmingAMD");
		Functions.vkSetLocalDimmingAMD(Device.Handle, Handle, localDimmingEnable);
	}

	/// <summary>vkAcquireFullScreenExclusiveModeEXT</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Vk.Result AcquireFullScreenExclusiveModeEXT()
	{
		if (Functions.vkAcquireFullScreenExclusiveModeEXT == null) throw new Vk.Extras.FunctionNotLoadedException("vkAcquireFullScreenExclusiveModeEXT");
		return Functions.vkAcquireFullScreenExclusiveModeEXT(Device.Handle, Handle);
	}

	/// <summary>vkReleaseFullScreenExclusiveModeEXT</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Vk.Result ReleaseFullScreenExclusiveModeEXT()
	{
		if (Functions.vkReleaseFullScreenExclusiveModeEXT == null) throw new Vk.Extras.FunctionNotLoadedException("vkReleaseFullScreenExclusiveModeEXT");
		return Functions.vkReleaseFullScreenExclusiveModeEXT(Device.Handle, Handle);
	}

}

} // namespace Vk.KHR
