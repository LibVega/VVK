/*
 * MIT License - Copyright(c) 2020 Sean Moss
 * This file is subject to the terms and conditions of the MIT License, the text of which can be found in the 'LICENSE'
 * file at the root of this repository, or online at<https://opensource.org/licenses/MIT>.
 */

/// This file was generated by VVKGen. Edits to this file will be lost on next generation.

using System;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;


namespace Vk
{

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct BaseOutStructure : IEquatable<BaseOutStructure>
{
	public const Vk.StructureType TYPE = (Vk.StructureType)0x7FFFFFFF;

	public Vk.StructureType sType;
	public Vk.BaseOutStructure* pNext;

	public readonly override bool Equals(object? obj) => (obj is BaseOutStructure o) && (this == o);
	readonly bool IEquatable<BaseOutStructure>.Equals(BaseOutStructure obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in BaseOutStructure l, in BaseOutStructure r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in BaseOutStructure l, in BaseOutStructure r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext)
			;
	}


	/// <summary>Creates a new BaseOutStructure value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out BaseOutStructure value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct BaseInStructure : IEquatable<BaseInStructure>
{
	public const Vk.StructureType TYPE = (Vk.StructureType)0x7FFFFFFF;

	public Vk.StructureType sType;
	public Vk.BaseInStructure* pNext;

	public readonly override bool Equals(object? obj) => (obj is BaseInStructure o) && (this == o);
	readonly bool IEquatable<BaseInStructure>.Equals(BaseInStructure obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in BaseInStructure l, in BaseInStructure r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in BaseInStructure l, in BaseInStructure r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext)
			;
	}


	/// <summary>Creates a new BaseInStructure value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out BaseInStructure value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct Offset2D : IEquatable<Offset2D>
{
	public int X;
	public int Y;
	public Offset2D(
		int x = default,
		int y = default
	) {
		X = x;
		Y = y;
	}


	public readonly override bool Equals(object? obj) => (obj is Offset2D o) && (this == o);
	readonly bool IEquatable<Offset2D>.Equals(Offset2D obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			X.GetHashCode() ^ Y.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in Offset2D l, in Offset2D r)
	{
		return
			(l.X == r.X) && (l.Y == r.Y)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in Offset2D l, in Offset2D r)
	{
		return
			(l.X != r.X) || (l.Y != r.Y)
			;
	}


	/// <summary>Creates a new Offset2D value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out Offset2D value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct Offset3D : IEquatable<Offset3D>
{
	public int X;
	public int Y;
	public int Z;
	public Offset3D(
		int x = default,
		int y = default,
		int z = default
	) {
		X = x;
		Y = y;
		Z = z;
	}


	public readonly override bool Equals(object? obj) => (obj is Offset3D o) && (this == o);
	readonly bool IEquatable<Offset3D>.Equals(Offset3D obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			X.GetHashCode() ^ Y.GetHashCode() ^ Z.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in Offset3D l, in Offset3D r)
	{
		return
			(l.X == r.X) && (l.Y == r.Y) && (l.Z == r.Z)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in Offset3D l, in Offset3D r)
	{
		return
			(l.X != r.X) || (l.Y != r.Y) || (l.Z != r.Z)
			;
	}


	/// <summary>Creates a new Offset3D value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out Offset3D value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct Extent2D : IEquatable<Extent2D>
{
	public uint Width;
	public uint Height;
	public Extent2D(
		uint width = default,
		uint height = default
	) {
		Width = width;
		Height = height;
	}


	public readonly override bool Equals(object? obj) => (obj is Extent2D o) && (this == o);
	readonly bool IEquatable<Extent2D>.Equals(Extent2D obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Width.GetHashCode() ^ Height.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in Extent2D l, in Extent2D r)
	{
		return
			(l.Width == r.Width) && (l.Height == r.Height)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in Extent2D l, in Extent2D r)
	{
		return
			(l.Width != r.Width) || (l.Height != r.Height)
			;
	}


	/// <summary>Creates a new Extent2D value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out Extent2D value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct Extent3D : IEquatable<Extent3D>
{
	public uint Width;
	public uint Height;
	public uint Depth;
	public Extent3D(
		uint width = default,
		uint height = default,
		uint depth = default
	) {
		Width = width;
		Height = height;
		Depth = depth;
	}


	public readonly override bool Equals(object? obj) => (obj is Extent3D o) && (this == o);
	readonly bool IEquatable<Extent3D>.Equals(Extent3D obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Width.GetHashCode() ^ Height.GetHashCode() ^ Depth.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in Extent3D l, in Extent3D r)
	{
		return
			(l.Width == r.Width) && (l.Height == r.Height) && (l.Depth == r.Depth)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in Extent3D l, in Extent3D r)
	{
		return
			(l.Width != r.Width) || (l.Height != r.Height) || (l.Depth != r.Depth)
			;
	}


	/// <summary>Creates a new Extent3D value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out Extent3D value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct Viewport : IEquatable<Viewport>
{
	public float X;
	public float Y;
	public float Width;
	public float Height;
	public float MinDepth;
	public float MaxDepth;
	public Viewport(
		float x = default,
		float y = default,
		float width = default,
		float height = default,
		float minDepth = default,
		float maxDepth = default
	) {
		X = x;
		Y = y;
		Width = width;
		Height = height;
		MinDepth = minDepth;
		MaxDepth = maxDepth;
	}


	public readonly override bool Equals(object? obj) => (obj is Viewport o) && (this == o);
	readonly bool IEquatable<Viewport>.Equals(Viewport obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			X.GetHashCode() ^ Y.GetHashCode() ^ Width.GetHashCode() ^ Height.GetHashCode()
			^ MinDepth.GetHashCode() ^ MaxDepth.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in Viewport l, in Viewport r)
	{
		return
			(l.X == r.X) && (l.Y == r.Y) && (l.Width == r.Width) && (l.Height == r.Height)
			&& (l.MinDepth == r.MinDepth) && (l.MaxDepth == r.MaxDepth)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in Viewport l, in Viewport r)
	{
		return
			(l.X != r.X) || (l.Y != r.Y) || (l.Width != r.Width) || (l.Height != r.Height)
			|| (l.MinDepth != r.MinDepth) || (l.MaxDepth != r.MaxDepth)
			;
	}


	/// <summary>Creates a new Viewport value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out Viewport value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct Rect2D : IEquatable<Rect2D>
{
	public Vk.Offset2D Offset;
	public Vk.Extent2D Extent;
	public Rect2D(
		in Vk.Offset2D offset = default,
		in Vk.Extent2D extent = default
	) {
		Offset = offset;
		Extent = extent;
	}


	public readonly override bool Equals(object? obj) => (obj is Rect2D o) && (this == o);
	readonly bool IEquatable<Rect2D>.Equals(Rect2D obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Offset.GetHashCode() ^ Extent.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in Rect2D l, in Rect2D r)
	{
		return
			(l.Offset == r.Offset) && (l.Extent == r.Extent)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in Rect2D l, in Rect2D r)
	{
		return
			(l.Offset != r.Offset) || (l.Extent != r.Extent)
			;
	}


	/// <summary>Creates a new Rect2D value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out Rect2D value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ClearRect : IEquatable<ClearRect>
{
	public Vk.Rect2D Rect;
	public uint BaseArrayLayer;
	public uint LayerCount;
	public ClearRect(
		in Vk.Rect2D rect = default,
		uint baseArrayLayer = default,
		uint layerCount = default
	) {
		Rect = rect;
		BaseArrayLayer = baseArrayLayer;
		LayerCount = layerCount;
	}


	public readonly override bool Equals(object? obj) => (obj is ClearRect o) && (this == o);
	readonly bool IEquatable<ClearRect>.Equals(ClearRect obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Rect.GetHashCode() ^ BaseArrayLayer.GetHashCode() ^ LayerCount.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ClearRect l, in ClearRect r)
	{
		return
			(l.Rect == r.Rect) && (l.BaseArrayLayer == r.BaseArrayLayer) && (l.LayerCount == r.LayerCount)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ClearRect l, in ClearRect r)
	{
		return
			(l.Rect != r.Rect) || (l.BaseArrayLayer != r.BaseArrayLayer) || (l.LayerCount != r.LayerCount)
			;
	}


	/// <summary>Creates a new ClearRect value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ClearRect value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ComponentMapping : IEquatable<ComponentMapping>
{
	public Vk.ComponentSwizzle R;
	public Vk.ComponentSwizzle G;
	public Vk.ComponentSwizzle B;
	public Vk.ComponentSwizzle A;
	public ComponentMapping(
		in Vk.ComponentSwizzle r = default,
		in Vk.ComponentSwizzle g = default,
		in Vk.ComponentSwizzle b = default,
		in Vk.ComponentSwizzle a = default
	) {
		R = r;
		G = g;
		B = b;
		A = a;
	}


	public readonly override bool Equals(object? obj) => (obj is ComponentMapping o) && (this == o);
	readonly bool IEquatable<ComponentMapping>.Equals(ComponentMapping obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			R.GetHashCode() ^ G.GetHashCode() ^ B.GetHashCode() ^ A.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ComponentMapping l, in ComponentMapping r)
	{
		return
			(l.R == r.R) && (l.G == r.G) && (l.B == r.B) && (l.A == r.A)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ComponentMapping l, in ComponentMapping r)
	{
		return
			(l.R != r.R) || (l.G != r.G) || (l.B != r.B) || (l.A != r.A)
			;
	}


	/// <summary>Creates a new ComponentMapping value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ComponentMapping value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceProperties : IEquatable<PhysicalDeviceProperties>
{
	public uint ApiVersion;
	public uint DriverVersion;
	public uint VendorID;
	public uint DeviceID;
	public Vk.PhysicalDeviceType DeviceType;
	public Vk.FixedString DeviceName;
	public Vk.UUID PipelineCacheUUID;
	public Vk.PhysicalDeviceLimits Limits;
	public Vk.PhysicalDeviceSparseProperties SparseProperties;
	public PhysicalDeviceProperties(
		uint apiVersion = default,
		uint driverVersion = default,
		uint vendorID = default,
		uint deviceID = default,
		in Vk.PhysicalDeviceType deviceType = default,
		in Vk.FixedString deviceName = default,
		in Vk.UUID pipelineCacheUUID = default,
		in Vk.PhysicalDeviceLimits limits = default,
		in Vk.PhysicalDeviceSparseProperties sparseProperties = default
	) {
		ApiVersion = apiVersion;
		DriverVersion = driverVersion;
		VendorID = vendorID;
		DeviceID = deviceID;
		DeviceType = deviceType;
		DeviceName = deviceName;
		PipelineCacheUUID = pipelineCacheUUID;
		Limits = limits;
		SparseProperties = sparseProperties;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceProperties>.Equals(PhysicalDeviceProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			ApiVersion.GetHashCode() ^ DriverVersion.GetHashCode() ^ VendorID.GetHashCode() ^ DeviceID.GetHashCode()
			^ DeviceType.GetHashCode() ^ DeviceName.GetHashCode() ^ PipelineCacheUUID.GetHashCode() ^ Limits.GetHashCode()
			^ SparseProperties.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceProperties l, in PhysicalDeviceProperties r)
	{
		return
			(l.ApiVersion == r.ApiVersion) && (l.DriverVersion == r.DriverVersion) && (l.VendorID == r.VendorID) && (l.DeviceID == r.DeviceID)
			&& (l.DeviceType == r.DeviceType) && (l.DeviceName == r.DeviceName) && (l.PipelineCacheUUID == r.PipelineCacheUUID) && (l.Limits == r.Limits)
			&& (l.SparseProperties == r.SparseProperties)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceProperties l, in PhysicalDeviceProperties r)
	{
		return
			(l.ApiVersion != r.ApiVersion) || (l.DriverVersion != r.DriverVersion) || (l.VendorID != r.VendorID) || (l.DeviceID != r.DeviceID)
			|| (l.DeviceType != r.DeviceType) || (l.DeviceName != r.DeviceName) || (l.PipelineCacheUUID != r.PipelineCacheUUID) || (l.Limits != r.Limits)
			|| (l.SparseProperties != r.SparseProperties)
			;
	}


	/// <summary>Creates a new PhysicalDeviceProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceProperties value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ExtensionProperties : IEquatable<ExtensionProperties>
{
	public Vk.FixedString ExtensionName;
	public uint SpecVersion;
	public ExtensionProperties(
		in Vk.FixedString extensionName = default,
		uint specVersion = default
	) {
		ExtensionName = extensionName;
		SpecVersion = specVersion;
	}


	public readonly override bool Equals(object? obj) => (obj is ExtensionProperties o) && (this == o);
	readonly bool IEquatable<ExtensionProperties>.Equals(ExtensionProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			ExtensionName.GetHashCode() ^ SpecVersion.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ExtensionProperties l, in ExtensionProperties r)
	{
		return
			(l.ExtensionName == r.ExtensionName) && (l.SpecVersion == r.SpecVersion)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ExtensionProperties l, in ExtensionProperties r)
	{
		return
			(l.ExtensionName != r.ExtensionName) || (l.SpecVersion != r.SpecVersion)
			;
	}


	/// <summary>Creates a new ExtensionProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ExtensionProperties value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct LayerProperties : IEquatable<LayerProperties>
{
	public Vk.FixedString LayerName;
	public uint SpecVersion;
	public uint ImplementationVersion;
	public Vk.FixedString Description;
	public LayerProperties(
		in Vk.FixedString layerName = default,
		uint specVersion = default,
		uint implementationVersion = default,
		in Vk.FixedString description = default
	) {
		LayerName = layerName;
		SpecVersion = specVersion;
		ImplementationVersion = implementationVersion;
		Description = description;
	}


	public readonly override bool Equals(object? obj) => (obj is LayerProperties o) && (this == o);
	readonly bool IEquatable<LayerProperties>.Equals(LayerProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			LayerName.GetHashCode() ^ SpecVersion.GetHashCode() ^ ImplementationVersion.GetHashCode() ^ Description.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in LayerProperties l, in LayerProperties r)
	{
		return
			(l.LayerName == r.LayerName) && (l.SpecVersion == r.SpecVersion) && (l.ImplementationVersion == r.ImplementationVersion) && (l.Description == r.Description)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in LayerProperties l, in LayerProperties r)
	{
		return
			(l.LayerName != r.LayerName) || (l.SpecVersion != r.SpecVersion) || (l.ImplementationVersion != r.ImplementationVersion) || (l.Description != r.Description)
			;
	}


	/// <summary>Creates a new LayerProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out LayerProperties value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ApplicationInfo : IEquatable<ApplicationInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ApplicationInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public byte* ApplicationName;
	public uint ApplicationVersion;
	public byte* EngineName;
	public uint EngineVersion;
	public uint ApiVersion;
	public ApplicationInfo(
		byte* applicationName = default,
		uint applicationVersion = default,
		byte* engineName = default,
		uint engineVersion = default,
		uint apiVersion = default
	) {
		sType = TYPE;
		pNext = null;
		ApplicationName = applicationName;
		ApplicationVersion = applicationVersion;
		EngineName = engineName;
		EngineVersion = engineVersion;
		ApiVersion = apiVersion;
	}


	public readonly override bool Equals(object? obj) => (obj is ApplicationInfo o) && (this == o);
	readonly bool IEquatable<ApplicationInfo>.Equals(ApplicationInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ((ulong)ApplicationName).GetHashCode() ^ ApplicationVersion.GetHashCode()
			^ ((ulong)EngineName).GetHashCode() ^ EngineVersion.GetHashCode() ^ ApiVersion.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ApplicationInfo l, in ApplicationInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ApplicationName == r.ApplicationName) && (l.ApplicationVersion == r.ApplicationVersion)
			&& (l.EngineName == r.EngineName) && (l.EngineVersion == r.EngineVersion) && (l.ApiVersion == r.ApiVersion)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ApplicationInfo l, in ApplicationInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ApplicationName != r.ApplicationName) || (l.ApplicationVersion != r.ApplicationVersion)
			|| (l.EngineName != r.EngineName) || (l.EngineVersion != r.EngineVersion) || (l.ApiVersion != r.ApiVersion)
			;
	}


	/// <summary>Creates a new ApplicationInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ApplicationInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct AllocationCallbacks : IEquatable<AllocationCallbacks>
{
	public void* UserData;
	public delegate* managed<void*, ulong, ulong, Vk.SystemAllocationScope, void*> Allocation;
	public delegate* managed<void*, void*, ulong, ulong, Vk.SystemAllocationScope, void*> Reallocation;
	public delegate* managed<void*, void*, void> Free;
	public delegate* managed<void*, ulong, Vk.InternalAllocationType, Vk.SystemAllocationScope, void> InternalAllocation;
	public delegate* managed<void*, ulong, Vk.InternalAllocationType, Vk.SystemAllocationScope, void> InternalFree;
	public AllocationCallbacks(
		void* userData = default,
		delegate* managed<void*, ulong, ulong, Vk.SystemAllocationScope, void*> allocation = default,
		delegate* managed<void*, void*, ulong, ulong, Vk.SystemAllocationScope, void*> reallocation = default,
		delegate* managed<void*, void*, void> free = default,
		delegate* managed<void*, ulong, Vk.InternalAllocationType, Vk.SystemAllocationScope, void> internalAllocation = default,
		delegate* managed<void*, ulong, Vk.InternalAllocationType, Vk.SystemAllocationScope, void> internalFree = default
	) {
		UserData = userData;
		Allocation = allocation;
		Reallocation = reallocation;
		Free = free;
		InternalAllocation = internalAllocation;
		InternalFree = internalFree;
	}


	public readonly override bool Equals(object? obj) => (obj is AllocationCallbacks o) && (this == o);
	readonly bool IEquatable<AllocationCallbacks>.Equals(AllocationCallbacks obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			((ulong)UserData).GetHashCode() ^ ((ulong)Allocation).GetHashCode() ^ ((ulong)Reallocation).GetHashCode() ^ ((ulong)Free).GetHashCode()
			^ ((ulong)InternalAllocation).GetHashCode() ^ ((ulong)InternalFree).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in AllocationCallbacks l, in AllocationCallbacks r)
	{
		return
			(l.UserData == r.UserData) && (l.Allocation == r.Allocation) && (l.Reallocation == r.Reallocation) && (l.Free == r.Free)
			&& (l.InternalAllocation == r.InternalAllocation) && (l.InternalFree == r.InternalFree)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in AllocationCallbacks l, in AllocationCallbacks r)
	{
		return
			(l.UserData != r.UserData) || (l.Allocation != r.Allocation) || (l.Reallocation != r.Reallocation) || (l.Free != r.Free)
			|| (l.InternalAllocation != r.InternalAllocation) || (l.InternalFree != r.InternalFree)
			;
	}


	/// <summary>Creates a new AllocationCallbacks value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out AllocationCallbacks value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DeviceQueueCreateInfo : IEquatable<DeviceQueueCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DeviceQueueCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.DeviceQueueCreateFlags Flags;
	public uint QueueFamilyIndex;
	public uint QueueCount;
	public float* QueuePriorities;
	public DeviceQueueCreateInfo(
		in Vk.DeviceQueueCreateFlags flags = default,
		uint queueFamilyIndex = default,
		uint queueCount = default,
		float* queuePriorities = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		QueueFamilyIndex = queueFamilyIndex;
		QueueCount = queueCount;
		QueuePriorities = queuePriorities;
	}


	public readonly override bool Equals(object? obj) => (obj is DeviceQueueCreateInfo o) && (this == o);
	readonly bool IEquatable<DeviceQueueCreateInfo>.Equals(DeviceQueueCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ QueueFamilyIndex.GetHashCode()
			^ QueueCount.GetHashCode() ^ ((ulong)QueuePriorities).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DeviceQueueCreateInfo l, in DeviceQueueCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.QueueFamilyIndex == r.QueueFamilyIndex)
			&& (l.QueueCount == r.QueueCount) && (l.QueuePriorities == r.QueuePriorities)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DeviceQueueCreateInfo l, in DeviceQueueCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.QueueFamilyIndex != r.QueueFamilyIndex)
			|| (l.QueueCount != r.QueueCount) || (l.QueuePriorities != r.QueuePriorities)
			;
	}


	/// <summary>Creates a new DeviceQueueCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DeviceQueueCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DeviceCreateInfo : IEquatable<DeviceCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DeviceCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.DeviceCreateFlags Flags;
	public uint QueueCreateInfoCount;
	public Vk.DeviceQueueCreateInfo* QueueCreateInfos;
	public uint EnabledLayerCount;
	public byte** EnabledLayerNames;
	public uint EnabledExtensionCount;
	public byte** EnabledExtensionNames;
	public Vk.PhysicalDeviceFeatures* EnabledFeatures;
	public DeviceCreateInfo(
		in Vk.DeviceCreateFlags flags = default,
		uint queueCreateInfoCount = default,
		in Vk.DeviceQueueCreateInfo* queueCreateInfos = default,
		uint enabledLayerCount = default,
		byte** enabledLayerNames = default,
		uint enabledExtensionCount = default,
		byte** enabledExtensionNames = default,
		in Vk.PhysicalDeviceFeatures* enabledFeatures = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		QueueCreateInfoCount = queueCreateInfoCount;
		QueueCreateInfos = queueCreateInfos;
		EnabledLayerCount = enabledLayerCount;
		EnabledLayerNames = enabledLayerNames;
		EnabledExtensionCount = enabledExtensionCount;
		EnabledExtensionNames = enabledExtensionNames;
		EnabledFeatures = enabledFeatures;
	}


	public readonly override bool Equals(object? obj) => (obj is DeviceCreateInfo o) && (this == o);
	readonly bool IEquatable<DeviceCreateInfo>.Equals(DeviceCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ QueueCreateInfoCount.GetHashCode()
			^ ((ulong)QueueCreateInfos).GetHashCode() ^ EnabledLayerCount.GetHashCode() ^ ((ulong)EnabledLayerNames).GetHashCode() ^ EnabledExtensionCount.GetHashCode()
			^ ((ulong)EnabledExtensionNames).GetHashCode() ^ ((ulong)EnabledFeatures).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DeviceCreateInfo l, in DeviceCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.QueueCreateInfoCount == r.QueueCreateInfoCount)
			&& (l.QueueCreateInfos == r.QueueCreateInfos) && (l.EnabledLayerCount == r.EnabledLayerCount) && (l.EnabledLayerNames == r.EnabledLayerNames) && (l.EnabledExtensionCount == r.EnabledExtensionCount)
			&& (l.EnabledExtensionNames == r.EnabledExtensionNames) && (l.EnabledFeatures == r.EnabledFeatures)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DeviceCreateInfo l, in DeviceCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.QueueCreateInfoCount != r.QueueCreateInfoCount)
			|| (l.QueueCreateInfos != r.QueueCreateInfos) || (l.EnabledLayerCount != r.EnabledLayerCount) || (l.EnabledLayerNames != r.EnabledLayerNames) || (l.EnabledExtensionCount != r.EnabledExtensionCount)
			|| (l.EnabledExtensionNames != r.EnabledExtensionNames) || (l.EnabledFeatures != r.EnabledFeatures)
			;
	}


	/// <summary>Creates a new DeviceCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DeviceCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct InstanceCreateInfo : IEquatable<InstanceCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.InstanceCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.InstanceCreateFlags Flags;
	public Vk.ApplicationInfo* ApplicationInfo;
	public uint EnabledLayerCount;
	public byte** EnabledLayerNames;
	public uint EnabledExtensionCount;
	public byte** EnabledExtensionNames;
	public InstanceCreateInfo(
		in Vk.InstanceCreateFlags flags = default,
		in Vk.ApplicationInfo* applicationInfo = default,
		uint enabledLayerCount = default,
		byte** enabledLayerNames = default,
		uint enabledExtensionCount = default,
		byte** enabledExtensionNames = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		ApplicationInfo = applicationInfo;
		EnabledLayerCount = enabledLayerCount;
		EnabledLayerNames = enabledLayerNames;
		EnabledExtensionCount = enabledExtensionCount;
		EnabledExtensionNames = enabledExtensionNames;
	}


	public readonly override bool Equals(object? obj) => (obj is InstanceCreateInfo o) && (this == o);
	readonly bool IEquatable<InstanceCreateInfo>.Equals(InstanceCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ ((ulong)ApplicationInfo).GetHashCode()
			^ EnabledLayerCount.GetHashCode() ^ ((ulong)EnabledLayerNames).GetHashCode() ^ EnabledExtensionCount.GetHashCode() ^ ((ulong)EnabledExtensionNames).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in InstanceCreateInfo l, in InstanceCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.ApplicationInfo == r.ApplicationInfo)
			&& (l.EnabledLayerCount == r.EnabledLayerCount) && (l.EnabledLayerNames == r.EnabledLayerNames) && (l.EnabledExtensionCount == r.EnabledExtensionCount) && (l.EnabledExtensionNames == r.EnabledExtensionNames)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in InstanceCreateInfo l, in InstanceCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.ApplicationInfo != r.ApplicationInfo)
			|| (l.EnabledLayerCount != r.EnabledLayerCount) || (l.EnabledLayerNames != r.EnabledLayerNames) || (l.EnabledExtensionCount != r.EnabledExtensionCount) || (l.EnabledExtensionNames != r.EnabledExtensionNames)
			;
	}


	/// <summary>Creates a new InstanceCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out InstanceCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct QueueFamilyProperties : IEquatable<QueueFamilyProperties>
{
	public Vk.QueueFlags QueueFlags;
	public uint QueueCount;
	public uint TimestampValidBits;
	public Vk.Extent3D MinImageTransferGranularity;
	public QueueFamilyProperties(
		in Vk.QueueFlags queueFlags = default,
		uint queueCount = default,
		uint timestampValidBits = default,
		in Vk.Extent3D minImageTransferGranularity = default
	) {
		QueueFlags = queueFlags;
		QueueCount = queueCount;
		TimestampValidBits = timestampValidBits;
		MinImageTransferGranularity = minImageTransferGranularity;
	}


	public readonly override bool Equals(object? obj) => (obj is QueueFamilyProperties o) && (this == o);
	readonly bool IEquatable<QueueFamilyProperties>.Equals(QueueFamilyProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			QueueFlags.GetHashCode() ^ QueueCount.GetHashCode() ^ TimestampValidBits.GetHashCode() ^ MinImageTransferGranularity.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in QueueFamilyProperties l, in QueueFamilyProperties r)
	{
		return
			(l.QueueFlags == r.QueueFlags) && (l.QueueCount == r.QueueCount) && (l.TimestampValidBits == r.TimestampValidBits) && (l.MinImageTransferGranularity == r.MinImageTransferGranularity)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in QueueFamilyProperties l, in QueueFamilyProperties r)
	{
		return
			(l.QueueFlags != r.QueueFlags) || (l.QueueCount != r.QueueCount) || (l.TimestampValidBits != r.TimestampValidBits) || (l.MinImageTransferGranularity != r.MinImageTransferGranularity)
			;
	}


	/// <summary>Creates a new QueueFamilyProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out QueueFamilyProperties value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceMemoryProperties : IEquatable<PhysicalDeviceMemoryProperties>
{
	public uint MemoryTypeCount;
	public Vk.MemoryType MemoryTypes_0;
	public Vk.MemoryType MemoryTypes_1;
	public Vk.MemoryType MemoryTypes_2;
	public Vk.MemoryType MemoryTypes_3;
	public Vk.MemoryType MemoryTypes_4;
	public Vk.MemoryType MemoryTypes_5;
	public Vk.MemoryType MemoryTypes_6;
	public Vk.MemoryType MemoryTypes_7;
	public Vk.MemoryType MemoryTypes_8;
	public Vk.MemoryType MemoryTypes_9;
	public Vk.MemoryType MemoryTypes_10;
	public Vk.MemoryType MemoryTypes_11;
	public Vk.MemoryType MemoryTypes_12;
	public Vk.MemoryType MemoryTypes_13;
	public Vk.MemoryType MemoryTypes_14;
	public Vk.MemoryType MemoryTypes_15;
	public Vk.MemoryType MemoryTypes_16;
	public Vk.MemoryType MemoryTypes_17;
	public Vk.MemoryType MemoryTypes_18;
	public Vk.MemoryType MemoryTypes_19;
	public Vk.MemoryType MemoryTypes_20;
	public Vk.MemoryType MemoryTypes_21;
	public Vk.MemoryType MemoryTypes_22;
	public Vk.MemoryType MemoryTypes_23;
	public Vk.MemoryType MemoryTypes_24;
	public Vk.MemoryType MemoryTypes_25;
	public Vk.MemoryType MemoryTypes_26;
	public Vk.MemoryType MemoryTypes_27;
	public Vk.MemoryType MemoryTypes_28;
	public Vk.MemoryType MemoryTypes_29;
	public Vk.MemoryType MemoryTypes_30;
	public Vk.MemoryType MemoryTypes_31;
	public uint MemoryHeapCount;
	public Vk.MemoryHeap MemoryHeaps_0;
	public Vk.MemoryHeap MemoryHeaps_1;
	public Vk.MemoryHeap MemoryHeaps_2;
	public Vk.MemoryHeap MemoryHeaps_3;
	public Vk.MemoryHeap MemoryHeaps_4;
	public Vk.MemoryHeap MemoryHeaps_5;
	public Vk.MemoryHeap MemoryHeaps_6;
	public Vk.MemoryHeap MemoryHeaps_7;
	public Vk.MemoryHeap MemoryHeaps_8;
	public Vk.MemoryHeap MemoryHeaps_9;
	public Vk.MemoryHeap MemoryHeaps_10;
	public Vk.MemoryHeap MemoryHeaps_11;
	public Vk.MemoryHeap MemoryHeaps_12;
	public Vk.MemoryHeap MemoryHeaps_13;
	public Vk.MemoryHeap MemoryHeaps_14;
	public Vk.MemoryHeap MemoryHeaps_15;
	public PhysicalDeviceMemoryProperties(
		uint memoryTypeCount = default,
		in Vk.MemoryType memoryTypes0 = default,
		in Vk.MemoryType memoryTypes1 = default,
		in Vk.MemoryType memoryTypes2 = default,
		in Vk.MemoryType memoryTypes3 = default,
		in Vk.MemoryType memoryTypes4 = default,
		in Vk.MemoryType memoryTypes5 = default,
		in Vk.MemoryType memoryTypes6 = default,
		in Vk.MemoryType memoryTypes7 = default,
		in Vk.MemoryType memoryTypes8 = default,
		in Vk.MemoryType memoryTypes9 = default,
		in Vk.MemoryType memoryTypes10 = default,
		in Vk.MemoryType memoryTypes11 = default,
		in Vk.MemoryType memoryTypes12 = default,
		in Vk.MemoryType memoryTypes13 = default,
		in Vk.MemoryType memoryTypes14 = default,
		in Vk.MemoryType memoryTypes15 = default,
		in Vk.MemoryType memoryTypes16 = default,
		in Vk.MemoryType memoryTypes17 = default,
		in Vk.MemoryType memoryTypes18 = default,
		in Vk.MemoryType memoryTypes19 = default,
		in Vk.MemoryType memoryTypes20 = default,
		in Vk.MemoryType memoryTypes21 = default,
		in Vk.MemoryType memoryTypes22 = default,
		in Vk.MemoryType memoryTypes23 = default,
		in Vk.MemoryType memoryTypes24 = default,
		in Vk.MemoryType memoryTypes25 = default,
		in Vk.MemoryType memoryTypes26 = default,
		in Vk.MemoryType memoryTypes27 = default,
		in Vk.MemoryType memoryTypes28 = default,
		in Vk.MemoryType memoryTypes29 = default,
		in Vk.MemoryType memoryTypes30 = default,
		in Vk.MemoryType memoryTypes31 = default,
		uint memoryHeapCount = default,
		in Vk.MemoryHeap memoryHeaps0 = default,
		in Vk.MemoryHeap memoryHeaps1 = default,
		in Vk.MemoryHeap memoryHeaps2 = default,
		in Vk.MemoryHeap memoryHeaps3 = default,
		in Vk.MemoryHeap memoryHeaps4 = default,
		in Vk.MemoryHeap memoryHeaps5 = default,
		in Vk.MemoryHeap memoryHeaps6 = default,
		in Vk.MemoryHeap memoryHeaps7 = default,
		in Vk.MemoryHeap memoryHeaps8 = default,
		in Vk.MemoryHeap memoryHeaps9 = default,
		in Vk.MemoryHeap memoryHeaps10 = default,
		in Vk.MemoryHeap memoryHeaps11 = default,
		in Vk.MemoryHeap memoryHeaps12 = default,
		in Vk.MemoryHeap memoryHeaps13 = default,
		in Vk.MemoryHeap memoryHeaps14 = default,
		in Vk.MemoryHeap memoryHeaps15 = default
	) {
		MemoryTypeCount = memoryTypeCount;
		MemoryTypes_0 = memoryTypes0;
		MemoryTypes_1 = memoryTypes1;
		MemoryTypes_2 = memoryTypes2;
		MemoryTypes_3 = memoryTypes3;
		MemoryTypes_4 = memoryTypes4;
		MemoryTypes_5 = memoryTypes5;
		MemoryTypes_6 = memoryTypes6;
		MemoryTypes_7 = memoryTypes7;
		MemoryTypes_8 = memoryTypes8;
		MemoryTypes_9 = memoryTypes9;
		MemoryTypes_10 = memoryTypes10;
		MemoryTypes_11 = memoryTypes11;
		MemoryTypes_12 = memoryTypes12;
		MemoryTypes_13 = memoryTypes13;
		MemoryTypes_14 = memoryTypes14;
		MemoryTypes_15 = memoryTypes15;
		MemoryTypes_16 = memoryTypes16;
		MemoryTypes_17 = memoryTypes17;
		MemoryTypes_18 = memoryTypes18;
		MemoryTypes_19 = memoryTypes19;
		MemoryTypes_20 = memoryTypes20;
		MemoryTypes_21 = memoryTypes21;
		MemoryTypes_22 = memoryTypes22;
		MemoryTypes_23 = memoryTypes23;
		MemoryTypes_24 = memoryTypes24;
		MemoryTypes_25 = memoryTypes25;
		MemoryTypes_26 = memoryTypes26;
		MemoryTypes_27 = memoryTypes27;
		MemoryTypes_28 = memoryTypes28;
		MemoryTypes_29 = memoryTypes29;
		MemoryTypes_30 = memoryTypes30;
		MemoryTypes_31 = memoryTypes31;
		MemoryHeapCount = memoryHeapCount;
		MemoryHeaps_0 = memoryHeaps0;
		MemoryHeaps_1 = memoryHeaps1;
		MemoryHeaps_2 = memoryHeaps2;
		MemoryHeaps_3 = memoryHeaps3;
		MemoryHeaps_4 = memoryHeaps4;
		MemoryHeaps_5 = memoryHeaps5;
		MemoryHeaps_6 = memoryHeaps6;
		MemoryHeaps_7 = memoryHeaps7;
		MemoryHeaps_8 = memoryHeaps8;
		MemoryHeaps_9 = memoryHeaps9;
		MemoryHeaps_10 = memoryHeaps10;
		MemoryHeaps_11 = memoryHeaps11;
		MemoryHeaps_12 = memoryHeaps12;
		MemoryHeaps_13 = memoryHeaps13;
		MemoryHeaps_14 = memoryHeaps14;
		MemoryHeaps_15 = memoryHeaps15;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceMemoryProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceMemoryProperties>.Equals(PhysicalDeviceMemoryProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			MemoryTypeCount.GetHashCode() ^ MemoryTypes_0.GetHashCode() ^ MemoryTypes_1.GetHashCode() ^ MemoryTypes_2.GetHashCode()
			^ MemoryTypes_3.GetHashCode() ^ MemoryTypes_4.GetHashCode() ^ MemoryTypes_5.GetHashCode() ^ MemoryTypes_6.GetHashCode()
			^ MemoryTypes_7.GetHashCode() ^ MemoryTypes_8.GetHashCode() ^ MemoryTypes_9.GetHashCode() ^ MemoryTypes_10.GetHashCode()
			^ MemoryTypes_11.GetHashCode() ^ MemoryTypes_12.GetHashCode() ^ MemoryTypes_13.GetHashCode() ^ MemoryTypes_14.GetHashCode()
			^ MemoryTypes_15.GetHashCode() ^ MemoryTypes_16.GetHashCode() ^ MemoryTypes_17.GetHashCode() ^ MemoryTypes_18.GetHashCode()
			^ MemoryTypes_19.GetHashCode() ^ MemoryTypes_20.GetHashCode() ^ MemoryTypes_21.GetHashCode() ^ MemoryTypes_22.GetHashCode()
			^ MemoryTypes_23.GetHashCode() ^ MemoryTypes_24.GetHashCode() ^ MemoryTypes_25.GetHashCode() ^ MemoryTypes_26.GetHashCode()
			^ MemoryTypes_27.GetHashCode() ^ MemoryTypes_28.GetHashCode() ^ MemoryTypes_29.GetHashCode() ^ MemoryTypes_30.GetHashCode()
			^ MemoryTypes_31.GetHashCode() ^ MemoryHeapCount.GetHashCode() ^ MemoryHeaps_0.GetHashCode() ^ MemoryHeaps_1.GetHashCode()
			^ MemoryHeaps_2.GetHashCode() ^ MemoryHeaps_3.GetHashCode() ^ MemoryHeaps_4.GetHashCode() ^ MemoryHeaps_5.GetHashCode()
			^ MemoryHeaps_6.GetHashCode() ^ MemoryHeaps_7.GetHashCode() ^ MemoryHeaps_8.GetHashCode() ^ MemoryHeaps_9.GetHashCode()
			^ MemoryHeaps_10.GetHashCode() ^ MemoryHeaps_11.GetHashCode() ^ MemoryHeaps_12.GetHashCode() ^ MemoryHeaps_13.GetHashCode()
			^ MemoryHeaps_14.GetHashCode() ^ MemoryHeaps_15.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceMemoryProperties l, in PhysicalDeviceMemoryProperties r)
	{
		return
			(l.MemoryTypeCount == r.MemoryTypeCount) && (l.MemoryTypes_0 == r.MemoryTypes_0) && (l.MemoryTypes_1 == r.MemoryTypes_1) && (l.MemoryTypes_2 == r.MemoryTypes_2)
			&& (l.MemoryTypes_3 == r.MemoryTypes_3) && (l.MemoryTypes_4 == r.MemoryTypes_4) && (l.MemoryTypes_5 == r.MemoryTypes_5) && (l.MemoryTypes_6 == r.MemoryTypes_6)
			&& (l.MemoryTypes_7 == r.MemoryTypes_7) && (l.MemoryTypes_8 == r.MemoryTypes_8) && (l.MemoryTypes_9 == r.MemoryTypes_9) && (l.MemoryTypes_10 == r.MemoryTypes_10)
			&& (l.MemoryTypes_11 == r.MemoryTypes_11) && (l.MemoryTypes_12 == r.MemoryTypes_12) && (l.MemoryTypes_13 == r.MemoryTypes_13) && (l.MemoryTypes_14 == r.MemoryTypes_14)
			&& (l.MemoryTypes_15 == r.MemoryTypes_15) && (l.MemoryTypes_16 == r.MemoryTypes_16) && (l.MemoryTypes_17 == r.MemoryTypes_17) && (l.MemoryTypes_18 == r.MemoryTypes_18)
			&& (l.MemoryTypes_19 == r.MemoryTypes_19) && (l.MemoryTypes_20 == r.MemoryTypes_20) && (l.MemoryTypes_21 == r.MemoryTypes_21) && (l.MemoryTypes_22 == r.MemoryTypes_22)
			&& (l.MemoryTypes_23 == r.MemoryTypes_23) && (l.MemoryTypes_24 == r.MemoryTypes_24) && (l.MemoryTypes_25 == r.MemoryTypes_25) && (l.MemoryTypes_26 == r.MemoryTypes_26)
			&& (l.MemoryTypes_27 == r.MemoryTypes_27) && (l.MemoryTypes_28 == r.MemoryTypes_28) && (l.MemoryTypes_29 == r.MemoryTypes_29) && (l.MemoryTypes_30 == r.MemoryTypes_30)
			&& (l.MemoryTypes_31 == r.MemoryTypes_31) && (l.MemoryHeapCount == r.MemoryHeapCount) && (l.MemoryHeaps_0 == r.MemoryHeaps_0) && (l.MemoryHeaps_1 == r.MemoryHeaps_1)
			&& (l.MemoryHeaps_2 == r.MemoryHeaps_2) && (l.MemoryHeaps_3 == r.MemoryHeaps_3) && (l.MemoryHeaps_4 == r.MemoryHeaps_4) && (l.MemoryHeaps_5 == r.MemoryHeaps_5)
			&& (l.MemoryHeaps_6 == r.MemoryHeaps_6) && (l.MemoryHeaps_7 == r.MemoryHeaps_7) && (l.MemoryHeaps_8 == r.MemoryHeaps_8) && (l.MemoryHeaps_9 == r.MemoryHeaps_9)
			&& (l.MemoryHeaps_10 == r.MemoryHeaps_10) && (l.MemoryHeaps_11 == r.MemoryHeaps_11) && (l.MemoryHeaps_12 == r.MemoryHeaps_12) && (l.MemoryHeaps_13 == r.MemoryHeaps_13)
			&& (l.MemoryHeaps_14 == r.MemoryHeaps_14) && (l.MemoryHeaps_15 == r.MemoryHeaps_15)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceMemoryProperties l, in PhysicalDeviceMemoryProperties r)
	{
		return
			(l.MemoryTypeCount != r.MemoryTypeCount) || (l.MemoryTypes_0 != r.MemoryTypes_0) || (l.MemoryTypes_1 != r.MemoryTypes_1) || (l.MemoryTypes_2 != r.MemoryTypes_2)
			|| (l.MemoryTypes_3 != r.MemoryTypes_3) || (l.MemoryTypes_4 != r.MemoryTypes_4) || (l.MemoryTypes_5 != r.MemoryTypes_5) || (l.MemoryTypes_6 != r.MemoryTypes_6)
			|| (l.MemoryTypes_7 != r.MemoryTypes_7) || (l.MemoryTypes_8 != r.MemoryTypes_8) || (l.MemoryTypes_9 != r.MemoryTypes_9) || (l.MemoryTypes_10 != r.MemoryTypes_10)
			|| (l.MemoryTypes_11 != r.MemoryTypes_11) || (l.MemoryTypes_12 != r.MemoryTypes_12) || (l.MemoryTypes_13 != r.MemoryTypes_13) || (l.MemoryTypes_14 != r.MemoryTypes_14)
			|| (l.MemoryTypes_15 != r.MemoryTypes_15) || (l.MemoryTypes_16 != r.MemoryTypes_16) || (l.MemoryTypes_17 != r.MemoryTypes_17) || (l.MemoryTypes_18 != r.MemoryTypes_18)
			|| (l.MemoryTypes_19 != r.MemoryTypes_19) || (l.MemoryTypes_20 != r.MemoryTypes_20) || (l.MemoryTypes_21 != r.MemoryTypes_21) || (l.MemoryTypes_22 != r.MemoryTypes_22)
			|| (l.MemoryTypes_23 != r.MemoryTypes_23) || (l.MemoryTypes_24 != r.MemoryTypes_24) || (l.MemoryTypes_25 != r.MemoryTypes_25) || (l.MemoryTypes_26 != r.MemoryTypes_26)
			|| (l.MemoryTypes_27 != r.MemoryTypes_27) || (l.MemoryTypes_28 != r.MemoryTypes_28) || (l.MemoryTypes_29 != r.MemoryTypes_29) || (l.MemoryTypes_30 != r.MemoryTypes_30)
			|| (l.MemoryTypes_31 != r.MemoryTypes_31) || (l.MemoryHeapCount != r.MemoryHeapCount) || (l.MemoryHeaps_0 != r.MemoryHeaps_0) || (l.MemoryHeaps_1 != r.MemoryHeaps_1)
			|| (l.MemoryHeaps_2 != r.MemoryHeaps_2) || (l.MemoryHeaps_3 != r.MemoryHeaps_3) || (l.MemoryHeaps_4 != r.MemoryHeaps_4) || (l.MemoryHeaps_5 != r.MemoryHeaps_5)
			|| (l.MemoryHeaps_6 != r.MemoryHeaps_6) || (l.MemoryHeaps_7 != r.MemoryHeaps_7) || (l.MemoryHeaps_8 != r.MemoryHeaps_8) || (l.MemoryHeaps_9 != r.MemoryHeaps_9)
			|| (l.MemoryHeaps_10 != r.MemoryHeaps_10) || (l.MemoryHeaps_11 != r.MemoryHeaps_11) || (l.MemoryHeaps_12 != r.MemoryHeaps_12) || (l.MemoryHeaps_13 != r.MemoryHeaps_13)
			|| (l.MemoryHeaps_14 != r.MemoryHeaps_14) || (l.MemoryHeaps_15 != r.MemoryHeaps_15)
			;
	}


	/// <summary>Creates a new PhysicalDeviceMemoryProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceMemoryProperties value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct MemoryAllocateInfo : IEquatable<MemoryAllocateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.MemoryAllocateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.DeviceSize AllocationSize;
	public uint MemoryTypeIndex;
	public MemoryAllocateInfo(
		in Vk.DeviceSize allocationSize = default,
		uint memoryTypeIndex = default
	) {
		sType = TYPE;
		pNext = null;
		AllocationSize = allocationSize;
		MemoryTypeIndex = memoryTypeIndex;
	}


	public readonly override bool Equals(object? obj) => (obj is MemoryAllocateInfo o) && (this == o);
	readonly bool IEquatable<MemoryAllocateInfo>.Equals(MemoryAllocateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ AllocationSize.GetHashCode() ^ MemoryTypeIndex.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in MemoryAllocateInfo l, in MemoryAllocateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.AllocationSize == r.AllocationSize) && (l.MemoryTypeIndex == r.MemoryTypeIndex)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in MemoryAllocateInfo l, in MemoryAllocateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.AllocationSize != r.AllocationSize) || (l.MemoryTypeIndex != r.MemoryTypeIndex)
			;
	}


	/// <summary>Creates a new MemoryAllocateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out MemoryAllocateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct MemoryRequirements : IEquatable<MemoryRequirements>
{
	public Vk.DeviceSize Size;
	public Vk.DeviceSize Alignment;
	public uint MemoryTypeBits;
	public MemoryRequirements(
		in Vk.DeviceSize size = default,
		in Vk.DeviceSize alignment = default,
		uint memoryTypeBits = default
	) {
		Size = size;
		Alignment = alignment;
		MemoryTypeBits = memoryTypeBits;
	}


	public readonly override bool Equals(object? obj) => (obj is MemoryRequirements o) && (this == o);
	readonly bool IEquatable<MemoryRequirements>.Equals(MemoryRequirements obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Size.GetHashCode() ^ Alignment.GetHashCode() ^ MemoryTypeBits.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in MemoryRequirements l, in MemoryRequirements r)
	{
		return
			(l.Size == r.Size) && (l.Alignment == r.Alignment) && (l.MemoryTypeBits == r.MemoryTypeBits)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in MemoryRequirements l, in MemoryRequirements r)
	{
		return
			(l.Size != r.Size) || (l.Alignment != r.Alignment) || (l.MemoryTypeBits != r.MemoryTypeBits)
			;
	}


	/// <summary>Creates a new MemoryRequirements value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out MemoryRequirements value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SparseImageFormatProperties : IEquatable<SparseImageFormatProperties>
{
	public Vk.ImageAspectFlags AspectMask;
	public Vk.Extent3D ImageGranularity;
	public Vk.SparseImageFormatFlags Flags;
	public SparseImageFormatProperties(
		in Vk.ImageAspectFlags aspectMask = default,
		in Vk.Extent3D imageGranularity = default,
		in Vk.SparseImageFormatFlags flags = default
	) {
		AspectMask = aspectMask;
		ImageGranularity = imageGranularity;
		Flags = flags;
	}


	public readonly override bool Equals(object? obj) => (obj is SparseImageFormatProperties o) && (this == o);
	readonly bool IEquatable<SparseImageFormatProperties>.Equals(SparseImageFormatProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			AspectMask.GetHashCode() ^ ImageGranularity.GetHashCode() ^ Flags.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SparseImageFormatProperties l, in SparseImageFormatProperties r)
	{
		return
			(l.AspectMask == r.AspectMask) && (l.ImageGranularity == r.ImageGranularity) && (l.Flags == r.Flags)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SparseImageFormatProperties l, in SparseImageFormatProperties r)
	{
		return
			(l.AspectMask != r.AspectMask) || (l.ImageGranularity != r.ImageGranularity) || (l.Flags != r.Flags)
			;
	}


	/// <summary>Creates a new SparseImageFormatProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SparseImageFormatProperties value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SparseImageMemoryRequirements : IEquatable<SparseImageMemoryRequirements>
{
	public Vk.SparseImageFormatProperties FormatProperties;
	public uint ImageMipTailFirstLod;
	public Vk.DeviceSize ImageMipTailSize;
	public Vk.DeviceSize ImageMipTailOffset;
	public Vk.DeviceSize ImageMipTailStride;
	public SparseImageMemoryRequirements(
		in Vk.SparseImageFormatProperties formatProperties = default,
		uint imageMipTailFirstLod = default,
		in Vk.DeviceSize imageMipTailSize = default,
		in Vk.DeviceSize imageMipTailOffset = default,
		in Vk.DeviceSize imageMipTailStride = default
	) {
		FormatProperties = formatProperties;
		ImageMipTailFirstLod = imageMipTailFirstLod;
		ImageMipTailSize = imageMipTailSize;
		ImageMipTailOffset = imageMipTailOffset;
		ImageMipTailStride = imageMipTailStride;
	}


	public readonly override bool Equals(object? obj) => (obj is SparseImageMemoryRequirements o) && (this == o);
	readonly bool IEquatable<SparseImageMemoryRequirements>.Equals(SparseImageMemoryRequirements obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			FormatProperties.GetHashCode() ^ ImageMipTailFirstLod.GetHashCode() ^ ImageMipTailSize.GetHashCode() ^ ImageMipTailOffset.GetHashCode()
			^ ImageMipTailStride.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SparseImageMemoryRequirements l, in SparseImageMemoryRequirements r)
	{
		return
			(l.FormatProperties == r.FormatProperties) && (l.ImageMipTailFirstLod == r.ImageMipTailFirstLod) && (l.ImageMipTailSize == r.ImageMipTailSize) && (l.ImageMipTailOffset == r.ImageMipTailOffset)
			&& (l.ImageMipTailStride == r.ImageMipTailStride)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SparseImageMemoryRequirements l, in SparseImageMemoryRequirements r)
	{
		return
			(l.FormatProperties != r.FormatProperties) || (l.ImageMipTailFirstLod != r.ImageMipTailFirstLod) || (l.ImageMipTailSize != r.ImageMipTailSize) || (l.ImageMipTailOffset != r.ImageMipTailOffset)
			|| (l.ImageMipTailStride != r.ImageMipTailStride)
			;
	}


	/// <summary>Creates a new SparseImageMemoryRequirements value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SparseImageMemoryRequirements value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct MemoryType : IEquatable<MemoryType>
{
	public Vk.MemoryPropertyFlags PropertyFlags;
	public uint HeapIndex;
	public MemoryType(
		in Vk.MemoryPropertyFlags propertyFlags = default,
		uint heapIndex = default
	) {
		PropertyFlags = propertyFlags;
		HeapIndex = heapIndex;
	}


	public readonly override bool Equals(object? obj) => (obj is MemoryType o) && (this == o);
	readonly bool IEquatable<MemoryType>.Equals(MemoryType obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			PropertyFlags.GetHashCode() ^ HeapIndex.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in MemoryType l, in MemoryType r)
	{
		return
			(l.PropertyFlags == r.PropertyFlags) && (l.HeapIndex == r.HeapIndex)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in MemoryType l, in MemoryType r)
	{
		return
			(l.PropertyFlags != r.PropertyFlags) || (l.HeapIndex != r.HeapIndex)
			;
	}


	/// <summary>Creates a new MemoryType value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out MemoryType value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct MemoryHeap : IEquatable<MemoryHeap>
{
	public Vk.DeviceSize Size;
	public Vk.MemoryHeapFlags Flags;
	public MemoryHeap(
		in Vk.DeviceSize size = default,
		in Vk.MemoryHeapFlags flags = default
	) {
		Size = size;
		Flags = flags;
	}


	public readonly override bool Equals(object? obj) => (obj is MemoryHeap o) && (this == o);
	readonly bool IEquatable<MemoryHeap>.Equals(MemoryHeap obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Size.GetHashCode() ^ Flags.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in MemoryHeap l, in MemoryHeap r)
	{
		return
			(l.Size == r.Size) && (l.Flags == r.Flags)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in MemoryHeap l, in MemoryHeap r)
	{
		return
			(l.Size != r.Size) || (l.Flags != r.Flags)
			;
	}


	/// <summary>Creates a new MemoryHeap value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out MemoryHeap value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct MappedMemoryRange : IEquatable<MappedMemoryRange>
{
	public const Vk.StructureType TYPE = Vk.StructureType.MappedMemoryRange;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Handle<Vk.DeviceMemory> Memory;
	public Vk.DeviceSize Offset;
	public Vk.DeviceSize Size;
	public MappedMemoryRange(
		in Vk.Handle<Vk.DeviceMemory> memory = default,
		in Vk.DeviceSize offset = default,
		in Vk.DeviceSize size = default
	) {
		sType = TYPE;
		pNext = null;
		Memory = memory;
		Offset = offset;
		Size = size;
	}


	public readonly override bool Equals(object? obj) => (obj is MappedMemoryRange o) && (this == o);
	readonly bool IEquatable<MappedMemoryRange>.Equals(MappedMemoryRange obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Memory.GetHashCode() ^ Offset.GetHashCode()
			^ Size.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in MappedMemoryRange l, in MappedMemoryRange r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Memory == r.Memory) && (l.Offset == r.Offset)
			&& (l.Size == r.Size)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in MappedMemoryRange l, in MappedMemoryRange r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Memory != r.Memory) || (l.Offset != r.Offset)
			|| (l.Size != r.Size)
			;
	}


	/// <summary>Creates a new MappedMemoryRange value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out MappedMemoryRange value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct FormatProperties : IEquatable<FormatProperties>
{
	public Vk.FormatFeatureFlags LinearTilingFeatures;
	public Vk.FormatFeatureFlags OptimalTilingFeatures;
	public Vk.FormatFeatureFlags BufferFeatures;
	public FormatProperties(
		in Vk.FormatFeatureFlags linearTilingFeatures = default,
		in Vk.FormatFeatureFlags optimalTilingFeatures = default,
		in Vk.FormatFeatureFlags bufferFeatures = default
	) {
		LinearTilingFeatures = linearTilingFeatures;
		OptimalTilingFeatures = optimalTilingFeatures;
		BufferFeatures = bufferFeatures;
	}


	public readonly override bool Equals(object? obj) => (obj is FormatProperties o) && (this == o);
	readonly bool IEquatable<FormatProperties>.Equals(FormatProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			LinearTilingFeatures.GetHashCode() ^ OptimalTilingFeatures.GetHashCode() ^ BufferFeatures.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in FormatProperties l, in FormatProperties r)
	{
		return
			(l.LinearTilingFeatures == r.LinearTilingFeatures) && (l.OptimalTilingFeatures == r.OptimalTilingFeatures) && (l.BufferFeatures == r.BufferFeatures)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in FormatProperties l, in FormatProperties r)
	{
		return
			(l.LinearTilingFeatures != r.LinearTilingFeatures) || (l.OptimalTilingFeatures != r.OptimalTilingFeatures) || (l.BufferFeatures != r.BufferFeatures)
			;
	}


	/// <summary>Creates a new FormatProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out FormatProperties value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ImageFormatProperties : IEquatable<ImageFormatProperties>
{
	public Vk.Extent3D MaxExtent;
	public uint MaxMipLevels;
	public uint MaxArrayLayers;
	public Vk.SampleCountFlags SampleCounts;
	public Vk.DeviceSize MaxResourceSize;
	public ImageFormatProperties(
		in Vk.Extent3D maxExtent = default,
		uint maxMipLevels = default,
		uint maxArrayLayers = default,
		in Vk.SampleCountFlags sampleCounts = default,
		in Vk.DeviceSize maxResourceSize = default
	) {
		MaxExtent = maxExtent;
		MaxMipLevels = maxMipLevels;
		MaxArrayLayers = maxArrayLayers;
		SampleCounts = sampleCounts;
		MaxResourceSize = maxResourceSize;
	}


	public readonly override bool Equals(object? obj) => (obj is ImageFormatProperties o) && (this == o);
	readonly bool IEquatable<ImageFormatProperties>.Equals(ImageFormatProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			MaxExtent.GetHashCode() ^ MaxMipLevels.GetHashCode() ^ MaxArrayLayers.GetHashCode() ^ SampleCounts.GetHashCode()
			^ MaxResourceSize.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ImageFormatProperties l, in ImageFormatProperties r)
	{
		return
			(l.MaxExtent == r.MaxExtent) && (l.MaxMipLevels == r.MaxMipLevels) && (l.MaxArrayLayers == r.MaxArrayLayers) && (l.SampleCounts == r.SampleCounts)
			&& (l.MaxResourceSize == r.MaxResourceSize)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ImageFormatProperties l, in ImageFormatProperties r)
	{
		return
			(l.MaxExtent != r.MaxExtent) || (l.MaxMipLevels != r.MaxMipLevels) || (l.MaxArrayLayers != r.MaxArrayLayers) || (l.SampleCounts != r.SampleCounts)
			|| (l.MaxResourceSize != r.MaxResourceSize)
			;
	}


	/// <summary>Creates a new ImageFormatProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ImageFormatProperties value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DescriptorBufferInfo : IEquatable<DescriptorBufferInfo>
{
	public Vk.Handle<Vk.Buffer> Buffer;
	public Vk.DeviceSize Offset;
	public Vk.DeviceSize Range;
	public DescriptorBufferInfo(
		in Vk.Handle<Vk.Buffer> buffer = default,
		in Vk.DeviceSize offset = default,
		in Vk.DeviceSize range = default
	) {
		Buffer = buffer;
		Offset = offset;
		Range = range;
	}


	public readonly override bool Equals(object? obj) => (obj is DescriptorBufferInfo o) && (this == o);
	readonly bool IEquatable<DescriptorBufferInfo>.Equals(DescriptorBufferInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Buffer.GetHashCode() ^ Offset.GetHashCode() ^ Range.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DescriptorBufferInfo l, in DescriptorBufferInfo r)
	{
		return
			(l.Buffer == r.Buffer) && (l.Offset == r.Offset) && (l.Range == r.Range)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DescriptorBufferInfo l, in DescriptorBufferInfo r)
	{
		return
			(l.Buffer != r.Buffer) || (l.Offset != r.Offset) || (l.Range != r.Range)
			;
	}


	/// <summary>Creates a new DescriptorBufferInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DescriptorBufferInfo value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DescriptorImageInfo : IEquatable<DescriptorImageInfo>
{
	public Vk.Handle<Vk.Sampler> Sampler;
	public Vk.Handle<Vk.ImageView> ImageView;
	public Vk.ImageLayout ImageLayout;
	public DescriptorImageInfo(
		in Vk.Handle<Vk.Sampler> sampler = default,
		in Vk.Handle<Vk.ImageView> imageView = default,
		in Vk.ImageLayout imageLayout = default
	) {
		Sampler = sampler;
		ImageView = imageView;
		ImageLayout = imageLayout;
	}


	public readonly override bool Equals(object? obj) => (obj is DescriptorImageInfo o) && (this == o);
	readonly bool IEquatable<DescriptorImageInfo>.Equals(DescriptorImageInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Sampler.GetHashCode() ^ ImageView.GetHashCode() ^ ImageLayout.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DescriptorImageInfo l, in DescriptorImageInfo r)
	{
		return
			(l.Sampler == r.Sampler) && (l.ImageView == r.ImageView) && (l.ImageLayout == r.ImageLayout)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DescriptorImageInfo l, in DescriptorImageInfo r)
	{
		return
			(l.Sampler != r.Sampler) || (l.ImageView != r.ImageView) || (l.ImageLayout != r.ImageLayout)
			;
	}


	/// <summary>Creates a new DescriptorImageInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DescriptorImageInfo value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct WriteDescriptorSet : IEquatable<WriteDescriptorSet>
{
	public const Vk.StructureType TYPE = Vk.StructureType.WriteDescriptorSet;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Handle<Vk.DescriptorSet> DstSet;
	public uint DstBinding;
	public uint DstArrayElement;
	public uint DescriptorCount;
	public Vk.DescriptorType DescriptorType;
	public Vk.DescriptorImageInfo* ImageInfo;
	public Vk.DescriptorBufferInfo* BufferInfo;
	public Vk.Handle<Vk.BufferView>* TexelBufferView;
	public WriteDescriptorSet(
		in Vk.Handle<Vk.DescriptorSet> dstSet = default,
		uint dstBinding = default,
		uint dstArrayElement = default,
		uint descriptorCount = default,
		in Vk.DescriptorType descriptorType = default,
		in Vk.DescriptorImageInfo* imageInfo = default,
		in Vk.DescriptorBufferInfo* bufferInfo = default,
		in Vk.Handle<Vk.BufferView>* texelBufferView = default
	) {
		sType = TYPE;
		pNext = null;
		DstSet = dstSet;
		DstBinding = dstBinding;
		DstArrayElement = dstArrayElement;
		DescriptorCount = descriptorCount;
		DescriptorType = descriptorType;
		ImageInfo = imageInfo;
		BufferInfo = bufferInfo;
		TexelBufferView = texelBufferView;
	}


	public readonly override bool Equals(object? obj) => (obj is WriteDescriptorSet o) && (this == o);
	readonly bool IEquatable<WriteDescriptorSet>.Equals(WriteDescriptorSet obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DstSet.GetHashCode() ^ DstBinding.GetHashCode()
			^ DstArrayElement.GetHashCode() ^ DescriptorCount.GetHashCode() ^ DescriptorType.GetHashCode() ^ ((ulong)ImageInfo).GetHashCode()
			^ ((ulong)BufferInfo).GetHashCode() ^ ((ulong)TexelBufferView).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in WriteDescriptorSet l, in WriteDescriptorSet r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DstSet == r.DstSet) && (l.DstBinding == r.DstBinding)
			&& (l.DstArrayElement == r.DstArrayElement) && (l.DescriptorCount == r.DescriptorCount) && (l.DescriptorType == r.DescriptorType) && (l.ImageInfo == r.ImageInfo)
			&& (l.BufferInfo == r.BufferInfo) && (l.TexelBufferView == r.TexelBufferView)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in WriteDescriptorSet l, in WriteDescriptorSet r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DstSet != r.DstSet) || (l.DstBinding != r.DstBinding)
			|| (l.DstArrayElement != r.DstArrayElement) || (l.DescriptorCount != r.DescriptorCount) || (l.DescriptorType != r.DescriptorType) || (l.ImageInfo != r.ImageInfo)
			|| (l.BufferInfo != r.BufferInfo) || (l.TexelBufferView != r.TexelBufferView)
			;
	}


	/// <summary>Creates a new WriteDescriptorSet value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out WriteDescriptorSet value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct CopyDescriptorSet : IEquatable<CopyDescriptorSet>
{
	public const Vk.StructureType TYPE = Vk.StructureType.CopyDescriptorSet;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Handle<Vk.DescriptorSet> SrcSet;
	public uint SrcBinding;
	public uint SrcArrayElement;
	public Vk.Handle<Vk.DescriptorSet> DstSet;
	public uint DstBinding;
	public uint DstArrayElement;
	public uint DescriptorCount;
	public CopyDescriptorSet(
		in Vk.Handle<Vk.DescriptorSet> srcSet = default,
		uint srcBinding = default,
		uint srcArrayElement = default,
		in Vk.Handle<Vk.DescriptorSet> dstSet = default,
		uint dstBinding = default,
		uint dstArrayElement = default,
		uint descriptorCount = default
	) {
		sType = TYPE;
		pNext = null;
		SrcSet = srcSet;
		SrcBinding = srcBinding;
		SrcArrayElement = srcArrayElement;
		DstSet = dstSet;
		DstBinding = dstBinding;
		DstArrayElement = dstArrayElement;
		DescriptorCount = descriptorCount;
	}


	public readonly override bool Equals(object? obj) => (obj is CopyDescriptorSet o) && (this == o);
	readonly bool IEquatable<CopyDescriptorSet>.Equals(CopyDescriptorSet obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SrcSet.GetHashCode() ^ SrcBinding.GetHashCode()
			^ SrcArrayElement.GetHashCode() ^ DstSet.GetHashCode() ^ DstBinding.GetHashCode() ^ DstArrayElement.GetHashCode()
			^ DescriptorCount.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in CopyDescriptorSet l, in CopyDescriptorSet r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SrcSet == r.SrcSet) && (l.SrcBinding == r.SrcBinding)
			&& (l.SrcArrayElement == r.SrcArrayElement) && (l.DstSet == r.DstSet) && (l.DstBinding == r.DstBinding) && (l.DstArrayElement == r.DstArrayElement)
			&& (l.DescriptorCount == r.DescriptorCount)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in CopyDescriptorSet l, in CopyDescriptorSet r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SrcSet != r.SrcSet) || (l.SrcBinding != r.SrcBinding)
			|| (l.SrcArrayElement != r.SrcArrayElement) || (l.DstSet != r.DstSet) || (l.DstBinding != r.DstBinding) || (l.DstArrayElement != r.DstArrayElement)
			|| (l.DescriptorCount != r.DescriptorCount)
			;
	}


	/// <summary>Creates a new CopyDescriptorSet value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out CopyDescriptorSet value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct BufferCreateInfo : IEquatable<BufferCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.BufferCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.BufferCreateFlags Flags;
	public Vk.DeviceSize Size;
	public Vk.BufferUsageFlags Usage;
	public Vk.SharingMode SharingMode;
	public uint QueueFamilyIndexCount;
	public uint* QueueFamilyIndices;
	public BufferCreateInfo(
		in Vk.BufferCreateFlags flags = default,
		in Vk.DeviceSize size = default,
		in Vk.BufferUsageFlags usage = default,
		in Vk.SharingMode sharingMode = default,
		uint queueFamilyIndexCount = default,
		uint* queueFamilyIndices = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		Size = size;
		Usage = usage;
		SharingMode = sharingMode;
		QueueFamilyIndexCount = queueFamilyIndexCount;
		QueueFamilyIndices = queueFamilyIndices;
	}


	public readonly override bool Equals(object? obj) => (obj is BufferCreateInfo o) && (this == o);
	readonly bool IEquatable<BufferCreateInfo>.Equals(BufferCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ Size.GetHashCode()
			^ Usage.GetHashCode() ^ SharingMode.GetHashCode() ^ QueueFamilyIndexCount.GetHashCode() ^ ((ulong)QueueFamilyIndices).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in BufferCreateInfo l, in BufferCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.Size == r.Size)
			&& (l.Usage == r.Usage) && (l.SharingMode == r.SharingMode) && (l.QueueFamilyIndexCount == r.QueueFamilyIndexCount) && (l.QueueFamilyIndices == r.QueueFamilyIndices)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in BufferCreateInfo l, in BufferCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.Size != r.Size)
			|| (l.Usage != r.Usage) || (l.SharingMode != r.SharingMode) || (l.QueueFamilyIndexCount != r.QueueFamilyIndexCount) || (l.QueueFamilyIndices != r.QueueFamilyIndices)
			;
	}


	/// <summary>Creates a new BufferCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out BufferCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct BufferViewCreateInfo : IEquatable<BufferViewCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.BufferViewCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.BufferViewCreateFlags Flags;
	public Vk.Handle<Vk.Buffer> Buffer;
	public Vk.Format Format;
	public Vk.DeviceSize Offset;
	public Vk.DeviceSize Range;
	public BufferViewCreateInfo(
		in Vk.BufferViewCreateFlags flags = default,
		in Vk.Handle<Vk.Buffer> buffer = default,
		in Vk.Format format = default,
		in Vk.DeviceSize offset = default,
		in Vk.DeviceSize range = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		Buffer = buffer;
		Format = format;
		Offset = offset;
		Range = range;
	}


	public readonly override bool Equals(object? obj) => (obj is BufferViewCreateInfo o) && (this == o);
	readonly bool IEquatable<BufferViewCreateInfo>.Equals(BufferViewCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ Buffer.GetHashCode()
			^ Format.GetHashCode() ^ Offset.GetHashCode() ^ Range.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in BufferViewCreateInfo l, in BufferViewCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.Buffer == r.Buffer)
			&& (l.Format == r.Format) && (l.Offset == r.Offset) && (l.Range == r.Range)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in BufferViewCreateInfo l, in BufferViewCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.Buffer != r.Buffer)
			|| (l.Format != r.Format) || (l.Offset != r.Offset) || (l.Range != r.Range)
			;
	}


	/// <summary>Creates a new BufferViewCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out BufferViewCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ImageSubresource : IEquatable<ImageSubresource>
{
	public Vk.ImageAspectFlags AspectMask;
	public uint MipLevel;
	public uint ArrayLayer;
	public ImageSubresource(
		in Vk.ImageAspectFlags aspectMask = default,
		uint mipLevel = default,
		uint arrayLayer = default
	) {
		AspectMask = aspectMask;
		MipLevel = mipLevel;
		ArrayLayer = arrayLayer;
	}


	public readonly override bool Equals(object? obj) => (obj is ImageSubresource o) && (this == o);
	readonly bool IEquatable<ImageSubresource>.Equals(ImageSubresource obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			AspectMask.GetHashCode() ^ MipLevel.GetHashCode() ^ ArrayLayer.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ImageSubresource l, in ImageSubresource r)
	{
		return
			(l.AspectMask == r.AspectMask) && (l.MipLevel == r.MipLevel) && (l.ArrayLayer == r.ArrayLayer)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ImageSubresource l, in ImageSubresource r)
	{
		return
			(l.AspectMask != r.AspectMask) || (l.MipLevel != r.MipLevel) || (l.ArrayLayer != r.ArrayLayer)
			;
	}


	/// <summary>Creates a new ImageSubresource value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ImageSubresource value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ImageSubresourceLayers : IEquatable<ImageSubresourceLayers>
{
	public Vk.ImageAspectFlags AspectMask;
	public uint MipLevel;
	public uint BaseArrayLayer;
	public uint LayerCount;
	public ImageSubresourceLayers(
		in Vk.ImageAspectFlags aspectMask = default,
		uint mipLevel = default,
		uint baseArrayLayer = default,
		uint layerCount = default
	) {
		AspectMask = aspectMask;
		MipLevel = mipLevel;
		BaseArrayLayer = baseArrayLayer;
		LayerCount = layerCount;
	}


	public readonly override bool Equals(object? obj) => (obj is ImageSubresourceLayers o) && (this == o);
	readonly bool IEquatable<ImageSubresourceLayers>.Equals(ImageSubresourceLayers obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			AspectMask.GetHashCode() ^ MipLevel.GetHashCode() ^ BaseArrayLayer.GetHashCode() ^ LayerCount.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ImageSubresourceLayers l, in ImageSubresourceLayers r)
	{
		return
			(l.AspectMask == r.AspectMask) && (l.MipLevel == r.MipLevel) && (l.BaseArrayLayer == r.BaseArrayLayer) && (l.LayerCount == r.LayerCount)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ImageSubresourceLayers l, in ImageSubresourceLayers r)
	{
		return
			(l.AspectMask != r.AspectMask) || (l.MipLevel != r.MipLevel) || (l.BaseArrayLayer != r.BaseArrayLayer) || (l.LayerCount != r.LayerCount)
			;
	}


	/// <summary>Creates a new ImageSubresourceLayers value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ImageSubresourceLayers value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ImageSubresourceRange : IEquatable<ImageSubresourceRange>
{
	public Vk.ImageAspectFlags AspectMask;
	public uint BaseMipLevel;
	public uint LevelCount;
	public uint BaseArrayLayer;
	public uint LayerCount;
	public ImageSubresourceRange(
		in Vk.ImageAspectFlags aspectMask = default,
		uint baseMipLevel = default,
		uint levelCount = default,
		uint baseArrayLayer = default,
		uint layerCount = default
	) {
		AspectMask = aspectMask;
		BaseMipLevel = baseMipLevel;
		LevelCount = levelCount;
		BaseArrayLayer = baseArrayLayer;
		LayerCount = layerCount;
	}


	public readonly override bool Equals(object? obj) => (obj is ImageSubresourceRange o) && (this == o);
	readonly bool IEquatable<ImageSubresourceRange>.Equals(ImageSubresourceRange obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			AspectMask.GetHashCode() ^ BaseMipLevel.GetHashCode() ^ LevelCount.GetHashCode() ^ BaseArrayLayer.GetHashCode()
			^ LayerCount.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ImageSubresourceRange l, in ImageSubresourceRange r)
	{
		return
			(l.AspectMask == r.AspectMask) && (l.BaseMipLevel == r.BaseMipLevel) && (l.LevelCount == r.LevelCount) && (l.BaseArrayLayer == r.BaseArrayLayer)
			&& (l.LayerCount == r.LayerCount)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ImageSubresourceRange l, in ImageSubresourceRange r)
	{
		return
			(l.AspectMask != r.AspectMask) || (l.BaseMipLevel != r.BaseMipLevel) || (l.LevelCount != r.LevelCount) || (l.BaseArrayLayer != r.BaseArrayLayer)
			|| (l.LayerCount != r.LayerCount)
			;
	}


	/// <summary>Creates a new ImageSubresourceRange value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ImageSubresourceRange value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct MemoryBarrier : IEquatable<MemoryBarrier>
{
	public const Vk.StructureType TYPE = Vk.StructureType.MemoryBarrier;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.AccessFlags SrcAccessMask;
	public Vk.AccessFlags DstAccessMask;
	public MemoryBarrier(
		in Vk.AccessFlags srcAccessMask = default,
		in Vk.AccessFlags dstAccessMask = default
	) {
		sType = TYPE;
		pNext = null;
		SrcAccessMask = srcAccessMask;
		DstAccessMask = dstAccessMask;
	}


	public readonly override bool Equals(object? obj) => (obj is MemoryBarrier o) && (this == o);
	readonly bool IEquatable<MemoryBarrier>.Equals(MemoryBarrier obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SrcAccessMask.GetHashCode() ^ DstAccessMask.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in MemoryBarrier l, in MemoryBarrier r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SrcAccessMask == r.SrcAccessMask) && (l.DstAccessMask == r.DstAccessMask)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in MemoryBarrier l, in MemoryBarrier r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SrcAccessMask != r.SrcAccessMask) || (l.DstAccessMask != r.DstAccessMask)
			;
	}


	/// <summary>Creates a new MemoryBarrier value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out MemoryBarrier value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct BufferMemoryBarrier : IEquatable<BufferMemoryBarrier>
{
	public const Vk.StructureType TYPE = Vk.StructureType.BufferMemoryBarrier;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.AccessFlags SrcAccessMask;
	public Vk.AccessFlags DstAccessMask;
	public uint SrcQueueFamilyIndex;
	public uint DstQueueFamilyIndex;
	public Vk.Handle<Vk.Buffer> Buffer;
	public Vk.DeviceSize Offset;
	public Vk.DeviceSize Size;
	public BufferMemoryBarrier(
		in Vk.AccessFlags srcAccessMask = default,
		in Vk.AccessFlags dstAccessMask = default,
		uint srcQueueFamilyIndex = default,
		uint dstQueueFamilyIndex = default,
		in Vk.Handle<Vk.Buffer> buffer = default,
		in Vk.DeviceSize offset = default,
		in Vk.DeviceSize size = default
	) {
		sType = TYPE;
		pNext = null;
		SrcAccessMask = srcAccessMask;
		DstAccessMask = dstAccessMask;
		SrcQueueFamilyIndex = srcQueueFamilyIndex;
		DstQueueFamilyIndex = dstQueueFamilyIndex;
		Buffer = buffer;
		Offset = offset;
		Size = size;
	}


	public readonly override bool Equals(object? obj) => (obj is BufferMemoryBarrier o) && (this == o);
	readonly bool IEquatable<BufferMemoryBarrier>.Equals(BufferMemoryBarrier obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SrcAccessMask.GetHashCode() ^ DstAccessMask.GetHashCode()
			^ SrcQueueFamilyIndex.GetHashCode() ^ DstQueueFamilyIndex.GetHashCode() ^ Buffer.GetHashCode() ^ Offset.GetHashCode()
			^ Size.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in BufferMemoryBarrier l, in BufferMemoryBarrier r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SrcAccessMask == r.SrcAccessMask) && (l.DstAccessMask == r.DstAccessMask)
			&& (l.SrcQueueFamilyIndex == r.SrcQueueFamilyIndex) && (l.DstQueueFamilyIndex == r.DstQueueFamilyIndex) && (l.Buffer == r.Buffer) && (l.Offset == r.Offset)
			&& (l.Size == r.Size)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in BufferMemoryBarrier l, in BufferMemoryBarrier r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SrcAccessMask != r.SrcAccessMask) || (l.DstAccessMask != r.DstAccessMask)
			|| (l.SrcQueueFamilyIndex != r.SrcQueueFamilyIndex) || (l.DstQueueFamilyIndex != r.DstQueueFamilyIndex) || (l.Buffer != r.Buffer) || (l.Offset != r.Offset)
			|| (l.Size != r.Size)
			;
	}


	/// <summary>Creates a new BufferMemoryBarrier value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out BufferMemoryBarrier value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ImageMemoryBarrier : IEquatable<ImageMemoryBarrier>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ImageMemoryBarrier;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.AccessFlags SrcAccessMask;
	public Vk.AccessFlags DstAccessMask;
	public Vk.ImageLayout OldLayout;
	public Vk.ImageLayout NewLayout;
	public uint SrcQueueFamilyIndex;
	public uint DstQueueFamilyIndex;
	public Vk.Handle<Vk.Image> Image;
	public Vk.ImageSubresourceRange SubresourceRange;
	public ImageMemoryBarrier(
		in Vk.AccessFlags srcAccessMask = default,
		in Vk.AccessFlags dstAccessMask = default,
		in Vk.ImageLayout oldLayout = default,
		in Vk.ImageLayout newLayout = default,
		uint srcQueueFamilyIndex = default,
		uint dstQueueFamilyIndex = default,
		in Vk.Handle<Vk.Image> image = default,
		in Vk.ImageSubresourceRange subresourceRange = default
	) {
		sType = TYPE;
		pNext = null;
		SrcAccessMask = srcAccessMask;
		DstAccessMask = dstAccessMask;
		OldLayout = oldLayout;
		NewLayout = newLayout;
		SrcQueueFamilyIndex = srcQueueFamilyIndex;
		DstQueueFamilyIndex = dstQueueFamilyIndex;
		Image = image;
		SubresourceRange = subresourceRange;
	}


	public readonly override bool Equals(object? obj) => (obj is ImageMemoryBarrier o) && (this == o);
	readonly bool IEquatable<ImageMemoryBarrier>.Equals(ImageMemoryBarrier obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SrcAccessMask.GetHashCode() ^ DstAccessMask.GetHashCode()
			^ OldLayout.GetHashCode() ^ NewLayout.GetHashCode() ^ SrcQueueFamilyIndex.GetHashCode() ^ DstQueueFamilyIndex.GetHashCode()
			^ Image.GetHashCode() ^ SubresourceRange.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ImageMemoryBarrier l, in ImageMemoryBarrier r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SrcAccessMask == r.SrcAccessMask) && (l.DstAccessMask == r.DstAccessMask)
			&& (l.OldLayout == r.OldLayout) && (l.NewLayout == r.NewLayout) && (l.SrcQueueFamilyIndex == r.SrcQueueFamilyIndex) && (l.DstQueueFamilyIndex == r.DstQueueFamilyIndex)
			&& (l.Image == r.Image) && (l.SubresourceRange == r.SubresourceRange)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ImageMemoryBarrier l, in ImageMemoryBarrier r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SrcAccessMask != r.SrcAccessMask) || (l.DstAccessMask != r.DstAccessMask)
			|| (l.OldLayout != r.OldLayout) || (l.NewLayout != r.NewLayout) || (l.SrcQueueFamilyIndex != r.SrcQueueFamilyIndex) || (l.DstQueueFamilyIndex != r.DstQueueFamilyIndex)
			|| (l.Image != r.Image) || (l.SubresourceRange != r.SubresourceRange)
			;
	}


	/// <summary>Creates a new ImageMemoryBarrier value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ImageMemoryBarrier value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ImageCreateInfo : IEquatable<ImageCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ImageCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.ImageCreateFlags Flags;
	public Vk.ImageType ImageType;
	public Vk.Format Format;
	public Vk.Extent3D Extent;
	public uint MipLevels;
	public uint ArrayLayers;
	public Vk.SampleCountFlags Samples;
	public Vk.ImageTiling Tiling;
	public Vk.ImageUsageFlags Usage;
	public Vk.SharingMode SharingMode;
	public uint QueueFamilyIndexCount;
	public uint* QueueFamilyIndices;
	public Vk.ImageLayout InitialLayout;
	public ImageCreateInfo(
		in Vk.ImageCreateFlags flags = default,
		in Vk.ImageType imageType = default,
		in Vk.Format format = default,
		in Vk.Extent3D extent = default,
		uint mipLevels = default,
		uint arrayLayers = default,
		in Vk.SampleCountFlags samples = default,
		in Vk.ImageTiling tiling = default,
		in Vk.ImageUsageFlags usage = default,
		in Vk.SharingMode sharingMode = default,
		uint queueFamilyIndexCount = default,
		uint* queueFamilyIndices = default,
		in Vk.ImageLayout initialLayout = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		ImageType = imageType;
		Format = format;
		Extent = extent;
		MipLevels = mipLevels;
		ArrayLayers = arrayLayers;
		Samples = samples;
		Tiling = tiling;
		Usage = usage;
		SharingMode = sharingMode;
		QueueFamilyIndexCount = queueFamilyIndexCount;
		QueueFamilyIndices = queueFamilyIndices;
		InitialLayout = initialLayout;
	}


	public readonly override bool Equals(object? obj) => (obj is ImageCreateInfo o) && (this == o);
	readonly bool IEquatable<ImageCreateInfo>.Equals(ImageCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ ImageType.GetHashCode()
			^ Format.GetHashCode() ^ Extent.GetHashCode() ^ MipLevels.GetHashCode() ^ ArrayLayers.GetHashCode()
			^ Samples.GetHashCode() ^ Tiling.GetHashCode() ^ Usage.GetHashCode() ^ SharingMode.GetHashCode()
			^ QueueFamilyIndexCount.GetHashCode() ^ ((ulong)QueueFamilyIndices).GetHashCode() ^ InitialLayout.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ImageCreateInfo l, in ImageCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.ImageType == r.ImageType)
			&& (l.Format == r.Format) && (l.Extent == r.Extent) && (l.MipLevels == r.MipLevels) && (l.ArrayLayers == r.ArrayLayers)
			&& (l.Samples == r.Samples) && (l.Tiling == r.Tiling) && (l.Usage == r.Usage) && (l.SharingMode == r.SharingMode)
			&& (l.QueueFamilyIndexCount == r.QueueFamilyIndexCount) && (l.QueueFamilyIndices == r.QueueFamilyIndices) && (l.InitialLayout == r.InitialLayout)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ImageCreateInfo l, in ImageCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.ImageType != r.ImageType)
			|| (l.Format != r.Format) || (l.Extent != r.Extent) || (l.MipLevels != r.MipLevels) || (l.ArrayLayers != r.ArrayLayers)
			|| (l.Samples != r.Samples) || (l.Tiling != r.Tiling) || (l.Usage != r.Usage) || (l.SharingMode != r.SharingMode)
			|| (l.QueueFamilyIndexCount != r.QueueFamilyIndexCount) || (l.QueueFamilyIndices != r.QueueFamilyIndices) || (l.InitialLayout != r.InitialLayout)
			;
	}


	/// <summary>Creates a new ImageCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ImageCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SubresourceLayout : IEquatable<SubresourceLayout>
{
	public Vk.DeviceSize Offset;
	public Vk.DeviceSize Size;
	public Vk.DeviceSize RowPitch;
	public Vk.DeviceSize ArrayPitch;
	public Vk.DeviceSize DepthPitch;
	public SubresourceLayout(
		in Vk.DeviceSize offset = default,
		in Vk.DeviceSize size = default,
		in Vk.DeviceSize rowPitch = default,
		in Vk.DeviceSize arrayPitch = default,
		in Vk.DeviceSize depthPitch = default
	) {
		Offset = offset;
		Size = size;
		RowPitch = rowPitch;
		ArrayPitch = arrayPitch;
		DepthPitch = depthPitch;
	}


	public readonly override bool Equals(object? obj) => (obj is SubresourceLayout o) && (this == o);
	readonly bool IEquatable<SubresourceLayout>.Equals(SubresourceLayout obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Offset.GetHashCode() ^ Size.GetHashCode() ^ RowPitch.GetHashCode() ^ ArrayPitch.GetHashCode()
			^ DepthPitch.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SubresourceLayout l, in SubresourceLayout r)
	{
		return
			(l.Offset == r.Offset) && (l.Size == r.Size) && (l.RowPitch == r.RowPitch) && (l.ArrayPitch == r.ArrayPitch)
			&& (l.DepthPitch == r.DepthPitch)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SubresourceLayout l, in SubresourceLayout r)
	{
		return
			(l.Offset != r.Offset) || (l.Size != r.Size) || (l.RowPitch != r.RowPitch) || (l.ArrayPitch != r.ArrayPitch)
			|| (l.DepthPitch != r.DepthPitch)
			;
	}


	/// <summary>Creates a new SubresourceLayout value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SubresourceLayout value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ImageViewCreateInfo : IEquatable<ImageViewCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ImageViewCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.ImageViewCreateFlags Flags;
	public Vk.Handle<Vk.Image> Image;
	public Vk.ImageViewType ViewType;
	public Vk.Format Format;
	public Vk.ComponentMapping Components;
	public Vk.ImageSubresourceRange SubresourceRange;
	public ImageViewCreateInfo(
		in Vk.ImageViewCreateFlags flags = default,
		in Vk.Handle<Vk.Image> image = default,
		in Vk.ImageViewType viewType = default,
		in Vk.Format format = default,
		in Vk.ComponentMapping components = default,
		in Vk.ImageSubresourceRange subresourceRange = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		Image = image;
		ViewType = viewType;
		Format = format;
		Components = components;
		SubresourceRange = subresourceRange;
	}


	public readonly override bool Equals(object? obj) => (obj is ImageViewCreateInfo o) && (this == o);
	readonly bool IEquatable<ImageViewCreateInfo>.Equals(ImageViewCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ Image.GetHashCode()
			^ ViewType.GetHashCode() ^ Format.GetHashCode() ^ Components.GetHashCode() ^ SubresourceRange.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ImageViewCreateInfo l, in ImageViewCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.Image == r.Image)
			&& (l.ViewType == r.ViewType) && (l.Format == r.Format) && (l.Components == r.Components) && (l.SubresourceRange == r.SubresourceRange)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ImageViewCreateInfo l, in ImageViewCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.Image != r.Image)
			|| (l.ViewType != r.ViewType) || (l.Format != r.Format) || (l.Components != r.Components) || (l.SubresourceRange != r.SubresourceRange)
			;
	}


	/// <summary>Creates a new ImageViewCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ImageViewCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct BufferCopy : IEquatable<BufferCopy>
{
	public Vk.DeviceSize SrcOffset;
	public Vk.DeviceSize DstOffset;
	public Vk.DeviceSize Size;
	public BufferCopy(
		in Vk.DeviceSize srcOffset = default,
		in Vk.DeviceSize dstOffset = default,
		in Vk.DeviceSize size = default
	) {
		SrcOffset = srcOffset;
		DstOffset = dstOffset;
		Size = size;
	}


	public readonly override bool Equals(object? obj) => (obj is BufferCopy o) && (this == o);
	readonly bool IEquatable<BufferCopy>.Equals(BufferCopy obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			SrcOffset.GetHashCode() ^ DstOffset.GetHashCode() ^ Size.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in BufferCopy l, in BufferCopy r)
	{
		return
			(l.SrcOffset == r.SrcOffset) && (l.DstOffset == r.DstOffset) && (l.Size == r.Size)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in BufferCopy l, in BufferCopy r)
	{
		return
			(l.SrcOffset != r.SrcOffset) || (l.DstOffset != r.DstOffset) || (l.Size != r.Size)
			;
	}


	/// <summary>Creates a new BufferCopy value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out BufferCopy value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SparseMemoryBind : IEquatable<SparseMemoryBind>
{
	public Vk.DeviceSize ResourceOffset;
	public Vk.DeviceSize Size;
	public Vk.Handle<Vk.DeviceMemory> Memory;
	public Vk.DeviceSize MemoryOffset;
	public Vk.SparseMemoryBindFlags Flags;
	public SparseMemoryBind(
		in Vk.DeviceSize resourceOffset = default,
		in Vk.DeviceSize size = default,
		in Vk.Handle<Vk.DeviceMemory> memory = default,
		in Vk.DeviceSize memoryOffset = default,
		in Vk.SparseMemoryBindFlags flags = default
	) {
		ResourceOffset = resourceOffset;
		Size = size;
		Memory = memory;
		MemoryOffset = memoryOffset;
		Flags = flags;
	}


	public readonly override bool Equals(object? obj) => (obj is SparseMemoryBind o) && (this == o);
	readonly bool IEquatable<SparseMemoryBind>.Equals(SparseMemoryBind obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			ResourceOffset.GetHashCode() ^ Size.GetHashCode() ^ Memory.GetHashCode() ^ MemoryOffset.GetHashCode()
			^ Flags.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SparseMemoryBind l, in SparseMemoryBind r)
	{
		return
			(l.ResourceOffset == r.ResourceOffset) && (l.Size == r.Size) && (l.Memory == r.Memory) && (l.MemoryOffset == r.MemoryOffset)
			&& (l.Flags == r.Flags)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SparseMemoryBind l, in SparseMemoryBind r)
	{
		return
			(l.ResourceOffset != r.ResourceOffset) || (l.Size != r.Size) || (l.Memory != r.Memory) || (l.MemoryOffset != r.MemoryOffset)
			|| (l.Flags != r.Flags)
			;
	}


	/// <summary>Creates a new SparseMemoryBind value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SparseMemoryBind value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SparseImageMemoryBind : IEquatable<SparseImageMemoryBind>
{
	public Vk.ImageSubresource Subresource;
	public Vk.Offset3D Offset;
	public Vk.Extent3D Extent;
	public Vk.Handle<Vk.DeviceMemory> Memory;
	public Vk.DeviceSize MemoryOffset;
	public Vk.SparseMemoryBindFlags Flags;
	public SparseImageMemoryBind(
		in Vk.ImageSubresource subresource = default,
		in Vk.Offset3D offset = default,
		in Vk.Extent3D extent = default,
		in Vk.Handle<Vk.DeviceMemory> memory = default,
		in Vk.DeviceSize memoryOffset = default,
		in Vk.SparseMemoryBindFlags flags = default
	) {
		Subresource = subresource;
		Offset = offset;
		Extent = extent;
		Memory = memory;
		MemoryOffset = memoryOffset;
		Flags = flags;
	}


	public readonly override bool Equals(object? obj) => (obj is SparseImageMemoryBind o) && (this == o);
	readonly bool IEquatable<SparseImageMemoryBind>.Equals(SparseImageMemoryBind obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Subresource.GetHashCode() ^ Offset.GetHashCode() ^ Extent.GetHashCode() ^ Memory.GetHashCode()
			^ MemoryOffset.GetHashCode() ^ Flags.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SparseImageMemoryBind l, in SparseImageMemoryBind r)
	{
		return
			(l.Subresource == r.Subresource) && (l.Offset == r.Offset) && (l.Extent == r.Extent) && (l.Memory == r.Memory)
			&& (l.MemoryOffset == r.MemoryOffset) && (l.Flags == r.Flags)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SparseImageMemoryBind l, in SparseImageMemoryBind r)
	{
		return
			(l.Subresource != r.Subresource) || (l.Offset != r.Offset) || (l.Extent != r.Extent) || (l.Memory != r.Memory)
			|| (l.MemoryOffset != r.MemoryOffset) || (l.Flags != r.Flags)
			;
	}


	/// <summary>Creates a new SparseImageMemoryBind value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SparseImageMemoryBind value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SparseBufferMemoryBindInfo : IEquatable<SparseBufferMemoryBindInfo>
{
	public Vk.Handle<Vk.Buffer> Buffer;
	public uint BindCount;
	public Vk.SparseMemoryBind* Binds;
	public SparseBufferMemoryBindInfo(
		in Vk.Handle<Vk.Buffer> buffer = default,
		uint bindCount = default,
		in Vk.SparseMemoryBind* binds = default
	) {
		Buffer = buffer;
		BindCount = bindCount;
		Binds = binds;
	}


	public readonly override bool Equals(object? obj) => (obj is SparseBufferMemoryBindInfo o) && (this == o);
	readonly bool IEquatable<SparseBufferMemoryBindInfo>.Equals(SparseBufferMemoryBindInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Buffer.GetHashCode() ^ BindCount.GetHashCode() ^ ((ulong)Binds).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SparseBufferMemoryBindInfo l, in SparseBufferMemoryBindInfo r)
	{
		return
			(l.Buffer == r.Buffer) && (l.BindCount == r.BindCount) && (l.Binds == r.Binds)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SparseBufferMemoryBindInfo l, in SparseBufferMemoryBindInfo r)
	{
		return
			(l.Buffer != r.Buffer) || (l.BindCount != r.BindCount) || (l.Binds != r.Binds)
			;
	}


	/// <summary>Creates a new SparseBufferMemoryBindInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SparseBufferMemoryBindInfo value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SparseImageOpaqueMemoryBindInfo : IEquatable<SparseImageOpaqueMemoryBindInfo>
{
	public Vk.Handle<Vk.Image> Image;
	public uint BindCount;
	public Vk.SparseMemoryBind* Binds;
	public SparseImageOpaqueMemoryBindInfo(
		in Vk.Handle<Vk.Image> image = default,
		uint bindCount = default,
		in Vk.SparseMemoryBind* binds = default
	) {
		Image = image;
		BindCount = bindCount;
		Binds = binds;
	}


	public readonly override bool Equals(object? obj) => (obj is SparseImageOpaqueMemoryBindInfo o) && (this == o);
	readonly bool IEquatable<SparseImageOpaqueMemoryBindInfo>.Equals(SparseImageOpaqueMemoryBindInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Image.GetHashCode() ^ BindCount.GetHashCode() ^ ((ulong)Binds).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SparseImageOpaqueMemoryBindInfo l, in SparseImageOpaqueMemoryBindInfo r)
	{
		return
			(l.Image == r.Image) && (l.BindCount == r.BindCount) && (l.Binds == r.Binds)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SparseImageOpaqueMemoryBindInfo l, in SparseImageOpaqueMemoryBindInfo r)
	{
		return
			(l.Image != r.Image) || (l.BindCount != r.BindCount) || (l.Binds != r.Binds)
			;
	}


	/// <summary>Creates a new SparseImageOpaqueMemoryBindInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SparseImageOpaqueMemoryBindInfo value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SparseImageMemoryBindInfo : IEquatable<SparseImageMemoryBindInfo>
{
	public Vk.Handle<Vk.Image> Image;
	public uint BindCount;
	public Vk.SparseImageMemoryBind* Binds;
	public SparseImageMemoryBindInfo(
		in Vk.Handle<Vk.Image> image = default,
		uint bindCount = default,
		in Vk.SparseImageMemoryBind* binds = default
	) {
		Image = image;
		BindCount = bindCount;
		Binds = binds;
	}


	public readonly override bool Equals(object? obj) => (obj is SparseImageMemoryBindInfo o) && (this == o);
	readonly bool IEquatable<SparseImageMemoryBindInfo>.Equals(SparseImageMemoryBindInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Image.GetHashCode() ^ BindCount.GetHashCode() ^ ((ulong)Binds).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SparseImageMemoryBindInfo l, in SparseImageMemoryBindInfo r)
	{
		return
			(l.Image == r.Image) && (l.BindCount == r.BindCount) && (l.Binds == r.Binds)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SparseImageMemoryBindInfo l, in SparseImageMemoryBindInfo r)
	{
		return
			(l.Image != r.Image) || (l.BindCount != r.BindCount) || (l.Binds != r.Binds)
			;
	}


	/// <summary>Creates a new SparseImageMemoryBindInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SparseImageMemoryBindInfo value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct BindSparseInfo : IEquatable<BindSparseInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.BindSparseInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public uint WaitSemaphoreCount;
	public Vk.Handle<Vk.Semaphore>* WaitSemaphores;
	public uint BufferBindCount;
	public Vk.SparseBufferMemoryBindInfo* BufferBinds;
	public uint ImageOpaqueBindCount;
	public Vk.SparseImageOpaqueMemoryBindInfo* ImageOpaqueBinds;
	public uint ImageBindCount;
	public Vk.SparseImageMemoryBindInfo* ImageBinds;
	public uint SignalSemaphoreCount;
	public Vk.Handle<Vk.Semaphore>* SignalSemaphores;
	public BindSparseInfo(
		uint waitSemaphoreCount = default,
		in Vk.Handle<Vk.Semaphore>* waitSemaphores = default,
		uint bufferBindCount = default,
		in Vk.SparseBufferMemoryBindInfo* bufferBinds = default,
		uint imageOpaqueBindCount = default,
		in Vk.SparseImageOpaqueMemoryBindInfo* imageOpaqueBinds = default,
		uint imageBindCount = default,
		in Vk.SparseImageMemoryBindInfo* imageBinds = default,
		uint signalSemaphoreCount = default,
		in Vk.Handle<Vk.Semaphore>* signalSemaphores = default
	) {
		sType = TYPE;
		pNext = null;
		WaitSemaphoreCount = waitSemaphoreCount;
		WaitSemaphores = waitSemaphores;
		BufferBindCount = bufferBindCount;
		BufferBinds = bufferBinds;
		ImageOpaqueBindCount = imageOpaqueBindCount;
		ImageOpaqueBinds = imageOpaqueBinds;
		ImageBindCount = imageBindCount;
		ImageBinds = imageBinds;
		SignalSemaphoreCount = signalSemaphoreCount;
		SignalSemaphores = signalSemaphores;
	}


	public readonly override bool Equals(object? obj) => (obj is BindSparseInfo o) && (this == o);
	readonly bool IEquatable<BindSparseInfo>.Equals(BindSparseInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ WaitSemaphoreCount.GetHashCode() ^ ((ulong)WaitSemaphores).GetHashCode()
			^ BufferBindCount.GetHashCode() ^ ((ulong)BufferBinds).GetHashCode() ^ ImageOpaqueBindCount.GetHashCode() ^ ((ulong)ImageOpaqueBinds).GetHashCode()
			^ ImageBindCount.GetHashCode() ^ ((ulong)ImageBinds).GetHashCode() ^ SignalSemaphoreCount.GetHashCode() ^ ((ulong)SignalSemaphores).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in BindSparseInfo l, in BindSparseInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.WaitSemaphoreCount == r.WaitSemaphoreCount) && (l.WaitSemaphores == r.WaitSemaphores)
			&& (l.BufferBindCount == r.BufferBindCount) && (l.BufferBinds == r.BufferBinds) && (l.ImageOpaqueBindCount == r.ImageOpaqueBindCount) && (l.ImageOpaqueBinds == r.ImageOpaqueBinds)
			&& (l.ImageBindCount == r.ImageBindCount) && (l.ImageBinds == r.ImageBinds) && (l.SignalSemaphoreCount == r.SignalSemaphoreCount) && (l.SignalSemaphores == r.SignalSemaphores)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in BindSparseInfo l, in BindSparseInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.WaitSemaphoreCount != r.WaitSemaphoreCount) || (l.WaitSemaphores != r.WaitSemaphores)
			|| (l.BufferBindCount != r.BufferBindCount) || (l.BufferBinds != r.BufferBinds) || (l.ImageOpaqueBindCount != r.ImageOpaqueBindCount) || (l.ImageOpaqueBinds != r.ImageOpaqueBinds)
			|| (l.ImageBindCount != r.ImageBindCount) || (l.ImageBinds != r.ImageBinds) || (l.SignalSemaphoreCount != r.SignalSemaphoreCount) || (l.SignalSemaphores != r.SignalSemaphores)
			;
	}


	/// <summary>Creates a new BindSparseInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out BindSparseInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ImageCopy : IEquatable<ImageCopy>
{
	public Vk.ImageSubresourceLayers SrcSubresource;
	public Vk.Offset3D SrcOffset;
	public Vk.ImageSubresourceLayers DstSubresource;
	public Vk.Offset3D DstOffset;
	public Vk.Extent3D Extent;
	public ImageCopy(
		in Vk.ImageSubresourceLayers srcSubresource = default,
		in Vk.Offset3D srcOffset = default,
		in Vk.ImageSubresourceLayers dstSubresource = default,
		in Vk.Offset3D dstOffset = default,
		in Vk.Extent3D extent = default
	) {
		SrcSubresource = srcSubresource;
		SrcOffset = srcOffset;
		DstSubresource = dstSubresource;
		DstOffset = dstOffset;
		Extent = extent;
	}


	public readonly override bool Equals(object? obj) => (obj is ImageCopy o) && (this == o);
	readonly bool IEquatable<ImageCopy>.Equals(ImageCopy obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			SrcSubresource.GetHashCode() ^ SrcOffset.GetHashCode() ^ DstSubresource.GetHashCode() ^ DstOffset.GetHashCode()
			^ Extent.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ImageCopy l, in ImageCopy r)
	{
		return
			(l.SrcSubresource == r.SrcSubresource) && (l.SrcOffset == r.SrcOffset) && (l.DstSubresource == r.DstSubresource) && (l.DstOffset == r.DstOffset)
			&& (l.Extent == r.Extent)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ImageCopy l, in ImageCopy r)
	{
		return
			(l.SrcSubresource != r.SrcSubresource) || (l.SrcOffset != r.SrcOffset) || (l.DstSubresource != r.DstSubresource) || (l.DstOffset != r.DstOffset)
			|| (l.Extent != r.Extent)
			;
	}


	/// <summary>Creates a new ImageCopy value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ImageCopy value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ImageBlit : IEquatable<ImageBlit>
{
	public Vk.ImageSubresourceLayers SrcSubresource;
	public Vk.Offset3D SrcOffsets_0;
	public Vk.Offset3D SrcOffsets_1;
	public Vk.ImageSubresourceLayers DstSubresource;
	public Vk.Offset3D DstOffsets_0;
	public Vk.Offset3D DstOffsets_1;
	public ImageBlit(
		in Vk.ImageSubresourceLayers srcSubresource = default,
		in Vk.Offset3D srcOffsets0 = default,
		in Vk.Offset3D srcOffsets1 = default,
		in Vk.ImageSubresourceLayers dstSubresource = default,
		in Vk.Offset3D dstOffsets0 = default,
		in Vk.Offset3D dstOffsets1 = default
	) {
		SrcSubresource = srcSubresource;
		SrcOffsets_0 = srcOffsets0;
		SrcOffsets_1 = srcOffsets1;
		DstSubresource = dstSubresource;
		DstOffsets_0 = dstOffsets0;
		DstOffsets_1 = dstOffsets1;
	}


	public readonly override bool Equals(object? obj) => (obj is ImageBlit o) && (this == o);
	readonly bool IEquatable<ImageBlit>.Equals(ImageBlit obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			SrcSubresource.GetHashCode() ^ SrcOffsets_0.GetHashCode() ^ SrcOffsets_1.GetHashCode() ^ DstSubresource.GetHashCode()
			^ DstOffsets_0.GetHashCode() ^ DstOffsets_1.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ImageBlit l, in ImageBlit r)
	{
		return
			(l.SrcSubresource == r.SrcSubresource) && (l.SrcOffsets_0 == r.SrcOffsets_0) && (l.SrcOffsets_1 == r.SrcOffsets_1) && (l.DstSubresource == r.DstSubresource)
			&& (l.DstOffsets_0 == r.DstOffsets_0) && (l.DstOffsets_1 == r.DstOffsets_1)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ImageBlit l, in ImageBlit r)
	{
		return
			(l.SrcSubresource != r.SrcSubresource) || (l.SrcOffsets_0 != r.SrcOffsets_0) || (l.SrcOffsets_1 != r.SrcOffsets_1) || (l.DstSubresource != r.DstSubresource)
			|| (l.DstOffsets_0 != r.DstOffsets_0) || (l.DstOffsets_1 != r.DstOffsets_1)
			;
	}


	/// <summary>Creates a new ImageBlit value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ImageBlit value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct BufferImageCopy : IEquatable<BufferImageCopy>
{
	public Vk.DeviceSize BufferOffset;
	public uint BufferRowLength;
	public uint BufferImageHeight;
	public Vk.ImageSubresourceLayers ImageSubresource;
	public Vk.Offset3D ImageOffset;
	public Vk.Extent3D ImageExtent;
	public BufferImageCopy(
		in Vk.DeviceSize bufferOffset = default,
		uint bufferRowLength = default,
		uint bufferImageHeight = default,
		in Vk.ImageSubresourceLayers imageSubresource = default,
		in Vk.Offset3D imageOffset = default,
		in Vk.Extent3D imageExtent = default
	) {
		BufferOffset = bufferOffset;
		BufferRowLength = bufferRowLength;
		BufferImageHeight = bufferImageHeight;
		ImageSubresource = imageSubresource;
		ImageOffset = imageOffset;
		ImageExtent = imageExtent;
	}


	public readonly override bool Equals(object? obj) => (obj is BufferImageCopy o) && (this == o);
	readonly bool IEquatable<BufferImageCopy>.Equals(BufferImageCopy obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			BufferOffset.GetHashCode() ^ BufferRowLength.GetHashCode() ^ BufferImageHeight.GetHashCode() ^ ImageSubresource.GetHashCode()
			^ ImageOffset.GetHashCode() ^ ImageExtent.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in BufferImageCopy l, in BufferImageCopy r)
	{
		return
			(l.BufferOffset == r.BufferOffset) && (l.BufferRowLength == r.BufferRowLength) && (l.BufferImageHeight == r.BufferImageHeight) && (l.ImageSubresource == r.ImageSubresource)
			&& (l.ImageOffset == r.ImageOffset) && (l.ImageExtent == r.ImageExtent)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in BufferImageCopy l, in BufferImageCopy r)
	{
		return
			(l.BufferOffset != r.BufferOffset) || (l.BufferRowLength != r.BufferRowLength) || (l.BufferImageHeight != r.BufferImageHeight) || (l.ImageSubresource != r.ImageSubresource)
			|| (l.ImageOffset != r.ImageOffset) || (l.ImageExtent != r.ImageExtent)
			;
	}


	/// <summary>Creates a new BufferImageCopy value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out BufferImageCopy value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ImageResolve : IEquatable<ImageResolve>
{
	public Vk.ImageSubresourceLayers SrcSubresource;
	public Vk.Offset3D SrcOffset;
	public Vk.ImageSubresourceLayers DstSubresource;
	public Vk.Offset3D DstOffset;
	public Vk.Extent3D Extent;
	public ImageResolve(
		in Vk.ImageSubresourceLayers srcSubresource = default,
		in Vk.Offset3D srcOffset = default,
		in Vk.ImageSubresourceLayers dstSubresource = default,
		in Vk.Offset3D dstOffset = default,
		in Vk.Extent3D extent = default
	) {
		SrcSubresource = srcSubresource;
		SrcOffset = srcOffset;
		DstSubresource = dstSubresource;
		DstOffset = dstOffset;
		Extent = extent;
	}


	public readonly override bool Equals(object? obj) => (obj is ImageResolve o) && (this == o);
	readonly bool IEquatable<ImageResolve>.Equals(ImageResolve obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			SrcSubresource.GetHashCode() ^ SrcOffset.GetHashCode() ^ DstSubresource.GetHashCode() ^ DstOffset.GetHashCode()
			^ Extent.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ImageResolve l, in ImageResolve r)
	{
		return
			(l.SrcSubresource == r.SrcSubresource) && (l.SrcOffset == r.SrcOffset) && (l.DstSubresource == r.DstSubresource) && (l.DstOffset == r.DstOffset)
			&& (l.Extent == r.Extent)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ImageResolve l, in ImageResolve r)
	{
		return
			(l.SrcSubresource != r.SrcSubresource) || (l.SrcOffset != r.SrcOffset) || (l.DstSubresource != r.DstSubresource) || (l.DstOffset != r.DstOffset)
			|| (l.Extent != r.Extent)
			;
	}


	/// <summary>Creates a new ImageResolve value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ImageResolve value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ShaderModuleCreateInfo : IEquatable<ShaderModuleCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ShaderModuleCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.ShaderModuleCreateFlags Flags;
	public ulong CodeSize;
	public uint* Code;
	public ShaderModuleCreateInfo(
		in Vk.ShaderModuleCreateFlags flags = default,
		ulong codeSize = default,
		uint* code = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		CodeSize = codeSize;
		Code = code;
	}


	public readonly override bool Equals(object? obj) => (obj is ShaderModuleCreateInfo o) && (this == o);
	readonly bool IEquatable<ShaderModuleCreateInfo>.Equals(ShaderModuleCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ CodeSize.GetHashCode()
			^ ((ulong)Code).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ShaderModuleCreateInfo l, in ShaderModuleCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.CodeSize == r.CodeSize)
			&& (l.Code == r.Code)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ShaderModuleCreateInfo l, in ShaderModuleCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.CodeSize != r.CodeSize)
			|| (l.Code != r.Code)
			;
	}


	/// <summary>Creates a new ShaderModuleCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ShaderModuleCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DescriptorSetLayoutBinding : IEquatable<DescriptorSetLayoutBinding>
{
	public uint Binding;
	public Vk.DescriptorType DescriptorType;
	public uint DescriptorCount;
	public Vk.ShaderStageFlags StageFlags;
	public Vk.Handle<Vk.Sampler>* ImmutableSamplers;
	public DescriptorSetLayoutBinding(
		uint binding = default,
		in Vk.DescriptorType descriptorType = default,
		uint descriptorCount = default,
		in Vk.ShaderStageFlags stageFlags = default,
		in Vk.Handle<Vk.Sampler>* immutableSamplers = default
	) {
		Binding = binding;
		DescriptorType = descriptorType;
		DescriptorCount = descriptorCount;
		StageFlags = stageFlags;
		ImmutableSamplers = immutableSamplers;
	}


	public readonly override bool Equals(object? obj) => (obj is DescriptorSetLayoutBinding o) && (this == o);
	readonly bool IEquatable<DescriptorSetLayoutBinding>.Equals(DescriptorSetLayoutBinding obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Binding.GetHashCode() ^ DescriptorType.GetHashCode() ^ DescriptorCount.GetHashCode() ^ StageFlags.GetHashCode()
			^ ((ulong)ImmutableSamplers).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DescriptorSetLayoutBinding l, in DescriptorSetLayoutBinding r)
	{
		return
			(l.Binding == r.Binding) && (l.DescriptorType == r.DescriptorType) && (l.DescriptorCount == r.DescriptorCount) && (l.StageFlags == r.StageFlags)
			&& (l.ImmutableSamplers == r.ImmutableSamplers)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DescriptorSetLayoutBinding l, in DescriptorSetLayoutBinding r)
	{
		return
			(l.Binding != r.Binding) || (l.DescriptorType != r.DescriptorType) || (l.DescriptorCount != r.DescriptorCount) || (l.StageFlags != r.StageFlags)
			|| (l.ImmutableSamplers != r.ImmutableSamplers)
			;
	}


	/// <summary>Creates a new DescriptorSetLayoutBinding value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DescriptorSetLayoutBinding value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DescriptorSetLayoutCreateInfo : IEquatable<DescriptorSetLayoutCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DescriptorSetLayoutCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.DescriptorSetLayoutCreateFlags Flags;
	public uint BindingCount;
	public Vk.DescriptorSetLayoutBinding* Bindings;
	public DescriptorSetLayoutCreateInfo(
		in Vk.DescriptorSetLayoutCreateFlags flags = default,
		uint bindingCount = default,
		in Vk.DescriptorSetLayoutBinding* bindings = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		BindingCount = bindingCount;
		Bindings = bindings;
	}


	public readonly override bool Equals(object? obj) => (obj is DescriptorSetLayoutCreateInfo o) && (this == o);
	readonly bool IEquatable<DescriptorSetLayoutCreateInfo>.Equals(DescriptorSetLayoutCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ BindingCount.GetHashCode()
			^ ((ulong)Bindings).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DescriptorSetLayoutCreateInfo l, in DescriptorSetLayoutCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.BindingCount == r.BindingCount)
			&& (l.Bindings == r.Bindings)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DescriptorSetLayoutCreateInfo l, in DescriptorSetLayoutCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.BindingCount != r.BindingCount)
			|| (l.Bindings != r.Bindings)
			;
	}


	/// <summary>Creates a new DescriptorSetLayoutCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DescriptorSetLayoutCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DescriptorPoolSize : IEquatable<DescriptorPoolSize>
{
	public Vk.DescriptorType Type;
	public uint DescriptorCount;
	public DescriptorPoolSize(
		in Vk.DescriptorType type = default,
		uint descriptorCount = default
	) {
		Type = type;
		DescriptorCount = descriptorCount;
	}


	public readonly override bool Equals(object? obj) => (obj is DescriptorPoolSize o) && (this == o);
	readonly bool IEquatable<DescriptorPoolSize>.Equals(DescriptorPoolSize obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Type.GetHashCode() ^ DescriptorCount.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DescriptorPoolSize l, in DescriptorPoolSize r)
	{
		return
			(l.Type == r.Type) && (l.DescriptorCount == r.DescriptorCount)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DescriptorPoolSize l, in DescriptorPoolSize r)
	{
		return
			(l.Type != r.Type) || (l.DescriptorCount != r.DescriptorCount)
			;
	}


	/// <summary>Creates a new DescriptorPoolSize value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DescriptorPoolSize value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DescriptorPoolCreateInfo : IEquatable<DescriptorPoolCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DescriptorPoolCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.DescriptorPoolCreateFlags Flags;
	public uint MaxSets;
	public uint PoolSizeCount;
	public Vk.DescriptorPoolSize* PoolSizes;
	public DescriptorPoolCreateInfo(
		in Vk.DescriptorPoolCreateFlags flags = default,
		uint maxSets = default,
		uint poolSizeCount = default,
		in Vk.DescriptorPoolSize* poolSizes = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		MaxSets = maxSets;
		PoolSizeCount = poolSizeCount;
		PoolSizes = poolSizes;
	}


	public readonly override bool Equals(object? obj) => (obj is DescriptorPoolCreateInfo o) && (this == o);
	readonly bool IEquatable<DescriptorPoolCreateInfo>.Equals(DescriptorPoolCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ MaxSets.GetHashCode()
			^ PoolSizeCount.GetHashCode() ^ ((ulong)PoolSizes).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DescriptorPoolCreateInfo l, in DescriptorPoolCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.MaxSets == r.MaxSets)
			&& (l.PoolSizeCount == r.PoolSizeCount) && (l.PoolSizes == r.PoolSizes)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DescriptorPoolCreateInfo l, in DescriptorPoolCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.MaxSets != r.MaxSets)
			|| (l.PoolSizeCount != r.PoolSizeCount) || (l.PoolSizes != r.PoolSizes)
			;
	}


	/// <summary>Creates a new DescriptorPoolCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DescriptorPoolCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DescriptorSetAllocateInfo : IEquatable<DescriptorSetAllocateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DescriptorSetAllocateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Handle<Vk.DescriptorPool> DescriptorPool;
	public uint DescriptorSetCount;
	public Vk.Handle<Vk.DescriptorSetLayout>* SetLayouts;
	public DescriptorSetAllocateInfo(
		in Vk.Handle<Vk.DescriptorPool> descriptorPool = default,
		uint descriptorSetCount = default,
		in Vk.Handle<Vk.DescriptorSetLayout>* setLayouts = default
	) {
		sType = TYPE;
		pNext = null;
		DescriptorPool = descriptorPool;
		DescriptorSetCount = descriptorSetCount;
		SetLayouts = setLayouts;
	}


	public readonly override bool Equals(object? obj) => (obj is DescriptorSetAllocateInfo o) && (this == o);
	readonly bool IEquatable<DescriptorSetAllocateInfo>.Equals(DescriptorSetAllocateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DescriptorPool.GetHashCode() ^ DescriptorSetCount.GetHashCode()
			^ ((ulong)SetLayouts).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DescriptorSetAllocateInfo l, in DescriptorSetAllocateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DescriptorPool == r.DescriptorPool) && (l.DescriptorSetCount == r.DescriptorSetCount)
			&& (l.SetLayouts == r.SetLayouts)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DescriptorSetAllocateInfo l, in DescriptorSetAllocateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DescriptorPool != r.DescriptorPool) || (l.DescriptorSetCount != r.DescriptorSetCount)
			|| (l.SetLayouts != r.SetLayouts)
			;
	}


	/// <summary>Creates a new DescriptorSetAllocateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DescriptorSetAllocateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SpecializationMapEntry : IEquatable<SpecializationMapEntry>
{
	public uint ConstantID;
	public uint Offset;
	public ulong Size;
	public SpecializationMapEntry(
		uint constantID = default,
		uint offset = default,
		ulong size = default
	) {
		ConstantID = constantID;
		Offset = offset;
		Size = size;
	}


	public readonly override bool Equals(object? obj) => (obj is SpecializationMapEntry o) && (this == o);
	readonly bool IEquatable<SpecializationMapEntry>.Equals(SpecializationMapEntry obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			ConstantID.GetHashCode() ^ Offset.GetHashCode() ^ Size.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SpecializationMapEntry l, in SpecializationMapEntry r)
	{
		return
			(l.ConstantID == r.ConstantID) && (l.Offset == r.Offset) && (l.Size == r.Size)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SpecializationMapEntry l, in SpecializationMapEntry r)
	{
		return
			(l.ConstantID != r.ConstantID) || (l.Offset != r.Offset) || (l.Size != r.Size)
			;
	}


	/// <summary>Creates a new SpecializationMapEntry value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SpecializationMapEntry value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SpecializationInfo : IEquatable<SpecializationInfo>
{
	public uint MapEntryCount;
	public Vk.SpecializationMapEntry* MapEntries;
	public ulong DataSize;
	public void* Data;
	public SpecializationInfo(
		uint mapEntryCount = default,
		in Vk.SpecializationMapEntry* mapEntries = default,
		ulong dataSize = default,
		void* data = default
	) {
		MapEntryCount = mapEntryCount;
		MapEntries = mapEntries;
		DataSize = dataSize;
		Data = data;
	}


	public readonly override bool Equals(object? obj) => (obj is SpecializationInfo o) && (this == o);
	readonly bool IEquatable<SpecializationInfo>.Equals(SpecializationInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			MapEntryCount.GetHashCode() ^ ((ulong)MapEntries).GetHashCode() ^ DataSize.GetHashCode() ^ ((ulong)Data).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SpecializationInfo l, in SpecializationInfo r)
	{
		return
			(l.MapEntryCount == r.MapEntryCount) && (l.MapEntries == r.MapEntries) && (l.DataSize == r.DataSize) && (l.Data == r.Data)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SpecializationInfo l, in SpecializationInfo r)
	{
		return
			(l.MapEntryCount != r.MapEntryCount) || (l.MapEntries != r.MapEntries) || (l.DataSize != r.DataSize) || (l.Data != r.Data)
			;
	}


	/// <summary>Creates a new SpecializationInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SpecializationInfo value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PipelineShaderStageCreateInfo : IEquatable<PipelineShaderStageCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PipelineShaderStageCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.PipelineShaderStageCreateFlags Flags;
	public Vk.ShaderStageFlags Stage;
	public Vk.Handle<Vk.ShaderModule> Module;
	public byte* Name;
	public Vk.SpecializationInfo* SpecializationInfo;
	public PipelineShaderStageCreateInfo(
		in Vk.PipelineShaderStageCreateFlags flags = default,
		in Vk.ShaderStageFlags stage = default,
		in Vk.Handle<Vk.ShaderModule> module = default,
		byte* name = default,
		in Vk.SpecializationInfo* specializationInfo = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		Stage = stage;
		Module = module;
		Name = name;
		SpecializationInfo = specializationInfo;
	}


	public readonly override bool Equals(object? obj) => (obj is PipelineShaderStageCreateInfo o) && (this == o);
	readonly bool IEquatable<PipelineShaderStageCreateInfo>.Equals(PipelineShaderStageCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ Stage.GetHashCode()
			^ Module.GetHashCode() ^ ((ulong)Name).GetHashCode() ^ ((ulong)SpecializationInfo).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PipelineShaderStageCreateInfo l, in PipelineShaderStageCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.Stage == r.Stage)
			&& (l.Module == r.Module) && (l.Name == r.Name) && (l.SpecializationInfo == r.SpecializationInfo)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PipelineShaderStageCreateInfo l, in PipelineShaderStageCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.Stage != r.Stage)
			|| (l.Module != r.Module) || (l.Name != r.Name) || (l.SpecializationInfo != r.SpecializationInfo)
			;
	}


	/// <summary>Creates a new PipelineShaderStageCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PipelineShaderStageCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ComputePipelineCreateInfo : IEquatable<ComputePipelineCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ComputePipelineCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.PipelineCreateFlags Flags;
	public Vk.PipelineShaderStageCreateInfo Stage;
	public Vk.Handle<Vk.PipelineLayout> Layout;
	public Vk.Handle<Vk.Pipeline> BasePipelineHandle;
	public int BasePipelineIndex;
	public ComputePipelineCreateInfo(
		in Vk.PipelineCreateFlags flags = default,
		in Vk.PipelineShaderStageCreateInfo stage = default,
		in Vk.Handle<Vk.PipelineLayout> layout = default,
		in Vk.Handle<Vk.Pipeline> basePipelineHandle = default,
		int basePipelineIndex = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		Stage = stage;
		Layout = layout;
		BasePipelineHandle = basePipelineHandle;
		BasePipelineIndex = basePipelineIndex;
	}


	public readonly override bool Equals(object? obj) => (obj is ComputePipelineCreateInfo o) && (this == o);
	readonly bool IEquatable<ComputePipelineCreateInfo>.Equals(ComputePipelineCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ Stage.GetHashCode()
			^ Layout.GetHashCode() ^ BasePipelineHandle.GetHashCode() ^ BasePipelineIndex.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ComputePipelineCreateInfo l, in ComputePipelineCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.Stage == r.Stage)
			&& (l.Layout == r.Layout) && (l.BasePipelineHandle == r.BasePipelineHandle) && (l.BasePipelineIndex == r.BasePipelineIndex)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ComputePipelineCreateInfo l, in ComputePipelineCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.Stage != r.Stage)
			|| (l.Layout != r.Layout) || (l.BasePipelineHandle != r.BasePipelineHandle) || (l.BasePipelineIndex != r.BasePipelineIndex)
			;
	}


	/// <summary>Creates a new ComputePipelineCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ComputePipelineCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VertexInputBindingDescription : IEquatable<VertexInputBindingDescription>
{
	public uint Binding;
	public uint Stride;
	public Vk.VertexInputRate InputRate;
	public VertexInputBindingDescription(
		uint binding = default,
		uint stride = default,
		in Vk.VertexInputRate inputRate = default
	) {
		Binding = binding;
		Stride = stride;
		InputRate = inputRate;
	}


	public readonly override bool Equals(object? obj) => (obj is VertexInputBindingDescription o) && (this == o);
	readonly bool IEquatable<VertexInputBindingDescription>.Equals(VertexInputBindingDescription obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Binding.GetHashCode() ^ Stride.GetHashCode() ^ InputRate.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VertexInputBindingDescription l, in VertexInputBindingDescription r)
	{
		return
			(l.Binding == r.Binding) && (l.Stride == r.Stride) && (l.InputRate == r.InputRate)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VertexInputBindingDescription l, in VertexInputBindingDescription r)
	{
		return
			(l.Binding != r.Binding) || (l.Stride != r.Stride) || (l.InputRate != r.InputRate)
			;
	}


	/// <summary>Creates a new VertexInputBindingDescription value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VertexInputBindingDescription value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VertexInputAttributeDescription : IEquatable<VertexInputAttributeDescription>
{
	public uint Location;
	public uint Binding;
	public Vk.Format Format;
	public uint Offset;
	public VertexInputAttributeDescription(
		uint location = default,
		uint binding = default,
		in Vk.Format format = default,
		uint offset = default
	) {
		Location = location;
		Binding = binding;
		Format = format;
		Offset = offset;
	}


	public readonly override bool Equals(object? obj) => (obj is VertexInputAttributeDescription o) && (this == o);
	readonly bool IEquatable<VertexInputAttributeDescription>.Equals(VertexInputAttributeDescription obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Location.GetHashCode() ^ Binding.GetHashCode() ^ Format.GetHashCode() ^ Offset.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VertexInputAttributeDescription l, in VertexInputAttributeDescription r)
	{
		return
			(l.Location == r.Location) && (l.Binding == r.Binding) && (l.Format == r.Format) && (l.Offset == r.Offset)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VertexInputAttributeDescription l, in VertexInputAttributeDescription r)
	{
		return
			(l.Location != r.Location) || (l.Binding != r.Binding) || (l.Format != r.Format) || (l.Offset != r.Offset)
			;
	}


	/// <summary>Creates a new VertexInputAttributeDescription value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VertexInputAttributeDescription value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PipelineVertexInputStateCreateInfo : IEquatable<PipelineVertexInputStateCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PipelineVertexInputStateCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.PipelineVertexInputStateCreateFlags Flags;
	public uint VertexBindingDescriptionCount;
	public Vk.VertexInputBindingDescription* VertexBindingDescriptions;
	public uint VertexAttributeDescriptionCount;
	public Vk.VertexInputAttributeDescription* VertexAttributeDescriptions;
	public PipelineVertexInputStateCreateInfo(
		in Vk.PipelineVertexInputStateCreateFlags flags = default,
		uint vertexBindingDescriptionCount = default,
		in Vk.VertexInputBindingDescription* vertexBindingDescriptions = default,
		uint vertexAttributeDescriptionCount = default,
		in Vk.VertexInputAttributeDescription* vertexAttributeDescriptions = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		VertexBindingDescriptionCount = vertexBindingDescriptionCount;
		VertexBindingDescriptions = vertexBindingDescriptions;
		VertexAttributeDescriptionCount = vertexAttributeDescriptionCount;
		VertexAttributeDescriptions = vertexAttributeDescriptions;
	}


	public readonly override bool Equals(object? obj) => (obj is PipelineVertexInputStateCreateInfo o) && (this == o);
	readonly bool IEquatable<PipelineVertexInputStateCreateInfo>.Equals(PipelineVertexInputStateCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ VertexBindingDescriptionCount.GetHashCode()
			^ ((ulong)VertexBindingDescriptions).GetHashCode() ^ VertexAttributeDescriptionCount.GetHashCode() ^ ((ulong)VertexAttributeDescriptions).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PipelineVertexInputStateCreateInfo l, in PipelineVertexInputStateCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.VertexBindingDescriptionCount == r.VertexBindingDescriptionCount)
			&& (l.VertexBindingDescriptions == r.VertexBindingDescriptions) && (l.VertexAttributeDescriptionCount == r.VertexAttributeDescriptionCount) && (l.VertexAttributeDescriptions == r.VertexAttributeDescriptions)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PipelineVertexInputStateCreateInfo l, in PipelineVertexInputStateCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.VertexBindingDescriptionCount != r.VertexBindingDescriptionCount)
			|| (l.VertexBindingDescriptions != r.VertexBindingDescriptions) || (l.VertexAttributeDescriptionCount != r.VertexAttributeDescriptionCount) || (l.VertexAttributeDescriptions != r.VertexAttributeDescriptions)
			;
	}


	/// <summary>Creates a new PipelineVertexInputStateCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PipelineVertexInputStateCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PipelineInputAssemblyStateCreateInfo : IEquatable<PipelineInputAssemblyStateCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PipelineInputAssemblyStateCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.PipelineInputAssemblyStateCreateFlags Flags;
	public Vk.PrimitiveTopology Topology;
	public Vk.Bool32 PrimitiveRestartEnable;
	public PipelineInputAssemblyStateCreateInfo(
		in Vk.PipelineInputAssemblyStateCreateFlags flags = default,
		in Vk.PrimitiveTopology topology = default,
		in Vk.Bool32 primitiveRestartEnable = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		Topology = topology;
		PrimitiveRestartEnable = primitiveRestartEnable;
	}


	public readonly override bool Equals(object? obj) => (obj is PipelineInputAssemblyStateCreateInfo o) && (this == o);
	readonly bool IEquatable<PipelineInputAssemblyStateCreateInfo>.Equals(PipelineInputAssemblyStateCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ Topology.GetHashCode()
			^ PrimitiveRestartEnable.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PipelineInputAssemblyStateCreateInfo l, in PipelineInputAssemblyStateCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.Topology == r.Topology)
			&& (l.PrimitiveRestartEnable == r.PrimitiveRestartEnable)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PipelineInputAssemblyStateCreateInfo l, in PipelineInputAssemblyStateCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.Topology != r.Topology)
			|| (l.PrimitiveRestartEnable != r.PrimitiveRestartEnable)
			;
	}


	/// <summary>Creates a new PipelineInputAssemblyStateCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PipelineInputAssemblyStateCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PipelineTessellationStateCreateInfo : IEquatable<PipelineTessellationStateCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PipelineTessellationStateCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.PipelineTessellationStateCreateFlags Flags;
	public uint PatchControlPoints;
	public PipelineTessellationStateCreateInfo(
		in Vk.PipelineTessellationStateCreateFlags flags = default,
		uint patchControlPoints = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		PatchControlPoints = patchControlPoints;
	}


	public readonly override bool Equals(object? obj) => (obj is PipelineTessellationStateCreateInfo o) && (this == o);
	readonly bool IEquatable<PipelineTessellationStateCreateInfo>.Equals(PipelineTessellationStateCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ PatchControlPoints.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PipelineTessellationStateCreateInfo l, in PipelineTessellationStateCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.PatchControlPoints == r.PatchControlPoints)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PipelineTessellationStateCreateInfo l, in PipelineTessellationStateCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.PatchControlPoints != r.PatchControlPoints)
			;
	}


	/// <summary>Creates a new PipelineTessellationStateCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PipelineTessellationStateCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PipelineViewportStateCreateInfo : IEquatable<PipelineViewportStateCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PipelineViewportStateCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.PipelineViewportStateCreateFlags Flags;
	public uint ViewportCount;
	public Vk.Viewport* Viewports;
	public uint ScissorCount;
	public Vk.Rect2D* Scissors;
	public PipelineViewportStateCreateInfo(
		in Vk.PipelineViewportStateCreateFlags flags = default,
		uint viewportCount = default,
		in Vk.Viewport* viewports = default,
		uint scissorCount = default,
		in Vk.Rect2D* scissors = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		ViewportCount = viewportCount;
		Viewports = viewports;
		ScissorCount = scissorCount;
		Scissors = scissors;
	}


	public readonly override bool Equals(object? obj) => (obj is PipelineViewportStateCreateInfo o) && (this == o);
	readonly bool IEquatable<PipelineViewportStateCreateInfo>.Equals(PipelineViewportStateCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ ViewportCount.GetHashCode()
			^ ((ulong)Viewports).GetHashCode() ^ ScissorCount.GetHashCode() ^ ((ulong)Scissors).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PipelineViewportStateCreateInfo l, in PipelineViewportStateCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.ViewportCount == r.ViewportCount)
			&& (l.Viewports == r.Viewports) && (l.ScissorCount == r.ScissorCount) && (l.Scissors == r.Scissors)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PipelineViewportStateCreateInfo l, in PipelineViewportStateCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.ViewportCount != r.ViewportCount)
			|| (l.Viewports != r.Viewports) || (l.ScissorCount != r.ScissorCount) || (l.Scissors != r.Scissors)
			;
	}


	/// <summary>Creates a new PipelineViewportStateCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PipelineViewportStateCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PipelineRasterizationStateCreateInfo : IEquatable<PipelineRasterizationStateCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PipelineRasterizationStateCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.PipelineRasterizationStateCreateFlags Flags;
	public Vk.Bool32 DepthClampEnable;
	public Vk.Bool32 RasterizerDiscardEnable;
	public Vk.PolygonMode PolygonMode;
	public Vk.CullModeFlags CullMode;
	public Vk.FrontFace FrontFace;
	public Vk.Bool32 DepthBiasEnable;
	public float DepthBiasConstantFactor;
	public float DepthBiasClamp;
	public float DepthBiasSlopeFactor;
	public float LineWidth;
	public PipelineRasterizationStateCreateInfo(
		in Vk.PipelineRasterizationStateCreateFlags flags = default,
		in Vk.Bool32 depthClampEnable = default,
		in Vk.Bool32 rasterizerDiscardEnable = default,
		in Vk.PolygonMode polygonMode = default,
		in Vk.CullModeFlags cullMode = default,
		in Vk.FrontFace frontFace = default,
		in Vk.Bool32 depthBiasEnable = default,
		float depthBiasConstantFactor = default,
		float depthBiasClamp = default,
		float depthBiasSlopeFactor = default,
		float lineWidth = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		DepthClampEnable = depthClampEnable;
		RasterizerDiscardEnable = rasterizerDiscardEnable;
		PolygonMode = polygonMode;
		CullMode = cullMode;
		FrontFace = frontFace;
		DepthBiasEnable = depthBiasEnable;
		DepthBiasConstantFactor = depthBiasConstantFactor;
		DepthBiasClamp = depthBiasClamp;
		DepthBiasSlopeFactor = depthBiasSlopeFactor;
		LineWidth = lineWidth;
	}


	public readonly override bool Equals(object? obj) => (obj is PipelineRasterizationStateCreateInfo o) && (this == o);
	readonly bool IEquatable<PipelineRasterizationStateCreateInfo>.Equals(PipelineRasterizationStateCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ DepthClampEnable.GetHashCode()
			^ RasterizerDiscardEnable.GetHashCode() ^ PolygonMode.GetHashCode() ^ CullMode.GetHashCode() ^ FrontFace.GetHashCode()
			^ DepthBiasEnable.GetHashCode() ^ DepthBiasConstantFactor.GetHashCode() ^ DepthBiasClamp.GetHashCode() ^ DepthBiasSlopeFactor.GetHashCode()
			^ LineWidth.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PipelineRasterizationStateCreateInfo l, in PipelineRasterizationStateCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.DepthClampEnable == r.DepthClampEnable)
			&& (l.RasterizerDiscardEnable == r.RasterizerDiscardEnable) && (l.PolygonMode == r.PolygonMode) && (l.CullMode == r.CullMode) && (l.FrontFace == r.FrontFace)
			&& (l.DepthBiasEnable == r.DepthBiasEnable) && (l.DepthBiasConstantFactor == r.DepthBiasConstantFactor) && (l.DepthBiasClamp == r.DepthBiasClamp) && (l.DepthBiasSlopeFactor == r.DepthBiasSlopeFactor)
			&& (l.LineWidth == r.LineWidth)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PipelineRasterizationStateCreateInfo l, in PipelineRasterizationStateCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.DepthClampEnable != r.DepthClampEnable)
			|| (l.RasterizerDiscardEnable != r.RasterizerDiscardEnable) || (l.PolygonMode != r.PolygonMode) || (l.CullMode != r.CullMode) || (l.FrontFace != r.FrontFace)
			|| (l.DepthBiasEnable != r.DepthBiasEnable) || (l.DepthBiasConstantFactor != r.DepthBiasConstantFactor) || (l.DepthBiasClamp != r.DepthBiasClamp) || (l.DepthBiasSlopeFactor != r.DepthBiasSlopeFactor)
			|| (l.LineWidth != r.LineWidth)
			;
	}


	/// <summary>Creates a new PipelineRasterizationStateCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PipelineRasterizationStateCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PipelineMultisampleStateCreateInfo : IEquatable<PipelineMultisampleStateCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PipelineMultisampleStateCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.PipelineMultisampleStateCreateFlags Flags;
	public Vk.SampleCountFlags RasterizationSamples;
	public Vk.Bool32 SampleShadingEnable;
	public float MinSampleShading;
	public uint* SampleMask;
	public Vk.Bool32 AlphaToCoverageEnable;
	public Vk.Bool32 AlphaToOneEnable;
	public PipelineMultisampleStateCreateInfo(
		in Vk.PipelineMultisampleStateCreateFlags flags = default,
		in Vk.SampleCountFlags rasterizationSamples = default,
		in Vk.Bool32 sampleShadingEnable = default,
		float minSampleShading = default,
		uint* sampleMask = default,
		in Vk.Bool32 alphaToCoverageEnable = default,
		in Vk.Bool32 alphaToOneEnable = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		RasterizationSamples = rasterizationSamples;
		SampleShadingEnable = sampleShadingEnable;
		MinSampleShading = minSampleShading;
		SampleMask = sampleMask;
		AlphaToCoverageEnable = alphaToCoverageEnable;
		AlphaToOneEnable = alphaToOneEnable;
	}


	public readonly override bool Equals(object? obj) => (obj is PipelineMultisampleStateCreateInfo o) && (this == o);
	readonly bool IEquatable<PipelineMultisampleStateCreateInfo>.Equals(PipelineMultisampleStateCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ RasterizationSamples.GetHashCode()
			^ SampleShadingEnable.GetHashCode() ^ MinSampleShading.GetHashCode() ^ ((ulong)SampleMask).GetHashCode() ^ AlphaToCoverageEnable.GetHashCode()
			^ AlphaToOneEnable.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PipelineMultisampleStateCreateInfo l, in PipelineMultisampleStateCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.RasterizationSamples == r.RasterizationSamples)
			&& (l.SampleShadingEnable == r.SampleShadingEnable) && (l.MinSampleShading == r.MinSampleShading) && (l.SampleMask == r.SampleMask) && (l.AlphaToCoverageEnable == r.AlphaToCoverageEnable)
			&& (l.AlphaToOneEnable == r.AlphaToOneEnable)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PipelineMultisampleStateCreateInfo l, in PipelineMultisampleStateCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.RasterizationSamples != r.RasterizationSamples)
			|| (l.SampleShadingEnable != r.SampleShadingEnable) || (l.MinSampleShading != r.MinSampleShading) || (l.SampleMask != r.SampleMask) || (l.AlphaToCoverageEnable != r.AlphaToCoverageEnable)
			|| (l.AlphaToOneEnable != r.AlphaToOneEnable)
			;
	}


	/// <summary>Creates a new PipelineMultisampleStateCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PipelineMultisampleStateCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PipelineColorBlendAttachmentState : IEquatable<PipelineColorBlendAttachmentState>
{
	public Vk.Bool32 BlendEnable;
	public Vk.BlendFactor SrcColorBlendFactor;
	public Vk.BlendFactor DstColorBlendFactor;
	public Vk.BlendOp ColorBlendOp;
	public Vk.BlendFactor SrcAlphaBlendFactor;
	public Vk.BlendFactor DstAlphaBlendFactor;
	public Vk.BlendOp AlphaBlendOp;
	public Vk.ColorComponentFlags ColorWriteMask;
	public PipelineColorBlendAttachmentState(
		in Vk.Bool32 blendEnable = default,
		in Vk.BlendFactor srcColorBlendFactor = default,
		in Vk.BlendFactor dstColorBlendFactor = default,
		in Vk.BlendOp colorBlendOp = default,
		in Vk.BlendFactor srcAlphaBlendFactor = default,
		in Vk.BlendFactor dstAlphaBlendFactor = default,
		in Vk.BlendOp alphaBlendOp = default,
		in Vk.ColorComponentFlags colorWriteMask = default
	) {
		BlendEnable = blendEnable;
		SrcColorBlendFactor = srcColorBlendFactor;
		DstColorBlendFactor = dstColorBlendFactor;
		ColorBlendOp = colorBlendOp;
		SrcAlphaBlendFactor = srcAlphaBlendFactor;
		DstAlphaBlendFactor = dstAlphaBlendFactor;
		AlphaBlendOp = alphaBlendOp;
		ColorWriteMask = colorWriteMask;
	}


	public readonly override bool Equals(object? obj) => (obj is PipelineColorBlendAttachmentState o) && (this == o);
	readonly bool IEquatable<PipelineColorBlendAttachmentState>.Equals(PipelineColorBlendAttachmentState obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			BlendEnable.GetHashCode() ^ SrcColorBlendFactor.GetHashCode() ^ DstColorBlendFactor.GetHashCode() ^ ColorBlendOp.GetHashCode()
			^ SrcAlphaBlendFactor.GetHashCode() ^ DstAlphaBlendFactor.GetHashCode() ^ AlphaBlendOp.GetHashCode() ^ ColorWriteMask.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PipelineColorBlendAttachmentState l, in PipelineColorBlendAttachmentState r)
	{
		return
			(l.BlendEnable == r.BlendEnable) && (l.SrcColorBlendFactor == r.SrcColorBlendFactor) && (l.DstColorBlendFactor == r.DstColorBlendFactor) && (l.ColorBlendOp == r.ColorBlendOp)
			&& (l.SrcAlphaBlendFactor == r.SrcAlphaBlendFactor) && (l.DstAlphaBlendFactor == r.DstAlphaBlendFactor) && (l.AlphaBlendOp == r.AlphaBlendOp) && (l.ColorWriteMask == r.ColorWriteMask)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PipelineColorBlendAttachmentState l, in PipelineColorBlendAttachmentState r)
	{
		return
			(l.BlendEnable != r.BlendEnable) || (l.SrcColorBlendFactor != r.SrcColorBlendFactor) || (l.DstColorBlendFactor != r.DstColorBlendFactor) || (l.ColorBlendOp != r.ColorBlendOp)
			|| (l.SrcAlphaBlendFactor != r.SrcAlphaBlendFactor) || (l.DstAlphaBlendFactor != r.DstAlphaBlendFactor) || (l.AlphaBlendOp != r.AlphaBlendOp) || (l.ColorWriteMask != r.ColorWriteMask)
			;
	}


	/// <summary>Creates a new PipelineColorBlendAttachmentState value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PipelineColorBlendAttachmentState value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PipelineColorBlendStateCreateInfo : IEquatable<PipelineColorBlendStateCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PipelineColorBlendStateCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.PipelineColorBlendStateCreateFlags Flags;
	public Vk.Bool32 LogicOpEnable;
	public Vk.LogicOp LogicOp;
	public uint AttachmentCount;
	public Vk.PipelineColorBlendAttachmentState* Attachments;
	public fixed float BlendConstants[4];
	public PipelineColorBlendStateCreateInfo(
		in Vk.PipelineColorBlendStateCreateFlags flags = default,
		in Vk.Bool32 logicOpEnable = default,
		in Vk.LogicOp logicOp = default,
		uint attachmentCount = default,
		in Vk.PipelineColorBlendAttachmentState* attachments = default,
		float blendConstants0 = default,
		float blendConstants1 = default,
		float blendConstants2 = default,
		float blendConstants3 = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		LogicOpEnable = logicOpEnable;
		LogicOp = logicOp;
		AttachmentCount = attachmentCount;
		Attachments = attachments;
		BlendConstants[0] = blendConstants0;
		BlendConstants[1] = blendConstants1;
		BlendConstants[2] = blendConstants2;
		BlendConstants[3] = blendConstants3;
	}


	public readonly override bool Equals(object? obj) => (obj is PipelineColorBlendStateCreateInfo o) && (this == o);
	readonly bool IEquatable<PipelineColorBlendStateCreateInfo>.Equals(PipelineColorBlendStateCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ LogicOpEnable.GetHashCode()
			^ LogicOp.GetHashCode() ^ AttachmentCount.GetHashCode() ^ ((ulong)Attachments).GetHashCode() ^ BlendConstants[0].GetHashCode()
			^ BlendConstants[1].GetHashCode() ^ BlendConstants[2].GetHashCode() ^ BlendConstants[3].GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PipelineColorBlendStateCreateInfo l, in PipelineColorBlendStateCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.LogicOpEnable == r.LogicOpEnable)
			&& (l.LogicOp == r.LogicOp) && (l.AttachmentCount == r.AttachmentCount) && (l.Attachments == r.Attachments) && (l.BlendConstants[0] == r.BlendConstants[0])
			&& (l.BlendConstants[1] == r.BlendConstants[1]) && (l.BlendConstants[2] == r.BlendConstants[2]) && (l.BlendConstants[3] == r.BlendConstants[3])
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PipelineColorBlendStateCreateInfo l, in PipelineColorBlendStateCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.LogicOpEnable != r.LogicOpEnable)
			|| (l.LogicOp != r.LogicOp) || (l.AttachmentCount != r.AttachmentCount) || (l.Attachments != r.Attachments) || (l.BlendConstants[0] != r.BlendConstants[0])
			|| (l.BlendConstants[1] != r.BlendConstants[1]) || (l.BlendConstants[2] != r.BlendConstants[2]) || (l.BlendConstants[3] != r.BlendConstants[3])
			;
	}


	/// <summary>Creates a new PipelineColorBlendStateCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PipelineColorBlendStateCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PipelineDynamicStateCreateInfo : IEquatable<PipelineDynamicStateCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PipelineDynamicStateCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.PipelineDynamicStateCreateFlags Flags;
	public uint DynamicStateCount;
	public Vk.DynamicState* DynamicStates;
	public PipelineDynamicStateCreateInfo(
		in Vk.PipelineDynamicStateCreateFlags flags = default,
		uint dynamicStateCount = default,
		in Vk.DynamicState* dynamicStates = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		DynamicStateCount = dynamicStateCount;
		DynamicStates = dynamicStates;
	}


	public readonly override bool Equals(object? obj) => (obj is PipelineDynamicStateCreateInfo o) && (this == o);
	readonly bool IEquatable<PipelineDynamicStateCreateInfo>.Equals(PipelineDynamicStateCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ DynamicStateCount.GetHashCode()
			^ ((ulong)DynamicStates).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PipelineDynamicStateCreateInfo l, in PipelineDynamicStateCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.DynamicStateCount == r.DynamicStateCount)
			&& (l.DynamicStates == r.DynamicStates)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PipelineDynamicStateCreateInfo l, in PipelineDynamicStateCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.DynamicStateCount != r.DynamicStateCount)
			|| (l.DynamicStates != r.DynamicStates)
			;
	}


	/// <summary>Creates a new PipelineDynamicStateCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PipelineDynamicStateCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct StencilOpState : IEquatable<StencilOpState>
{
	public Vk.StencilOp FailOp;
	public Vk.StencilOp PassOp;
	public Vk.StencilOp DepthFailOp;
	public Vk.CompareOp CompareOp;
	public uint CompareMask;
	public uint WriteMask;
	public uint Reference;
	public StencilOpState(
		in Vk.StencilOp failOp = default,
		in Vk.StencilOp passOp = default,
		in Vk.StencilOp depthFailOp = default,
		in Vk.CompareOp compareOp = default,
		uint compareMask = default,
		uint writeMask = default,
		uint reference = default
	) {
		FailOp = failOp;
		PassOp = passOp;
		DepthFailOp = depthFailOp;
		CompareOp = compareOp;
		CompareMask = compareMask;
		WriteMask = writeMask;
		Reference = reference;
	}


	public readonly override bool Equals(object? obj) => (obj is StencilOpState o) && (this == o);
	readonly bool IEquatable<StencilOpState>.Equals(StencilOpState obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			FailOp.GetHashCode() ^ PassOp.GetHashCode() ^ DepthFailOp.GetHashCode() ^ CompareOp.GetHashCode()
			^ CompareMask.GetHashCode() ^ WriteMask.GetHashCode() ^ Reference.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in StencilOpState l, in StencilOpState r)
	{
		return
			(l.FailOp == r.FailOp) && (l.PassOp == r.PassOp) && (l.DepthFailOp == r.DepthFailOp) && (l.CompareOp == r.CompareOp)
			&& (l.CompareMask == r.CompareMask) && (l.WriteMask == r.WriteMask) && (l.Reference == r.Reference)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in StencilOpState l, in StencilOpState r)
	{
		return
			(l.FailOp != r.FailOp) || (l.PassOp != r.PassOp) || (l.DepthFailOp != r.DepthFailOp) || (l.CompareOp != r.CompareOp)
			|| (l.CompareMask != r.CompareMask) || (l.WriteMask != r.WriteMask) || (l.Reference != r.Reference)
			;
	}


	/// <summary>Creates a new StencilOpState value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out StencilOpState value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PipelineDepthStencilStateCreateInfo : IEquatable<PipelineDepthStencilStateCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PipelineDepthStencilStateCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.PipelineDepthStencilStateCreateFlags Flags;
	public Vk.Bool32 DepthTestEnable;
	public Vk.Bool32 DepthWriteEnable;
	public Vk.CompareOp DepthCompareOp;
	public Vk.Bool32 DepthBoundsTestEnable;
	public Vk.Bool32 StencilTestEnable;
	public Vk.StencilOpState Front;
	public Vk.StencilOpState Back;
	public float MinDepthBounds;
	public float MaxDepthBounds;
	public PipelineDepthStencilStateCreateInfo(
		in Vk.PipelineDepthStencilStateCreateFlags flags = default,
		in Vk.Bool32 depthTestEnable = default,
		in Vk.Bool32 depthWriteEnable = default,
		in Vk.CompareOp depthCompareOp = default,
		in Vk.Bool32 depthBoundsTestEnable = default,
		in Vk.Bool32 stencilTestEnable = default,
		in Vk.StencilOpState front = default,
		in Vk.StencilOpState back = default,
		float minDepthBounds = default,
		float maxDepthBounds = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		DepthTestEnable = depthTestEnable;
		DepthWriteEnable = depthWriteEnable;
		DepthCompareOp = depthCompareOp;
		DepthBoundsTestEnable = depthBoundsTestEnable;
		StencilTestEnable = stencilTestEnable;
		Front = front;
		Back = back;
		MinDepthBounds = minDepthBounds;
		MaxDepthBounds = maxDepthBounds;
	}


	public readonly override bool Equals(object? obj) => (obj is PipelineDepthStencilStateCreateInfo o) && (this == o);
	readonly bool IEquatable<PipelineDepthStencilStateCreateInfo>.Equals(PipelineDepthStencilStateCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ DepthTestEnable.GetHashCode()
			^ DepthWriteEnable.GetHashCode() ^ DepthCompareOp.GetHashCode() ^ DepthBoundsTestEnable.GetHashCode() ^ StencilTestEnable.GetHashCode()
			^ Front.GetHashCode() ^ Back.GetHashCode() ^ MinDepthBounds.GetHashCode() ^ MaxDepthBounds.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PipelineDepthStencilStateCreateInfo l, in PipelineDepthStencilStateCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.DepthTestEnable == r.DepthTestEnable)
			&& (l.DepthWriteEnable == r.DepthWriteEnable) && (l.DepthCompareOp == r.DepthCompareOp) && (l.DepthBoundsTestEnable == r.DepthBoundsTestEnable) && (l.StencilTestEnable == r.StencilTestEnable)
			&& (l.Front == r.Front) && (l.Back == r.Back) && (l.MinDepthBounds == r.MinDepthBounds) && (l.MaxDepthBounds == r.MaxDepthBounds)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PipelineDepthStencilStateCreateInfo l, in PipelineDepthStencilStateCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.DepthTestEnable != r.DepthTestEnable)
			|| (l.DepthWriteEnable != r.DepthWriteEnable) || (l.DepthCompareOp != r.DepthCompareOp) || (l.DepthBoundsTestEnable != r.DepthBoundsTestEnable) || (l.StencilTestEnable != r.StencilTestEnable)
			|| (l.Front != r.Front) || (l.Back != r.Back) || (l.MinDepthBounds != r.MinDepthBounds) || (l.MaxDepthBounds != r.MaxDepthBounds)
			;
	}


	/// <summary>Creates a new PipelineDepthStencilStateCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PipelineDepthStencilStateCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct GraphicsPipelineCreateInfo : IEquatable<GraphicsPipelineCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.GraphicsPipelineCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.PipelineCreateFlags Flags;
	public uint StageCount;
	public Vk.PipelineShaderStageCreateInfo* Stages;
	public Vk.PipelineVertexInputStateCreateInfo* VertexInputState;
	public Vk.PipelineInputAssemblyStateCreateInfo* InputAssemblyState;
	public Vk.PipelineTessellationStateCreateInfo* TessellationState;
	public Vk.PipelineViewportStateCreateInfo* ViewportState;
	public Vk.PipelineRasterizationStateCreateInfo* RasterizationState;
	public Vk.PipelineMultisampleStateCreateInfo* MultisampleState;
	public Vk.PipelineDepthStencilStateCreateInfo* DepthStencilState;
	public Vk.PipelineColorBlendStateCreateInfo* ColorBlendState;
	public Vk.PipelineDynamicStateCreateInfo* DynamicState;
	public Vk.Handle<Vk.PipelineLayout> Layout;
	public Vk.Handle<Vk.RenderPass> RenderPass;
	public uint Subpass;
	public Vk.Handle<Vk.Pipeline> BasePipelineHandle;
	public int BasePipelineIndex;
	public GraphicsPipelineCreateInfo(
		in Vk.PipelineCreateFlags flags = default,
		uint stageCount = default,
		in Vk.PipelineShaderStageCreateInfo* stages = default,
		in Vk.PipelineVertexInputStateCreateInfo* vertexInputState = default,
		in Vk.PipelineInputAssemblyStateCreateInfo* inputAssemblyState = default,
		in Vk.PipelineTessellationStateCreateInfo* tessellationState = default,
		in Vk.PipelineViewportStateCreateInfo* viewportState = default,
		in Vk.PipelineRasterizationStateCreateInfo* rasterizationState = default,
		in Vk.PipelineMultisampleStateCreateInfo* multisampleState = default,
		in Vk.PipelineDepthStencilStateCreateInfo* depthStencilState = default,
		in Vk.PipelineColorBlendStateCreateInfo* colorBlendState = default,
		in Vk.PipelineDynamicStateCreateInfo* dynamicState = default,
		in Vk.Handle<Vk.PipelineLayout> layout = default,
		in Vk.Handle<Vk.RenderPass> renderPass = default,
		uint subpass = default,
		in Vk.Handle<Vk.Pipeline> basePipelineHandle = default,
		int basePipelineIndex = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		StageCount = stageCount;
		Stages = stages;
		VertexInputState = vertexInputState;
		InputAssemblyState = inputAssemblyState;
		TessellationState = tessellationState;
		ViewportState = viewportState;
		RasterizationState = rasterizationState;
		MultisampleState = multisampleState;
		DepthStencilState = depthStencilState;
		ColorBlendState = colorBlendState;
		DynamicState = dynamicState;
		Layout = layout;
		RenderPass = renderPass;
		Subpass = subpass;
		BasePipelineHandle = basePipelineHandle;
		BasePipelineIndex = basePipelineIndex;
	}


	public readonly override bool Equals(object? obj) => (obj is GraphicsPipelineCreateInfo o) && (this == o);
	readonly bool IEquatable<GraphicsPipelineCreateInfo>.Equals(GraphicsPipelineCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ StageCount.GetHashCode()
			^ ((ulong)Stages).GetHashCode() ^ ((ulong)VertexInputState).GetHashCode() ^ ((ulong)InputAssemblyState).GetHashCode() ^ ((ulong)TessellationState).GetHashCode()
			^ ((ulong)ViewportState).GetHashCode() ^ ((ulong)RasterizationState).GetHashCode() ^ ((ulong)MultisampleState).GetHashCode() ^ ((ulong)DepthStencilState).GetHashCode()
			^ ((ulong)ColorBlendState).GetHashCode() ^ ((ulong)DynamicState).GetHashCode() ^ Layout.GetHashCode() ^ RenderPass.GetHashCode()
			^ Subpass.GetHashCode() ^ BasePipelineHandle.GetHashCode() ^ BasePipelineIndex.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in GraphicsPipelineCreateInfo l, in GraphicsPipelineCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.StageCount == r.StageCount)
			&& (l.Stages == r.Stages) && (l.VertexInputState == r.VertexInputState) && (l.InputAssemblyState == r.InputAssemblyState) && (l.TessellationState == r.TessellationState)
			&& (l.ViewportState == r.ViewportState) && (l.RasterizationState == r.RasterizationState) && (l.MultisampleState == r.MultisampleState) && (l.DepthStencilState == r.DepthStencilState)
			&& (l.ColorBlendState == r.ColorBlendState) && (l.DynamicState == r.DynamicState) && (l.Layout == r.Layout) && (l.RenderPass == r.RenderPass)
			&& (l.Subpass == r.Subpass) && (l.BasePipelineHandle == r.BasePipelineHandle) && (l.BasePipelineIndex == r.BasePipelineIndex)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in GraphicsPipelineCreateInfo l, in GraphicsPipelineCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.StageCount != r.StageCount)
			|| (l.Stages != r.Stages) || (l.VertexInputState != r.VertexInputState) || (l.InputAssemblyState != r.InputAssemblyState) || (l.TessellationState != r.TessellationState)
			|| (l.ViewportState != r.ViewportState) || (l.RasterizationState != r.RasterizationState) || (l.MultisampleState != r.MultisampleState) || (l.DepthStencilState != r.DepthStencilState)
			|| (l.ColorBlendState != r.ColorBlendState) || (l.DynamicState != r.DynamicState) || (l.Layout != r.Layout) || (l.RenderPass != r.RenderPass)
			|| (l.Subpass != r.Subpass) || (l.BasePipelineHandle != r.BasePipelineHandle) || (l.BasePipelineIndex != r.BasePipelineIndex)
			;
	}


	/// <summary>Creates a new GraphicsPipelineCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out GraphicsPipelineCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PipelineCacheCreateInfo : IEquatable<PipelineCacheCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PipelineCacheCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.PipelineCacheCreateFlags Flags;
	public ulong InitialDataSize;
	public void* InitialData;
	public PipelineCacheCreateInfo(
		in Vk.PipelineCacheCreateFlags flags = default,
		ulong initialDataSize = default,
		void* initialData = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		InitialDataSize = initialDataSize;
		InitialData = initialData;
	}


	public readonly override bool Equals(object? obj) => (obj is PipelineCacheCreateInfo o) && (this == o);
	readonly bool IEquatable<PipelineCacheCreateInfo>.Equals(PipelineCacheCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ InitialDataSize.GetHashCode()
			^ ((ulong)InitialData).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PipelineCacheCreateInfo l, in PipelineCacheCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.InitialDataSize == r.InitialDataSize)
			&& (l.InitialData == r.InitialData)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PipelineCacheCreateInfo l, in PipelineCacheCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.InitialDataSize != r.InitialDataSize)
			|| (l.InitialData != r.InitialData)
			;
	}


	/// <summary>Creates a new PipelineCacheCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PipelineCacheCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PushConstantRange : IEquatable<PushConstantRange>
{
	public Vk.ShaderStageFlags StageFlags;
	public uint Offset;
	public uint Size;
	public PushConstantRange(
		in Vk.ShaderStageFlags stageFlags = default,
		uint offset = default,
		uint size = default
	) {
		StageFlags = stageFlags;
		Offset = offset;
		Size = size;
	}


	public readonly override bool Equals(object? obj) => (obj is PushConstantRange o) && (this == o);
	readonly bool IEquatable<PushConstantRange>.Equals(PushConstantRange obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			StageFlags.GetHashCode() ^ Offset.GetHashCode() ^ Size.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PushConstantRange l, in PushConstantRange r)
	{
		return
			(l.StageFlags == r.StageFlags) && (l.Offset == r.Offset) && (l.Size == r.Size)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PushConstantRange l, in PushConstantRange r)
	{
		return
			(l.StageFlags != r.StageFlags) || (l.Offset != r.Offset) || (l.Size != r.Size)
			;
	}


	/// <summary>Creates a new PushConstantRange value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PushConstantRange value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PipelineLayoutCreateInfo : IEquatable<PipelineLayoutCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PipelineLayoutCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.PipelineLayoutCreateFlags Flags;
	public uint SetLayoutCount;
	public Vk.Handle<Vk.DescriptorSetLayout>* SetLayouts;
	public uint PushConstantRangeCount;
	public Vk.PushConstantRange* PushConstantRanges;
	public PipelineLayoutCreateInfo(
		in Vk.PipelineLayoutCreateFlags flags = default,
		uint setLayoutCount = default,
		in Vk.Handle<Vk.DescriptorSetLayout>* setLayouts = default,
		uint pushConstantRangeCount = default,
		in Vk.PushConstantRange* pushConstantRanges = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		SetLayoutCount = setLayoutCount;
		SetLayouts = setLayouts;
		PushConstantRangeCount = pushConstantRangeCount;
		PushConstantRanges = pushConstantRanges;
	}


	public readonly override bool Equals(object? obj) => (obj is PipelineLayoutCreateInfo o) && (this == o);
	readonly bool IEquatable<PipelineLayoutCreateInfo>.Equals(PipelineLayoutCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ SetLayoutCount.GetHashCode()
			^ ((ulong)SetLayouts).GetHashCode() ^ PushConstantRangeCount.GetHashCode() ^ ((ulong)PushConstantRanges).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PipelineLayoutCreateInfo l, in PipelineLayoutCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.SetLayoutCount == r.SetLayoutCount)
			&& (l.SetLayouts == r.SetLayouts) && (l.PushConstantRangeCount == r.PushConstantRangeCount) && (l.PushConstantRanges == r.PushConstantRanges)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PipelineLayoutCreateInfo l, in PipelineLayoutCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.SetLayoutCount != r.SetLayoutCount)
			|| (l.SetLayouts != r.SetLayouts) || (l.PushConstantRangeCount != r.PushConstantRangeCount) || (l.PushConstantRanges != r.PushConstantRanges)
			;
	}


	/// <summary>Creates a new PipelineLayoutCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PipelineLayoutCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SamplerCreateInfo : IEquatable<SamplerCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.SamplerCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.SamplerCreateFlags Flags;
	public Vk.Filter MagFilter;
	public Vk.Filter MinFilter;
	public Vk.SamplerMipmapMode MipmapMode;
	public Vk.SamplerAddressMode AddressModeU;
	public Vk.SamplerAddressMode AddressModeV;
	public Vk.SamplerAddressMode AddressModeW;
	public float MipLodBias;
	public Vk.Bool32 AnisotropyEnable;
	public float MaxAnisotropy;
	public Vk.Bool32 CompareEnable;
	public Vk.CompareOp CompareOp;
	public float MinLod;
	public float MaxLod;
	public Vk.BorderColor BorderColor;
	public Vk.Bool32 UnnormalizedCoordinates;
	public SamplerCreateInfo(
		in Vk.SamplerCreateFlags flags = default,
		in Vk.Filter magFilter = default,
		in Vk.Filter minFilter = default,
		in Vk.SamplerMipmapMode mipmapMode = default,
		in Vk.SamplerAddressMode addressModeU = default,
		in Vk.SamplerAddressMode addressModeV = default,
		in Vk.SamplerAddressMode addressModeW = default,
		float mipLodBias = default,
		in Vk.Bool32 anisotropyEnable = default,
		float maxAnisotropy = default,
		in Vk.Bool32 compareEnable = default,
		in Vk.CompareOp compareOp = default,
		float minLod = default,
		float maxLod = default,
		in Vk.BorderColor borderColor = default,
		in Vk.Bool32 unnormalizedCoordinates = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		MagFilter = magFilter;
		MinFilter = minFilter;
		MipmapMode = mipmapMode;
		AddressModeU = addressModeU;
		AddressModeV = addressModeV;
		AddressModeW = addressModeW;
		MipLodBias = mipLodBias;
		AnisotropyEnable = anisotropyEnable;
		MaxAnisotropy = maxAnisotropy;
		CompareEnable = compareEnable;
		CompareOp = compareOp;
		MinLod = minLod;
		MaxLod = maxLod;
		BorderColor = borderColor;
		UnnormalizedCoordinates = unnormalizedCoordinates;
	}


	public readonly override bool Equals(object? obj) => (obj is SamplerCreateInfo o) && (this == o);
	readonly bool IEquatable<SamplerCreateInfo>.Equals(SamplerCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ MagFilter.GetHashCode()
			^ MinFilter.GetHashCode() ^ MipmapMode.GetHashCode() ^ AddressModeU.GetHashCode() ^ AddressModeV.GetHashCode()
			^ AddressModeW.GetHashCode() ^ MipLodBias.GetHashCode() ^ AnisotropyEnable.GetHashCode() ^ MaxAnisotropy.GetHashCode()
			^ CompareEnable.GetHashCode() ^ CompareOp.GetHashCode() ^ MinLod.GetHashCode() ^ MaxLod.GetHashCode()
			^ BorderColor.GetHashCode() ^ UnnormalizedCoordinates.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SamplerCreateInfo l, in SamplerCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.MagFilter == r.MagFilter)
			&& (l.MinFilter == r.MinFilter) && (l.MipmapMode == r.MipmapMode) && (l.AddressModeU == r.AddressModeU) && (l.AddressModeV == r.AddressModeV)
			&& (l.AddressModeW == r.AddressModeW) && (l.MipLodBias == r.MipLodBias) && (l.AnisotropyEnable == r.AnisotropyEnable) && (l.MaxAnisotropy == r.MaxAnisotropy)
			&& (l.CompareEnable == r.CompareEnable) && (l.CompareOp == r.CompareOp) && (l.MinLod == r.MinLod) && (l.MaxLod == r.MaxLod)
			&& (l.BorderColor == r.BorderColor) && (l.UnnormalizedCoordinates == r.UnnormalizedCoordinates)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SamplerCreateInfo l, in SamplerCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.MagFilter != r.MagFilter)
			|| (l.MinFilter != r.MinFilter) || (l.MipmapMode != r.MipmapMode) || (l.AddressModeU != r.AddressModeU) || (l.AddressModeV != r.AddressModeV)
			|| (l.AddressModeW != r.AddressModeW) || (l.MipLodBias != r.MipLodBias) || (l.AnisotropyEnable != r.AnisotropyEnable) || (l.MaxAnisotropy != r.MaxAnisotropy)
			|| (l.CompareEnable != r.CompareEnable) || (l.CompareOp != r.CompareOp) || (l.MinLod != r.MinLod) || (l.MaxLod != r.MaxLod)
			|| (l.BorderColor != r.BorderColor) || (l.UnnormalizedCoordinates != r.UnnormalizedCoordinates)
			;
	}


	/// <summary>Creates a new SamplerCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SamplerCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct CommandPoolCreateInfo : IEquatable<CommandPoolCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.CommandPoolCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.CommandPoolCreateFlags Flags;
	public uint QueueFamilyIndex;
	public CommandPoolCreateInfo(
		in Vk.CommandPoolCreateFlags flags = default,
		uint queueFamilyIndex = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		QueueFamilyIndex = queueFamilyIndex;
	}


	public readonly override bool Equals(object? obj) => (obj is CommandPoolCreateInfo o) && (this == o);
	readonly bool IEquatable<CommandPoolCreateInfo>.Equals(CommandPoolCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ QueueFamilyIndex.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in CommandPoolCreateInfo l, in CommandPoolCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.QueueFamilyIndex == r.QueueFamilyIndex)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in CommandPoolCreateInfo l, in CommandPoolCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.QueueFamilyIndex != r.QueueFamilyIndex)
			;
	}


	/// <summary>Creates a new CommandPoolCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out CommandPoolCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct CommandBufferAllocateInfo : IEquatable<CommandBufferAllocateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.CommandBufferAllocateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Handle<Vk.CommandPool> CommandPool;
	public Vk.CommandBufferLevel Level;
	public uint CommandBufferCount;
	public CommandBufferAllocateInfo(
		in Vk.Handle<Vk.CommandPool> commandPool = default,
		in Vk.CommandBufferLevel level = default,
		uint commandBufferCount = default
	) {
		sType = TYPE;
		pNext = null;
		CommandPool = commandPool;
		Level = level;
		CommandBufferCount = commandBufferCount;
	}


	public readonly override bool Equals(object? obj) => (obj is CommandBufferAllocateInfo o) && (this == o);
	readonly bool IEquatable<CommandBufferAllocateInfo>.Equals(CommandBufferAllocateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ CommandPool.GetHashCode() ^ Level.GetHashCode()
			^ CommandBufferCount.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in CommandBufferAllocateInfo l, in CommandBufferAllocateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.CommandPool == r.CommandPool) && (l.Level == r.Level)
			&& (l.CommandBufferCount == r.CommandBufferCount)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in CommandBufferAllocateInfo l, in CommandBufferAllocateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.CommandPool != r.CommandPool) || (l.Level != r.Level)
			|| (l.CommandBufferCount != r.CommandBufferCount)
			;
	}


	/// <summary>Creates a new CommandBufferAllocateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out CommandBufferAllocateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct CommandBufferInheritanceInfo : IEquatable<CommandBufferInheritanceInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.CommandBufferInheritanceInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Handle<Vk.RenderPass> RenderPass;
	public uint Subpass;
	public Vk.Handle<Vk.Framebuffer> Framebuffer;
	public Vk.Bool32 OcclusionQueryEnable;
	public Vk.QueryControlFlags QueryFlags;
	public Vk.QueryPipelineStatisticFlags PipelineStatistics;
	public CommandBufferInheritanceInfo(
		in Vk.Handle<Vk.RenderPass> renderPass = default,
		uint subpass = default,
		in Vk.Handle<Vk.Framebuffer> framebuffer = default,
		in Vk.Bool32 occlusionQueryEnable = default,
		in Vk.QueryControlFlags queryFlags = default,
		in Vk.QueryPipelineStatisticFlags pipelineStatistics = default
	) {
		sType = TYPE;
		pNext = null;
		RenderPass = renderPass;
		Subpass = subpass;
		Framebuffer = framebuffer;
		OcclusionQueryEnable = occlusionQueryEnable;
		QueryFlags = queryFlags;
		PipelineStatistics = pipelineStatistics;
	}


	public readonly override bool Equals(object? obj) => (obj is CommandBufferInheritanceInfo o) && (this == o);
	readonly bool IEquatable<CommandBufferInheritanceInfo>.Equals(CommandBufferInheritanceInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ RenderPass.GetHashCode() ^ Subpass.GetHashCode()
			^ Framebuffer.GetHashCode() ^ OcclusionQueryEnable.GetHashCode() ^ QueryFlags.GetHashCode() ^ PipelineStatistics.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in CommandBufferInheritanceInfo l, in CommandBufferInheritanceInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.RenderPass == r.RenderPass) && (l.Subpass == r.Subpass)
			&& (l.Framebuffer == r.Framebuffer) && (l.OcclusionQueryEnable == r.OcclusionQueryEnable) && (l.QueryFlags == r.QueryFlags) && (l.PipelineStatistics == r.PipelineStatistics)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in CommandBufferInheritanceInfo l, in CommandBufferInheritanceInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.RenderPass != r.RenderPass) || (l.Subpass != r.Subpass)
			|| (l.Framebuffer != r.Framebuffer) || (l.OcclusionQueryEnable != r.OcclusionQueryEnable) || (l.QueryFlags != r.QueryFlags) || (l.PipelineStatistics != r.PipelineStatistics)
			;
	}


	/// <summary>Creates a new CommandBufferInheritanceInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out CommandBufferInheritanceInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct CommandBufferBeginInfo : IEquatable<CommandBufferBeginInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.CommandBufferBeginInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.CommandBufferUsageFlags Flags;
	public Vk.CommandBufferInheritanceInfo* InheritanceInfo;
	public CommandBufferBeginInfo(
		in Vk.CommandBufferUsageFlags flags = default,
		in Vk.CommandBufferInheritanceInfo* inheritanceInfo = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		InheritanceInfo = inheritanceInfo;
	}


	public readonly override bool Equals(object? obj) => (obj is CommandBufferBeginInfo o) && (this == o);
	readonly bool IEquatable<CommandBufferBeginInfo>.Equals(CommandBufferBeginInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ ((ulong)InheritanceInfo).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in CommandBufferBeginInfo l, in CommandBufferBeginInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.InheritanceInfo == r.InheritanceInfo)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in CommandBufferBeginInfo l, in CommandBufferBeginInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.InheritanceInfo != r.InheritanceInfo)
			;
	}


	/// <summary>Creates a new CommandBufferBeginInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out CommandBufferBeginInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct RenderPassBeginInfo : IEquatable<RenderPassBeginInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.RenderPassBeginInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Handle<Vk.RenderPass> RenderPass;
	public Vk.Handle<Vk.Framebuffer> Framebuffer;
	public Vk.Rect2D RenderArea;
	public uint ClearValueCount;
	public Vk.ClearValue* ClearValues;
	public RenderPassBeginInfo(
		in Vk.Handle<Vk.RenderPass> renderPass = default,
		in Vk.Handle<Vk.Framebuffer> framebuffer = default,
		in Vk.Rect2D renderArea = default,
		uint clearValueCount = default,
		in Vk.ClearValue* clearValues = default
	) {
		sType = TYPE;
		pNext = null;
		RenderPass = renderPass;
		Framebuffer = framebuffer;
		RenderArea = renderArea;
		ClearValueCount = clearValueCount;
		ClearValues = clearValues;
	}


	public readonly override bool Equals(object? obj) => (obj is RenderPassBeginInfo o) && (this == o);
	readonly bool IEquatable<RenderPassBeginInfo>.Equals(RenderPassBeginInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ RenderPass.GetHashCode() ^ Framebuffer.GetHashCode()
			^ RenderArea.GetHashCode() ^ ClearValueCount.GetHashCode() ^ ((ulong)ClearValues).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in RenderPassBeginInfo l, in RenderPassBeginInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.RenderPass == r.RenderPass) && (l.Framebuffer == r.Framebuffer)
			&& (l.RenderArea == r.RenderArea) && (l.ClearValueCount == r.ClearValueCount) && (l.ClearValues == r.ClearValues)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in RenderPassBeginInfo l, in RenderPassBeginInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.RenderPass != r.RenderPass) || (l.Framebuffer != r.Framebuffer)
			|| (l.RenderArea != r.RenderArea) || (l.ClearValueCount != r.ClearValueCount) || (l.ClearValues != r.ClearValues)
			;
	}


	/// <summary>Creates a new RenderPassBeginInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out RenderPassBeginInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Explicit)]
public unsafe partial struct ClearColorValue : IEquatable<ClearColorValue>
{
	[FieldOffset(0)] public fixed float Float32[4];
	[FieldOffset(0)] public fixed int Int32[4];
	[FieldOffset(0)] public fixed uint Uint32[4];

	public readonly override bool Equals(object? obj) => (obj is ClearColorValue o) && (this == o);
	readonly bool IEquatable<ClearColorValue>.Equals(ClearColorValue obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Float32[0].GetHashCode() ^ Float32[1].GetHashCode() ^ Float32[2].GetHashCode() ^ Float32[3].GetHashCode()
			^ Int32[0].GetHashCode() ^ Int32[1].GetHashCode() ^ Int32[2].GetHashCode() ^ Int32[3].GetHashCode()
			^ Uint32[0].GetHashCode() ^ Uint32[1].GetHashCode() ^ Uint32[2].GetHashCode() ^ Uint32[3].GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ClearColorValue l, in ClearColorValue r)
	{
		return
			(l.Float32[0] == r.Float32[0]) && (l.Float32[1] == r.Float32[1]) && (l.Float32[2] == r.Float32[2]) && (l.Float32[3] == r.Float32[3])
			&& (l.Int32[0] == r.Int32[0]) && (l.Int32[1] == r.Int32[1]) && (l.Int32[2] == r.Int32[2]) && (l.Int32[3] == r.Int32[3])
			&& (l.Uint32[0] == r.Uint32[0]) && (l.Uint32[1] == r.Uint32[1]) && (l.Uint32[2] == r.Uint32[2]) && (l.Uint32[3] == r.Uint32[3])
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ClearColorValue l, in ClearColorValue r)
	{
		return
			(l.Float32[0] != r.Float32[0]) || (l.Float32[1] != r.Float32[1]) || (l.Float32[2] != r.Float32[2]) || (l.Float32[3] != r.Float32[3])
			|| (l.Int32[0] != r.Int32[0]) || (l.Int32[1] != r.Int32[1]) || (l.Int32[2] != r.Int32[2]) || (l.Int32[3] != r.Int32[3])
			|| (l.Uint32[0] != r.Uint32[0]) || (l.Uint32[1] != r.Uint32[1]) || (l.Uint32[2] != r.Uint32[2]) || (l.Uint32[3] != r.Uint32[3])
			;
	}


	/// <summary>Creates a new ClearColorValue value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ClearColorValue value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ClearDepthStencilValue : IEquatable<ClearDepthStencilValue>
{
	public float Depth;
	public uint Stencil;
	public ClearDepthStencilValue(
		float depth = default,
		uint stencil = default
	) {
		Depth = depth;
		Stencil = stencil;
	}


	public readonly override bool Equals(object? obj) => (obj is ClearDepthStencilValue o) && (this == o);
	readonly bool IEquatable<ClearDepthStencilValue>.Equals(ClearDepthStencilValue obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Depth.GetHashCode() ^ Stencil.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ClearDepthStencilValue l, in ClearDepthStencilValue r)
	{
		return
			(l.Depth == r.Depth) && (l.Stencil == r.Stencil)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ClearDepthStencilValue l, in ClearDepthStencilValue r)
	{
		return
			(l.Depth != r.Depth) || (l.Stencil != r.Stencil)
			;
	}


	/// <summary>Creates a new ClearDepthStencilValue value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ClearDepthStencilValue value) => value = new();
}

[StructLayout(LayoutKind.Explicit)]
public unsafe partial struct ClearValue : IEquatable<ClearValue>
{
	[FieldOffset(0)] public Vk.ClearColorValue Color;
	[FieldOffset(0)] public Vk.ClearDepthStencilValue DepthStencil;

	public readonly override bool Equals(object? obj) => (obj is ClearValue o) && (this == o);
	readonly bool IEquatable<ClearValue>.Equals(ClearValue obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Color.GetHashCode() ^ DepthStencil.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ClearValue l, in ClearValue r)
	{
		return
			(l.Color == r.Color) && (l.DepthStencil == r.DepthStencil)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ClearValue l, in ClearValue r)
	{
		return
			(l.Color != r.Color) || (l.DepthStencil != r.DepthStencil)
			;
	}


	/// <summary>Creates a new ClearValue value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ClearValue value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ClearAttachment : IEquatable<ClearAttachment>
{
	public Vk.ImageAspectFlags AspectMask;
	public uint ColorAttachment;
	public Vk.ClearValue ClearValue;
	public ClearAttachment(
		in Vk.ImageAspectFlags aspectMask = default,
		uint colorAttachment = default,
		in Vk.ClearValue clearValue = default
	) {
		AspectMask = aspectMask;
		ColorAttachment = colorAttachment;
		ClearValue = clearValue;
	}


	public readonly override bool Equals(object? obj) => (obj is ClearAttachment o) && (this == o);
	readonly bool IEquatable<ClearAttachment>.Equals(ClearAttachment obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			AspectMask.GetHashCode() ^ ColorAttachment.GetHashCode() ^ ClearValue.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ClearAttachment l, in ClearAttachment r)
	{
		return
			(l.AspectMask == r.AspectMask) && (l.ColorAttachment == r.ColorAttachment) && (l.ClearValue == r.ClearValue)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ClearAttachment l, in ClearAttachment r)
	{
		return
			(l.AspectMask != r.AspectMask) || (l.ColorAttachment != r.ColorAttachment) || (l.ClearValue != r.ClearValue)
			;
	}


	/// <summary>Creates a new ClearAttachment value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ClearAttachment value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct AttachmentDescription : IEquatable<AttachmentDescription>
{
	public Vk.AttachmentDescriptionFlags Flags;
	public Vk.Format Format;
	public Vk.SampleCountFlags Samples;
	public Vk.AttachmentLoadOp LoadOp;
	public Vk.AttachmentStoreOp StoreOp;
	public Vk.AttachmentLoadOp StencilLoadOp;
	public Vk.AttachmentStoreOp StencilStoreOp;
	public Vk.ImageLayout InitialLayout;
	public Vk.ImageLayout FinalLayout;
	public AttachmentDescription(
		in Vk.AttachmentDescriptionFlags flags = default,
		in Vk.Format format = default,
		in Vk.SampleCountFlags samples = default,
		in Vk.AttachmentLoadOp loadOp = default,
		in Vk.AttachmentStoreOp storeOp = default,
		in Vk.AttachmentLoadOp stencilLoadOp = default,
		in Vk.AttachmentStoreOp stencilStoreOp = default,
		in Vk.ImageLayout initialLayout = default,
		in Vk.ImageLayout finalLayout = default
	) {
		Flags = flags;
		Format = format;
		Samples = samples;
		LoadOp = loadOp;
		StoreOp = storeOp;
		StencilLoadOp = stencilLoadOp;
		StencilStoreOp = stencilStoreOp;
		InitialLayout = initialLayout;
		FinalLayout = finalLayout;
	}


	public readonly override bool Equals(object? obj) => (obj is AttachmentDescription o) && (this == o);
	readonly bool IEquatable<AttachmentDescription>.Equals(AttachmentDescription obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Flags.GetHashCode() ^ Format.GetHashCode() ^ Samples.GetHashCode() ^ LoadOp.GetHashCode()
			^ StoreOp.GetHashCode() ^ StencilLoadOp.GetHashCode() ^ StencilStoreOp.GetHashCode() ^ InitialLayout.GetHashCode()
			^ FinalLayout.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in AttachmentDescription l, in AttachmentDescription r)
	{
		return
			(l.Flags == r.Flags) && (l.Format == r.Format) && (l.Samples == r.Samples) && (l.LoadOp == r.LoadOp)
			&& (l.StoreOp == r.StoreOp) && (l.StencilLoadOp == r.StencilLoadOp) && (l.StencilStoreOp == r.StencilStoreOp) && (l.InitialLayout == r.InitialLayout)
			&& (l.FinalLayout == r.FinalLayout)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in AttachmentDescription l, in AttachmentDescription r)
	{
		return
			(l.Flags != r.Flags) || (l.Format != r.Format) || (l.Samples != r.Samples) || (l.LoadOp != r.LoadOp)
			|| (l.StoreOp != r.StoreOp) || (l.StencilLoadOp != r.StencilLoadOp) || (l.StencilStoreOp != r.StencilStoreOp) || (l.InitialLayout != r.InitialLayout)
			|| (l.FinalLayout != r.FinalLayout)
			;
	}


	/// <summary>Creates a new AttachmentDescription value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out AttachmentDescription value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct AttachmentReference : IEquatable<AttachmentReference>
{
	public uint Attachment;
	public Vk.ImageLayout Layout;
	public AttachmentReference(
		uint attachment = default,
		in Vk.ImageLayout layout = default
	) {
		Attachment = attachment;
		Layout = layout;
	}


	public readonly override bool Equals(object? obj) => (obj is AttachmentReference o) && (this == o);
	readonly bool IEquatable<AttachmentReference>.Equals(AttachmentReference obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Attachment.GetHashCode() ^ Layout.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in AttachmentReference l, in AttachmentReference r)
	{
		return
			(l.Attachment == r.Attachment) && (l.Layout == r.Layout)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in AttachmentReference l, in AttachmentReference r)
	{
		return
			(l.Attachment != r.Attachment) || (l.Layout != r.Layout)
			;
	}


	/// <summary>Creates a new AttachmentReference value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out AttachmentReference value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SubpassDescription : IEquatable<SubpassDescription>
{
	public Vk.SubpassDescriptionFlags Flags;
	public Vk.PipelineBindPoint PipelineBindPoint;
	public uint InputAttachmentCount;
	public Vk.AttachmentReference* InputAttachments;
	public uint ColorAttachmentCount;
	public Vk.AttachmentReference* ColorAttachments;
	public Vk.AttachmentReference* ResolveAttachments;
	public Vk.AttachmentReference* DepthStencilAttachment;
	public uint PreserveAttachmentCount;
	public uint* PreserveAttachments;
	public SubpassDescription(
		in Vk.SubpassDescriptionFlags flags = default,
		in Vk.PipelineBindPoint pipelineBindPoint = default,
		uint inputAttachmentCount = default,
		in Vk.AttachmentReference* inputAttachments = default,
		uint colorAttachmentCount = default,
		in Vk.AttachmentReference* colorAttachments = default,
		in Vk.AttachmentReference* resolveAttachments = default,
		in Vk.AttachmentReference* depthStencilAttachment = default,
		uint preserveAttachmentCount = default,
		uint* preserveAttachments = default
	) {
		Flags = flags;
		PipelineBindPoint = pipelineBindPoint;
		InputAttachmentCount = inputAttachmentCount;
		InputAttachments = inputAttachments;
		ColorAttachmentCount = colorAttachmentCount;
		ColorAttachments = colorAttachments;
		ResolveAttachments = resolveAttachments;
		DepthStencilAttachment = depthStencilAttachment;
		PreserveAttachmentCount = preserveAttachmentCount;
		PreserveAttachments = preserveAttachments;
	}


	public readonly override bool Equals(object? obj) => (obj is SubpassDescription o) && (this == o);
	readonly bool IEquatable<SubpassDescription>.Equals(SubpassDescription obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Flags.GetHashCode() ^ PipelineBindPoint.GetHashCode() ^ InputAttachmentCount.GetHashCode() ^ ((ulong)InputAttachments).GetHashCode()
			^ ColorAttachmentCount.GetHashCode() ^ ((ulong)ColorAttachments).GetHashCode() ^ ((ulong)ResolveAttachments).GetHashCode() ^ ((ulong)DepthStencilAttachment).GetHashCode()
			^ PreserveAttachmentCount.GetHashCode() ^ ((ulong)PreserveAttachments).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SubpassDescription l, in SubpassDescription r)
	{
		return
			(l.Flags == r.Flags) && (l.PipelineBindPoint == r.PipelineBindPoint) && (l.InputAttachmentCount == r.InputAttachmentCount) && (l.InputAttachments == r.InputAttachments)
			&& (l.ColorAttachmentCount == r.ColorAttachmentCount) && (l.ColorAttachments == r.ColorAttachments) && (l.ResolveAttachments == r.ResolveAttachments) && (l.DepthStencilAttachment == r.DepthStencilAttachment)
			&& (l.PreserveAttachmentCount == r.PreserveAttachmentCount) && (l.PreserveAttachments == r.PreserveAttachments)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SubpassDescription l, in SubpassDescription r)
	{
		return
			(l.Flags != r.Flags) || (l.PipelineBindPoint != r.PipelineBindPoint) || (l.InputAttachmentCount != r.InputAttachmentCount) || (l.InputAttachments != r.InputAttachments)
			|| (l.ColorAttachmentCount != r.ColorAttachmentCount) || (l.ColorAttachments != r.ColorAttachments) || (l.ResolveAttachments != r.ResolveAttachments) || (l.DepthStencilAttachment != r.DepthStencilAttachment)
			|| (l.PreserveAttachmentCount != r.PreserveAttachmentCount) || (l.PreserveAttachments != r.PreserveAttachments)
			;
	}


	/// <summary>Creates a new SubpassDescription value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SubpassDescription value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SubpassDependency : IEquatable<SubpassDependency>
{
	public uint SrcSubpass;
	public uint DstSubpass;
	public Vk.PipelineStageFlags SrcStageMask;
	public Vk.PipelineStageFlags DstStageMask;
	public Vk.AccessFlags SrcAccessMask;
	public Vk.AccessFlags DstAccessMask;
	public Vk.DependencyFlags DependencyFlags;
	public SubpassDependency(
		uint srcSubpass = default,
		uint dstSubpass = default,
		in Vk.PipelineStageFlags srcStageMask = default,
		in Vk.PipelineStageFlags dstStageMask = default,
		in Vk.AccessFlags srcAccessMask = default,
		in Vk.AccessFlags dstAccessMask = default,
		in Vk.DependencyFlags dependencyFlags = default
	) {
		SrcSubpass = srcSubpass;
		DstSubpass = dstSubpass;
		SrcStageMask = srcStageMask;
		DstStageMask = dstStageMask;
		SrcAccessMask = srcAccessMask;
		DstAccessMask = dstAccessMask;
		DependencyFlags = dependencyFlags;
	}


	public readonly override bool Equals(object? obj) => (obj is SubpassDependency o) && (this == o);
	readonly bool IEquatable<SubpassDependency>.Equals(SubpassDependency obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			SrcSubpass.GetHashCode() ^ DstSubpass.GetHashCode() ^ SrcStageMask.GetHashCode() ^ DstStageMask.GetHashCode()
			^ SrcAccessMask.GetHashCode() ^ DstAccessMask.GetHashCode() ^ DependencyFlags.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SubpassDependency l, in SubpassDependency r)
	{
		return
			(l.SrcSubpass == r.SrcSubpass) && (l.DstSubpass == r.DstSubpass) && (l.SrcStageMask == r.SrcStageMask) && (l.DstStageMask == r.DstStageMask)
			&& (l.SrcAccessMask == r.SrcAccessMask) && (l.DstAccessMask == r.DstAccessMask) && (l.DependencyFlags == r.DependencyFlags)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SubpassDependency l, in SubpassDependency r)
	{
		return
			(l.SrcSubpass != r.SrcSubpass) || (l.DstSubpass != r.DstSubpass) || (l.SrcStageMask != r.SrcStageMask) || (l.DstStageMask != r.DstStageMask)
			|| (l.SrcAccessMask != r.SrcAccessMask) || (l.DstAccessMask != r.DstAccessMask) || (l.DependencyFlags != r.DependencyFlags)
			;
	}


	/// <summary>Creates a new SubpassDependency value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SubpassDependency value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct RenderPassCreateInfo : IEquatable<RenderPassCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.RenderPassCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.RenderPassCreateFlags Flags;
	public uint AttachmentCount;
	public Vk.AttachmentDescription* Attachments;
	public uint SubpassCount;
	public Vk.SubpassDescription* Subpasses;
	public uint DependencyCount;
	public Vk.SubpassDependency* Dependencies;
	public RenderPassCreateInfo(
		in Vk.RenderPassCreateFlags flags = default,
		uint attachmentCount = default,
		in Vk.AttachmentDescription* attachments = default,
		uint subpassCount = default,
		in Vk.SubpassDescription* subpasses = default,
		uint dependencyCount = default,
		in Vk.SubpassDependency* dependencies = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		AttachmentCount = attachmentCount;
		Attachments = attachments;
		SubpassCount = subpassCount;
		Subpasses = subpasses;
		DependencyCount = dependencyCount;
		Dependencies = dependencies;
	}


	public readonly override bool Equals(object? obj) => (obj is RenderPassCreateInfo o) && (this == o);
	readonly bool IEquatable<RenderPassCreateInfo>.Equals(RenderPassCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ AttachmentCount.GetHashCode()
			^ ((ulong)Attachments).GetHashCode() ^ SubpassCount.GetHashCode() ^ ((ulong)Subpasses).GetHashCode() ^ DependencyCount.GetHashCode()
			^ ((ulong)Dependencies).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in RenderPassCreateInfo l, in RenderPassCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.AttachmentCount == r.AttachmentCount)
			&& (l.Attachments == r.Attachments) && (l.SubpassCount == r.SubpassCount) && (l.Subpasses == r.Subpasses) && (l.DependencyCount == r.DependencyCount)
			&& (l.Dependencies == r.Dependencies)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in RenderPassCreateInfo l, in RenderPassCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.AttachmentCount != r.AttachmentCount)
			|| (l.Attachments != r.Attachments) || (l.SubpassCount != r.SubpassCount) || (l.Subpasses != r.Subpasses) || (l.DependencyCount != r.DependencyCount)
			|| (l.Dependencies != r.Dependencies)
			;
	}


	/// <summary>Creates a new RenderPassCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out RenderPassCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct EventCreateInfo : IEquatable<EventCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.EventCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.EventCreateFlags Flags;
	public EventCreateInfo(
		in Vk.EventCreateFlags flags = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
	}


	public readonly override bool Equals(object? obj) => (obj is EventCreateInfo o) && (this == o);
	readonly bool IEquatable<EventCreateInfo>.Equals(EventCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in EventCreateInfo l, in EventCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in EventCreateInfo l, in EventCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags)
			;
	}


	/// <summary>Creates a new EventCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out EventCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct FenceCreateInfo : IEquatable<FenceCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.FenceCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.FenceCreateFlags Flags;
	public FenceCreateInfo(
		in Vk.FenceCreateFlags flags = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
	}


	public readonly override bool Equals(object? obj) => (obj is FenceCreateInfo o) && (this == o);
	readonly bool IEquatable<FenceCreateInfo>.Equals(FenceCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in FenceCreateInfo l, in FenceCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in FenceCreateInfo l, in FenceCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags)
			;
	}


	/// <summary>Creates a new FenceCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out FenceCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceFeatures : IEquatable<PhysicalDeviceFeatures>
{
	public Vk.Bool32 RobustBufferAccess;
	public Vk.Bool32 FullDrawIndexUint32;
	public Vk.Bool32 ImageCubeArray;
	public Vk.Bool32 IndependentBlend;
	public Vk.Bool32 GeometryShader;
	public Vk.Bool32 TessellationShader;
	public Vk.Bool32 SampleRateShading;
	public Vk.Bool32 DualSrcBlend;
	public Vk.Bool32 LogicOp;
	public Vk.Bool32 MultiDrawIndirect;
	public Vk.Bool32 DrawIndirectFirstInstance;
	public Vk.Bool32 DepthClamp;
	public Vk.Bool32 DepthBiasClamp;
	public Vk.Bool32 FillModeNonSolid;
	public Vk.Bool32 DepthBounds;
	public Vk.Bool32 WideLines;
	public Vk.Bool32 LargePoints;
	public Vk.Bool32 AlphaToOne;
	public Vk.Bool32 MultiViewport;
	public Vk.Bool32 SamplerAnisotropy;
	public Vk.Bool32 TextureCompressionETC2;
	public Vk.Bool32 TextureCompressionASTC_LDR;
	public Vk.Bool32 TextureCompressionBC;
	public Vk.Bool32 OcclusionQueryPrecise;
	public Vk.Bool32 PipelineStatisticsQuery;
	public Vk.Bool32 VertexPipelineStoresAndAtomics;
	public Vk.Bool32 FragmentStoresAndAtomics;
	public Vk.Bool32 ShaderTessellationAndGeometryPointSize;
	public Vk.Bool32 ShaderImageGatherExtended;
	public Vk.Bool32 ShaderStorageImageExtendedFormats;
	public Vk.Bool32 ShaderStorageImageMultisample;
	public Vk.Bool32 ShaderStorageImageReadWithoutFormat;
	public Vk.Bool32 ShaderStorageImageWriteWithoutFormat;
	public Vk.Bool32 ShaderUniformBufferArrayDynamicIndexing;
	public Vk.Bool32 ShaderSampledImageArrayDynamicIndexing;
	public Vk.Bool32 ShaderStorageBufferArrayDynamicIndexing;
	public Vk.Bool32 ShaderStorageImageArrayDynamicIndexing;
	public Vk.Bool32 ShaderClipDistance;
	public Vk.Bool32 ShaderCullDistance;
	public Vk.Bool32 ShaderFloat64;
	public Vk.Bool32 ShaderInt64;
	public Vk.Bool32 ShaderInt16;
	public Vk.Bool32 ShaderResourceResidency;
	public Vk.Bool32 ShaderResourceMinLod;
	public Vk.Bool32 SparseBinding;
	public Vk.Bool32 SparseResidencyBuffer;
	public Vk.Bool32 SparseResidencyImage2D;
	public Vk.Bool32 SparseResidencyImage3D;
	public Vk.Bool32 SparseResidency2Samples;
	public Vk.Bool32 SparseResidency4Samples;
	public Vk.Bool32 SparseResidency8Samples;
	public Vk.Bool32 SparseResidency16Samples;
	public Vk.Bool32 SparseResidencyAliased;
	public Vk.Bool32 VariableMultisampleRate;
	public Vk.Bool32 InheritedQueries;
	public PhysicalDeviceFeatures(
		in Vk.Bool32 robustBufferAccess = default,
		in Vk.Bool32 fullDrawIndexUint32 = default,
		in Vk.Bool32 imageCubeArray = default,
		in Vk.Bool32 independentBlend = default,
		in Vk.Bool32 geometryShader = default,
		in Vk.Bool32 tessellationShader = default,
		in Vk.Bool32 sampleRateShading = default,
		in Vk.Bool32 dualSrcBlend = default,
		in Vk.Bool32 logicOp = default,
		in Vk.Bool32 multiDrawIndirect = default,
		in Vk.Bool32 drawIndirectFirstInstance = default,
		in Vk.Bool32 depthClamp = default,
		in Vk.Bool32 depthBiasClamp = default,
		in Vk.Bool32 fillModeNonSolid = default,
		in Vk.Bool32 depthBounds = default,
		in Vk.Bool32 wideLines = default,
		in Vk.Bool32 largePoints = default,
		in Vk.Bool32 alphaToOne = default,
		in Vk.Bool32 multiViewport = default,
		in Vk.Bool32 samplerAnisotropy = default,
		in Vk.Bool32 textureCompressionETC2 = default,
		in Vk.Bool32 textureCompressionASTC_LDR = default,
		in Vk.Bool32 textureCompressionBC = default,
		in Vk.Bool32 occlusionQueryPrecise = default,
		in Vk.Bool32 pipelineStatisticsQuery = default,
		in Vk.Bool32 vertexPipelineStoresAndAtomics = default,
		in Vk.Bool32 fragmentStoresAndAtomics = default,
		in Vk.Bool32 shaderTessellationAndGeometryPointSize = default,
		in Vk.Bool32 shaderImageGatherExtended = default,
		in Vk.Bool32 shaderStorageImageExtendedFormats = default,
		in Vk.Bool32 shaderStorageImageMultisample = default,
		in Vk.Bool32 shaderStorageImageReadWithoutFormat = default,
		in Vk.Bool32 shaderStorageImageWriteWithoutFormat = default,
		in Vk.Bool32 shaderUniformBufferArrayDynamicIndexing = default,
		in Vk.Bool32 shaderSampledImageArrayDynamicIndexing = default,
		in Vk.Bool32 shaderStorageBufferArrayDynamicIndexing = default,
		in Vk.Bool32 shaderStorageImageArrayDynamicIndexing = default,
		in Vk.Bool32 shaderClipDistance = default,
		in Vk.Bool32 shaderCullDistance = default,
		in Vk.Bool32 shaderFloat64 = default,
		in Vk.Bool32 shaderInt64 = default,
		in Vk.Bool32 shaderInt16 = default,
		in Vk.Bool32 shaderResourceResidency = default,
		in Vk.Bool32 shaderResourceMinLod = default,
		in Vk.Bool32 sparseBinding = default,
		in Vk.Bool32 sparseResidencyBuffer = default,
		in Vk.Bool32 sparseResidencyImage2D = default,
		in Vk.Bool32 sparseResidencyImage3D = default,
		in Vk.Bool32 sparseResidency2Samples = default,
		in Vk.Bool32 sparseResidency4Samples = default,
		in Vk.Bool32 sparseResidency8Samples = default,
		in Vk.Bool32 sparseResidency16Samples = default,
		in Vk.Bool32 sparseResidencyAliased = default,
		in Vk.Bool32 variableMultisampleRate = default,
		in Vk.Bool32 inheritedQueries = default
	) {
		RobustBufferAccess = robustBufferAccess;
		FullDrawIndexUint32 = fullDrawIndexUint32;
		ImageCubeArray = imageCubeArray;
		IndependentBlend = independentBlend;
		GeometryShader = geometryShader;
		TessellationShader = tessellationShader;
		SampleRateShading = sampleRateShading;
		DualSrcBlend = dualSrcBlend;
		LogicOp = logicOp;
		MultiDrawIndirect = multiDrawIndirect;
		DrawIndirectFirstInstance = drawIndirectFirstInstance;
		DepthClamp = depthClamp;
		DepthBiasClamp = depthBiasClamp;
		FillModeNonSolid = fillModeNonSolid;
		DepthBounds = depthBounds;
		WideLines = wideLines;
		LargePoints = largePoints;
		AlphaToOne = alphaToOne;
		MultiViewport = multiViewport;
		SamplerAnisotropy = samplerAnisotropy;
		TextureCompressionETC2 = textureCompressionETC2;
		TextureCompressionASTC_LDR = textureCompressionASTC_LDR;
		TextureCompressionBC = textureCompressionBC;
		OcclusionQueryPrecise = occlusionQueryPrecise;
		PipelineStatisticsQuery = pipelineStatisticsQuery;
		VertexPipelineStoresAndAtomics = vertexPipelineStoresAndAtomics;
		FragmentStoresAndAtomics = fragmentStoresAndAtomics;
		ShaderTessellationAndGeometryPointSize = shaderTessellationAndGeometryPointSize;
		ShaderImageGatherExtended = shaderImageGatherExtended;
		ShaderStorageImageExtendedFormats = shaderStorageImageExtendedFormats;
		ShaderStorageImageMultisample = shaderStorageImageMultisample;
		ShaderStorageImageReadWithoutFormat = shaderStorageImageReadWithoutFormat;
		ShaderStorageImageWriteWithoutFormat = shaderStorageImageWriteWithoutFormat;
		ShaderUniformBufferArrayDynamicIndexing = shaderUniformBufferArrayDynamicIndexing;
		ShaderSampledImageArrayDynamicIndexing = shaderSampledImageArrayDynamicIndexing;
		ShaderStorageBufferArrayDynamicIndexing = shaderStorageBufferArrayDynamicIndexing;
		ShaderStorageImageArrayDynamicIndexing = shaderStorageImageArrayDynamicIndexing;
		ShaderClipDistance = shaderClipDistance;
		ShaderCullDistance = shaderCullDistance;
		ShaderFloat64 = shaderFloat64;
		ShaderInt64 = shaderInt64;
		ShaderInt16 = shaderInt16;
		ShaderResourceResidency = shaderResourceResidency;
		ShaderResourceMinLod = shaderResourceMinLod;
		SparseBinding = sparseBinding;
		SparseResidencyBuffer = sparseResidencyBuffer;
		SparseResidencyImage2D = sparseResidencyImage2D;
		SparseResidencyImage3D = sparseResidencyImage3D;
		SparseResidency2Samples = sparseResidency2Samples;
		SparseResidency4Samples = sparseResidency4Samples;
		SparseResidency8Samples = sparseResidency8Samples;
		SparseResidency16Samples = sparseResidency16Samples;
		SparseResidencyAliased = sparseResidencyAliased;
		VariableMultisampleRate = variableMultisampleRate;
		InheritedQueries = inheritedQueries;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceFeatures>.Equals(PhysicalDeviceFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			RobustBufferAccess.GetHashCode() ^ FullDrawIndexUint32.GetHashCode() ^ ImageCubeArray.GetHashCode() ^ IndependentBlend.GetHashCode()
			^ GeometryShader.GetHashCode() ^ TessellationShader.GetHashCode() ^ SampleRateShading.GetHashCode() ^ DualSrcBlend.GetHashCode()
			^ LogicOp.GetHashCode() ^ MultiDrawIndirect.GetHashCode() ^ DrawIndirectFirstInstance.GetHashCode() ^ DepthClamp.GetHashCode()
			^ DepthBiasClamp.GetHashCode() ^ FillModeNonSolid.GetHashCode() ^ DepthBounds.GetHashCode() ^ WideLines.GetHashCode()
			^ LargePoints.GetHashCode() ^ AlphaToOne.GetHashCode() ^ MultiViewport.GetHashCode() ^ SamplerAnisotropy.GetHashCode()
			^ TextureCompressionETC2.GetHashCode() ^ TextureCompressionASTC_LDR.GetHashCode() ^ TextureCompressionBC.GetHashCode() ^ OcclusionQueryPrecise.GetHashCode()
			^ PipelineStatisticsQuery.GetHashCode() ^ VertexPipelineStoresAndAtomics.GetHashCode() ^ FragmentStoresAndAtomics.GetHashCode() ^ ShaderTessellationAndGeometryPointSize.GetHashCode()
			^ ShaderImageGatherExtended.GetHashCode() ^ ShaderStorageImageExtendedFormats.GetHashCode() ^ ShaderStorageImageMultisample.GetHashCode() ^ ShaderStorageImageReadWithoutFormat.GetHashCode()
			^ ShaderStorageImageWriteWithoutFormat.GetHashCode() ^ ShaderUniformBufferArrayDynamicIndexing.GetHashCode() ^ ShaderSampledImageArrayDynamicIndexing.GetHashCode() ^ ShaderStorageBufferArrayDynamicIndexing.GetHashCode()
			^ ShaderStorageImageArrayDynamicIndexing.GetHashCode() ^ ShaderClipDistance.GetHashCode() ^ ShaderCullDistance.GetHashCode() ^ ShaderFloat64.GetHashCode()
			^ ShaderInt64.GetHashCode() ^ ShaderInt16.GetHashCode() ^ ShaderResourceResidency.GetHashCode() ^ ShaderResourceMinLod.GetHashCode()
			^ SparseBinding.GetHashCode() ^ SparseResidencyBuffer.GetHashCode() ^ SparseResidencyImage2D.GetHashCode() ^ SparseResidencyImage3D.GetHashCode()
			^ SparseResidency2Samples.GetHashCode() ^ SparseResidency4Samples.GetHashCode() ^ SparseResidency8Samples.GetHashCode() ^ SparseResidency16Samples.GetHashCode()
			^ SparseResidencyAliased.GetHashCode() ^ VariableMultisampleRate.GetHashCode() ^ InheritedQueries.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceFeatures l, in PhysicalDeviceFeatures r)
	{
		return
			(l.RobustBufferAccess == r.RobustBufferAccess) && (l.FullDrawIndexUint32 == r.FullDrawIndexUint32) && (l.ImageCubeArray == r.ImageCubeArray) && (l.IndependentBlend == r.IndependentBlend)
			&& (l.GeometryShader == r.GeometryShader) && (l.TessellationShader == r.TessellationShader) && (l.SampleRateShading == r.SampleRateShading) && (l.DualSrcBlend == r.DualSrcBlend)
			&& (l.LogicOp == r.LogicOp) && (l.MultiDrawIndirect == r.MultiDrawIndirect) && (l.DrawIndirectFirstInstance == r.DrawIndirectFirstInstance) && (l.DepthClamp == r.DepthClamp)
			&& (l.DepthBiasClamp == r.DepthBiasClamp) && (l.FillModeNonSolid == r.FillModeNonSolid) && (l.DepthBounds == r.DepthBounds) && (l.WideLines == r.WideLines)
			&& (l.LargePoints == r.LargePoints) && (l.AlphaToOne == r.AlphaToOne) && (l.MultiViewport == r.MultiViewport) && (l.SamplerAnisotropy == r.SamplerAnisotropy)
			&& (l.TextureCompressionETC2 == r.TextureCompressionETC2) && (l.TextureCompressionASTC_LDR == r.TextureCompressionASTC_LDR) && (l.TextureCompressionBC == r.TextureCompressionBC) && (l.OcclusionQueryPrecise == r.OcclusionQueryPrecise)
			&& (l.PipelineStatisticsQuery == r.PipelineStatisticsQuery) && (l.VertexPipelineStoresAndAtomics == r.VertexPipelineStoresAndAtomics) && (l.FragmentStoresAndAtomics == r.FragmentStoresAndAtomics) && (l.ShaderTessellationAndGeometryPointSize == r.ShaderTessellationAndGeometryPointSize)
			&& (l.ShaderImageGatherExtended == r.ShaderImageGatherExtended) && (l.ShaderStorageImageExtendedFormats == r.ShaderStorageImageExtendedFormats) && (l.ShaderStorageImageMultisample == r.ShaderStorageImageMultisample) && (l.ShaderStorageImageReadWithoutFormat == r.ShaderStorageImageReadWithoutFormat)
			&& (l.ShaderStorageImageWriteWithoutFormat == r.ShaderStorageImageWriteWithoutFormat) && (l.ShaderUniformBufferArrayDynamicIndexing == r.ShaderUniformBufferArrayDynamicIndexing) && (l.ShaderSampledImageArrayDynamicIndexing == r.ShaderSampledImageArrayDynamicIndexing) && (l.ShaderStorageBufferArrayDynamicIndexing == r.ShaderStorageBufferArrayDynamicIndexing)
			&& (l.ShaderStorageImageArrayDynamicIndexing == r.ShaderStorageImageArrayDynamicIndexing) && (l.ShaderClipDistance == r.ShaderClipDistance) && (l.ShaderCullDistance == r.ShaderCullDistance) && (l.ShaderFloat64 == r.ShaderFloat64)
			&& (l.ShaderInt64 == r.ShaderInt64) && (l.ShaderInt16 == r.ShaderInt16) && (l.ShaderResourceResidency == r.ShaderResourceResidency) && (l.ShaderResourceMinLod == r.ShaderResourceMinLod)
			&& (l.SparseBinding == r.SparseBinding) && (l.SparseResidencyBuffer == r.SparseResidencyBuffer) && (l.SparseResidencyImage2D == r.SparseResidencyImage2D) && (l.SparseResidencyImage3D == r.SparseResidencyImage3D)
			&& (l.SparseResidency2Samples == r.SparseResidency2Samples) && (l.SparseResidency4Samples == r.SparseResidency4Samples) && (l.SparseResidency8Samples == r.SparseResidency8Samples) && (l.SparseResidency16Samples == r.SparseResidency16Samples)
			&& (l.SparseResidencyAliased == r.SparseResidencyAliased) && (l.VariableMultisampleRate == r.VariableMultisampleRate) && (l.InheritedQueries == r.InheritedQueries)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceFeatures l, in PhysicalDeviceFeatures r)
	{
		return
			(l.RobustBufferAccess != r.RobustBufferAccess) || (l.FullDrawIndexUint32 != r.FullDrawIndexUint32) || (l.ImageCubeArray != r.ImageCubeArray) || (l.IndependentBlend != r.IndependentBlend)
			|| (l.GeometryShader != r.GeometryShader) || (l.TessellationShader != r.TessellationShader) || (l.SampleRateShading != r.SampleRateShading) || (l.DualSrcBlend != r.DualSrcBlend)
			|| (l.LogicOp != r.LogicOp) || (l.MultiDrawIndirect != r.MultiDrawIndirect) || (l.DrawIndirectFirstInstance != r.DrawIndirectFirstInstance) || (l.DepthClamp != r.DepthClamp)
			|| (l.DepthBiasClamp != r.DepthBiasClamp) || (l.FillModeNonSolid != r.FillModeNonSolid) || (l.DepthBounds != r.DepthBounds) || (l.WideLines != r.WideLines)
			|| (l.LargePoints != r.LargePoints) || (l.AlphaToOne != r.AlphaToOne) || (l.MultiViewport != r.MultiViewport) || (l.SamplerAnisotropy != r.SamplerAnisotropy)
			|| (l.TextureCompressionETC2 != r.TextureCompressionETC2) || (l.TextureCompressionASTC_LDR != r.TextureCompressionASTC_LDR) || (l.TextureCompressionBC != r.TextureCompressionBC) || (l.OcclusionQueryPrecise != r.OcclusionQueryPrecise)
			|| (l.PipelineStatisticsQuery != r.PipelineStatisticsQuery) || (l.VertexPipelineStoresAndAtomics != r.VertexPipelineStoresAndAtomics) || (l.FragmentStoresAndAtomics != r.FragmentStoresAndAtomics) || (l.ShaderTessellationAndGeometryPointSize != r.ShaderTessellationAndGeometryPointSize)
			|| (l.ShaderImageGatherExtended != r.ShaderImageGatherExtended) || (l.ShaderStorageImageExtendedFormats != r.ShaderStorageImageExtendedFormats) || (l.ShaderStorageImageMultisample != r.ShaderStorageImageMultisample) || (l.ShaderStorageImageReadWithoutFormat != r.ShaderStorageImageReadWithoutFormat)
			|| (l.ShaderStorageImageWriteWithoutFormat != r.ShaderStorageImageWriteWithoutFormat) || (l.ShaderUniformBufferArrayDynamicIndexing != r.ShaderUniformBufferArrayDynamicIndexing) || (l.ShaderSampledImageArrayDynamicIndexing != r.ShaderSampledImageArrayDynamicIndexing) || (l.ShaderStorageBufferArrayDynamicIndexing != r.ShaderStorageBufferArrayDynamicIndexing)
			|| (l.ShaderStorageImageArrayDynamicIndexing != r.ShaderStorageImageArrayDynamicIndexing) || (l.ShaderClipDistance != r.ShaderClipDistance) || (l.ShaderCullDistance != r.ShaderCullDistance) || (l.ShaderFloat64 != r.ShaderFloat64)
			|| (l.ShaderInt64 != r.ShaderInt64) || (l.ShaderInt16 != r.ShaderInt16) || (l.ShaderResourceResidency != r.ShaderResourceResidency) || (l.ShaderResourceMinLod != r.ShaderResourceMinLod)
			|| (l.SparseBinding != r.SparseBinding) || (l.SparseResidencyBuffer != r.SparseResidencyBuffer) || (l.SparseResidencyImage2D != r.SparseResidencyImage2D) || (l.SparseResidencyImage3D != r.SparseResidencyImage3D)
			|| (l.SparseResidency2Samples != r.SparseResidency2Samples) || (l.SparseResidency4Samples != r.SparseResidency4Samples) || (l.SparseResidency8Samples != r.SparseResidency8Samples) || (l.SparseResidency16Samples != r.SparseResidency16Samples)
			|| (l.SparseResidencyAliased != r.SparseResidencyAliased) || (l.VariableMultisampleRate != r.VariableMultisampleRate) || (l.InheritedQueries != r.InheritedQueries)
			;
	}


	/// <summary>Creates a new PhysicalDeviceFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceFeatures value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceSparseProperties : IEquatable<PhysicalDeviceSparseProperties>
{
	public Vk.Bool32 ResidencyStandard2DBlockShape;
	public Vk.Bool32 ResidencyStandard2DMultisampleBlockShape;
	public Vk.Bool32 ResidencyStandard3DBlockShape;
	public Vk.Bool32 ResidencyAlignedMipSize;
	public Vk.Bool32 ResidencyNonResidentStrict;
	public PhysicalDeviceSparseProperties(
		in Vk.Bool32 residencyStandard2DBlockShape = default,
		in Vk.Bool32 residencyStandard2DMultisampleBlockShape = default,
		in Vk.Bool32 residencyStandard3DBlockShape = default,
		in Vk.Bool32 residencyAlignedMipSize = default,
		in Vk.Bool32 residencyNonResidentStrict = default
	) {
		ResidencyStandard2DBlockShape = residencyStandard2DBlockShape;
		ResidencyStandard2DMultisampleBlockShape = residencyStandard2DMultisampleBlockShape;
		ResidencyStandard3DBlockShape = residencyStandard3DBlockShape;
		ResidencyAlignedMipSize = residencyAlignedMipSize;
		ResidencyNonResidentStrict = residencyNonResidentStrict;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceSparseProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceSparseProperties>.Equals(PhysicalDeviceSparseProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			ResidencyStandard2DBlockShape.GetHashCode() ^ ResidencyStandard2DMultisampleBlockShape.GetHashCode() ^ ResidencyStandard3DBlockShape.GetHashCode() ^ ResidencyAlignedMipSize.GetHashCode()
			^ ResidencyNonResidentStrict.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceSparseProperties l, in PhysicalDeviceSparseProperties r)
	{
		return
			(l.ResidencyStandard2DBlockShape == r.ResidencyStandard2DBlockShape) && (l.ResidencyStandard2DMultisampleBlockShape == r.ResidencyStandard2DMultisampleBlockShape) && (l.ResidencyStandard3DBlockShape == r.ResidencyStandard3DBlockShape) && (l.ResidencyAlignedMipSize == r.ResidencyAlignedMipSize)
			&& (l.ResidencyNonResidentStrict == r.ResidencyNonResidentStrict)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceSparseProperties l, in PhysicalDeviceSparseProperties r)
	{
		return
			(l.ResidencyStandard2DBlockShape != r.ResidencyStandard2DBlockShape) || (l.ResidencyStandard2DMultisampleBlockShape != r.ResidencyStandard2DMultisampleBlockShape) || (l.ResidencyStandard3DBlockShape != r.ResidencyStandard3DBlockShape) || (l.ResidencyAlignedMipSize != r.ResidencyAlignedMipSize)
			|| (l.ResidencyNonResidentStrict != r.ResidencyNonResidentStrict)
			;
	}


	/// <summary>Creates a new PhysicalDeviceSparseProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceSparseProperties value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceLimits : IEquatable<PhysicalDeviceLimits>
{
	public uint MaxImageDimension1D;
	public uint MaxImageDimension2D;
	public uint MaxImageDimension3D;
	public uint MaxImageDimensionCube;
	public uint MaxImageArrayLayers;
	public uint MaxTexelBufferElements;
	public uint MaxUniformBufferRange;
	public uint MaxStorageBufferRange;
	public uint MaxPushConstantsSize;
	public uint MaxMemoryAllocationCount;
	public uint MaxSamplerAllocationCount;
	public Vk.DeviceSize BufferImageGranularity;
	public Vk.DeviceSize SparseAddressSpaceSize;
	public uint MaxBoundDescriptorSets;
	public uint MaxPerStageDescriptorSamplers;
	public uint MaxPerStageDescriptorUniformBuffers;
	public uint MaxPerStageDescriptorStorageBuffers;
	public uint MaxPerStageDescriptorSampledImages;
	public uint MaxPerStageDescriptorStorageImages;
	public uint MaxPerStageDescriptorInputAttachments;
	public uint MaxPerStageResources;
	public uint MaxDescriptorSetSamplers;
	public uint MaxDescriptorSetUniformBuffers;
	public uint MaxDescriptorSetUniformBuffersDynamic;
	public uint MaxDescriptorSetStorageBuffers;
	public uint MaxDescriptorSetStorageBuffersDynamic;
	public uint MaxDescriptorSetSampledImages;
	public uint MaxDescriptorSetStorageImages;
	public uint MaxDescriptorSetInputAttachments;
	public uint MaxVertexInputAttributes;
	public uint MaxVertexInputBindings;
	public uint MaxVertexInputAttributeOffset;
	public uint MaxVertexInputBindingStride;
	public uint MaxVertexOutputComponents;
	public uint MaxTessellationGenerationLevel;
	public uint MaxTessellationPatchSize;
	public uint MaxTessellationControlPerVertexInputComponents;
	public uint MaxTessellationControlPerVertexOutputComponents;
	public uint MaxTessellationControlPerPatchOutputComponents;
	public uint MaxTessellationControlTotalOutputComponents;
	public uint MaxTessellationEvaluationInputComponents;
	public uint MaxTessellationEvaluationOutputComponents;
	public uint MaxGeometryShaderInvocations;
	public uint MaxGeometryInputComponents;
	public uint MaxGeometryOutputComponents;
	public uint MaxGeometryOutputVertices;
	public uint MaxGeometryTotalOutputComponents;
	public uint MaxFragmentInputComponents;
	public uint MaxFragmentOutputAttachments;
	public uint MaxFragmentDualSrcAttachments;
	public uint MaxFragmentCombinedOutputResources;
	public uint MaxComputeSharedMemorySize;
	public fixed uint MaxComputeWorkGroupCount[3];
	public uint MaxComputeWorkGroupInvocations;
	public fixed uint MaxComputeWorkGroupSize[3];
	public uint SubPixelPrecisionBits;
	public uint SubTexelPrecisionBits;
	public uint MipmapPrecisionBits;
	public uint MaxDrawIndexedIndexValue;
	public uint MaxDrawIndirectCount;
	public float MaxSamplerLodBias;
	public float MaxSamplerAnisotropy;
	public uint MaxViewports;
	public fixed uint MaxViewportDimensions[2];
	public fixed float ViewportBoundsRange[2];
	public uint ViewportSubPixelBits;
	public ulong MinMemoryMapAlignment;
	public Vk.DeviceSize MinTexelBufferOffsetAlignment;
	public Vk.DeviceSize MinUniformBufferOffsetAlignment;
	public Vk.DeviceSize MinStorageBufferOffsetAlignment;
	public int MinTexelOffset;
	public uint MaxTexelOffset;
	public int MinTexelGatherOffset;
	public uint MaxTexelGatherOffset;
	public float MinInterpolationOffset;
	public float MaxInterpolationOffset;
	public uint SubPixelInterpolationOffsetBits;
	public uint MaxFramebufferWidth;
	public uint MaxFramebufferHeight;
	public uint MaxFramebufferLayers;
	public Vk.SampleCountFlags FramebufferColorSampleCounts;
	public Vk.SampleCountFlags FramebufferDepthSampleCounts;
	public Vk.SampleCountFlags FramebufferStencilSampleCounts;
	public Vk.SampleCountFlags FramebufferNoAttachmentsSampleCounts;
	public uint MaxColorAttachments;
	public Vk.SampleCountFlags SampledImageColorSampleCounts;
	public Vk.SampleCountFlags SampledImageIntegerSampleCounts;
	public Vk.SampleCountFlags SampledImageDepthSampleCounts;
	public Vk.SampleCountFlags SampledImageStencilSampleCounts;
	public Vk.SampleCountFlags StorageImageSampleCounts;
	public uint MaxSampleMaskWords;
	public Vk.Bool32 TimestampComputeAndGraphics;
	public float TimestampPeriod;
	public uint MaxClipDistances;
	public uint MaxCullDistances;
	public uint MaxCombinedClipAndCullDistances;
	public uint DiscreteQueuePriorities;
	public fixed float PointSizeRange[2];
	public fixed float LineWidthRange[2];
	public float PointSizeGranularity;
	public float LineWidthGranularity;
	public Vk.Bool32 StrictLines;
	public Vk.Bool32 StandardSampleLocations;
	public Vk.DeviceSize OptimalBufferCopyOffsetAlignment;
	public Vk.DeviceSize OptimalBufferCopyRowPitchAlignment;
	public Vk.DeviceSize NonCoherentAtomSize;
	public PhysicalDeviceLimits(
		uint maxImageDimension1D = default,
		uint maxImageDimension2D = default,
		uint maxImageDimension3D = default,
		uint maxImageDimensionCube = default,
		uint maxImageArrayLayers = default,
		uint maxTexelBufferElements = default,
		uint maxUniformBufferRange = default,
		uint maxStorageBufferRange = default,
		uint maxPushConstantsSize = default,
		uint maxMemoryAllocationCount = default,
		uint maxSamplerAllocationCount = default,
		in Vk.DeviceSize bufferImageGranularity = default,
		in Vk.DeviceSize sparseAddressSpaceSize = default,
		uint maxBoundDescriptorSets = default,
		uint maxPerStageDescriptorSamplers = default,
		uint maxPerStageDescriptorUniformBuffers = default,
		uint maxPerStageDescriptorStorageBuffers = default,
		uint maxPerStageDescriptorSampledImages = default,
		uint maxPerStageDescriptorStorageImages = default,
		uint maxPerStageDescriptorInputAttachments = default,
		uint maxPerStageResources = default,
		uint maxDescriptorSetSamplers = default,
		uint maxDescriptorSetUniformBuffers = default,
		uint maxDescriptorSetUniformBuffersDynamic = default,
		uint maxDescriptorSetStorageBuffers = default,
		uint maxDescriptorSetStorageBuffersDynamic = default,
		uint maxDescriptorSetSampledImages = default,
		uint maxDescriptorSetStorageImages = default,
		uint maxDescriptorSetInputAttachments = default,
		uint maxVertexInputAttributes = default,
		uint maxVertexInputBindings = default,
		uint maxVertexInputAttributeOffset = default,
		uint maxVertexInputBindingStride = default,
		uint maxVertexOutputComponents = default,
		uint maxTessellationGenerationLevel = default,
		uint maxTessellationPatchSize = default,
		uint maxTessellationControlPerVertexInputComponents = default,
		uint maxTessellationControlPerVertexOutputComponents = default,
		uint maxTessellationControlPerPatchOutputComponents = default,
		uint maxTessellationControlTotalOutputComponents = default,
		uint maxTessellationEvaluationInputComponents = default,
		uint maxTessellationEvaluationOutputComponents = default,
		uint maxGeometryShaderInvocations = default,
		uint maxGeometryInputComponents = default,
		uint maxGeometryOutputComponents = default,
		uint maxGeometryOutputVertices = default,
		uint maxGeometryTotalOutputComponents = default,
		uint maxFragmentInputComponents = default,
		uint maxFragmentOutputAttachments = default,
		uint maxFragmentDualSrcAttachments = default,
		uint maxFragmentCombinedOutputResources = default,
		uint maxComputeSharedMemorySize = default,
		uint maxComputeWorkGroupCount0 = default,
		uint maxComputeWorkGroupCount1 = default,
		uint maxComputeWorkGroupCount2 = default,
		uint maxComputeWorkGroupInvocations = default,
		uint maxComputeWorkGroupSize0 = default,
		uint maxComputeWorkGroupSize1 = default,
		uint maxComputeWorkGroupSize2 = default,
		uint subPixelPrecisionBits = default,
		uint subTexelPrecisionBits = default,
		uint mipmapPrecisionBits = default,
		uint maxDrawIndexedIndexValue = default,
		uint maxDrawIndirectCount = default,
		float maxSamplerLodBias = default,
		float maxSamplerAnisotropy = default,
		uint maxViewports = default,
		uint maxViewportDimensions0 = default,
		uint maxViewportDimensions1 = default,
		float viewportBoundsRange0 = default,
		float viewportBoundsRange1 = default,
		uint viewportSubPixelBits = default,
		ulong minMemoryMapAlignment = default,
		in Vk.DeviceSize minTexelBufferOffsetAlignment = default,
		in Vk.DeviceSize minUniformBufferOffsetAlignment = default,
		in Vk.DeviceSize minStorageBufferOffsetAlignment = default,
		int minTexelOffset = default,
		uint maxTexelOffset = default,
		int minTexelGatherOffset = default,
		uint maxTexelGatherOffset = default,
		float minInterpolationOffset = default,
		float maxInterpolationOffset = default,
		uint subPixelInterpolationOffsetBits = default,
		uint maxFramebufferWidth = default,
		uint maxFramebufferHeight = default,
		uint maxFramebufferLayers = default,
		in Vk.SampleCountFlags framebufferColorSampleCounts = default,
		in Vk.SampleCountFlags framebufferDepthSampleCounts = default,
		in Vk.SampleCountFlags framebufferStencilSampleCounts = default,
		in Vk.SampleCountFlags framebufferNoAttachmentsSampleCounts = default,
		uint maxColorAttachments = default,
		in Vk.SampleCountFlags sampledImageColorSampleCounts = default,
		in Vk.SampleCountFlags sampledImageIntegerSampleCounts = default,
		in Vk.SampleCountFlags sampledImageDepthSampleCounts = default,
		in Vk.SampleCountFlags sampledImageStencilSampleCounts = default,
		in Vk.SampleCountFlags storageImageSampleCounts = default,
		uint maxSampleMaskWords = default,
		in Vk.Bool32 timestampComputeAndGraphics = default,
		float timestampPeriod = default,
		uint maxClipDistances = default,
		uint maxCullDistances = default,
		uint maxCombinedClipAndCullDistances = default,
		uint discreteQueuePriorities = default,
		float pointSizeRange0 = default,
		float pointSizeRange1 = default,
		float lineWidthRange0 = default,
		float lineWidthRange1 = default,
		float pointSizeGranularity = default,
		float lineWidthGranularity = default,
		in Vk.Bool32 strictLines = default,
		in Vk.Bool32 standardSampleLocations = default,
		in Vk.DeviceSize optimalBufferCopyOffsetAlignment = default,
		in Vk.DeviceSize optimalBufferCopyRowPitchAlignment = default,
		in Vk.DeviceSize nonCoherentAtomSize = default
	) {
		MaxImageDimension1D = maxImageDimension1D;
		MaxImageDimension2D = maxImageDimension2D;
		MaxImageDimension3D = maxImageDimension3D;
		MaxImageDimensionCube = maxImageDimensionCube;
		MaxImageArrayLayers = maxImageArrayLayers;
		MaxTexelBufferElements = maxTexelBufferElements;
		MaxUniformBufferRange = maxUniformBufferRange;
		MaxStorageBufferRange = maxStorageBufferRange;
		MaxPushConstantsSize = maxPushConstantsSize;
		MaxMemoryAllocationCount = maxMemoryAllocationCount;
		MaxSamplerAllocationCount = maxSamplerAllocationCount;
		BufferImageGranularity = bufferImageGranularity;
		SparseAddressSpaceSize = sparseAddressSpaceSize;
		MaxBoundDescriptorSets = maxBoundDescriptorSets;
		MaxPerStageDescriptorSamplers = maxPerStageDescriptorSamplers;
		MaxPerStageDescriptorUniformBuffers = maxPerStageDescriptorUniformBuffers;
		MaxPerStageDescriptorStorageBuffers = maxPerStageDescriptorStorageBuffers;
		MaxPerStageDescriptorSampledImages = maxPerStageDescriptorSampledImages;
		MaxPerStageDescriptorStorageImages = maxPerStageDescriptorStorageImages;
		MaxPerStageDescriptorInputAttachments = maxPerStageDescriptorInputAttachments;
		MaxPerStageResources = maxPerStageResources;
		MaxDescriptorSetSamplers = maxDescriptorSetSamplers;
		MaxDescriptorSetUniformBuffers = maxDescriptorSetUniformBuffers;
		MaxDescriptorSetUniformBuffersDynamic = maxDescriptorSetUniformBuffersDynamic;
		MaxDescriptorSetStorageBuffers = maxDescriptorSetStorageBuffers;
		MaxDescriptorSetStorageBuffersDynamic = maxDescriptorSetStorageBuffersDynamic;
		MaxDescriptorSetSampledImages = maxDescriptorSetSampledImages;
		MaxDescriptorSetStorageImages = maxDescriptorSetStorageImages;
		MaxDescriptorSetInputAttachments = maxDescriptorSetInputAttachments;
		MaxVertexInputAttributes = maxVertexInputAttributes;
		MaxVertexInputBindings = maxVertexInputBindings;
		MaxVertexInputAttributeOffset = maxVertexInputAttributeOffset;
		MaxVertexInputBindingStride = maxVertexInputBindingStride;
		MaxVertexOutputComponents = maxVertexOutputComponents;
		MaxTessellationGenerationLevel = maxTessellationGenerationLevel;
		MaxTessellationPatchSize = maxTessellationPatchSize;
		MaxTessellationControlPerVertexInputComponents = maxTessellationControlPerVertexInputComponents;
		MaxTessellationControlPerVertexOutputComponents = maxTessellationControlPerVertexOutputComponents;
		MaxTessellationControlPerPatchOutputComponents = maxTessellationControlPerPatchOutputComponents;
		MaxTessellationControlTotalOutputComponents = maxTessellationControlTotalOutputComponents;
		MaxTessellationEvaluationInputComponents = maxTessellationEvaluationInputComponents;
		MaxTessellationEvaluationOutputComponents = maxTessellationEvaluationOutputComponents;
		MaxGeometryShaderInvocations = maxGeometryShaderInvocations;
		MaxGeometryInputComponents = maxGeometryInputComponents;
		MaxGeometryOutputComponents = maxGeometryOutputComponents;
		MaxGeometryOutputVertices = maxGeometryOutputVertices;
		MaxGeometryTotalOutputComponents = maxGeometryTotalOutputComponents;
		MaxFragmentInputComponents = maxFragmentInputComponents;
		MaxFragmentOutputAttachments = maxFragmentOutputAttachments;
		MaxFragmentDualSrcAttachments = maxFragmentDualSrcAttachments;
		MaxFragmentCombinedOutputResources = maxFragmentCombinedOutputResources;
		MaxComputeSharedMemorySize = maxComputeSharedMemorySize;
		MaxComputeWorkGroupCount[0] = maxComputeWorkGroupCount0;
		MaxComputeWorkGroupCount[1] = maxComputeWorkGroupCount1;
		MaxComputeWorkGroupCount[2] = maxComputeWorkGroupCount2;
		MaxComputeWorkGroupInvocations = maxComputeWorkGroupInvocations;
		MaxComputeWorkGroupSize[0] = maxComputeWorkGroupSize0;
		MaxComputeWorkGroupSize[1] = maxComputeWorkGroupSize1;
		MaxComputeWorkGroupSize[2] = maxComputeWorkGroupSize2;
		SubPixelPrecisionBits = subPixelPrecisionBits;
		SubTexelPrecisionBits = subTexelPrecisionBits;
		MipmapPrecisionBits = mipmapPrecisionBits;
		MaxDrawIndexedIndexValue = maxDrawIndexedIndexValue;
		MaxDrawIndirectCount = maxDrawIndirectCount;
		MaxSamplerLodBias = maxSamplerLodBias;
		MaxSamplerAnisotropy = maxSamplerAnisotropy;
		MaxViewports = maxViewports;
		MaxViewportDimensions[0] = maxViewportDimensions0;
		MaxViewportDimensions[1] = maxViewportDimensions1;
		ViewportBoundsRange[0] = viewportBoundsRange0;
		ViewportBoundsRange[1] = viewportBoundsRange1;
		ViewportSubPixelBits = viewportSubPixelBits;
		MinMemoryMapAlignment = minMemoryMapAlignment;
		MinTexelBufferOffsetAlignment = minTexelBufferOffsetAlignment;
		MinUniformBufferOffsetAlignment = minUniformBufferOffsetAlignment;
		MinStorageBufferOffsetAlignment = minStorageBufferOffsetAlignment;
		MinTexelOffset = minTexelOffset;
		MaxTexelOffset = maxTexelOffset;
		MinTexelGatherOffset = minTexelGatherOffset;
		MaxTexelGatherOffset = maxTexelGatherOffset;
		MinInterpolationOffset = minInterpolationOffset;
		MaxInterpolationOffset = maxInterpolationOffset;
		SubPixelInterpolationOffsetBits = subPixelInterpolationOffsetBits;
		MaxFramebufferWidth = maxFramebufferWidth;
		MaxFramebufferHeight = maxFramebufferHeight;
		MaxFramebufferLayers = maxFramebufferLayers;
		FramebufferColorSampleCounts = framebufferColorSampleCounts;
		FramebufferDepthSampleCounts = framebufferDepthSampleCounts;
		FramebufferStencilSampleCounts = framebufferStencilSampleCounts;
		FramebufferNoAttachmentsSampleCounts = framebufferNoAttachmentsSampleCounts;
		MaxColorAttachments = maxColorAttachments;
		SampledImageColorSampleCounts = sampledImageColorSampleCounts;
		SampledImageIntegerSampleCounts = sampledImageIntegerSampleCounts;
		SampledImageDepthSampleCounts = sampledImageDepthSampleCounts;
		SampledImageStencilSampleCounts = sampledImageStencilSampleCounts;
		StorageImageSampleCounts = storageImageSampleCounts;
		MaxSampleMaskWords = maxSampleMaskWords;
		TimestampComputeAndGraphics = timestampComputeAndGraphics;
		TimestampPeriod = timestampPeriod;
		MaxClipDistances = maxClipDistances;
		MaxCullDistances = maxCullDistances;
		MaxCombinedClipAndCullDistances = maxCombinedClipAndCullDistances;
		DiscreteQueuePriorities = discreteQueuePriorities;
		PointSizeRange[0] = pointSizeRange0;
		PointSizeRange[1] = pointSizeRange1;
		LineWidthRange[0] = lineWidthRange0;
		LineWidthRange[1] = lineWidthRange1;
		PointSizeGranularity = pointSizeGranularity;
		LineWidthGranularity = lineWidthGranularity;
		StrictLines = strictLines;
		StandardSampleLocations = standardSampleLocations;
		OptimalBufferCopyOffsetAlignment = optimalBufferCopyOffsetAlignment;
		OptimalBufferCopyRowPitchAlignment = optimalBufferCopyRowPitchAlignment;
		NonCoherentAtomSize = nonCoherentAtomSize;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceLimits o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceLimits>.Equals(PhysicalDeviceLimits obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			MaxImageDimension1D.GetHashCode() ^ MaxImageDimension2D.GetHashCode() ^ MaxImageDimension3D.GetHashCode() ^ MaxImageDimensionCube.GetHashCode()
			^ MaxImageArrayLayers.GetHashCode() ^ MaxTexelBufferElements.GetHashCode() ^ MaxUniformBufferRange.GetHashCode() ^ MaxStorageBufferRange.GetHashCode()
			^ MaxPushConstantsSize.GetHashCode() ^ MaxMemoryAllocationCount.GetHashCode() ^ MaxSamplerAllocationCount.GetHashCode() ^ BufferImageGranularity.GetHashCode()
			^ SparseAddressSpaceSize.GetHashCode() ^ MaxBoundDescriptorSets.GetHashCode() ^ MaxPerStageDescriptorSamplers.GetHashCode() ^ MaxPerStageDescriptorUniformBuffers.GetHashCode()
			^ MaxPerStageDescriptorStorageBuffers.GetHashCode() ^ MaxPerStageDescriptorSampledImages.GetHashCode() ^ MaxPerStageDescriptorStorageImages.GetHashCode() ^ MaxPerStageDescriptorInputAttachments.GetHashCode()
			^ MaxPerStageResources.GetHashCode() ^ MaxDescriptorSetSamplers.GetHashCode() ^ MaxDescriptorSetUniformBuffers.GetHashCode() ^ MaxDescriptorSetUniformBuffersDynamic.GetHashCode()
			^ MaxDescriptorSetStorageBuffers.GetHashCode() ^ MaxDescriptorSetStorageBuffersDynamic.GetHashCode() ^ MaxDescriptorSetSampledImages.GetHashCode() ^ MaxDescriptorSetStorageImages.GetHashCode()
			^ MaxDescriptorSetInputAttachments.GetHashCode() ^ MaxVertexInputAttributes.GetHashCode() ^ MaxVertexInputBindings.GetHashCode() ^ MaxVertexInputAttributeOffset.GetHashCode()
			^ MaxVertexInputBindingStride.GetHashCode() ^ MaxVertexOutputComponents.GetHashCode() ^ MaxTessellationGenerationLevel.GetHashCode() ^ MaxTessellationPatchSize.GetHashCode()
			^ MaxTessellationControlPerVertexInputComponents.GetHashCode() ^ MaxTessellationControlPerVertexOutputComponents.GetHashCode() ^ MaxTessellationControlPerPatchOutputComponents.GetHashCode() ^ MaxTessellationControlTotalOutputComponents.GetHashCode()
			^ MaxTessellationEvaluationInputComponents.GetHashCode() ^ MaxTessellationEvaluationOutputComponents.GetHashCode() ^ MaxGeometryShaderInvocations.GetHashCode() ^ MaxGeometryInputComponents.GetHashCode()
			^ MaxGeometryOutputComponents.GetHashCode() ^ MaxGeometryOutputVertices.GetHashCode() ^ MaxGeometryTotalOutputComponents.GetHashCode() ^ MaxFragmentInputComponents.GetHashCode()
			^ MaxFragmentOutputAttachments.GetHashCode() ^ MaxFragmentDualSrcAttachments.GetHashCode() ^ MaxFragmentCombinedOutputResources.GetHashCode() ^ MaxComputeSharedMemorySize.GetHashCode()
			^ MaxComputeWorkGroupCount[0].GetHashCode() ^ MaxComputeWorkGroupCount[1].GetHashCode() ^ MaxComputeWorkGroupCount[2].GetHashCode() ^ MaxComputeWorkGroupInvocations.GetHashCode()
			^ MaxComputeWorkGroupSize[0].GetHashCode() ^ MaxComputeWorkGroupSize[1].GetHashCode() ^ MaxComputeWorkGroupSize[2].GetHashCode() ^ SubPixelPrecisionBits.GetHashCode()
			^ SubTexelPrecisionBits.GetHashCode() ^ MipmapPrecisionBits.GetHashCode() ^ MaxDrawIndexedIndexValue.GetHashCode() ^ MaxDrawIndirectCount.GetHashCode()
			^ MaxSamplerLodBias.GetHashCode() ^ MaxSamplerAnisotropy.GetHashCode() ^ MaxViewports.GetHashCode() ^ MaxViewportDimensions[0].GetHashCode()
			^ MaxViewportDimensions[1].GetHashCode() ^ ViewportBoundsRange[0].GetHashCode() ^ ViewportBoundsRange[1].GetHashCode() ^ ViewportSubPixelBits.GetHashCode()
			^ MinMemoryMapAlignment.GetHashCode() ^ MinTexelBufferOffsetAlignment.GetHashCode() ^ MinUniformBufferOffsetAlignment.GetHashCode() ^ MinStorageBufferOffsetAlignment.GetHashCode()
			^ MinTexelOffset.GetHashCode() ^ MaxTexelOffset.GetHashCode() ^ MinTexelGatherOffset.GetHashCode() ^ MaxTexelGatherOffset.GetHashCode()
			^ MinInterpolationOffset.GetHashCode() ^ MaxInterpolationOffset.GetHashCode() ^ SubPixelInterpolationOffsetBits.GetHashCode() ^ MaxFramebufferWidth.GetHashCode()
			^ MaxFramebufferHeight.GetHashCode() ^ MaxFramebufferLayers.GetHashCode() ^ FramebufferColorSampleCounts.GetHashCode() ^ FramebufferDepthSampleCounts.GetHashCode()
			^ FramebufferStencilSampleCounts.GetHashCode() ^ FramebufferNoAttachmentsSampleCounts.GetHashCode() ^ MaxColorAttachments.GetHashCode() ^ SampledImageColorSampleCounts.GetHashCode()
			^ SampledImageIntegerSampleCounts.GetHashCode() ^ SampledImageDepthSampleCounts.GetHashCode() ^ SampledImageStencilSampleCounts.GetHashCode() ^ StorageImageSampleCounts.GetHashCode()
			^ MaxSampleMaskWords.GetHashCode() ^ TimestampComputeAndGraphics.GetHashCode() ^ TimestampPeriod.GetHashCode() ^ MaxClipDistances.GetHashCode()
			^ MaxCullDistances.GetHashCode() ^ MaxCombinedClipAndCullDistances.GetHashCode() ^ DiscreteQueuePriorities.GetHashCode() ^ PointSizeRange[0].GetHashCode()
			^ PointSizeRange[1].GetHashCode() ^ LineWidthRange[0].GetHashCode() ^ LineWidthRange[1].GetHashCode() ^ PointSizeGranularity.GetHashCode()
			^ LineWidthGranularity.GetHashCode() ^ StrictLines.GetHashCode() ^ StandardSampleLocations.GetHashCode() ^ OptimalBufferCopyOffsetAlignment.GetHashCode()
			^ OptimalBufferCopyRowPitchAlignment.GetHashCode() ^ NonCoherentAtomSize.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceLimits l, in PhysicalDeviceLimits r)
	{
		return
			(l.MaxImageDimension1D == r.MaxImageDimension1D) && (l.MaxImageDimension2D == r.MaxImageDimension2D) && (l.MaxImageDimension3D == r.MaxImageDimension3D) && (l.MaxImageDimensionCube == r.MaxImageDimensionCube)
			&& (l.MaxImageArrayLayers == r.MaxImageArrayLayers) && (l.MaxTexelBufferElements == r.MaxTexelBufferElements) && (l.MaxUniformBufferRange == r.MaxUniformBufferRange) && (l.MaxStorageBufferRange == r.MaxStorageBufferRange)
			&& (l.MaxPushConstantsSize == r.MaxPushConstantsSize) && (l.MaxMemoryAllocationCount == r.MaxMemoryAllocationCount) && (l.MaxSamplerAllocationCount == r.MaxSamplerAllocationCount) && (l.BufferImageGranularity == r.BufferImageGranularity)
			&& (l.SparseAddressSpaceSize == r.SparseAddressSpaceSize) && (l.MaxBoundDescriptorSets == r.MaxBoundDescriptorSets) && (l.MaxPerStageDescriptorSamplers == r.MaxPerStageDescriptorSamplers) && (l.MaxPerStageDescriptorUniformBuffers == r.MaxPerStageDescriptorUniformBuffers)
			&& (l.MaxPerStageDescriptorStorageBuffers == r.MaxPerStageDescriptorStorageBuffers) && (l.MaxPerStageDescriptorSampledImages == r.MaxPerStageDescriptorSampledImages) && (l.MaxPerStageDescriptorStorageImages == r.MaxPerStageDescriptorStorageImages) && (l.MaxPerStageDescriptorInputAttachments == r.MaxPerStageDescriptorInputAttachments)
			&& (l.MaxPerStageResources == r.MaxPerStageResources) && (l.MaxDescriptorSetSamplers == r.MaxDescriptorSetSamplers) && (l.MaxDescriptorSetUniformBuffers == r.MaxDescriptorSetUniformBuffers) && (l.MaxDescriptorSetUniformBuffersDynamic == r.MaxDescriptorSetUniformBuffersDynamic)
			&& (l.MaxDescriptorSetStorageBuffers == r.MaxDescriptorSetStorageBuffers) && (l.MaxDescriptorSetStorageBuffersDynamic == r.MaxDescriptorSetStorageBuffersDynamic) && (l.MaxDescriptorSetSampledImages == r.MaxDescriptorSetSampledImages) && (l.MaxDescriptorSetStorageImages == r.MaxDescriptorSetStorageImages)
			&& (l.MaxDescriptorSetInputAttachments == r.MaxDescriptorSetInputAttachments) && (l.MaxVertexInputAttributes == r.MaxVertexInputAttributes) && (l.MaxVertexInputBindings == r.MaxVertexInputBindings) && (l.MaxVertexInputAttributeOffset == r.MaxVertexInputAttributeOffset)
			&& (l.MaxVertexInputBindingStride == r.MaxVertexInputBindingStride) && (l.MaxVertexOutputComponents == r.MaxVertexOutputComponents) && (l.MaxTessellationGenerationLevel == r.MaxTessellationGenerationLevel) && (l.MaxTessellationPatchSize == r.MaxTessellationPatchSize)
			&& (l.MaxTessellationControlPerVertexInputComponents == r.MaxTessellationControlPerVertexInputComponents) && (l.MaxTessellationControlPerVertexOutputComponents == r.MaxTessellationControlPerVertexOutputComponents) && (l.MaxTessellationControlPerPatchOutputComponents == r.MaxTessellationControlPerPatchOutputComponents) && (l.MaxTessellationControlTotalOutputComponents == r.MaxTessellationControlTotalOutputComponents)
			&& (l.MaxTessellationEvaluationInputComponents == r.MaxTessellationEvaluationInputComponents) && (l.MaxTessellationEvaluationOutputComponents == r.MaxTessellationEvaluationOutputComponents) && (l.MaxGeometryShaderInvocations == r.MaxGeometryShaderInvocations) && (l.MaxGeometryInputComponents == r.MaxGeometryInputComponents)
			&& (l.MaxGeometryOutputComponents == r.MaxGeometryOutputComponents) && (l.MaxGeometryOutputVertices == r.MaxGeometryOutputVertices) && (l.MaxGeometryTotalOutputComponents == r.MaxGeometryTotalOutputComponents) && (l.MaxFragmentInputComponents == r.MaxFragmentInputComponents)
			&& (l.MaxFragmentOutputAttachments == r.MaxFragmentOutputAttachments) && (l.MaxFragmentDualSrcAttachments == r.MaxFragmentDualSrcAttachments) && (l.MaxFragmentCombinedOutputResources == r.MaxFragmentCombinedOutputResources) && (l.MaxComputeSharedMemorySize == r.MaxComputeSharedMemorySize)
			&& (l.MaxComputeWorkGroupCount[0] == r.MaxComputeWorkGroupCount[0]) && (l.MaxComputeWorkGroupCount[1] == r.MaxComputeWorkGroupCount[1]) && (l.MaxComputeWorkGroupCount[2] == r.MaxComputeWorkGroupCount[2]) && (l.MaxComputeWorkGroupInvocations == r.MaxComputeWorkGroupInvocations)
			&& (l.MaxComputeWorkGroupSize[0] == r.MaxComputeWorkGroupSize[0]) && (l.MaxComputeWorkGroupSize[1] == r.MaxComputeWorkGroupSize[1]) && (l.MaxComputeWorkGroupSize[2] == r.MaxComputeWorkGroupSize[2]) && (l.SubPixelPrecisionBits == r.SubPixelPrecisionBits)
			&& (l.SubTexelPrecisionBits == r.SubTexelPrecisionBits) && (l.MipmapPrecisionBits == r.MipmapPrecisionBits) && (l.MaxDrawIndexedIndexValue == r.MaxDrawIndexedIndexValue) && (l.MaxDrawIndirectCount == r.MaxDrawIndirectCount)
			&& (l.MaxSamplerLodBias == r.MaxSamplerLodBias) && (l.MaxSamplerAnisotropy == r.MaxSamplerAnisotropy) && (l.MaxViewports == r.MaxViewports) && (l.MaxViewportDimensions[0] == r.MaxViewportDimensions[0])
			&& (l.MaxViewportDimensions[1] == r.MaxViewportDimensions[1]) && (l.ViewportBoundsRange[0] == r.ViewportBoundsRange[0]) && (l.ViewportBoundsRange[1] == r.ViewportBoundsRange[1]) && (l.ViewportSubPixelBits == r.ViewportSubPixelBits)
			&& (l.MinMemoryMapAlignment == r.MinMemoryMapAlignment) && (l.MinTexelBufferOffsetAlignment == r.MinTexelBufferOffsetAlignment) && (l.MinUniformBufferOffsetAlignment == r.MinUniformBufferOffsetAlignment) && (l.MinStorageBufferOffsetAlignment == r.MinStorageBufferOffsetAlignment)
			&& (l.MinTexelOffset == r.MinTexelOffset) && (l.MaxTexelOffset == r.MaxTexelOffset) && (l.MinTexelGatherOffset == r.MinTexelGatherOffset) && (l.MaxTexelGatherOffset == r.MaxTexelGatherOffset)
			&& (l.MinInterpolationOffset == r.MinInterpolationOffset) && (l.MaxInterpolationOffset == r.MaxInterpolationOffset) && (l.SubPixelInterpolationOffsetBits == r.SubPixelInterpolationOffsetBits) && (l.MaxFramebufferWidth == r.MaxFramebufferWidth)
			&& (l.MaxFramebufferHeight == r.MaxFramebufferHeight) && (l.MaxFramebufferLayers == r.MaxFramebufferLayers) && (l.FramebufferColorSampleCounts == r.FramebufferColorSampleCounts) && (l.FramebufferDepthSampleCounts == r.FramebufferDepthSampleCounts)
			&& (l.FramebufferStencilSampleCounts == r.FramebufferStencilSampleCounts) && (l.FramebufferNoAttachmentsSampleCounts == r.FramebufferNoAttachmentsSampleCounts) && (l.MaxColorAttachments == r.MaxColorAttachments) && (l.SampledImageColorSampleCounts == r.SampledImageColorSampleCounts)
			&& (l.SampledImageIntegerSampleCounts == r.SampledImageIntegerSampleCounts) && (l.SampledImageDepthSampleCounts == r.SampledImageDepthSampleCounts) && (l.SampledImageStencilSampleCounts == r.SampledImageStencilSampleCounts) && (l.StorageImageSampleCounts == r.StorageImageSampleCounts)
			&& (l.MaxSampleMaskWords == r.MaxSampleMaskWords) && (l.TimestampComputeAndGraphics == r.TimestampComputeAndGraphics) && (l.TimestampPeriod == r.TimestampPeriod) && (l.MaxClipDistances == r.MaxClipDistances)
			&& (l.MaxCullDistances == r.MaxCullDistances) && (l.MaxCombinedClipAndCullDistances == r.MaxCombinedClipAndCullDistances) && (l.DiscreteQueuePriorities == r.DiscreteQueuePriorities) && (l.PointSizeRange[0] == r.PointSizeRange[0])
			&& (l.PointSizeRange[1] == r.PointSizeRange[1]) && (l.LineWidthRange[0] == r.LineWidthRange[0]) && (l.LineWidthRange[1] == r.LineWidthRange[1]) && (l.PointSizeGranularity == r.PointSizeGranularity)
			&& (l.LineWidthGranularity == r.LineWidthGranularity) && (l.StrictLines == r.StrictLines) && (l.StandardSampleLocations == r.StandardSampleLocations) && (l.OptimalBufferCopyOffsetAlignment == r.OptimalBufferCopyOffsetAlignment)
			&& (l.OptimalBufferCopyRowPitchAlignment == r.OptimalBufferCopyRowPitchAlignment) && (l.NonCoherentAtomSize == r.NonCoherentAtomSize)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceLimits l, in PhysicalDeviceLimits r)
	{
		return
			(l.MaxImageDimension1D != r.MaxImageDimension1D) || (l.MaxImageDimension2D != r.MaxImageDimension2D) || (l.MaxImageDimension3D != r.MaxImageDimension3D) || (l.MaxImageDimensionCube != r.MaxImageDimensionCube)
			|| (l.MaxImageArrayLayers != r.MaxImageArrayLayers) || (l.MaxTexelBufferElements != r.MaxTexelBufferElements) || (l.MaxUniformBufferRange != r.MaxUniformBufferRange) || (l.MaxStorageBufferRange != r.MaxStorageBufferRange)
			|| (l.MaxPushConstantsSize != r.MaxPushConstantsSize) || (l.MaxMemoryAllocationCount != r.MaxMemoryAllocationCount) || (l.MaxSamplerAllocationCount != r.MaxSamplerAllocationCount) || (l.BufferImageGranularity != r.BufferImageGranularity)
			|| (l.SparseAddressSpaceSize != r.SparseAddressSpaceSize) || (l.MaxBoundDescriptorSets != r.MaxBoundDescriptorSets) || (l.MaxPerStageDescriptorSamplers != r.MaxPerStageDescriptorSamplers) || (l.MaxPerStageDescriptorUniformBuffers != r.MaxPerStageDescriptorUniformBuffers)
			|| (l.MaxPerStageDescriptorStorageBuffers != r.MaxPerStageDescriptorStorageBuffers) || (l.MaxPerStageDescriptorSampledImages != r.MaxPerStageDescriptorSampledImages) || (l.MaxPerStageDescriptorStorageImages != r.MaxPerStageDescriptorStorageImages) || (l.MaxPerStageDescriptorInputAttachments != r.MaxPerStageDescriptorInputAttachments)
			|| (l.MaxPerStageResources != r.MaxPerStageResources) || (l.MaxDescriptorSetSamplers != r.MaxDescriptorSetSamplers) || (l.MaxDescriptorSetUniformBuffers != r.MaxDescriptorSetUniformBuffers) || (l.MaxDescriptorSetUniformBuffersDynamic != r.MaxDescriptorSetUniformBuffersDynamic)
			|| (l.MaxDescriptorSetStorageBuffers != r.MaxDescriptorSetStorageBuffers) || (l.MaxDescriptorSetStorageBuffersDynamic != r.MaxDescriptorSetStorageBuffersDynamic) || (l.MaxDescriptorSetSampledImages != r.MaxDescriptorSetSampledImages) || (l.MaxDescriptorSetStorageImages != r.MaxDescriptorSetStorageImages)
			|| (l.MaxDescriptorSetInputAttachments != r.MaxDescriptorSetInputAttachments) || (l.MaxVertexInputAttributes != r.MaxVertexInputAttributes) || (l.MaxVertexInputBindings != r.MaxVertexInputBindings) || (l.MaxVertexInputAttributeOffset != r.MaxVertexInputAttributeOffset)
			|| (l.MaxVertexInputBindingStride != r.MaxVertexInputBindingStride) || (l.MaxVertexOutputComponents != r.MaxVertexOutputComponents) || (l.MaxTessellationGenerationLevel != r.MaxTessellationGenerationLevel) || (l.MaxTessellationPatchSize != r.MaxTessellationPatchSize)
			|| (l.MaxTessellationControlPerVertexInputComponents != r.MaxTessellationControlPerVertexInputComponents) || (l.MaxTessellationControlPerVertexOutputComponents != r.MaxTessellationControlPerVertexOutputComponents) || (l.MaxTessellationControlPerPatchOutputComponents != r.MaxTessellationControlPerPatchOutputComponents) || (l.MaxTessellationControlTotalOutputComponents != r.MaxTessellationControlTotalOutputComponents)
			|| (l.MaxTessellationEvaluationInputComponents != r.MaxTessellationEvaluationInputComponents) || (l.MaxTessellationEvaluationOutputComponents != r.MaxTessellationEvaluationOutputComponents) || (l.MaxGeometryShaderInvocations != r.MaxGeometryShaderInvocations) || (l.MaxGeometryInputComponents != r.MaxGeometryInputComponents)
			|| (l.MaxGeometryOutputComponents != r.MaxGeometryOutputComponents) || (l.MaxGeometryOutputVertices != r.MaxGeometryOutputVertices) || (l.MaxGeometryTotalOutputComponents != r.MaxGeometryTotalOutputComponents) || (l.MaxFragmentInputComponents != r.MaxFragmentInputComponents)
			|| (l.MaxFragmentOutputAttachments != r.MaxFragmentOutputAttachments) || (l.MaxFragmentDualSrcAttachments != r.MaxFragmentDualSrcAttachments) || (l.MaxFragmentCombinedOutputResources != r.MaxFragmentCombinedOutputResources) || (l.MaxComputeSharedMemorySize != r.MaxComputeSharedMemorySize)
			|| (l.MaxComputeWorkGroupCount[0] != r.MaxComputeWorkGroupCount[0]) || (l.MaxComputeWorkGroupCount[1] != r.MaxComputeWorkGroupCount[1]) || (l.MaxComputeWorkGroupCount[2] != r.MaxComputeWorkGroupCount[2]) || (l.MaxComputeWorkGroupInvocations != r.MaxComputeWorkGroupInvocations)
			|| (l.MaxComputeWorkGroupSize[0] != r.MaxComputeWorkGroupSize[0]) || (l.MaxComputeWorkGroupSize[1] != r.MaxComputeWorkGroupSize[1]) || (l.MaxComputeWorkGroupSize[2] != r.MaxComputeWorkGroupSize[2]) || (l.SubPixelPrecisionBits != r.SubPixelPrecisionBits)
			|| (l.SubTexelPrecisionBits != r.SubTexelPrecisionBits) || (l.MipmapPrecisionBits != r.MipmapPrecisionBits) || (l.MaxDrawIndexedIndexValue != r.MaxDrawIndexedIndexValue) || (l.MaxDrawIndirectCount != r.MaxDrawIndirectCount)
			|| (l.MaxSamplerLodBias != r.MaxSamplerLodBias) || (l.MaxSamplerAnisotropy != r.MaxSamplerAnisotropy) || (l.MaxViewports != r.MaxViewports) || (l.MaxViewportDimensions[0] != r.MaxViewportDimensions[0])
			|| (l.MaxViewportDimensions[1] != r.MaxViewportDimensions[1]) || (l.ViewportBoundsRange[0] != r.ViewportBoundsRange[0]) || (l.ViewportBoundsRange[1] != r.ViewportBoundsRange[1]) || (l.ViewportSubPixelBits != r.ViewportSubPixelBits)
			|| (l.MinMemoryMapAlignment != r.MinMemoryMapAlignment) || (l.MinTexelBufferOffsetAlignment != r.MinTexelBufferOffsetAlignment) || (l.MinUniformBufferOffsetAlignment != r.MinUniformBufferOffsetAlignment) || (l.MinStorageBufferOffsetAlignment != r.MinStorageBufferOffsetAlignment)
			|| (l.MinTexelOffset != r.MinTexelOffset) || (l.MaxTexelOffset != r.MaxTexelOffset) || (l.MinTexelGatherOffset != r.MinTexelGatherOffset) || (l.MaxTexelGatherOffset != r.MaxTexelGatherOffset)
			|| (l.MinInterpolationOffset != r.MinInterpolationOffset) || (l.MaxInterpolationOffset != r.MaxInterpolationOffset) || (l.SubPixelInterpolationOffsetBits != r.SubPixelInterpolationOffsetBits) || (l.MaxFramebufferWidth != r.MaxFramebufferWidth)
			|| (l.MaxFramebufferHeight != r.MaxFramebufferHeight) || (l.MaxFramebufferLayers != r.MaxFramebufferLayers) || (l.FramebufferColorSampleCounts != r.FramebufferColorSampleCounts) || (l.FramebufferDepthSampleCounts != r.FramebufferDepthSampleCounts)
			|| (l.FramebufferStencilSampleCounts != r.FramebufferStencilSampleCounts) || (l.FramebufferNoAttachmentsSampleCounts != r.FramebufferNoAttachmentsSampleCounts) || (l.MaxColorAttachments != r.MaxColorAttachments) || (l.SampledImageColorSampleCounts != r.SampledImageColorSampleCounts)
			|| (l.SampledImageIntegerSampleCounts != r.SampledImageIntegerSampleCounts) || (l.SampledImageDepthSampleCounts != r.SampledImageDepthSampleCounts) || (l.SampledImageStencilSampleCounts != r.SampledImageStencilSampleCounts) || (l.StorageImageSampleCounts != r.StorageImageSampleCounts)
			|| (l.MaxSampleMaskWords != r.MaxSampleMaskWords) || (l.TimestampComputeAndGraphics != r.TimestampComputeAndGraphics) || (l.TimestampPeriod != r.TimestampPeriod) || (l.MaxClipDistances != r.MaxClipDistances)
			|| (l.MaxCullDistances != r.MaxCullDistances) || (l.MaxCombinedClipAndCullDistances != r.MaxCombinedClipAndCullDistances) || (l.DiscreteQueuePriorities != r.DiscreteQueuePriorities) || (l.PointSizeRange[0] != r.PointSizeRange[0])
			|| (l.PointSizeRange[1] != r.PointSizeRange[1]) || (l.LineWidthRange[0] != r.LineWidthRange[0]) || (l.LineWidthRange[1] != r.LineWidthRange[1]) || (l.PointSizeGranularity != r.PointSizeGranularity)
			|| (l.LineWidthGranularity != r.LineWidthGranularity) || (l.StrictLines != r.StrictLines) || (l.StandardSampleLocations != r.StandardSampleLocations) || (l.OptimalBufferCopyOffsetAlignment != r.OptimalBufferCopyOffsetAlignment)
			|| (l.OptimalBufferCopyRowPitchAlignment != r.OptimalBufferCopyRowPitchAlignment) || (l.NonCoherentAtomSize != r.NonCoherentAtomSize)
			;
	}


	/// <summary>Creates a new PhysicalDeviceLimits value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceLimits value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SemaphoreCreateInfo : IEquatable<SemaphoreCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.SemaphoreCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.SemaphoreCreateFlags Flags;
	public SemaphoreCreateInfo(
		in Vk.SemaphoreCreateFlags flags = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
	}


	public readonly override bool Equals(object? obj) => (obj is SemaphoreCreateInfo o) && (this == o);
	readonly bool IEquatable<SemaphoreCreateInfo>.Equals(SemaphoreCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SemaphoreCreateInfo l, in SemaphoreCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SemaphoreCreateInfo l, in SemaphoreCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags)
			;
	}


	/// <summary>Creates a new SemaphoreCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SemaphoreCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct QueryPoolCreateInfo : IEquatable<QueryPoolCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.QueryPoolCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.QueryPoolCreateFlags Flags;
	public Vk.QueryType QueryType;
	public uint QueryCount;
	public Vk.QueryPipelineStatisticFlags PipelineStatistics;
	public QueryPoolCreateInfo(
		in Vk.QueryPoolCreateFlags flags = default,
		in Vk.QueryType queryType = default,
		uint queryCount = default,
		in Vk.QueryPipelineStatisticFlags pipelineStatistics = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		QueryType = queryType;
		QueryCount = queryCount;
		PipelineStatistics = pipelineStatistics;
	}


	public readonly override bool Equals(object? obj) => (obj is QueryPoolCreateInfo o) && (this == o);
	readonly bool IEquatable<QueryPoolCreateInfo>.Equals(QueryPoolCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ QueryType.GetHashCode()
			^ QueryCount.GetHashCode() ^ PipelineStatistics.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in QueryPoolCreateInfo l, in QueryPoolCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.QueryType == r.QueryType)
			&& (l.QueryCount == r.QueryCount) && (l.PipelineStatistics == r.PipelineStatistics)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in QueryPoolCreateInfo l, in QueryPoolCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.QueryType != r.QueryType)
			|| (l.QueryCount != r.QueryCount) || (l.PipelineStatistics != r.PipelineStatistics)
			;
	}


	/// <summary>Creates a new QueryPoolCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out QueryPoolCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct FramebufferCreateInfo : IEquatable<FramebufferCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.FramebufferCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.FramebufferCreateFlags Flags;
	public Vk.Handle<Vk.RenderPass> RenderPass;
	public uint AttachmentCount;
	public Vk.Handle<Vk.ImageView>* Attachments;
	public uint Width;
	public uint Height;
	public uint Layers;
	public FramebufferCreateInfo(
		in Vk.FramebufferCreateFlags flags = default,
		in Vk.Handle<Vk.RenderPass> renderPass = default,
		uint attachmentCount = default,
		in Vk.Handle<Vk.ImageView>* attachments = default,
		uint width = default,
		uint height = default,
		uint layers = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		RenderPass = renderPass;
		AttachmentCount = attachmentCount;
		Attachments = attachments;
		Width = width;
		Height = height;
		Layers = layers;
	}


	public readonly override bool Equals(object? obj) => (obj is FramebufferCreateInfo o) && (this == o);
	readonly bool IEquatable<FramebufferCreateInfo>.Equals(FramebufferCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ RenderPass.GetHashCode()
			^ AttachmentCount.GetHashCode() ^ ((ulong)Attachments).GetHashCode() ^ Width.GetHashCode() ^ Height.GetHashCode()
			^ Layers.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in FramebufferCreateInfo l, in FramebufferCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.RenderPass == r.RenderPass)
			&& (l.AttachmentCount == r.AttachmentCount) && (l.Attachments == r.Attachments) && (l.Width == r.Width) && (l.Height == r.Height)
			&& (l.Layers == r.Layers)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in FramebufferCreateInfo l, in FramebufferCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.RenderPass != r.RenderPass)
			|| (l.AttachmentCount != r.AttachmentCount) || (l.Attachments != r.Attachments) || (l.Width != r.Width) || (l.Height != r.Height)
			|| (l.Layers != r.Layers)
			;
	}


	/// <summary>Creates a new FramebufferCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out FramebufferCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DrawIndirectCommand : IEquatable<DrawIndirectCommand>
{
	public uint VertexCount;
	public uint InstanceCount;
	public uint FirstVertex;
	public uint FirstInstance;
	public DrawIndirectCommand(
		uint vertexCount = default,
		uint instanceCount = default,
		uint firstVertex = default,
		uint firstInstance = default
	) {
		VertexCount = vertexCount;
		InstanceCount = instanceCount;
		FirstVertex = firstVertex;
		FirstInstance = firstInstance;
	}


	public readonly override bool Equals(object? obj) => (obj is DrawIndirectCommand o) && (this == o);
	readonly bool IEquatable<DrawIndirectCommand>.Equals(DrawIndirectCommand obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			VertexCount.GetHashCode() ^ InstanceCount.GetHashCode() ^ FirstVertex.GetHashCode() ^ FirstInstance.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DrawIndirectCommand l, in DrawIndirectCommand r)
	{
		return
			(l.VertexCount == r.VertexCount) && (l.InstanceCount == r.InstanceCount) && (l.FirstVertex == r.FirstVertex) && (l.FirstInstance == r.FirstInstance)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DrawIndirectCommand l, in DrawIndirectCommand r)
	{
		return
			(l.VertexCount != r.VertexCount) || (l.InstanceCount != r.InstanceCount) || (l.FirstVertex != r.FirstVertex) || (l.FirstInstance != r.FirstInstance)
			;
	}


	/// <summary>Creates a new DrawIndirectCommand value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DrawIndirectCommand value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DrawIndexedIndirectCommand : IEquatable<DrawIndexedIndirectCommand>
{
	public uint IndexCount;
	public uint InstanceCount;
	public uint FirstIndex;
	public int VertexOffset;
	public uint FirstInstance;
	public DrawIndexedIndirectCommand(
		uint indexCount = default,
		uint instanceCount = default,
		uint firstIndex = default,
		int vertexOffset = default,
		uint firstInstance = default
	) {
		IndexCount = indexCount;
		InstanceCount = instanceCount;
		FirstIndex = firstIndex;
		VertexOffset = vertexOffset;
		FirstInstance = firstInstance;
	}


	public readonly override bool Equals(object? obj) => (obj is DrawIndexedIndirectCommand o) && (this == o);
	readonly bool IEquatable<DrawIndexedIndirectCommand>.Equals(DrawIndexedIndirectCommand obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			IndexCount.GetHashCode() ^ InstanceCount.GetHashCode() ^ FirstIndex.GetHashCode() ^ VertexOffset.GetHashCode()
			^ FirstInstance.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DrawIndexedIndirectCommand l, in DrawIndexedIndirectCommand r)
	{
		return
			(l.IndexCount == r.IndexCount) && (l.InstanceCount == r.InstanceCount) && (l.FirstIndex == r.FirstIndex) && (l.VertexOffset == r.VertexOffset)
			&& (l.FirstInstance == r.FirstInstance)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DrawIndexedIndirectCommand l, in DrawIndexedIndirectCommand r)
	{
		return
			(l.IndexCount != r.IndexCount) || (l.InstanceCount != r.InstanceCount) || (l.FirstIndex != r.FirstIndex) || (l.VertexOffset != r.VertexOffset)
			|| (l.FirstInstance != r.FirstInstance)
			;
	}


	/// <summary>Creates a new DrawIndexedIndirectCommand value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DrawIndexedIndirectCommand value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DispatchIndirectCommand : IEquatable<DispatchIndirectCommand>
{
	public uint X;
	public uint Y;
	public uint Z;
	public DispatchIndirectCommand(
		uint x = default,
		uint y = default,
		uint z = default
	) {
		X = x;
		Y = y;
		Z = z;
	}


	public readonly override bool Equals(object? obj) => (obj is DispatchIndirectCommand o) && (this == o);
	readonly bool IEquatable<DispatchIndirectCommand>.Equals(DispatchIndirectCommand obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			X.GetHashCode() ^ Y.GetHashCode() ^ Z.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DispatchIndirectCommand l, in DispatchIndirectCommand r)
	{
		return
			(l.X == r.X) && (l.Y == r.Y) && (l.Z == r.Z)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DispatchIndirectCommand l, in DispatchIndirectCommand r)
	{
		return
			(l.X != r.X) || (l.Y != r.Y) || (l.Z != r.Z)
			;
	}


	/// <summary>Creates a new DispatchIndirectCommand value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DispatchIndirectCommand value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SubmitInfo : IEquatable<SubmitInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.SubmitInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public uint WaitSemaphoreCount;
	public Vk.Handle<Vk.Semaphore>* WaitSemaphores;
	public Vk.PipelineStageFlags* WaitDstStageMask;
	public uint CommandBufferCount;
	public Vk.Handle<Vk.CommandBuffer>* CommandBuffers;
	public uint SignalSemaphoreCount;
	public Vk.Handle<Vk.Semaphore>* SignalSemaphores;
	public SubmitInfo(
		uint waitSemaphoreCount = default,
		in Vk.Handle<Vk.Semaphore>* waitSemaphores = default,
		in Vk.PipelineStageFlags* waitDstStageMask = default,
		uint commandBufferCount = default,
		in Vk.Handle<Vk.CommandBuffer>* commandBuffers = default,
		uint signalSemaphoreCount = default,
		in Vk.Handle<Vk.Semaphore>* signalSemaphores = default
	) {
		sType = TYPE;
		pNext = null;
		WaitSemaphoreCount = waitSemaphoreCount;
		WaitSemaphores = waitSemaphores;
		WaitDstStageMask = waitDstStageMask;
		CommandBufferCount = commandBufferCount;
		CommandBuffers = commandBuffers;
		SignalSemaphoreCount = signalSemaphoreCount;
		SignalSemaphores = signalSemaphores;
	}


	public readonly override bool Equals(object? obj) => (obj is SubmitInfo o) && (this == o);
	readonly bool IEquatable<SubmitInfo>.Equals(SubmitInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ WaitSemaphoreCount.GetHashCode() ^ ((ulong)WaitSemaphores).GetHashCode()
			^ ((ulong)WaitDstStageMask).GetHashCode() ^ CommandBufferCount.GetHashCode() ^ ((ulong)CommandBuffers).GetHashCode() ^ SignalSemaphoreCount.GetHashCode()
			^ ((ulong)SignalSemaphores).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SubmitInfo l, in SubmitInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.WaitSemaphoreCount == r.WaitSemaphoreCount) && (l.WaitSemaphores == r.WaitSemaphores)
			&& (l.WaitDstStageMask == r.WaitDstStageMask) && (l.CommandBufferCount == r.CommandBufferCount) && (l.CommandBuffers == r.CommandBuffers) && (l.SignalSemaphoreCount == r.SignalSemaphoreCount)
			&& (l.SignalSemaphores == r.SignalSemaphores)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SubmitInfo l, in SubmitInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.WaitSemaphoreCount != r.WaitSemaphoreCount) || (l.WaitSemaphores != r.WaitSemaphores)
			|| (l.WaitDstStageMask != r.WaitDstStageMask) || (l.CommandBufferCount != r.CommandBufferCount) || (l.CommandBuffers != r.CommandBuffers) || (l.SignalSemaphoreCount != r.SignalSemaphoreCount)
			|| (l.SignalSemaphores != r.SignalSemaphores)
			;
	}


	/// <summary>Creates a new SubmitInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SubmitInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceFeatures2 : IEquatable<PhysicalDeviceFeatures2>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceFeatures2;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.PhysicalDeviceFeatures Features;
	public PhysicalDeviceFeatures2(
		in Vk.PhysicalDeviceFeatures features = default
	) {
		sType = TYPE;
		pNext = null;
		Features = features;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceFeatures2 o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceFeatures2>.Equals(PhysicalDeviceFeatures2 obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Features.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceFeatures2 l, in PhysicalDeviceFeatures2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Features == r.Features)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceFeatures2 l, in PhysicalDeviceFeatures2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Features != r.Features)
			;
	}


	/// <summary>Creates a new PhysicalDeviceFeatures2 value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceFeatures2 value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceProperties2 : IEquatable<PhysicalDeviceProperties2>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceProperties2;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.PhysicalDeviceProperties Properties;
	public PhysicalDeviceProperties2(
		in Vk.PhysicalDeviceProperties properties = default
	) {
		sType = TYPE;
		pNext = null;
		Properties = properties;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceProperties2 o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceProperties2>.Equals(PhysicalDeviceProperties2 obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Properties.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceProperties2 l, in PhysicalDeviceProperties2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Properties == r.Properties)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceProperties2 l, in PhysicalDeviceProperties2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Properties != r.Properties)
			;
	}


	/// <summary>Creates a new PhysicalDeviceProperties2 value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceProperties2 value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct FormatProperties2 : IEquatable<FormatProperties2>
{
	public const Vk.StructureType TYPE = Vk.StructureType.FormatProperties2;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.FormatProperties FormatProperties;
	public FormatProperties2(
		in Vk.FormatProperties formatProperties = default
	) {
		sType = TYPE;
		pNext = null;
		FormatProperties = formatProperties;
	}


	public readonly override bool Equals(object? obj) => (obj is FormatProperties2 o) && (this == o);
	readonly bool IEquatable<FormatProperties2>.Equals(FormatProperties2 obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ FormatProperties.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in FormatProperties2 l, in FormatProperties2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.FormatProperties == r.FormatProperties)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in FormatProperties2 l, in FormatProperties2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.FormatProperties != r.FormatProperties)
			;
	}


	/// <summary>Creates a new FormatProperties2 value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out FormatProperties2 value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ImageFormatProperties2 : IEquatable<ImageFormatProperties2>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ImageFormatProperties2;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.ImageFormatProperties ImageFormatProperties;
	public ImageFormatProperties2(
		in Vk.ImageFormatProperties imageFormatProperties = default
	) {
		sType = TYPE;
		pNext = null;
		ImageFormatProperties = imageFormatProperties;
	}


	public readonly override bool Equals(object? obj) => (obj is ImageFormatProperties2 o) && (this == o);
	readonly bool IEquatable<ImageFormatProperties2>.Equals(ImageFormatProperties2 obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ImageFormatProperties.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ImageFormatProperties2 l, in ImageFormatProperties2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ImageFormatProperties == r.ImageFormatProperties)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ImageFormatProperties2 l, in ImageFormatProperties2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ImageFormatProperties != r.ImageFormatProperties)
			;
	}


	/// <summary>Creates a new ImageFormatProperties2 value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ImageFormatProperties2 value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceImageFormatInfo2 : IEquatable<PhysicalDeviceImageFormatInfo2>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceImageFormatInfo2;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Format Format;
	public Vk.ImageType Type;
	public Vk.ImageTiling Tiling;
	public Vk.ImageUsageFlags Usage;
	public Vk.ImageCreateFlags Flags;
	public PhysicalDeviceImageFormatInfo2(
		in Vk.Format format = default,
		in Vk.ImageType type = default,
		in Vk.ImageTiling tiling = default,
		in Vk.ImageUsageFlags usage = default,
		in Vk.ImageCreateFlags flags = default
	) {
		sType = TYPE;
		pNext = null;
		Format = format;
		Type = type;
		Tiling = tiling;
		Usage = usage;
		Flags = flags;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceImageFormatInfo2 o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceImageFormatInfo2>.Equals(PhysicalDeviceImageFormatInfo2 obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Format.GetHashCode() ^ Type.GetHashCode()
			^ Tiling.GetHashCode() ^ Usage.GetHashCode() ^ Flags.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceImageFormatInfo2 l, in PhysicalDeviceImageFormatInfo2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Format == r.Format) && (l.Type == r.Type)
			&& (l.Tiling == r.Tiling) && (l.Usage == r.Usage) && (l.Flags == r.Flags)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceImageFormatInfo2 l, in PhysicalDeviceImageFormatInfo2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Format != r.Format) || (l.Type != r.Type)
			|| (l.Tiling != r.Tiling) || (l.Usage != r.Usage) || (l.Flags != r.Flags)
			;
	}


	/// <summary>Creates a new PhysicalDeviceImageFormatInfo2 value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceImageFormatInfo2 value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct QueueFamilyProperties2 : IEquatable<QueueFamilyProperties2>
{
	public const Vk.StructureType TYPE = Vk.StructureType.QueueFamilyProperties2;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.QueueFamilyProperties QueueFamilyProperties;
	public QueueFamilyProperties2(
		in Vk.QueueFamilyProperties queueFamilyProperties = default
	) {
		sType = TYPE;
		pNext = null;
		QueueFamilyProperties = queueFamilyProperties;
	}


	public readonly override bool Equals(object? obj) => (obj is QueueFamilyProperties2 o) && (this == o);
	readonly bool IEquatable<QueueFamilyProperties2>.Equals(QueueFamilyProperties2 obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ QueueFamilyProperties.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in QueueFamilyProperties2 l, in QueueFamilyProperties2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.QueueFamilyProperties == r.QueueFamilyProperties)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in QueueFamilyProperties2 l, in QueueFamilyProperties2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.QueueFamilyProperties != r.QueueFamilyProperties)
			;
	}


	/// <summary>Creates a new QueueFamilyProperties2 value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out QueueFamilyProperties2 value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceMemoryProperties2 : IEquatable<PhysicalDeviceMemoryProperties2>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceMemoryProperties2;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.PhysicalDeviceMemoryProperties MemoryProperties;
	public PhysicalDeviceMemoryProperties2(
		in Vk.PhysicalDeviceMemoryProperties memoryProperties = default
	) {
		sType = TYPE;
		pNext = null;
		MemoryProperties = memoryProperties;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceMemoryProperties2 o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceMemoryProperties2>.Equals(PhysicalDeviceMemoryProperties2 obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MemoryProperties.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceMemoryProperties2 l, in PhysicalDeviceMemoryProperties2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MemoryProperties == r.MemoryProperties)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceMemoryProperties2 l, in PhysicalDeviceMemoryProperties2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MemoryProperties != r.MemoryProperties)
			;
	}


	/// <summary>Creates a new PhysicalDeviceMemoryProperties2 value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceMemoryProperties2 value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SparseImageFormatProperties2 : IEquatable<SparseImageFormatProperties2>
{
	public const Vk.StructureType TYPE = Vk.StructureType.SparseImageFormatProperties2;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.SparseImageFormatProperties Properties;
	public SparseImageFormatProperties2(
		in Vk.SparseImageFormatProperties properties = default
	) {
		sType = TYPE;
		pNext = null;
		Properties = properties;
	}


	public readonly override bool Equals(object? obj) => (obj is SparseImageFormatProperties2 o) && (this == o);
	readonly bool IEquatable<SparseImageFormatProperties2>.Equals(SparseImageFormatProperties2 obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Properties.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SparseImageFormatProperties2 l, in SparseImageFormatProperties2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Properties == r.Properties)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SparseImageFormatProperties2 l, in SparseImageFormatProperties2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Properties != r.Properties)
			;
	}


	/// <summary>Creates a new SparseImageFormatProperties2 value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SparseImageFormatProperties2 value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceSparseImageFormatInfo2 : IEquatable<PhysicalDeviceSparseImageFormatInfo2>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceSparseImageFormatInfo2;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Format Format;
	public Vk.ImageType Type;
	public Vk.SampleCountFlags Samples;
	public Vk.ImageUsageFlags Usage;
	public Vk.ImageTiling Tiling;
	public PhysicalDeviceSparseImageFormatInfo2(
		in Vk.Format format = default,
		in Vk.ImageType type = default,
		in Vk.SampleCountFlags samples = default,
		in Vk.ImageUsageFlags usage = default,
		in Vk.ImageTiling tiling = default
	) {
		sType = TYPE;
		pNext = null;
		Format = format;
		Type = type;
		Samples = samples;
		Usage = usage;
		Tiling = tiling;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceSparseImageFormatInfo2 o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceSparseImageFormatInfo2>.Equals(PhysicalDeviceSparseImageFormatInfo2 obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Format.GetHashCode() ^ Type.GetHashCode()
			^ Samples.GetHashCode() ^ Usage.GetHashCode() ^ Tiling.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceSparseImageFormatInfo2 l, in PhysicalDeviceSparseImageFormatInfo2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Format == r.Format) && (l.Type == r.Type)
			&& (l.Samples == r.Samples) && (l.Usage == r.Usage) && (l.Tiling == r.Tiling)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceSparseImageFormatInfo2 l, in PhysicalDeviceSparseImageFormatInfo2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Format != r.Format) || (l.Type != r.Type)
			|| (l.Samples != r.Samples) || (l.Usage != r.Usage) || (l.Tiling != r.Tiling)
			;
	}


	/// <summary>Creates a new PhysicalDeviceSparseImageFormatInfo2 value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceSparseImageFormatInfo2 value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ConformanceVersion : IEquatable<ConformanceVersion>
{
	public byte Major;
	public byte Minor;
	public byte Subminor;
	public byte Patch;
	public ConformanceVersion(
		byte major = default,
		byte minor = default,
		byte subminor = default,
		byte patch = default
	) {
		Major = major;
		Minor = minor;
		Subminor = subminor;
		Patch = patch;
	}


	public readonly override bool Equals(object? obj) => (obj is ConformanceVersion o) && (this == o);
	readonly bool IEquatable<ConformanceVersion>.Equals(ConformanceVersion obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Major.GetHashCode() ^ Minor.GetHashCode() ^ Subminor.GetHashCode() ^ Patch.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ConformanceVersion l, in ConformanceVersion r)
	{
		return
			(l.Major == r.Major) && (l.Minor == r.Minor) && (l.Subminor == r.Subminor) && (l.Patch == r.Patch)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ConformanceVersion l, in ConformanceVersion r)
	{
		return
			(l.Major != r.Major) || (l.Minor != r.Minor) || (l.Subminor != r.Subminor) || (l.Patch != r.Patch)
			;
	}


	/// <summary>Creates a new ConformanceVersion value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ConformanceVersion value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceDriverProperties : IEquatable<PhysicalDeviceDriverProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceDriverProperties;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.DriverId DriverID;
	public Vk.FixedString DriverName;
	public Vk.FixedString DriverInfo;
	public Vk.ConformanceVersion ConformanceVersion;
	public PhysicalDeviceDriverProperties(
		in Vk.DriverId driverID = default,
		in Vk.FixedString driverName = default,
		in Vk.FixedString driverInfo = default,
		in Vk.ConformanceVersion conformanceVersion = default
	) {
		sType = TYPE;
		pNext = null;
		DriverID = driverID;
		DriverName = driverName;
		DriverInfo = driverInfo;
		ConformanceVersion = conformanceVersion;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceDriverProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceDriverProperties>.Equals(PhysicalDeviceDriverProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DriverID.GetHashCode() ^ DriverName.GetHashCode()
			^ DriverInfo.GetHashCode() ^ ConformanceVersion.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceDriverProperties l, in PhysicalDeviceDriverProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DriverID == r.DriverID) && (l.DriverName == r.DriverName)
			&& (l.DriverInfo == r.DriverInfo) && (l.ConformanceVersion == r.ConformanceVersion)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceDriverProperties l, in PhysicalDeviceDriverProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DriverID != r.DriverID) || (l.DriverName != r.DriverName)
			|| (l.DriverInfo != r.DriverInfo) || (l.ConformanceVersion != r.ConformanceVersion)
			;
	}


	/// <summary>Creates a new PhysicalDeviceDriverProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceDriverProperties value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceVariablePointersFeatures : IEquatable<PhysicalDeviceVariablePointersFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceVariablePointersFeatures;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 VariablePointersStorageBuffer;
	public Vk.Bool32 VariablePointers;
	public PhysicalDeviceVariablePointersFeatures(
		in Vk.Bool32 variablePointersStorageBuffer = default,
		in Vk.Bool32 variablePointers = default
	) {
		sType = TYPE;
		pNext = null;
		VariablePointersStorageBuffer = variablePointersStorageBuffer;
		VariablePointers = variablePointers;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceVariablePointersFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceVariablePointersFeatures>.Equals(PhysicalDeviceVariablePointersFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ VariablePointersStorageBuffer.GetHashCode() ^ VariablePointers.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceVariablePointersFeatures l, in PhysicalDeviceVariablePointersFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.VariablePointersStorageBuffer == r.VariablePointersStorageBuffer) && (l.VariablePointers == r.VariablePointers)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceVariablePointersFeatures l, in PhysicalDeviceVariablePointersFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.VariablePointersStorageBuffer != r.VariablePointersStorageBuffer) || (l.VariablePointers != r.VariablePointers)
			;
	}


	/// <summary>Creates a new PhysicalDeviceVariablePointersFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceVariablePointersFeatures value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceVariablePointerFeatures : IEquatable<PhysicalDeviceVariablePointerFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceVariablePointersFeatures;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 VariablePointersStorageBuffer;
	public Vk.Bool32 VariablePointers;
	public PhysicalDeviceVariablePointerFeatures(
		in Vk.Bool32 variablePointersStorageBuffer = default,
		in Vk.Bool32 variablePointers = default
	) {
		sType = TYPE;
		pNext = null;
		VariablePointersStorageBuffer = variablePointersStorageBuffer;
		VariablePointers = variablePointers;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceVariablePointerFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceVariablePointerFeatures>.Equals(PhysicalDeviceVariablePointerFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ VariablePointersStorageBuffer.GetHashCode() ^ VariablePointers.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceVariablePointerFeatures l, in PhysicalDeviceVariablePointerFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.VariablePointersStorageBuffer == r.VariablePointersStorageBuffer) && (l.VariablePointers == r.VariablePointers)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceVariablePointerFeatures l, in PhysicalDeviceVariablePointerFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.VariablePointersStorageBuffer != r.VariablePointersStorageBuffer) || (l.VariablePointers != r.VariablePointers)
			;
	}


	/// <summary>Creates a new PhysicalDeviceVariablePointerFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceVariablePointerFeatures value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ExternalMemoryProperties : IEquatable<ExternalMemoryProperties>
{
	public Vk.ExternalMemoryFeatureFlags ExternalMemoryFeatures;
	public Vk.ExternalMemoryHandleTypeFlags ExportFromImportedHandleTypes;
	public Vk.ExternalMemoryHandleTypeFlags CompatibleHandleTypes;
	public ExternalMemoryProperties(
		in Vk.ExternalMemoryFeatureFlags externalMemoryFeatures = default,
		in Vk.ExternalMemoryHandleTypeFlags exportFromImportedHandleTypes = default,
		in Vk.ExternalMemoryHandleTypeFlags compatibleHandleTypes = default
	) {
		ExternalMemoryFeatures = externalMemoryFeatures;
		ExportFromImportedHandleTypes = exportFromImportedHandleTypes;
		CompatibleHandleTypes = compatibleHandleTypes;
	}


	public readonly override bool Equals(object? obj) => (obj is ExternalMemoryProperties o) && (this == o);
	readonly bool IEquatable<ExternalMemoryProperties>.Equals(ExternalMemoryProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			ExternalMemoryFeatures.GetHashCode() ^ ExportFromImportedHandleTypes.GetHashCode() ^ CompatibleHandleTypes.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ExternalMemoryProperties l, in ExternalMemoryProperties r)
	{
		return
			(l.ExternalMemoryFeatures == r.ExternalMemoryFeatures) && (l.ExportFromImportedHandleTypes == r.ExportFromImportedHandleTypes) && (l.CompatibleHandleTypes == r.CompatibleHandleTypes)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ExternalMemoryProperties l, in ExternalMemoryProperties r)
	{
		return
			(l.ExternalMemoryFeatures != r.ExternalMemoryFeatures) || (l.ExportFromImportedHandleTypes != r.ExportFromImportedHandleTypes) || (l.CompatibleHandleTypes != r.CompatibleHandleTypes)
			;
	}


	/// <summary>Creates a new ExternalMemoryProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ExternalMemoryProperties value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceExternalImageFormatInfo : IEquatable<PhysicalDeviceExternalImageFormatInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceExternalImageFormatInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.ExternalMemoryHandleTypeFlags HandleType;
	public PhysicalDeviceExternalImageFormatInfo(
		in Vk.ExternalMemoryHandleTypeFlags handleType = default
	) {
		sType = TYPE;
		pNext = null;
		HandleType = handleType;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceExternalImageFormatInfo o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceExternalImageFormatInfo>.Equals(PhysicalDeviceExternalImageFormatInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ HandleType.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceExternalImageFormatInfo l, in PhysicalDeviceExternalImageFormatInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.HandleType == r.HandleType)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceExternalImageFormatInfo l, in PhysicalDeviceExternalImageFormatInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.HandleType != r.HandleType)
			;
	}


	/// <summary>Creates a new PhysicalDeviceExternalImageFormatInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceExternalImageFormatInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ExternalImageFormatProperties : IEquatable<ExternalImageFormatProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ExternalImageFormatProperties;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.ExternalMemoryProperties ExternalMemoryProperties;
	public ExternalImageFormatProperties(
		in Vk.ExternalMemoryProperties externalMemoryProperties = default
	) {
		sType = TYPE;
		pNext = null;
		ExternalMemoryProperties = externalMemoryProperties;
	}


	public readonly override bool Equals(object? obj) => (obj is ExternalImageFormatProperties o) && (this == o);
	readonly bool IEquatable<ExternalImageFormatProperties>.Equals(ExternalImageFormatProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ExternalMemoryProperties.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ExternalImageFormatProperties l, in ExternalImageFormatProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ExternalMemoryProperties == r.ExternalMemoryProperties)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ExternalImageFormatProperties l, in ExternalImageFormatProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ExternalMemoryProperties != r.ExternalMemoryProperties)
			;
	}


	/// <summary>Creates a new ExternalImageFormatProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ExternalImageFormatProperties value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceExternalBufferInfo : IEquatable<PhysicalDeviceExternalBufferInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceExternalBufferInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.BufferCreateFlags Flags;
	public Vk.BufferUsageFlags Usage;
	public Vk.ExternalMemoryHandleTypeFlags HandleType;
	public PhysicalDeviceExternalBufferInfo(
		in Vk.BufferCreateFlags flags = default,
		in Vk.BufferUsageFlags usage = default,
		in Vk.ExternalMemoryHandleTypeFlags handleType = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		Usage = usage;
		HandleType = handleType;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceExternalBufferInfo o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceExternalBufferInfo>.Equals(PhysicalDeviceExternalBufferInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ Usage.GetHashCode()
			^ HandleType.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceExternalBufferInfo l, in PhysicalDeviceExternalBufferInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.Usage == r.Usage)
			&& (l.HandleType == r.HandleType)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceExternalBufferInfo l, in PhysicalDeviceExternalBufferInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.Usage != r.Usage)
			|| (l.HandleType != r.HandleType)
			;
	}


	/// <summary>Creates a new PhysicalDeviceExternalBufferInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceExternalBufferInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ExternalBufferProperties : IEquatable<ExternalBufferProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ExternalBufferProperties;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.ExternalMemoryProperties ExternalMemoryProperties;
	public ExternalBufferProperties(
		in Vk.ExternalMemoryProperties externalMemoryProperties = default
	) {
		sType = TYPE;
		pNext = null;
		ExternalMemoryProperties = externalMemoryProperties;
	}


	public readonly override bool Equals(object? obj) => (obj is ExternalBufferProperties o) && (this == o);
	readonly bool IEquatable<ExternalBufferProperties>.Equals(ExternalBufferProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ExternalMemoryProperties.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ExternalBufferProperties l, in ExternalBufferProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ExternalMemoryProperties == r.ExternalMemoryProperties)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ExternalBufferProperties l, in ExternalBufferProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ExternalMemoryProperties != r.ExternalMemoryProperties)
			;
	}


	/// <summary>Creates a new ExternalBufferProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ExternalBufferProperties value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceIDProperties : IEquatable<PhysicalDeviceIDProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceIdProperties;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.UUID DeviceUUID;
	public Vk.UUID DriverUUID;
	public Vk.LUID DeviceLUID;
	public uint DeviceNodeMask;
	public Vk.Bool32 DeviceLUIDValid;
	public PhysicalDeviceIDProperties(
		in Vk.UUID deviceUUID = default,
		in Vk.UUID driverUUID = default,
		in Vk.LUID deviceLUID = default,
		uint deviceNodeMask = default,
		in Vk.Bool32 deviceLUIDValid = default
	) {
		sType = TYPE;
		pNext = null;
		DeviceUUID = deviceUUID;
		DriverUUID = driverUUID;
		DeviceLUID = deviceLUID;
		DeviceNodeMask = deviceNodeMask;
		DeviceLUIDValid = deviceLUIDValid;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceIDProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceIDProperties>.Equals(PhysicalDeviceIDProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DeviceUUID.GetHashCode() ^ DriverUUID.GetHashCode()
			^ DeviceLUID.GetHashCode() ^ DeviceNodeMask.GetHashCode() ^ DeviceLUIDValid.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceIDProperties l, in PhysicalDeviceIDProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DeviceUUID == r.DeviceUUID) && (l.DriverUUID == r.DriverUUID)
			&& (l.DeviceLUID == r.DeviceLUID) && (l.DeviceNodeMask == r.DeviceNodeMask) && (l.DeviceLUIDValid == r.DeviceLUIDValid)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceIDProperties l, in PhysicalDeviceIDProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DeviceUUID != r.DeviceUUID) || (l.DriverUUID != r.DriverUUID)
			|| (l.DeviceLUID != r.DeviceLUID) || (l.DeviceNodeMask != r.DeviceNodeMask) || (l.DeviceLUIDValid != r.DeviceLUIDValid)
			;
	}


	/// <summary>Creates a new PhysicalDeviceIDProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceIDProperties value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ExternalMemoryImageCreateInfo : IEquatable<ExternalMemoryImageCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ExternalMemoryImageCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.ExternalMemoryHandleTypeFlags HandleTypes;
	public ExternalMemoryImageCreateInfo(
		in Vk.ExternalMemoryHandleTypeFlags handleTypes = default
	) {
		sType = TYPE;
		pNext = null;
		HandleTypes = handleTypes;
	}


	public readonly override bool Equals(object? obj) => (obj is ExternalMemoryImageCreateInfo o) && (this == o);
	readonly bool IEquatable<ExternalMemoryImageCreateInfo>.Equals(ExternalMemoryImageCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ HandleTypes.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ExternalMemoryImageCreateInfo l, in ExternalMemoryImageCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.HandleTypes == r.HandleTypes)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ExternalMemoryImageCreateInfo l, in ExternalMemoryImageCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.HandleTypes != r.HandleTypes)
			;
	}


	/// <summary>Creates a new ExternalMemoryImageCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ExternalMemoryImageCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ExternalMemoryBufferCreateInfo : IEquatable<ExternalMemoryBufferCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ExternalMemoryBufferCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.ExternalMemoryHandleTypeFlags HandleTypes;
	public ExternalMemoryBufferCreateInfo(
		in Vk.ExternalMemoryHandleTypeFlags handleTypes = default
	) {
		sType = TYPE;
		pNext = null;
		HandleTypes = handleTypes;
	}


	public readonly override bool Equals(object? obj) => (obj is ExternalMemoryBufferCreateInfo o) && (this == o);
	readonly bool IEquatable<ExternalMemoryBufferCreateInfo>.Equals(ExternalMemoryBufferCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ HandleTypes.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ExternalMemoryBufferCreateInfo l, in ExternalMemoryBufferCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.HandleTypes == r.HandleTypes)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ExternalMemoryBufferCreateInfo l, in ExternalMemoryBufferCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.HandleTypes != r.HandleTypes)
			;
	}


	/// <summary>Creates a new ExternalMemoryBufferCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ExternalMemoryBufferCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ExportMemoryAllocateInfo : IEquatable<ExportMemoryAllocateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ExportMemoryAllocateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.ExternalMemoryHandleTypeFlags HandleTypes;
	public ExportMemoryAllocateInfo(
		in Vk.ExternalMemoryHandleTypeFlags handleTypes = default
	) {
		sType = TYPE;
		pNext = null;
		HandleTypes = handleTypes;
	}


	public readonly override bool Equals(object? obj) => (obj is ExportMemoryAllocateInfo o) && (this == o);
	readonly bool IEquatable<ExportMemoryAllocateInfo>.Equals(ExportMemoryAllocateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ HandleTypes.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ExportMemoryAllocateInfo l, in ExportMemoryAllocateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.HandleTypes == r.HandleTypes)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ExportMemoryAllocateInfo l, in ExportMemoryAllocateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.HandleTypes != r.HandleTypes)
			;
	}


	/// <summary>Creates a new ExportMemoryAllocateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ExportMemoryAllocateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceExternalSemaphoreInfo : IEquatable<PhysicalDeviceExternalSemaphoreInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceExternalSemaphoreInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.ExternalSemaphoreHandleTypeFlags HandleType;
	public PhysicalDeviceExternalSemaphoreInfo(
		in Vk.ExternalSemaphoreHandleTypeFlags handleType = default
	) {
		sType = TYPE;
		pNext = null;
		HandleType = handleType;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceExternalSemaphoreInfo o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceExternalSemaphoreInfo>.Equals(PhysicalDeviceExternalSemaphoreInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ HandleType.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceExternalSemaphoreInfo l, in PhysicalDeviceExternalSemaphoreInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.HandleType == r.HandleType)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceExternalSemaphoreInfo l, in PhysicalDeviceExternalSemaphoreInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.HandleType != r.HandleType)
			;
	}


	/// <summary>Creates a new PhysicalDeviceExternalSemaphoreInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceExternalSemaphoreInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ExternalSemaphoreProperties : IEquatable<ExternalSemaphoreProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ExternalSemaphoreProperties;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.ExternalSemaphoreHandleTypeFlags ExportFromImportedHandleTypes;
	public Vk.ExternalSemaphoreHandleTypeFlags CompatibleHandleTypes;
	public Vk.ExternalSemaphoreFeatureFlags ExternalSemaphoreFeatures;
	public ExternalSemaphoreProperties(
		in Vk.ExternalSemaphoreHandleTypeFlags exportFromImportedHandleTypes = default,
		in Vk.ExternalSemaphoreHandleTypeFlags compatibleHandleTypes = default,
		in Vk.ExternalSemaphoreFeatureFlags externalSemaphoreFeatures = default
	) {
		sType = TYPE;
		pNext = null;
		ExportFromImportedHandleTypes = exportFromImportedHandleTypes;
		CompatibleHandleTypes = compatibleHandleTypes;
		ExternalSemaphoreFeatures = externalSemaphoreFeatures;
	}


	public readonly override bool Equals(object? obj) => (obj is ExternalSemaphoreProperties o) && (this == o);
	readonly bool IEquatable<ExternalSemaphoreProperties>.Equals(ExternalSemaphoreProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ExportFromImportedHandleTypes.GetHashCode() ^ CompatibleHandleTypes.GetHashCode()
			^ ExternalSemaphoreFeatures.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ExternalSemaphoreProperties l, in ExternalSemaphoreProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ExportFromImportedHandleTypes == r.ExportFromImportedHandleTypes) && (l.CompatibleHandleTypes == r.CompatibleHandleTypes)
			&& (l.ExternalSemaphoreFeatures == r.ExternalSemaphoreFeatures)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ExternalSemaphoreProperties l, in ExternalSemaphoreProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ExportFromImportedHandleTypes != r.ExportFromImportedHandleTypes) || (l.CompatibleHandleTypes != r.CompatibleHandleTypes)
			|| (l.ExternalSemaphoreFeatures != r.ExternalSemaphoreFeatures)
			;
	}


	/// <summary>Creates a new ExternalSemaphoreProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ExternalSemaphoreProperties value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ExportSemaphoreCreateInfo : IEquatable<ExportSemaphoreCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ExportSemaphoreCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.ExternalSemaphoreHandleTypeFlags HandleTypes;
	public ExportSemaphoreCreateInfo(
		in Vk.ExternalSemaphoreHandleTypeFlags handleTypes = default
	) {
		sType = TYPE;
		pNext = null;
		HandleTypes = handleTypes;
	}


	public readonly override bool Equals(object? obj) => (obj is ExportSemaphoreCreateInfo o) && (this == o);
	readonly bool IEquatable<ExportSemaphoreCreateInfo>.Equals(ExportSemaphoreCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ HandleTypes.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ExportSemaphoreCreateInfo l, in ExportSemaphoreCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.HandleTypes == r.HandleTypes)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ExportSemaphoreCreateInfo l, in ExportSemaphoreCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.HandleTypes != r.HandleTypes)
			;
	}


	/// <summary>Creates a new ExportSemaphoreCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ExportSemaphoreCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceExternalFenceInfo : IEquatable<PhysicalDeviceExternalFenceInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceExternalFenceInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.ExternalFenceHandleTypeFlags HandleType;
	public PhysicalDeviceExternalFenceInfo(
		in Vk.ExternalFenceHandleTypeFlags handleType = default
	) {
		sType = TYPE;
		pNext = null;
		HandleType = handleType;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceExternalFenceInfo o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceExternalFenceInfo>.Equals(PhysicalDeviceExternalFenceInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ HandleType.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceExternalFenceInfo l, in PhysicalDeviceExternalFenceInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.HandleType == r.HandleType)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceExternalFenceInfo l, in PhysicalDeviceExternalFenceInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.HandleType != r.HandleType)
			;
	}


	/// <summary>Creates a new PhysicalDeviceExternalFenceInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceExternalFenceInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ExternalFenceProperties : IEquatable<ExternalFenceProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ExternalFenceProperties;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.ExternalFenceHandleTypeFlags ExportFromImportedHandleTypes;
	public Vk.ExternalFenceHandleTypeFlags CompatibleHandleTypes;
	public Vk.ExternalFenceFeatureFlags ExternalFenceFeatures;
	public ExternalFenceProperties(
		in Vk.ExternalFenceHandleTypeFlags exportFromImportedHandleTypes = default,
		in Vk.ExternalFenceHandleTypeFlags compatibleHandleTypes = default,
		in Vk.ExternalFenceFeatureFlags externalFenceFeatures = default
	) {
		sType = TYPE;
		pNext = null;
		ExportFromImportedHandleTypes = exportFromImportedHandleTypes;
		CompatibleHandleTypes = compatibleHandleTypes;
		ExternalFenceFeatures = externalFenceFeatures;
	}


	public readonly override bool Equals(object? obj) => (obj is ExternalFenceProperties o) && (this == o);
	readonly bool IEquatable<ExternalFenceProperties>.Equals(ExternalFenceProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ExportFromImportedHandleTypes.GetHashCode() ^ CompatibleHandleTypes.GetHashCode()
			^ ExternalFenceFeatures.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ExternalFenceProperties l, in ExternalFenceProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ExportFromImportedHandleTypes == r.ExportFromImportedHandleTypes) && (l.CompatibleHandleTypes == r.CompatibleHandleTypes)
			&& (l.ExternalFenceFeatures == r.ExternalFenceFeatures)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ExternalFenceProperties l, in ExternalFenceProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ExportFromImportedHandleTypes != r.ExportFromImportedHandleTypes) || (l.CompatibleHandleTypes != r.CompatibleHandleTypes)
			|| (l.ExternalFenceFeatures != r.ExternalFenceFeatures)
			;
	}


	/// <summary>Creates a new ExternalFenceProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ExternalFenceProperties value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ExportFenceCreateInfo : IEquatable<ExportFenceCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ExportFenceCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.ExternalFenceHandleTypeFlags HandleTypes;
	public ExportFenceCreateInfo(
		in Vk.ExternalFenceHandleTypeFlags handleTypes = default
	) {
		sType = TYPE;
		pNext = null;
		HandleTypes = handleTypes;
	}


	public readonly override bool Equals(object? obj) => (obj is ExportFenceCreateInfo o) && (this == o);
	readonly bool IEquatable<ExportFenceCreateInfo>.Equals(ExportFenceCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ HandleTypes.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ExportFenceCreateInfo l, in ExportFenceCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.HandleTypes == r.HandleTypes)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ExportFenceCreateInfo l, in ExportFenceCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.HandleTypes != r.HandleTypes)
			;
	}


	/// <summary>Creates a new ExportFenceCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ExportFenceCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceMultiviewFeatures : IEquatable<PhysicalDeviceMultiviewFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceMultiviewFeatures;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 Multiview;
	public Vk.Bool32 MultiviewGeometryShader;
	public Vk.Bool32 MultiviewTessellationShader;
	public PhysicalDeviceMultiviewFeatures(
		in Vk.Bool32 multiview = default,
		in Vk.Bool32 multiviewGeometryShader = default,
		in Vk.Bool32 multiviewTessellationShader = default
	) {
		sType = TYPE;
		pNext = null;
		Multiview = multiview;
		MultiviewGeometryShader = multiviewGeometryShader;
		MultiviewTessellationShader = multiviewTessellationShader;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceMultiviewFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceMultiviewFeatures>.Equals(PhysicalDeviceMultiviewFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Multiview.GetHashCode() ^ MultiviewGeometryShader.GetHashCode()
			^ MultiviewTessellationShader.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceMultiviewFeatures l, in PhysicalDeviceMultiviewFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Multiview == r.Multiview) && (l.MultiviewGeometryShader == r.MultiviewGeometryShader)
			&& (l.MultiviewTessellationShader == r.MultiviewTessellationShader)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceMultiviewFeatures l, in PhysicalDeviceMultiviewFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Multiview != r.Multiview) || (l.MultiviewGeometryShader != r.MultiviewGeometryShader)
			|| (l.MultiviewTessellationShader != r.MultiviewTessellationShader)
			;
	}


	/// <summary>Creates a new PhysicalDeviceMultiviewFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceMultiviewFeatures value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceMultiviewProperties : IEquatable<PhysicalDeviceMultiviewProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceMultiviewProperties;

	public Vk.StructureType sType;
	public void* pNext;
	public uint MaxMultiviewViewCount;
	public uint MaxMultiviewInstanceIndex;
	public PhysicalDeviceMultiviewProperties(
		uint maxMultiviewViewCount = default,
		uint maxMultiviewInstanceIndex = default
	) {
		sType = TYPE;
		pNext = null;
		MaxMultiviewViewCount = maxMultiviewViewCount;
		MaxMultiviewInstanceIndex = maxMultiviewInstanceIndex;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceMultiviewProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceMultiviewProperties>.Equals(PhysicalDeviceMultiviewProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MaxMultiviewViewCount.GetHashCode() ^ MaxMultiviewInstanceIndex.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceMultiviewProperties l, in PhysicalDeviceMultiviewProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MaxMultiviewViewCount == r.MaxMultiviewViewCount) && (l.MaxMultiviewInstanceIndex == r.MaxMultiviewInstanceIndex)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceMultiviewProperties l, in PhysicalDeviceMultiviewProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MaxMultiviewViewCount != r.MaxMultiviewViewCount) || (l.MaxMultiviewInstanceIndex != r.MaxMultiviewInstanceIndex)
			;
	}


	/// <summary>Creates a new PhysicalDeviceMultiviewProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceMultiviewProperties value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct RenderPassMultiviewCreateInfo : IEquatable<RenderPassMultiviewCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.RenderPassMultiviewCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public uint SubpassCount;
	public uint* ViewMasks;
	public uint DependencyCount;
	public int* ViewOffsets;
	public uint CorrelationMaskCount;
	public uint* CorrelationMasks;
	public RenderPassMultiviewCreateInfo(
		uint subpassCount = default,
		uint* viewMasks = default,
		uint dependencyCount = default,
		int* viewOffsets = default,
		uint correlationMaskCount = default,
		uint* correlationMasks = default
	) {
		sType = TYPE;
		pNext = null;
		SubpassCount = subpassCount;
		ViewMasks = viewMasks;
		DependencyCount = dependencyCount;
		ViewOffsets = viewOffsets;
		CorrelationMaskCount = correlationMaskCount;
		CorrelationMasks = correlationMasks;
	}


	public readonly override bool Equals(object? obj) => (obj is RenderPassMultiviewCreateInfo o) && (this == o);
	readonly bool IEquatable<RenderPassMultiviewCreateInfo>.Equals(RenderPassMultiviewCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SubpassCount.GetHashCode() ^ ((ulong)ViewMasks).GetHashCode()
			^ DependencyCount.GetHashCode() ^ ((ulong)ViewOffsets).GetHashCode() ^ CorrelationMaskCount.GetHashCode() ^ ((ulong)CorrelationMasks).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in RenderPassMultiviewCreateInfo l, in RenderPassMultiviewCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SubpassCount == r.SubpassCount) && (l.ViewMasks == r.ViewMasks)
			&& (l.DependencyCount == r.DependencyCount) && (l.ViewOffsets == r.ViewOffsets) && (l.CorrelationMaskCount == r.CorrelationMaskCount) && (l.CorrelationMasks == r.CorrelationMasks)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in RenderPassMultiviewCreateInfo l, in RenderPassMultiviewCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SubpassCount != r.SubpassCount) || (l.ViewMasks != r.ViewMasks)
			|| (l.DependencyCount != r.DependencyCount) || (l.ViewOffsets != r.ViewOffsets) || (l.CorrelationMaskCount != r.CorrelationMaskCount) || (l.CorrelationMasks != r.CorrelationMasks)
			;
	}


	/// <summary>Creates a new RenderPassMultiviewCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out RenderPassMultiviewCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceGroupProperties : IEquatable<PhysicalDeviceGroupProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceGroupProperties;

	public Vk.StructureType sType;
	public void* pNext;
	public uint PhysicalDeviceCount;
	public Vk.Handle<Vk.PhysicalDevice> PhysicalDevices_0;
	public Vk.Handle<Vk.PhysicalDevice> PhysicalDevices_1;
	public Vk.Handle<Vk.PhysicalDevice> PhysicalDevices_2;
	public Vk.Handle<Vk.PhysicalDevice> PhysicalDevices_3;
	public Vk.Handle<Vk.PhysicalDevice> PhysicalDevices_4;
	public Vk.Handle<Vk.PhysicalDevice> PhysicalDevices_5;
	public Vk.Handle<Vk.PhysicalDevice> PhysicalDevices_6;
	public Vk.Handle<Vk.PhysicalDevice> PhysicalDevices_7;
	public Vk.Handle<Vk.PhysicalDevice> PhysicalDevices_8;
	public Vk.Handle<Vk.PhysicalDevice> PhysicalDevices_9;
	public Vk.Handle<Vk.PhysicalDevice> PhysicalDevices_10;
	public Vk.Handle<Vk.PhysicalDevice> PhysicalDevices_11;
	public Vk.Handle<Vk.PhysicalDevice> PhysicalDevices_12;
	public Vk.Handle<Vk.PhysicalDevice> PhysicalDevices_13;
	public Vk.Handle<Vk.PhysicalDevice> PhysicalDevices_14;
	public Vk.Handle<Vk.PhysicalDevice> PhysicalDevices_15;
	public Vk.Handle<Vk.PhysicalDevice> PhysicalDevices_16;
	public Vk.Handle<Vk.PhysicalDevice> PhysicalDevices_17;
	public Vk.Handle<Vk.PhysicalDevice> PhysicalDevices_18;
	public Vk.Handle<Vk.PhysicalDevice> PhysicalDevices_19;
	public Vk.Handle<Vk.PhysicalDevice> PhysicalDevices_20;
	public Vk.Handle<Vk.PhysicalDevice> PhysicalDevices_21;
	public Vk.Handle<Vk.PhysicalDevice> PhysicalDevices_22;
	public Vk.Handle<Vk.PhysicalDevice> PhysicalDevices_23;
	public Vk.Handle<Vk.PhysicalDevice> PhysicalDevices_24;
	public Vk.Handle<Vk.PhysicalDevice> PhysicalDevices_25;
	public Vk.Handle<Vk.PhysicalDevice> PhysicalDevices_26;
	public Vk.Handle<Vk.PhysicalDevice> PhysicalDevices_27;
	public Vk.Handle<Vk.PhysicalDevice> PhysicalDevices_28;
	public Vk.Handle<Vk.PhysicalDevice> PhysicalDevices_29;
	public Vk.Handle<Vk.PhysicalDevice> PhysicalDevices_30;
	public Vk.Handle<Vk.PhysicalDevice> PhysicalDevices_31;
	public Vk.Bool32 SubsetAllocation;
	public PhysicalDeviceGroupProperties(
		uint physicalDeviceCount = default,
		in Vk.Handle<Vk.PhysicalDevice> physicalDevices0 = default,
		in Vk.Handle<Vk.PhysicalDevice> physicalDevices1 = default,
		in Vk.Handle<Vk.PhysicalDevice> physicalDevices2 = default,
		in Vk.Handle<Vk.PhysicalDevice> physicalDevices3 = default,
		in Vk.Handle<Vk.PhysicalDevice> physicalDevices4 = default,
		in Vk.Handle<Vk.PhysicalDevice> physicalDevices5 = default,
		in Vk.Handle<Vk.PhysicalDevice> physicalDevices6 = default,
		in Vk.Handle<Vk.PhysicalDevice> physicalDevices7 = default,
		in Vk.Handle<Vk.PhysicalDevice> physicalDevices8 = default,
		in Vk.Handle<Vk.PhysicalDevice> physicalDevices9 = default,
		in Vk.Handle<Vk.PhysicalDevice> physicalDevices10 = default,
		in Vk.Handle<Vk.PhysicalDevice> physicalDevices11 = default,
		in Vk.Handle<Vk.PhysicalDevice> physicalDevices12 = default,
		in Vk.Handle<Vk.PhysicalDevice> physicalDevices13 = default,
		in Vk.Handle<Vk.PhysicalDevice> physicalDevices14 = default,
		in Vk.Handle<Vk.PhysicalDevice> physicalDevices15 = default,
		in Vk.Handle<Vk.PhysicalDevice> physicalDevices16 = default,
		in Vk.Handle<Vk.PhysicalDevice> physicalDevices17 = default,
		in Vk.Handle<Vk.PhysicalDevice> physicalDevices18 = default,
		in Vk.Handle<Vk.PhysicalDevice> physicalDevices19 = default,
		in Vk.Handle<Vk.PhysicalDevice> physicalDevices20 = default,
		in Vk.Handle<Vk.PhysicalDevice> physicalDevices21 = default,
		in Vk.Handle<Vk.PhysicalDevice> physicalDevices22 = default,
		in Vk.Handle<Vk.PhysicalDevice> physicalDevices23 = default,
		in Vk.Handle<Vk.PhysicalDevice> physicalDevices24 = default,
		in Vk.Handle<Vk.PhysicalDevice> physicalDevices25 = default,
		in Vk.Handle<Vk.PhysicalDevice> physicalDevices26 = default,
		in Vk.Handle<Vk.PhysicalDevice> physicalDevices27 = default,
		in Vk.Handle<Vk.PhysicalDevice> physicalDevices28 = default,
		in Vk.Handle<Vk.PhysicalDevice> physicalDevices29 = default,
		in Vk.Handle<Vk.PhysicalDevice> physicalDevices30 = default,
		in Vk.Handle<Vk.PhysicalDevice> physicalDevices31 = default,
		in Vk.Bool32 subsetAllocation = default
	) {
		sType = TYPE;
		pNext = null;
		PhysicalDeviceCount = physicalDeviceCount;
		PhysicalDevices_0 = physicalDevices0;
		PhysicalDevices_1 = physicalDevices1;
		PhysicalDevices_2 = physicalDevices2;
		PhysicalDevices_3 = physicalDevices3;
		PhysicalDevices_4 = physicalDevices4;
		PhysicalDevices_5 = physicalDevices5;
		PhysicalDevices_6 = physicalDevices6;
		PhysicalDevices_7 = physicalDevices7;
		PhysicalDevices_8 = physicalDevices8;
		PhysicalDevices_9 = physicalDevices9;
		PhysicalDevices_10 = physicalDevices10;
		PhysicalDevices_11 = physicalDevices11;
		PhysicalDevices_12 = physicalDevices12;
		PhysicalDevices_13 = physicalDevices13;
		PhysicalDevices_14 = physicalDevices14;
		PhysicalDevices_15 = physicalDevices15;
		PhysicalDevices_16 = physicalDevices16;
		PhysicalDevices_17 = physicalDevices17;
		PhysicalDevices_18 = physicalDevices18;
		PhysicalDevices_19 = physicalDevices19;
		PhysicalDevices_20 = physicalDevices20;
		PhysicalDevices_21 = physicalDevices21;
		PhysicalDevices_22 = physicalDevices22;
		PhysicalDevices_23 = physicalDevices23;
		PhysicalDevices_24 = physicalDevices24;
		PhysicalDevices_25 = physicalDevices25;
		PhysicalDevices_26 = physicalDevices26;
		PhysicalDevices_27 = physicalDevices27;
		PhysicalDevices_28 = physicalDevices28;
		PhysicalDevices_29 = physicalDevices29;
		PhysicalDevices_30 = physicalDevices30;
		PhysicalDevices_31 = physicalDevices31;
		SubsetAllocation = subsetAllocation;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceGroupProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceGroupProperties>.Equals(PhysicalDeviceGroupProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ PhysicalDeviceCount.GetHashCode() ^ PhysicalDevices_0.GetHashCode()
			^ PhysicalDevices_1.GetHashCode() ^ PhysicalDevices_2.GetHashCode() ^ PhysicalDevices_3.GetHashCode() ^ PhysicalDevices_4.GetHashCode()
			^ PhysicalDevices_5.GetHashCode() ^ PhysicalDevices_6.GetHashCode() ^ PhysicalDevices_7.GetHashCode() ^ PhysicalDevices_8.GetHashCode()
			^ PhysicalDevices_9.GetHashCode() ^ PhysicalDevices_10.GetHashCode() ^ PhysicalDevices_11.GetHashCode() ^ PhysicalDevices_12.GetHashCode()
			^ PhysicalDevices_13.GetHashCode() ^ PhysicalDevices_14.GetHashCode() ^ PhysicalDevices_15.GetHashCode() ^ PhysicalDevices_16.GetHashCode()
			^ PhysicalDevices_17.GetHashCode() ^ PhysicalDevices_18.GetHashCode() ^ PhysicalDevices_19.GetHashCode() ^ PhysicalDevices_20.GetHashCode()
			^ PhysicalDevices_21.GetHashCode() ^ PhysicalDevices_22.GetHashCode() ^ PhysicalDevices_23.GetHashCode() ^ PhysicalDevices_24.GetHashCode()
			^ PhysicalDevices_25.GetHashCode() ^ PhysicalDevices_26.GetHashCode() ^ PhysicalDevices_27.GetHashCode() ^ PhysicalDevices_28.GetHashCode()
			^ PhysicalDevices_29.GetHashCode() ^ PhysicalDevices_30.GetHashCode() ^ PhysicalDevices_31.GetHashCode() ^ SubsetAllocation.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceGroupProperties l, in PhysicalDeviceGroupProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.PhysicalDeviceCount == r.PhysicalDeviceCount) && (l.PhysicalDevices_0 == r.PhysicalDevices_0)
			&& (l.PhysicalDevices_1 == r.PhysicalDevices_1) && (l.PhysicalDevices_2 == r.PhysicalDevices_2) && (l.PhysicalDevices_3 == r.PhysicalDevices_3) && (l.PhysicalDevices_4 == r.PhysicalDevices_4)
			&& (l.PhysicalDevices_5 == r.PhysicalDevices_5) && (l.PhysicalDevices_6 == r.PhysicalDevices_6) && (l.PhysicalDevices_7 == r.PhysicalDevices_7) && (l.PhysicalDevices_8 == r.PhysicalDevices_8)
			&& (l.PhysicalDevices_9 == r.PhysicalDevices_9) && (l.PhysicalDevices_10 == r.PhysicalDevices_10) && (l.PhysicalDevices_11 == r.PhysicalDevices_11) && (l.PhysicalDevices_12 == r.PhysicalDevices_12)
			&& (l.PhysicalDevices_13 == r.PhysicalDevices_13) && (l.PhysicalDevices_14 == r.PhysicalDevices_14) && (l.PhysicalDevices_15 == r.PhysicalDevices_15) && (l.PhysicalDevices_16 == r.PhysicalDevices_16)
			&& (l.PhysicalDevices_17 == r.PhysicalDevices_17) && (l.PhysicalDevices_18 == r.PhysicalDevices_18) && (l.PhysicalDevices_19 == r.PhysicalDevices_19) && (l.PhysicalDevices_20 == r.PhysicalDevices_20)
			&& (l.PhysicalDevices_21 == r.PhysicalDevices_21) && (l.PhysicalDevices_22 == r.PhysicalDevices_22) && (l.PhysicalDevices_23 == r.PhysicalDevices_23) && (l.PhysicalDevices_24 == r.PhysicalDevices_24)
			&& (l.PhysicalDevices_25 == r.PhysicalDevices_25) && (l.PhysicalDevices_26 == r.PhysicalDevices_26) && (l.PhysicalDevices_27 == r.PhysicalDevices_27) && (l.PhysicalDevices_28 == r.PhysicalDevices_28)
			&& (l.PhysicalDevices_29 == r.PhysicalDevices_29) && (l.PhysicalDevices_30 == r.PhysicalDevices_30) && (l.PhysicalDevices_31 == r.PhysicalDevices_31) && (l.SubsetAllocation == r.SubsetAllocation)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceGroupProperties l, in PhysicalDeviceGroupProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.PhysicalDeviceCount != r.PhysicalDeviceCount) || (l.PhysicalDevices_0 != r.PhysicalDevices_0)
			|| (l.PhysicalDevices_1 != r.PhysicalDevices_1) || (l.PhysicalDevices_2 != r.PhysicalDevices_2) || (l.PhysicalDevices_3 != r.PhysicalDevices_3) || (l.PhysicalDevices_4 != r.PhysicalDevices_4)
			|| (l.PhysicalDevices_5 != r.PhysicalDevices_5) || (l.PhysicalDevices_6 != r.PhysicalDevices_6) || (l.PhysicalDevices_7 != r.PhysicalDevices_7) || (l.PhysicalDevices_8 != r.PhysicalDevices_8)
			|| (l.PhysicalDevices_9 != r.PhysicalDevices_9) || (l.PhysicalDevices_10 != r.PhysicalDevices_10) || (l.PhysicalDevices_11 != r.PhysicalDevices_11) || (l.PhysicalDevices_12 != r.PhysicalDevices_12)
			|| (l.PhysicalDevices_13 != r.PhysicalDevices_13) || (l.PhysicalDevices_14 != r.PhysicalDevices_14) || (l.PhysicalDevices_15 != r.PhysicalDevices_15) || (l.PhysicalDevices_16 != r.PhysicalDevices_16)
			|| (l.PhysicalDevices_17 != r.PhysicalDevices_17) || (l.PhysicalDevices_18 != r.PhysicalDevices_18) || (l.PhysicalDevices_19 != r.PhysicalDevices_19) || (l.PhysicalDevices_20 != r.PhysicalDevices_20)
			|| (l.PhysicalDevices_21 != r.PhysicalDevices_21) || (l.PhysicalDevices_22 != r.PhysicalDevices_22) || (l.PhysicalDevices_23 != r.PhysicalDevices_23) || (l.PhysicalDevices_24 != r.PhysicalDevices_24)
			|| (l.PhysicalDevices_25 != r.PhysicalDevices_25) || (l.PhysicalDevices_26 != r.PhysicalDevices_26) || (l.PhysicalDevices_27 != r.PhysicalDevices_27) || (l.PhysicalDevices_28 != r.PhysicalDevices_28)
			|| (l.PhysicalDevices_29 != r.PhysicalDevices_29) || (l.PhysicalDevices_30 != r.PhysicalDevices_30) || (l.PhysicalDevices_31 != r.PhysicalDevices_31) || (l.SubsetAllocation != r.SubsetAllocation)
			;
	}


	/// <summary>Creates a new PhysicalDeviceGroupProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceGroupProperties value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct MemoryAllocateFlagsInfo : IEquatable<MemoryAllocateFlagsInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.MemoryAllocateFlagsInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.MemoryAllocateFlags Flags;
	public uint DeviceMask;
	public MemoryAllocateFlagsInfo(
		in Vk.MemoryAllocateFlags flags = default,
		uint deviceMask = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		DeviceMask = deviceMask;
	}


	public readonly override bool Equals(object? obj) => (obj is MemoryAllocateFlagsInfo o) && (this == o);
	readonly bool IEquatable<MemoryAllocateFlagsInfo>.Equals(MemoryAllocateFlagsInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ DeviceMask.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in MemoryAllocateFlagsInfo l, in MemoryAllocateFlagsInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.DeviceMask == r.DeviceMask)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in MemoryAllocateFlagsInfo l, in MemoryAllocateFlagsInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.DeviceMask != r.DeviceMask)
			;
	}


	/// <summary>Creates a new MemoryAllocateFlagsInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out MemoryAllocateFlagsInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct BindBufferMemoryInfo : IEquatable<BindBufferMemoryInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.BindBufferMemoryInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Handle<Vk.Buffer> Buffer;
	public Vk.Handle<Vk.DeviceMemory> Memory;
	public Vk.DeviceSize MemoryOffset;
	public BindBufferMemoryInfo(
		in Vk.Handle<Vk.Buffer> buffer = default,
		in Vk.Handle<Vk.DeviceMemory> memory = default,
		in Vk.DeviceSize memoryOffset = default
	) {
		sType = TYPE;
		pNext = null;
		Buffer = buffer;
		Memory = memory;
		MemoryOffset = memoryOffset;
	}


	public readonly override bool Equals(object? obj) => (obj is BindBufferMemoryInfo o) && (this == o);
	readonly bool IEquatable<BindBufferMemoryInfo>.Equals(BindBufferMemoryInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Buffer.GetHashCode() ^ Memory.GetHashCode()
			^ MemoryOffset.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in BindBufferMemoryInfo l, in BindBufferMemoryInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Buffer == r.Buffer) && (l.Memory == r.Memory)
			&& (l.MemoryOffset == r.MemoryOffset)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in BindBufferMemoryInfo l, in BindBufferMemoryInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Buffer != r.Buffer) || (l.Memory != r.Memory)
			|| (l.MemoryOffset != r.MemoryOffset)
			;
	}


	/// <summary>Creates a new BindBufferMemoryInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out BindBufferMemoryInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct BindBufferMemoryDeviceGroupInfo : IEquatable<BindBufferMemoryDeviceGroupInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.BindBufferMemoryDeviceGroupInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public uint DeviceIndexCount;
	public uint* DeviceIndices;
	public BindBufferMemoryDeviceGroupInfo(
		uint deviceIndexCount = default,
		uint* deviceIndices = default
	) {
		sType = TYPE;
		pNext = null;
		DeviceIndexCount = deviceIndexCount;
		DeviceIndices = deviceIndices;
	}


	public readonly override bool Equals(object? obj) => (obj is BindBufferMemoryDeviceGroupInfo o) && (this == o);
	readonly bool IEquatable<BindBufferMemoryDeviceGroupInfo>.Equals(BindBufferMemoryDeviceGroupInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DeviceIndexCount.GetHashCode() ^ ((ulong)DeviceIndices).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in BindBufferMemoryDeviceGroupInfo l, in BindBufferMemoryDeviceGroupInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DeviceIndexCount == r.DeviceIndexCount) && (l.DeviceIndices == r.DeviceIndices)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in BindBufferMemoryDeviceGroupInfo l, in BindBufferMemoryDeviceGroupInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DeviceIndexCount != r.DeviceIndexCount) || (l.DeviceIndices != r.DeviceIndices)
			;
	}


	/// <summary>Creates a new BindBufferMemoryDeviceGroupInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out BindBufferMemoryDeviceGroupInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct BindImageMemoryInfo : IEquatable<BindImageMemoryInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.BindImageMemoryInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Handle<Vk.Image> Image;
	public Vk.Handle<Vk.DeviceMemory> Memory;
	public Vk.DeviceSize MemoryOffset;
	public BindImageMemoryInfo(
		in Vk.Handle<Vk.Image> image = default,
		in Vk.Handle<Vk.DeviceMemory> memory = default,
		in Vk.DeviceSize memoryOffset = default
	) {
		sType = TYPE;
		pNext = null;
		Image = image;
		Memory = memory;
		MemoryOffset = memoryOffset;
	}


	public readonly override bool Equals(object? obj) => (obj is BindImageMemoryInfo o) && (this == o);
	readonly bool IEquatable<BindImageMemoryInfo>.Equals(BindImageMemoryInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Image.GetHashCode() ^ Memory.GetHashCode()
			^ MemoryOffset.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in BindImageMemoryInfo l, in BindImageMemoryInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Image == r.Image) && (l.Memory == r.Memory)
			&& (l.MemoryOffset == r.MemoryOffset)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in BindImageMemoryInfo l, in BindImageMemoryInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Image != r.Image) || (l.Memory != r.Memory)
			|| (l.MemoryOffset != r.MemoryOffset)
			;
	}


	/// <summary>Creates a new BindImageMemoryInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out BindImageMemoryInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct BindImageMemoryDeviceGroupInfo : IEquatable<BindImageMemoryDeviceGroupInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.BindImageMemoryDeviceGroupInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public uint DeviceIndexCount;
	public uint* DeviceIndices;
	public uint SplitInstanceBindRegionCount;
	public Vk.Rect2D* SplitInstanceBindRegions;
	public BindImageMemoryDeviceGroupInfo(
		uint deviceIndexCount = default,
		uint* deviceIndices = default,
		uint splitInstanceBindRegionCount = default,
		in Vk.Rect2D* splitInstanceBindRegions = default
	) {
		sType = TYPE;
		pNext = null;
		DeviceIndexCount = deviceIndexCount;
		DeviceIndices = deviceIndices;
		SplitInstanceBindRegionCount = splitInstanceBindRegionCount;
		SplitInstanceBindRegions = splitInstanceBindRegions;
	}


	public readonly override bool Equals(object? obj) => (obj is BindImageMemoryDeviceGroupInfo o) && (this == o);
	readonly bool IEquatable<BindImageMemoryDeviceGroupInfo>.Equals(BindImageMemoryDeviceGroupInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DeviceIndexCount.GetHashCode() ^ ((ulong)DeviceIndices).GetHashCode()
			^ SplitInstanceBindRegionCount.GetHashCode() ^ ((ulong)SplitInstanceBindRegions).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in BindImageMemoryDeviceGroupInfo l, in BindImageMemoryDeviceGroupInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DeviceIndexCount == r.DeviceIndexCount) && (l.DeviceIndices == r.DeviceIndices)
			&& (l.SplitInstanceBindRegionCount == r.SplitInstanceBindRegionCount) && (l.SplitInstanceBindRegions == r.SplitInstanceBindRegions)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in BindImageMemoryDeviceGroupInfo l, in BindImageMemoryDeviceGroupInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DeviceIndexCount != r.DeviceIndexCount) || (l.DeviceIndices != r.DeviceIndices)
			|| (l.SplitInstanceBindRegionCount != r.SplitInstanceBindRegionCount) || (l.SplitInstanceBindRegions != r.SplitInstanceBindRegions)
			;
	}


	/// <summary>Creates a new BindImageMemoryDeviceGroupInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out BindImageMemoryDeviceGroupInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DeviceGroupRenderPassBeginInfo : IEquatable<DeviceGroupRenderPassBeginInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DeviceGroupRenderPassBeginInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public uint DeviceMask;
	public uint DeviceRenderAreaCount;
	public Vk.Rect2D* DeviceRenderAreas;
	public DeviceGroupRenderPassBeginInfo(
		uint deviceMask = default,
		uint deviceRenderAreaCount = default,
		in Vk.Rect2D* deviceRenderAreas = default
	) {
		sType = TYPE;
		pNext = null;
		DeviceMask = deviceMask;
		DeviceRenderAreaCount = deviceRenderAreaCount;
		DeviceRenderAreas = deviceRenderAreas;
	}


	public readonly override bool Equals(object? obj) => (obj is DeviceGroupRenderPassBeginInfo o) && (this == o);
	readonly bool IEquatable<DeviceGroupRenderPassBeginInfo>.Equals(DeviceGroupRenderPassBeginInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DeviceMask.GetHashCode() ^ DeviceRenderAreaCount.GetHashCode()
			^ ((ulong)DeviceRenderAreas).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DeviceGroupRenderPassBeginInfo l, in DeviceGroupRenderPassBeginInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DeviceMask == r.DeviceMask) && (l.DeviceRenderAreaCount == r.DeviceRenderAreaCount)
			&& (l.DeviceRenderAreas == r.DeviceRenderAreas)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DeviceGroupRenderPassBeginInfo l, in DeviceGroupRenderPassBeginInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DeviceMask != r.DeviceMask) || (l.DeviceRenderAreaCount != r.DeviceRenderAreaCount)
			|| (l.DeviceRenderAreas != r.DeviceRenderAreas)
			;
	}


	/// <summary>Creates a new DeviceGroupRenderPassBeginInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DeviceGroupRenderPassBeginInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DeviceGroupCommandBufferBeginInfo : IEquatable<DeviceGroupCommandBufferBeginInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DeviceGroupCommandBufferBeginInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public uint DeviceMask;
	public DeviceGroupCommandBufferBeginInfo(
		uint deviceMask = default
	) {
		sType = TYPE;
		pNext = null;
		DeviceMask = deviceMask;
	}


	public readonly override bool Equals(object? obj) => (obj is DeviceGroupCommandBufferBeginInfo o) && (this == o);
	readonly bool IEquatable<DeviceGroupCommandBufferBeginInfo>.Equals(DeviceGroupCommandBufferBeginInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DeviceMask.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DeviceGroupCommandBufferBeginInfo l, in DeviceGroupCommandBufferBeginInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DeviceMask == r.DeviceMask)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DeviceGroupCommandBufferBeginInfo l, in DeviceGroupCommandBufferBeginInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DeviceMask != r.DeviceMask)
			;
	}


	/// <summary>Creates a new DeviceGroupCommandBufferBeginInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DeviceGroupCommandBufferBeginInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DeviceGroupSubmitInfo : IEquatable<DeviceGroupSubmitInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DeviceGroupSubmitInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public uint WaitSemaphoreCount;
	public uint* WaitSemaphoreDeviceIndices;
	public uint CommandBufferCount;
	public uint* CommandBufferDeviceMasks;
	public uint SignalSemaphoreCount;
	public uint* SignalSemaphoreDeviceIndices;
	public DeviceGroupSubmitInfo(
		uint waitSemaphoreCount = default,
		uint* waitSemaphoreDeviceIndices = default,
		uint commandBufferCount = default,
		uint* commandBufferDeviceMasks = default,
		uint signalSemaphoreCount = default,
		uint* signalSemaphoreDeviceIndices = default
	) {
		sType = TYPE;
		pNext = null;
		WaitSemaphoreCount = waitSemaphoreCount;
		WaitSemaphoreDeviceIndices = waitSemaphoreDeviceIndices;
		CommandBufferCount = commandBufferCount;
		CommandBufferDeviceMasks = commandBufferDeviceMasks;
		SignalSemaphoreCount = signalSemaphoreCount;
		SignalSemaphoreDeviceIndices = signalSemaphoreDeviceIndices;
	}


	public readonly override bool Equals(object? obj) => (obj is DeviceGroupSubmitInfo o) && (this == o);
	readonly bool IEquatable<DeviceGroupSubmitInfo>.Equals(DeviceGroupSubmitInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ WaitSemaphoreCount.GetHashCode() ^ ((ulong)WaitSemaphoreDeviceIndices).GetHashCode()
			^ CommandBufferCount.GetHashCode() ^ ((ulong)CommandBufferDeviceMasks).GetHashCode() ^ SignalSemaphoreCount.GetHashCode() ^ ((ulong)SignalSemaphoreDeviceIndices).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DeviceGroupSubmitInfo l, in DeviceGroupSubmitInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.WaitSemaphoreCount == r.WaitSemaphoreCount) && (l.WaitSemaphoreDeviceIndices == r.WaitSemaphoreDeviceIndices)
			&& (l.CommandBufferCount == r.CommandBufferCount) && (l.CommandBufferDeviceMasks == r.CommandBufferDeviceMasks) && (l.SignalSemaphoreCount == r.SignalSemaphoreCount) && (l.SignalSemaphoreDeviceIndices == r.SignalSemaphoreDeviceIndices)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DeviceGroupSubmitInfo l, in DeviceGroupSubmitInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.WaitSemaphoreCount != r.WaitSemaphoreCount) || (l.WaitSemaphoreDeviceIndices != r.WaitSemaphoreDeviceIndices)
			|| (l.CommandBufferCount != r.CommandBufferCount) || (l.CommandBufferDeviceMasks != r.CommandBufferDeviceMasks) || (l.SignalSemaphoreCount != r.SignalSemaphoreCount) || (l.SignalSemaphoreDeviceIndices != r.SignalSemaphoreDeviceIndices)
			;
	}


	/// <summary>Creates a new DeviceGroupSubmitInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DeviceGroupSubmitInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DeviceGroupBindSparseInfo : IEquatable<DeviceGroupBindSparseInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DeviceGroupBindSparseInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public uint ResourceDeviceIndex;
	public uint MemoryDeviceIndex;
	public DeviceGroupBindSparseInfo(
		uint resourceDeviceIndex = default,
		uint memoryDeviceIndex = default
	) {
		sType = TYPE;
		pNext = null;
		ResourceDeviceIndex = resourceDeviceIndex;
		MemoryDeviceIndex = memoryDeviceIndex;
	}


	public readonly override bool Equals(object? obj) => (obj is DeviceGroupBindSparseInfo o) && (this == o);
	readonly bool IEquatable<DeviceGroupBindSparseInfo>.Equals(DeviceGroupBindSparseInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ResourceDeviceIndex.GetHashCode() ^ MemoryDeviceIndex.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DeviceGroupBindSparseInfo l, in DeviceGroupBindSparseInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ResourceDeviceIndex == r.ResourceDeviceIndex) && (l.MemoryDeviceIndex == r.MemoryDeviceIndex)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DeviceGroupBindSparseInfo l, in DeviceGroupBindSparseInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ResourceDeviceIndex != r.ResourceDeviceIndex) || (l.MemoryDeviceIndex != r.MemoryDeviceIndex)
			;
	}


	/// <summary>Creates a new DeviceGroupBindSparseInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DeviceGroupBindSparseInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DeviceGroupDeviceCreateInfo : IEquatable<DeviceGroupDeviceCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DeviceGroupDeviceCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public uint PhysicalDeviceCount;
	public Vk.Handle<Vk.PhysicalDevice>* PhysicalDevices;
	public DeviceGroupDeviceCreateInfo(
		uint physicalDeviceCount = default,
		in Vk.Handle<Vk.PhysicalDevice>* physicalDevices = default
	) {
		sType = TYPE;
		pNext = null;
		PhysicalDeviceCount = physicalDeviceCount;
		PhysicalDevices = physicalDevices;
	}


	public readonly override bool Equals(object? obj) => (obj is DeviceGroupDeviceCreateInfo o) && (this == o);
	readonly bool IEquatable<DeviceGroupDeviceCreateInfo>.Equals(DeviceGroupDeviceCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ PhysicalDeviceCount.GetHashCode() ^ ((ulong)PhysicalDevices).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DeviceGroupDeviceCreateInfo l, in DeviceGroupDeviceCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.PhysicalDeviceCount == r.PhysicalDeviceCount) && (l.PhysicalDevices == r.PhysicalDevices)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DeviceGroupDeviceCreateInfo l, in DeviceGroupDeviceCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.PhysicalDeviceCount != r.PhysicalDeviceCount) || (l.PhysicalDevices != r.PhysicalDevices)
			;
	}


	/// <summary>Creates a new DeviceGroupDeviceCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DeviceGroupDeviceCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DescriptorUpdateTemplateEntry : IEquatable<DescriptorUpdateTemplateEntry>
{
	public uint DstBinding;
	public uint DstArrayElement;
	public uint DescriptorCount;
	public Vk.DescriptorType DescriptorType;
	public ulong Offset;
	public ulong Stride;
	public DescriptorUpdateTemplateEntry(
		uint dstBinding = default,
		uint dstArrayElement = default,
		uint descriptorCount = default,
		in Vk.DescriptorType descriptorType = default,
		ulong offset = default,
		ulong stride = default
	) {
		DstBinding = dstBinding;
		DstArrayElement = dstArrayElement;
		DescriptorCount = descriptorCount;
		DescriptorType = descriptorType;
		Offset = offset;
		Stride = stride;
	}


	public readonly override bool Equals(object? obj) => (obj is DescriptorUpdateTemplateEntry o) && (this == o);
	readonly bool IEquatable<DescriptorUpdateTemplateEntry>.Equals(DescriptorUpdateTemplateEntry obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			DstBinding.GetHashCode() ^ DstArrayElement.GetHashCode() ^ DescriptorCount.GetHashCode() ^ DescriptorType.GetHashCode()
			^ Offset.GetHashCode() ^ Stride.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DescriptorUpdateTemplateEntry l, in DescriptorUpdateTemplateEntry r)
	{
		return
			(l.DstBinding == r.DstBinding) && (l.DstArrayElement == r.DstArrayElement) && (l.DescriptorCount == r.DescriptorCount) && (l.DescriptorType == r.DescriptorType)
			&& (l.Offset == r.Offset) && (l.Stride == r.Stride)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DescriptorUpdateTemplateEntry l, in DescriptorUpdateTemplateEntry r)
	{
		return
			(l.DstBinding != r.DstBinding) || (l.DstArrayElement != r.DstArrayElement) || (l.DescriptorCount != r.DescriptorCount) || (l.DescriptorType != r.DescriptorType)
			|| (l.Offset != r.Offset) || (l.Stride != r.Stride)
			;
	}


	/// <summary>Creates a new DescriptorUpdateTemplateEntry value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DescriptorUpdateTemplateEntry value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DescriptorUpdateTemplateCreateInfo : IEquatable<DescriptorUpdateTemplateCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DescriptorUpdateTemplateCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.DescriptorUpdateTemplateCreateFlags Flags;
	public uint DescriptorUpdateEntryCount;
	public Vk.DescriptorUpdateTemplateEntry* DescriptorUpdateEntries;
	public Vk.DescriptorUpdateTemplateType TemplateType;
	public Vk.Handle<Vk.DescriptorSetLayout> DescriptorSetLayout;
	public Vk.PipelineBindPoint PipelineBindPoint;
	public Vk.Handle<Vk.PipelineLayout> PipelineLayout;
	public uint Set;
	public DescriptorUpdateTemplateCreateInfo(
		in Vk.DescriptorUpdateTemplateCreateFlags flags = default,
		uint descriptorUpdateEntryCount = default,
		in Vk.DescriptorUpdateTemplateEntry* descriptorUpdateEntries = default,
		in Vk.DescriptorUpdateTemplateType templateType = default,
		in Vk.Handle<Vk.DescriptorSetLayout> descriptorSetLayout = default,
		in Vk.PipelineBindPoint pipelineBindPoint = default,
		in Vk.Handle<Vk.PipelineLayout> pipelineLayout = default,
		uint set = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		DescriptorUpdateEntryCount = descriptorUpdateEntryCount;
		DescriptorUpdateEntries = descriptorUpdateEntries;
		TemplateType = templateType;
		DescriptorSetLayout = descriptorSetLayout;
		PipelineBindPoint = pipelineBindPoint;
		PipelineLayout = pipelineLayout;
		Set = set;
	}


	public readonly override bool Equals(object? obj) => (obj is DescriptorUpdateTemplateCreateInfo o) && (this == o);
	readonly bool IEquatable<DescriptorUpdateTemplateCreateInfo>.Equals(DescriptorUpdateTemplateCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ DescriptorUpdateEntryCount.GetHashCode()
			^ ((ulong)DescriptorUpdateEntries).GetHashCode() ^ TemplateType.GetHashCode() ^ DescriptorSetLayout.GetHashCode() ^ PipelineBindPoint.GetHashCode()
			^ PipelineLayout.GetHashCode() ^ Set.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DescriptorUpdateTemplateCreateInfo l, in DescriptorUpdateTemplateCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.DescriptorUpdateEntryCount == r.DescriptorUpdateEntryCount)
			&& (l.DescriptorUpdateEntries == r.DescriptorUpdateEntries) && (l.TemplateType == r.TemplateType) && (l.DescriptorSetLayout == r.DescriptorSetLayout) && (l.PipelineBindPoint == r.PipelineBindPoint)
			&& (l.PipelineLayout == r.PipelineLayout) && (l.Set == r.Set)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DescriptorUpdateTemplateCreateInfo l, in DescriptorUpdateTemplateCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.DescriptorUpdateEntryCount != r.DescriptorUpdateEntryCount)
			|| (l.DescriptorUpdateEntries != r.DescriptorUpdateEntries) || (l.TemplateType != r.TemplateType) || (l.DescriptorSetLayout != r.DescriptorSetLayout) || (l.PipelineBindPoint != r.PipelineBindPoint)
			|| (l.PipelineLayout != r.PipelineLayout) || (l.Set != r.Set)
			;
	}


	/// <summary>Creates a new DescriptorUpdateTemplateCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DescriptorUpdateTemplateCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct InputAttachmentAspectReference : IEquatable<InputAttachmentAspectReference>
{
	public uint Subpass;
	public uint InputAttachmentIndex;
	public Vk.ImageAspectFlags AspectMask;
	public InputAttachmentAspectReference(
		uint subpass = default,
		uint inputAttachmentIndex = default,
		in Vk.ImageAspectFlags aspectMask = default
	) {
		Subpass = subpass;
		InputAttachmentIndex = inputAttachmentIndex;
		AspectMask = aspectMask;
	}


	public readonly override bool Equals(object? obj) => (obj is InputAttachmentAspectReference o) && (this == o);
	readonly bool IEquatable<InputAttachmentAspectReference>.Equals(InputAttachmentAspectReference obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Subpass.GetHashCode() ^ InputAttachmentIndex.GetHashCode() ^ AspectMask.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in InputAttachmentAspectReference l, in InputAttachmentAspectReference r)
	{
		return
			(l.Subpass == r.Subpass) && (l.InputAttachmentIndex == r.InputAttachmentIndex) && (l.AspectMask == r.AspectMask)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in InputAttachmentAspectReference l, in InputAttachmentAspectReference r)
	{
		return
			(l.Subpass != r.Subpass) || (l.InputAttachmentIndex != r.InputAttachmentIndex) || (l.AspectMask != r.AspectMask)
			;
	}


	/// <summary>Creates a new InputAttachmentAspectReference value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out InputAttachmentAspectReference value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct RenderPassInputAttachmentAspectCreateInfo : IEquatable<RenderPassInputAttachmentAspectCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.RenderPassInputAttachmentAspectCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public uint AspectReferenceCount;
	public Vk.InputAttachmentAspectReference* AspectReferences;
	public RenderPassInputAttachmentAspectCreateInfo(
		uint aspectReferenceCount = default,
		in Vk.InputAttachmentAspectReference* aspectReferences = default
	) {
		sType = TYPE;
		pNext = null;
		AspectReferenceCount = aspectReferenceCount;
		AspectReferences = aspectReferences;
	}


	public readonly override bool Equals(object? obj) => (obj is RenderPassInputAttachmentAspectCreateInfo o) && (this == o);
	readonly bool IEquatable<RenderPassInputAttachmentAspectCreateInfo>.Equals(RenderPassInputAttachmentAspectCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ AspectReferenceCount.GetHashCode() ^ ((ulong)AspectReferences).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in RenderPassInputAttachmentAspectCreateInfo l, in RenderPassInputAttachmentAspectCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.AspectReferenceCount == r.AspectReferenceCount) && (l.AspectReferences == r.AspectReferences)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in RenderPassInputAttachmentAspectCreateInfo l, in RenderPassInputAttachmentAspectCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.AspectReferenceCount != r.AspectReferenceCount) || (l.AspectReferences != r.AspectReferences)
			;
	}


	/// <summary>Creates a new RenderPassInputAttachmentAspectCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out RenderPassInputAttachmentAspectCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDevice16BitStorageFeatures : IEquatable<PhysicalDevice16BitStorageFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDevice16BitStorageFeatures;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 StorageBuffer16BitAccess;
	public Vk.Bool32 UniformAndStorageBuffer16BitAccess;
	public Vk.Bool32 StoragePushConstant16;
	public Vk.Bool32 StorageInputOutput16;
	public PhysicalDevice16BitStorageFeatures(
		in Vk.Bool32 storageBuffer16BitAccess = default,
		in Vk.Bool32 uniformAndStorageBuffer16BitAccess = default,
		in Vk.Bool32 storagePushConstant16 = default,
		in Vk.Bool32 storageInputOutput16 = default
	) {
		sType = TYPE;
		pNext = null;
		StorageBuffer16BitAccess = storageBuffer16BitAccess;
		UniformAndStorageBuffer16BitAccess = uniformAndStorageBuffer16BitAccess;
		StoragePushConstant16 = storagePushConstant16;
		StorageInputOutput16 = storageInputOutput16;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDevice16BitStorageFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDevice16BitStorageFeatures>.Equals(PhysicalDevice16BitStorageFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ StorageBuffer16BitAccess.GetHashCode() ^ UniformAndStorageBuffer16BitAccess.GetHashCode()
			^ StoragePushConstant16.GetHashCode() ^ StorageInputOutput16.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDevice16BitStorageFeatures l, in PhysicalDevice16BitStorageFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.StorageBuffer16BitAccess == r.StorageBuffer16BitAccess) && (l.UniformAndStorageBuffer16BitAccess == r.UniformAndStorageBuffer16BitAccess)
			&& (l.StoragePushConstant16 == r.StoragePushConstant16) && (l.StorageInputOutput16 == r.StorageInputOutput16)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDevice16BitStorageFeatures l, in PhysicalDevice16BitStorageFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.StorageBuffer16BitAccess != r.StorageBuffer16BitAccess) || (l.UniformAndStorageBuffer16BitAccess != r.UniformAndStorageBuffer16BitAccess)
			|| (l.StoragePushConstant16 != r.StoragePushConstant16) || (l.StorageInputOutput16 != r.StorageInputOutput16)
			;
	}


	/// <summary>Creates a new PhysicalDevice16BitStorageFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDevice16BitStorageFeatures value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceSubgroupProperties : IEquatable<PhysicalDeviceSubgroupProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceSubgroupProperties;

	public Vk.StructureType sType;
	public void* pNext;
	public uint SubgroupSize;
	public Vk.ShaderStageFlags SupportedStages;
	public Vk.SubgroupFeatureFlags SupportedOperations;
	public Vk.Bool32 QuadOperationsInAllStages;
	public PhysicalDeviceSubgroupProperties(
		uint subgroupSize = default,
		in Vk.ShaderStageFlags supportedStages = default,
		in Vk.SubgroupFeatureFlags supportedOperations = default,
		in Vk.Bool32 quadOperationsInAllStages = default
	) {
		sType = TYPE;
		pNext = null;
		SubgroupSize = subgroupSize;
		SupportedStages = supportedStages;
		SupportedOperations = supportedOperations;
		QuadOperationsInAllStages = quadOperationsInAllStages;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceSubgroupProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceSubgroupProperties>.Equals(PhysicalDeviceSubgroupProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SubgroupSize.GetHashCode() ^ SupportedStages.GetHashCode()
			^ SupportedOperations.GetHashCode() ^ QuadOperationsInAllStages.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceSubgroupProperties l, in PhysicalDeviceSubgroupProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SubgroupSize == r.SubgroupSize) && (l.SupportedStages == r.SupportedStages)
			&& (l.SupportedOperations == r.SupportedOperations) && (l.QuadOperationsInAllStages == r.QuadOperationsInAllStages)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceSubgroupProperties l, in PhysicalDeviceSubgroupProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SubgroupSize != r.SubgroupSize) || (l.SupportedStages != r.SupportedStages)
			|| (l.SupportedOperations != r.SupportedOperations) || (l.QuadOperationsInAllStages != r.QuadOperationsInAllStages)
			;
	}


	/// <summary>Creates a new PhysicalDeviceSubgroupProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceSubgroupProperties value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceShaderSubgroupExtendedTypesFeatures : IEquatable<PhysicalDeviceShaderSubgroupExtendedTypesFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceShaderSubgroupExtendedTypesFeatures;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 ShaderSubgroupExtendedTypes;
	public PhysicalDeviceShaderSubgroupExtendedTypesFeatures(
		in Vk.Bool32 shaderSubgroupExtendedTypes = default
	) {
		sType = TYPE;
		pNext = null;
		ShaderSubgroupExtendedTypes = shaderSubgroupExtendedTypes;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceShaderSubgroupExtendedTypesFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceShaderSubgroupExtendedTypesFeatures>.Equals(PhysicalDeviceShaderSubgroupExtendedTypesFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ShaderSubgroupExtendedTypes.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceShaderSubgroupExtendedTypesFeatures l, in PhysicalDeviceShaderSubgroupExtendedTypesFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ShaderSubgroupExtendedTypes == r.ShaderSubgroupExtendedTypes)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceShaderSubgroupExtendedTypesFeatures l, in PhysicalDeviceShaderSubgroupExtendedTypesFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ShaderSubgroupExtendedTypes != r.ShaderSubgroupExtendedTypes)
			;
	}


	/// <summary>Creates a new PhysicalDeviceShaderSubgroupExtendedTypesFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceShaderSubgroupExtendedTypesFeatures value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct BufferMemoryRequirementsInfo2 : IEquatable<BufferMemoryRequirementsInfo2>
{
	public const Vk.StructureType TYPE = Vk.StructureType.BufferMemoryRequirementsInfo2;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Handle<Vk.Buffer> Buffer;
	public BufferMemoryRequirementsInfo2(
		in Vk.Handle<Vk.Buffer> buffer = default
	) {
		sType = TYPE;
		pNext = null;
		Buffer = buffer;
	}


	public readonly override bool Equals(object? obj) => (obj is BufferMemoryRequirementsInfo2 o) && (this == o);
	readonly bool IEquatable<BufferMemoryRequirementsInfo2>.Equals(BufferMemoryRequirementsInfo2 obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Buffer.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in BufferMemoryRequirementsInfo2 l, in BufferMemoryRequirementsInfo2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Buffer == r.Buffer)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in BufferMemoryRequirementsInfo2 l, in BufferMemoryRequirementsInfo2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Buffer != r.Buffer)
			;
	}


	/// <summary>Creates a new BufferMemoryRequirementsInfo2 value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out BufferMemoryRequirementsInfo2 value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ImageMemoryRequirementsInfo2 : IEquatable<ImageMemoryRequirementsInfo2>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ImageMemoryRequirementsInfo2;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Handle<Vk.Image> Image;
	public ImageMemoryRequirementsInfo2(
		in Vk.Handle<Vk.Image> image = default
	) {
		sType = TYPE;
		pNext = null;
		Image = image;
	}


	public readonly override bool Equals(object? obj) => (obj is ImageMemoryRequirementsInfo2 o) && (this == o);
	readonly bool IEquatable<ImageMemoryRequirementsInfo2>.Equals(ImageMemoryRequirementsInfo2 obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Image.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ImageMemoryRequirementsInfo2 l, in ImageMemoryRequirementsInfo2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Image == r.Image)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ImageMemoryRequirementsInfo2 l, in ImageMemoryRequirementsInfo2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Image != r.Image)
			;
	}


	/// <summary>Creates a new ImageMemoryRequirementsInfo2 value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ImageMemoryRequirementsInfo2 value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ImageSparseMemoryRequirementsInfo2 : IEquatable<ImageSparseMemoryRequirementsInfo2>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ImageSparseMemoryRequirementsInfo2;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Handle<Vk.Image> Image;
	public ImageSparseMemoryRequirementsInfo2(
		in Vk.Handle<Vk.Image> image = default
	) {
		sType = TYPE;
		pNext = null;
		Image = image;
	}


	public readonly override bool Equals(object? obj) => (obj is ImageSparseMemoryRequirementsInfo2 o) && (this == o);
	readonly bool IEquatable<ImageSparseMemoryRequirementsInfo2>.Equals(ImageSparseMemoryRequirementsInfo2 obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Image.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ImageSparseMemoryRequirementsInfo2 l, in ImageSparseMemoryRequirementsInfo2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Image == r.Image)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ImageSparseMemoryRequirementsInfo2 l, in ImageSparseMemoryRequirementsInfo2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Image != r.Image)
			;
	}


	/// <summary>Creates a new ImageSparseMemoryRequirementsInfo2 value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ImageSparseMemoryRequirementsInfo2 value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct MemoryRequirements2 : IEquatable<MemoryRequirements2>
{
	public const Vk.StructureType TYPE = Vk.StructureType.MemoryRequirements2;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.MemoryRequirements MemoryRequirements;
	public MemoryRequirements2(
		in Vk.MemoryRequirements memoryRequirements = default
	) {
		sType = TYPE;
		pNext = null;
		MemoryRequirements = memoryRequirements;
	}


	public readonly override bool Equals(object? obj) => (obj is MemoryRequirements2 o) && (this == o);
	readonly bool IEquatable<MemoryRequirements2>.Equals(MemoryRequirements2 obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MemoryRequirements.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in MemoryRequirements2 l, in MemoryRequirements2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MemoryRequirements == r.MemoryRequirements)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in MemoryRequirements2 l, in MemoryRequirements2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MemoryRequirements != r.MemoryRequirements)
			;
	}


	/// <summary>Creates a new MemoryRequirements2 value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out MemoryRequirements2 value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SparseImageMemoryRequirements2 : IEquatable<SparseImageMemoryRequirements2>
{
	public const Vk.StructureType TYPE = Vk.StructureType.SparseImageMemoryRequirements2;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.SparseImageMemoryRequirements MemoryRequirements;
	public SparseImageMemoryRequirements2(
		in Vk.SparseImageMemoryRequirements memoryRequirements = default
	) {
		sType = TYPE;
		pNext = null;
		MemoryRequirements = memoryRequirements;
	}


	public readonly override bool Equals(object? obj) => (obj is SparseImageMemoryRequirements2 o) && (this == o);
	readonly bool IEquatable<SparseImageMemoryRequirements2>.Equals(SparseImageMemoryRequirements2 obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MemoryRequirements.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SparseImageMemoryRequirements2 l, in SparseImageMemoryRequirements2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MemoryRequirements == r.MemoryRequirements)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SparseImageMemoryRequirements2 l, in SparseImageMemoryRequirements2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MemoryRequirements != r.MemoryRequirements)
			;
	}


	/// <summary>Creates a new SparseImageMemoryRequirements2 value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SparseImageMemoryRequirements2 value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDevicePointClippingProperties : IEquatable<PhysicalDevicePointClippingProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDevicePointClippingProperties;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.PointClippingBehavior PointClippingBehavior;
	public PhysicalDevicePointClippingProperties(
		in Vk.PointClippingBehavior pointClippingBehavior = default
	) {
		sType = TYPE;
		pNext = null;
		PointClippingBehavior = pointClippingBehavior;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDevicePointClippingProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDevicePointClippingProperties>.Equals(PhysicalDevicePointClippingProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ PointClippingBehavior.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDevicePointClippingProperties l, in PhysicalDevicePointClippingProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.PointClippingBehavior == r.PointClippingBehavior)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDevicePointClippingProperties l, in PhysicalDevicePointClippingProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.PointClippingBehavior != r.PointClippingBehavior)
			;
	}


	/// <summary>Creates a new PhysicalDevicePointClippingProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDevicePointClippingProperties value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct MemoryDedicatedRequirements : IEquatable<MemoryDedicatedRequirements>
{
	public const Vk.StructureType TYPE = Vk.StructureType.MemoryDedicatedRequirements;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 PrefersDedicatedAllocation;
	public Vk.Bool32 RequiresDedicatedAllocation;
	public MemoryDedicatedRequirements(
		in Vk.Bool32 prefersDedicatedAllocation = default,
		in Vk.Bool32 requiresDedicatedAllocation = default
	) {
		sType = TYPE;
		pNext = null;
		PrefersDedicatedAllocation = prefersDedicatedAllocation;
		RequiresDedicatedAllocation = requiresDedicatedAllocation;
	}


	public readonly override bool Equals(object? obj) => (obj is MemoryDedicatedRequirements o) && (this == o);
	readonly bool IEquatable<MemoryDedicatedRequirements>.Equals(MemoryDedicatedRequirements obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ PrefersDedicatedAllocation.GetHashCode() ^ RequiresDedicatedAllocation.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in MemoryDedicatedRequirements l, in MemoryDedicatedRequirements r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.PrefersDedicatedAllocation == r.PrefersDedicatedAllocation) && (l.RequiresDedicatedAllocation == r.RequiresDedicatedAllocation)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in MemoryDedicatedRequirements l, in MemoryDedicatedRequirements r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.PrefersDedicatedAllocation != r.PrefersDedicatedAllocation) || (l.RequiresDedicatedAllocation != r.RequiresDedicatedAllocation)
			;
	}


	/// <summary>Creates a new MemoryDedicatedRequirements value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out MemoryDedicatedRequirements value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct MemoryDedicatedAllocateInfo : IEquatable<MemoryDedicatedAllocateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.MemoryDedicatedAllocateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Handle<Vk.Image> Image;
	public Vk.Handle<Vk.Buffer> Buffer;
	public MemoryDedicatedAllocateInfo(
		in Vk.Handle<Vk.Image> image = default,
		in Vk.Handle<Vk.Buffer> buffer = default
	) {
		sType = TYPE;
		pNext = null;
		Image = image;
		Buffer = buffer;
	}


	public readonly override bool Equals(object? obj) => (obj is MemoryDedicatedAllocateInfo o) && (this == o);
	readonly bool IEquatable<MemoryDedicatedAllocateInfo>.Equals(MemoryDedicatedAllocateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Image.GetHashCode() ^ Buffer.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in MemoryDedicatedAllocateInfo l, in MemoryDedicatedAllocateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Image == r.Image) && (l.Buffer == r.Buffer)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in MemoryDedicatedAllocateInfo l, in MemoryDedicatedAllocateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Image != r.Image) || (l.Buffer != r.Buffer)
			;
	}


	/// <summary>Creates a new MemoryDedicatedAllocateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out MemoryDedicatedAllocateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ImageViewUsageCreateInfo : IEquatable<ImageViewUsageCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ImageViewUsageCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.ImageUsageFlags Usage;
	public ImageViewUsageCreateInfo(
		in Vk.ImageUsageFlags usage = default
	) {
		sType = TYPE;
		pNext = null;
		Usage = usage;
	}


	public readonly override bool Equals(object? obj) => (obj is ImageViewUsageCreateInfo o) && (this == o);
	readonly bool IEquatable<ImageViewUsageCreateInfo>.Equals(ImageViewUsageCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Usage.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ImageViewUsageCreateInfo l, in ImageViewUsageCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Usage == r.Usage)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ImageViewUsageCreateInfo l, in ImageViewUsageCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Usage != r.Usage)
			;
	}


	/// <summary>Creates a new ImageViewUsageCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ImageViewUsageCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PipelineTessellationDomainOriginStateCreateInfo : IEquatable<PipelineTessellationDomainOriginStateCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PipelineTessellationDomainOriginStateCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.TessellationDomainOrigin DomainOrigin;
	public PipelineTessellationDomainOriginStateCreateInfo(
		in Vk.TessellationDomainOrigin domainOrigin = default
	) {
		sType = TYPE;
		pNext = null;
		DomainOrigin = domainOrigin;
	}


	public readonly override bool Equals(object? obj) => (obj is PipelineTessellationDomainOriginStateCreateInfo o) && (this == o);
	readonly bool IEquatable<PipelineTessellationDomainOriginStateCreateInfo>.Equals(PipelineTessellationDomainOriginStateCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DomainOrigin.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PipelineTessellationDomainOriginStateCreateInfo l, in PipelineTessellationDomainOriginStateCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DomainOrigin == r.DomainOrigin)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PipelineTessellationDomainOriginStateCreateInfo l, in PipelineTessellationDomainOriginStateCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DomainOrigin != r.DomainOrigin)
			;
	}


	/// <summary>Creates a new PipelineTessellationDomainOriginStateCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PipelineTessellationDomainOriginStateCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SamplerYcbcrConversionInfo : IEquatable<SamplerYcbcrConversionInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.SamplerYcbcrConversionInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Handle<Vk.SamplerYcbcrConversion> Conversion;
	public SamplerYcbcrConversionInfo(
		in Vk.Handle<Vk.SamplerYcbcrConversion> conversion = default
	) {
		sType = TYPE;
		pNext = null;
		Conversion = conversion;
	}


	public readonly override bool Equals(object? obj) => (obj is SamplerYcbcrConversionInfo o) && (this == o);
	readonly bool IEquatable<SamplerYcbcrConversionInfo>.Equals(SamplerYcbcrConversionInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Conversion.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SamplerYcbcrConversionInfo l, in SamplerYcbcrConversionInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Conversion == r.Conversion)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SamplerYcbcrConversionInfo l, in SamplerYcbcrConversionInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Conversion != r.Conversion)
			;
	}


	/// <summary>Creates a new SamplerYcbcrConversionInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SamplerYcbcrConversionInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SamplerYcbcrConversionCreateInfo : IEquatable<SamplerYcbcrConversionCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.SamplerYcbcrConversionCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Format Format;
	public Vk.SamplerYcbcrModelConversion YcbcrModel;
	public Vk.SamplerYcbcrRange YcbcrRange;
	public Vk.ComponentMapping Components;
	public Vk.ChromaLocation XChromaOffset;
	public Vk.ChromaLocation YChromaOffset;
	public Vk.Filter ChromaFilter;
	public Vk.Bool32 ForceExplicitReconstruction;
	public SamplerYcbcrConversionCreateInfo(
		in Vk.Format format = default,
		in Vk.SamplerYcbcrModelConversion ycbcrModel = default,
		in Vk.SamplerYcbcrRange ycbcrRange = default,
		in Vk.ComponentMapping components = default,
		in Vk.ChromaLocation xChromaOffset = default,
		in Vk.ChromaLocation yChromaOffset = default,
		in Vk.Filter chromaFilter = default,
		in Vk.Bool32 forceExplicitReconstruction = default
	) {
		sType = TYPE;
		pNext = null;
		Format = format;
		YcbcrModel = ycbcrModel;
		YcbcrRange = ycbcrRange;
		Components = components;
		XChromaOffset = xChromaOffset;
		YChromaOffset = yChromaOffset;
		ChromaFilter = chromaFilter;
		ForceExplicitReconstruction = forceExplicitReconstruction;
	}


	public readonly override bool Equals(object? obj) => (obj is SamplerYcbcrConversionCreateInfo o) && (this == o);
	readonly bool IEquatable<SamplerYcbcrConversionCreateInfo>.Equals(SamplerYcbcrConversionCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Format.GetHashCode() ^ YcbcrModel.GetHashCode()
			^ YcbcrRange.GetHashCode() ^ Components.GetHashCode() ^ XChromaOffset.GetHashCode() ^ YChromaOffset.GetHashCode()
			^ ChromaFilter.GetHashCode() ^ ForceExplicitReconstruction.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SamplerYcbcrConversionCreateInfo l, in SamplerYcbcrConversionCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Format == r.Format) && (l.YcbcrModel == r.YcbcrModel)
			&& (l.YcbcrRange == r.YcbcrRange) && (l.Components == r.Components) && (l.XChromaOffset == r.XChromaOffset) && (l.YChromaOffset == r.YChromaOffset)
			&& (l.ChromaFilter == r.ChromaFilter) && (l.ForceExplicitReconstruction == r.ForceExplicitReconstruction)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SamplerYcbcrConversionCreateInfo l, in SamplerYcbcrConversionCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Format != r.Format) || (l.YcbcrModel != r.YcbcrModel)
			|| (l.YcbcrRange != r.YcbcrRange) || (l.Components != r.Components) || (l.XChromaOffset != r.XChromaOffset) || (l.YChromaOffset != r.YChromaOffset)
			|| (l.ChromaFilter != r.ChromaFilter) || (l.ForceExplicitReconstruction != r.ForceExplicitReconstruction)
			;
	}


	/// <summary>Creates a new SamplerYcbcrConversionCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SamplerYcbcrConversionCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct BindImagePlaneMemoryInfo : IEquatable<BindImagePlaneMemoryInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.BindImagePlaneMemoryInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.ImageAspectFlags PlaneAspect;
	public BindImagePlaneMemoryInfo(
		in Vk.ImageAspectFlags planeAspect = default
	) {
		sType = TYPE;
		pNext = null;
		PlaneAspect = planeAspect;
	}


	public readonly override bool Equals(object? obj) => (obj is BindImagePlaneMemoryInfo o) && (this == o);
	readonly bool IEquatable<BindImagePlaneMemoryInfo>.Equals(BindImagePlaneMemoryInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ PlaneAspect.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in BindImagePlaneMemoryInfo l, in BindImagePlaneMemoryInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.PlaneAspect == r.PlaneAspect)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in BindImagePlaneMemoryInfo l, in BindImagePlaneMemoryInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.PlaneAspect != r.PlaneAspect)
			;
	}


	/// <summary>Creates a new BindImagePlaneMemoryInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out BindImagePlaneMemoryInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ImagePlaneMemoryRequirementsInfo : IEquatable<ImagePlaneMemoryRequirementsInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ImagePlaneMemoryRequirementsInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.ImageAspectFlags PlaneAspect;
	public ImagePlaneMemoryRequirementsInfo(
		in Vk.ImageAspectFlags planeAspect = default
	) {
		sType = TYPE;
		pNext = null;
		PlaneAspect = planeAspect;
	}


	public readonly override bool Equals(object? obj) => (obj is ImagePlaneMemoryRequirementsInfo o) && (this == o);
	readonly bool IEquatable<ImagePlaneMemoryRequirementsInfo>.Equals(ImagePlaneMemoryRequirementsInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ PlaneAspect.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ImagePlaneMemoryRequirementsInfo l, in ImagePlaneMemoryRequirementsInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.PlaneAspect == r.PlaneAspect)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ImagePlaneMemoryRequirementsInfo l, in ImagePlaneMemoryRequirementsInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.PlaneAspect != r.PlaneAspect)
			;
	}


	/// <summary>Creates a new ImagePlaneMemoryRequirementsInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ImagePlaneMemoryRequirementsInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceSamplerYcbcrConversionFeatures : IEquatable<PhysicalDeviceSamplerYcbcrConversionFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceSamplerYcbcrConversionFeatures;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 SamplerYcbcrConversion;
	public PhysicalDeviceSamplerYcbcrConversionFeatures(
		in Vk.Bool32 samplerYcbcrConversion = default
	) {
		sType = TYPE;
		pNext = null;
		SamplerYcbcrConversion = samplerYcbcrConversion;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceSamplerYcbcrConversionFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceSamplerYcbcrConversionFeatures>.Equals(PhysicalDeviceSamplerYcbcrConversionFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SamplerYcbcrConversion.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceSamplerYcbcrConversionFeatures l, in PhysicalDeviceSamplerYcbcrConversionFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SamplerYcbcrConversion == r.SamplerYcbcrConversion)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceSamplerYcbcrConversionFeatures l, in PhysicalDeviceSamplerYcbcrConversionFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SamplerYcbcrConversion != r.SamplerYcbcrConversion)
			;
	}


	/// <summary>Creates a new PhysicalDeviceSamplerYcbcrConversionFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceSamplerYcbcrConversionFeatures value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SamplerYcbcrConversionImageFormatProperties : IEquatable<SamplerYcbcrConversionImageFormatProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.SamplerYcbcrConversionImageFormatProperties;

	public Vk.StructureType sType;
	public void* pNext;
	public uint CombinedImageSamplerDescriptorCount;
	public SamplerYcbcrConversionImageFormatProperties(
		uint combinedImageSamplerDescriptorCount = default
	) {
		sType = TYPE;
		pNext = null;
		CombinedImageSamplerDescriptorCount = combinedImageSamplerDescriptorCount;
	}


	public readonly override bool Equals(object? obj) => (obj is SamplerYcbcrConversionImageFormatProperties o) && (this == o);
	readonly bool IEquatable<SamplerYcbcrConversionImageFormatProperties>.Equals(SamplerYcbcrConversionImageFormatProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ CombinedImageSamplerDescriptorCount.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SamplerYcbcrConversionImageFormatProperties l, in SamplerYcbcrConversionImageFormatProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.CombinedImageSamplerDescriptorCount == r.CombinedImageSamplerDescriptorCount)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SamplerYcbcrConversionImageFormatProperties l, in SamplerYcbcrConversionImageFormatProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.CombinedImageSamplerDescriptorCount != r.CombinedImageSamplerDescriptorCount)
			;
	}


	/// <summary>Creates a new SamplerYcbcrConversionImageFormatProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SamplerYcbcrConversionImageFormatProperties value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ProtectedSubmitInfo : IEquatable<ProtectedSubmitInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ProtectedSubmitInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 ProtectedSubmit;
	public ProtectedSubmitInfo(
		in Vk.Bool32 protectedSubmit = default
	) {
		sType = TYPE;
		pNext = null;
		ProtectedSubmit = protectedSubmit;
	}


	public readonly override bool Equals(object? obj) => (obj is ProtectedSubmitInfo o) && (this == o);
	readonly bool IEquatable<ProtectedSubmitInfo>.Equals(ProtectedSubmitInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ProtectedSubmit.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ProtectedSubmitInfo l, in ProtectedSubmitInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ProtectedSubmit == r.ProtectedSubmit)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ProtectedSubmitInfo l, in ProtectedSubmitInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ProtectedSubmit != r.ProtectedSubmit)
			;
	}


	/// <summary>Creates a new ProtectedSubmitInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ProtectedSubmitInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceProtectedMemoryFeatures : IEquatable<PhysicalDeviceProtectedMemoryFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceProtectedMemoryFeatures;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 ProtectedMemory;
	public PhysicalDeviceProtectedMemoryFeatures(
		in Vk.Bool32 protectedMemory = default
	) {
		sType = TYPE;
		pNext = null;
		ProtectedMemory = protectedMemory;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceProtectedMemoryFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceProtectedMemoryFeatures>.Equals(PhysicalDeviceProtectedMemoryFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ProtectedMemory.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceProtectedMemoryFeatures l, in PhysicalDeviceProtectedMemoryFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ProtectedMemory == r.ProtectedMemory)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceProtectedMemoryFeatures l, in PhysicalDeviceProtectedMemoryFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ProtectedMemory != r.ProtectedMemory)
			;
	}


	/// <summary>Creates a new PhysicalDeviceProtectedMemoryFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceProtectedMemoryFeatures value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceProtectedMemoryProperties : IEquatable<PhysicalDeviceProtectedMemoryProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceProtectedMemoryProperties;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 ProtectedNoFault;
	public PhysicalDeviceProtectedMemoryProperties(
		in Vk.Bool32 protectedNoFault = default
	) {
		sType = TYPE;
		pNext = null;
		ProtectedNoFault = protectedNoFault;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceProtectedMemoryProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceProtectedMemoryProperties>.Equals(PhysicalDeviceProtectedMemoryProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ProtectedNoFault.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceProtectedMemoryProperties l, in PhysicalDeviceProtectedMemoryProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ProtectedNoFault == r.ProtectedNoFault)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceProtectedMemoryProperties l, in PhysicalDeviceProtectedMemoryProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ProtectedNoFault != r.ProtectedNoFault)
			;
	}


	/// <summary>Creates a new PhysicalDeviceProtectedMemoryProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceProtectedMemoryProperties value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DeviceQueueInfo2 : IEquatable<DeviceQueueInfo2>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DeviceQueueInfo2;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.DeviceQueueCreateFlags Flags;
	public uint QueueFamilyIndex;
	public uint QueueIndex;
	public DeviceQueueInfo2(
		in Vk.DeviceQueueCreateFlags flags = default,
		uint queueFamilyIndex = default,
		uint queueIndex = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		QueueFamilyIndex = queueFamilyIndex;
		QueueIndex = queueIndex;
	}


	public readonly override bool Equals(object? obj) => (obj is DeviceQueueInfo2 o) && (this == o);
	readonly bool IEquatable<DeviceQueueInfo2>.Equals(DeviceQueueInfo2 obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ QueueFamilyIndex.GetHashCode()
			^ QueueIndex.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DeviceQueueInfo2 l, in DeviceQueueInfo2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.QueueFamilyIndex == r.QueueFamilyIndex)
			&& (l.QueueIndex == r.QueueIndex)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DeviceQueueInfo2 l, in DeviceQueueInfo2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.QueueFamilyIndex != r.QueueFamilyIndex)
			|| (l.QueueIndex != r.QueueIndex)
			;
	}


	/// <summary>Creates a new DeviceQueueInfo2 value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DeviceQueueInfo2 value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceSamplerFilterMinmaxProperties : IEquatable<PhysicalDeviceSamplerFilterMinmaxProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceSamplerFilterMinmaxProperties;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 FilterMinmaxSingleComponentFormats;
	public Vk.Bool32 FilterMinmaxImageComponentMapping;
	public PhysicalDeviceSamplerFilterMinmaxProperties(
		in Vk.Bool32 filterMinmaxSingleComponentFormats = default,
		in Vk.Bool32 filterMinmaxImageComponentMapping = default
	) {
		sType = TYPE;
		pNext = null;
		FilterMinmaxSingleComponentFormats = filterMinmaxSingleComponentFormats;
		FilterMinmaxImageComponentMapping = filterMinmaxImageComponentMapping;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceSamplerFilterMinmaxProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceSamplerFilterMinmaxProperties>.Equals(PhysicalDeviceSamplerFilterMinmaxProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ FilterMinmaxSingleComponentFormats.GetHashCode() ^ FilterMinmaxImageComponentMapping.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceSamplerFilterMinmaxProperties l, in PhysicalDeviceSamplerFilterMinmaxProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.FilterMinmaxSingleComponentFormats == r.FilterMinmaxSingleComponentFormats) && (l.FilterMinmaxImageComponentMapping == r.FilterMinmaxImageComponentMapping)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceSamplerFilterMinmaxProperties l, in PhysicalDeviceSamplerFilterMinmaxProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.FilterMinmaxSingleComponentFormats != r.FilterMinmaxSingleComponentFormats) || (l.FilterMinmaxImageComponentMapping != r.FilterMinmaxImageComponentMapping)
			;
	}


	/// <summary>Creates a new PhysicalDeviceSamplerFilterMinmaxProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceSamplerFilterMinmaxProperties value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SamplerReductionModeCreateInfo : IEquatable<SamplerReductionModeCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.SamplerReductionModeCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.SamplerReductionMode ReductionMode;
	public SamplerReductionModeCreateInfo(
		in Vk.SamplerReductionMode reductionMode = default
	) {
		sType = TYPE;
		pNext = null;
		ReductionMode = reductionMode;
	}


	public readonly override bool Equals(object? obj) => (obj is SamplerReductionModeCreateInfo o) && (this == o);
	readonly bool IEquatable<SamplerReductionModeCreateInfo>.Equals(SamplerReductionModeCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ReductionMode.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SamplerReductionModeCreateInfo l, in SamplerReductionModeCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ReductionMode == r.ReductionMode)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SamplerReductionModeCreateInfo l, in SamplerReductionModeCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ReductionMode != r.ReductionMode)
			;
	}


	/// <summary>Creates a new SamplerReductionModeCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SamplerReductionModeCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ImageFormatListCreateInfo : IEquatable<ImageFormatListCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ImageFormatListCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public uint ViewFormatCount;
	public Vk.Format* ViewFormats;
	public ImageFormatListCreateInfo(
		uint viewFormatCount = default,
		in Vk.Format* viewFormats = default
	) {
		sType = TYPE;
		pNext = null;
		ViewFormatCount = viewFormatCount;
		ViewFormats = viewFormats;
	}


	public readonly override bool Equals(object? obj) => (obj is ImageFormatListCreateInfo o) && (this == o);
	readonly bool IEquatable<ImageFormatListCreateInfo>.Equals(ImageFormatListCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ViewFormatCount.GetHashCode() ^ ((ulong)ViewFormats).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ImageFormatListCreateInfo l, in ImageFormatListCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ViewFormatCount == r.ViewFormatCount) && (l.ViewFormats == r.ViewFormats)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ImageFormatListCreateInfo l, in ImageFormatListCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ViewFormatCount != r.ViewFormatCount) || (l.ViewFormats != r.ViewFormats)
			;
	}


	/// <summary>Creates a new ImageFormatListCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ImageFormatListCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceMaintenance3Properties : IEquatable<PhysicalDeviceMaintenance3Properties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceMaintenance3Properties;

	public Vk.StructureType sType;
	public void* pNext;
	public uint MaxPerSetDescriptors;
	public Vk.DeviceSize MaxMemoryAllocationSize;
	public PhysicalDeviceMaintenance3Properties(
		uint maxPerSetDescriptors = default,
		in Vk.DeviceSize maxMemoryAllocationSize = default
	) {
		sType = TYPE;
		pNext = null;
		MaxPerSetDescriptors = maxPerSetDescriptors;
		MaxMemoryAllocationSize = maxMemoryAllocationSize;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceMaintenance3Properties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceMaintenance3Properties>.Equals(PhysicalDeviceMaintenance3Properties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MaxPerSetDescriptors.GetHashCode() ^ MaxMemoryAllocationSize.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceMaintenance3Properties l, in PhysicalDeviceMaintenance3Properties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MaxPerSetDescriptors == r.MaxPerSetDescriptors) && (l.MaxMemoryAllocationSize == r.MaxMemoryAllocationSize)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceMaintenance3Properties l, in PhysicalDeviceMaintenance3Properties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MaxPerSetDescriptors != r.MaxPerSetDescriptors) || (l.MaxMemoryAllocationSize != r.MaxMemoryAllocationSize)
			;
	}


	/// <summary>Creates a new PhysicalDeviceMaintenance3Properties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceMaintenance3Properties value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DescriptorSetLayoutSupport : IEquatable<DescriptorSetLayoutSupport>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DescriptorSetLayoutSupport;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 Supported;
	public DescriptorSetLayoutSupport(
		in Vk.Bool32 supported = default
	) {
		sType = TYPE;
		pNext = null;
		Supported = supported;
	}


	public readonly override bool Equals(object? obj) => (obj is DescriptorSetLayoutSupport o) && (this == o);
	readonly bool IEquatable<DescriptorSetLayoutSupport>.Equals(DescriptorSetLayoutSupport obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Supported.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DescriptorSetLayoutSupport l, in DescriptorSetLayoutSupport r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Supported == r.Supported)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DescriptorSetLayoutSupport l, in DescriptorSetLayoutSupport r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Supported != r.Supported)
			;
	}


	/// <summary>Creates a new DescriptorSetLayoutSupport value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DescriptorSetLayoutSupport value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceShaderDrawParametersFeatures : IEquatable<PhysicalDeviceShaderDrawParametersFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceShaderDrawParametersFeatures;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 ShaderDrawParameters;
	public PhysicalDeviceShaderDrawParametersFeatures(
		in Vk.Bool32 shaderDrawParameters = default
	) {
		sType = TYPE;
		pNext = null;
		ShaderDrawParameters = shaderDrawParameters;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceShaderDrawParametersFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceShaderDrawParametersFeatures>.Equals(PhysicalDeviceShaderDrawParametersFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ShaderDrawParameters.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceShaderDrawParametersFeatures l, in PhysicalDeviceShaderDrawParametersFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ShaderDrawParameters == r.ShaderDrawParameters)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceShaderDrawParametersFeatures l, in PhysicalDeviceShaderDrawParametersFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ShaderDrawParameters != r.ShaderDrawParameters)
			;
	}


	/// <summary>Creates a new PhysicalDeviceShaderDrawParametersFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceShaderDrawParametersFeatures value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceShaderDrawParameterFeatures : IEquatable<PhysicalDeviceShaderDrawParameterFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceShaderDrawParametersFeatures;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 ShaderDrawParameters;
	public PhysicalDeviceShaderDrawParameterFeatures(
		in Vk.Bool32 shaderDrawParameters = default
	) {
		sType = TYPE;
		pNext = null;
		ShaderDrawParameters = shaderDrawParameters;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceShaderDrawParameterFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceShaderDrawParameterFeatures>.Equals(PhysicalDeviceShaderDrawParameterFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ShaderDrawParameters.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceShaderDrawParameterFeatures l, in PhysicalDeviceShaderDrawParameterFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ShaderDrawParameters == r.ShaderDrawParameters)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceShaderDrawParameterFeatures l, in PhysicalDeviceShaderDrawParameterFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ShaderDrawParameters != r.ShaderDrawParameters)
			;
	}


	/// <summary>Creates a new PhysicalDeviceShaderDrawParameterFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceShaderDrawParameterFeatures value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceShaderFloat16Int8Features : IEquatable<PhysicalDeviceShaderFloat16Int8Features>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceShaderFloat16Int8Features;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 ShaderFloat16;
	public Vk.Bool32 ShaderInt8;
	public PhysicalDeviceShaderFloat16Int8Features(
		in Vk.Bool32 shaderFloat16 = default,
		in Vk.Bool32 shaderInt8 = default
	) {
		sType = TYPE;
		pNext = null;
		ShaderFloat16 = shaderFloat16;
		ShaderInt8 = shaderInt8;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceShaderFloat16Int8Features o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceShaderFloat16Int8Features>.Equals(PhysicalDeviceShaderFloat16Int8Features obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ShaderFloat16.GetHashCode() ^ ShaderInt8.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceShaderFloat16Int8Features l, in PhysicalDeviceShaderFloat16Int8Features r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ShaderFloat16 == r.ShaderFloat16) && (l.ShaderInt8 == r.ShaderInt8)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceShaderFloat16Int8Features l, in PhysicalDeviceShaderFloat16Int8Features r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ShaderFloat16 != r.ShaderFloat16) || (l.ShaderInt8 != r.ShaderInt8)
			;
	}


	/// <summary>Creates a new PhysicalDeviceShaderFloat16Int8Features value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceShaderFloat16Int8Features value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceFloatControlsProperties : IEquatable<PhysicalDeviceFloatControlsProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceFloatControlsProperties;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.ShaderFloatControlsIndependence DenormBehaviorIndependence;
	public Vk.ShaderFloatControlsIndependence RoundingModeIndependence;
	public Vk.Bool32 ShaderSignedZeroInfNanPreserveFloat16;
	public Vk.Bool32 ShaderSignedZeroInfNanPreserveFloat32;
	public Vk.Bool32 ShaderSignedZeroInfNanPreserveFloat64;
	public Vk.Bool32 ShaderDenormPreserveFloat16;
	public Vk.Bool32 ShaderDenormPreserveFloat32;
	public Vk.Bool32 ShaderDenormPreserveFloat64;
	public Vk.Bool32 ShaderDenormFlushToZeroFloat16;
	public Vk.Bool32 ShaderDenormFlushToZeroFloat32;
	public Vk.Bool32 ShaderDenormFlushToZeroFloat64;
	public Vk.Bool32 ShaderRoundingModeRTEFloat16;
	public Vk.Bool32 ShaderRoundingModeRTEFloat32;
	public Vk.Bool32 ShaderRoundingModeRTEFloat64;
	public Vk.Bool32 ShaderRoundingModeRTZFloat16;
	public Vk.Bool32 ShaderRoundingModeRTZFloat32;
	public Vk.Bool32 ShaderRoundingModeRTZFloat64;
	public PhysicalDeviceFloatControlsProperties(
		in Vk.ShaderFloatControlsIndependence denormBehaviorIndependence = default,
		in Vk.ShaderFloatControlsIndependence roundingModeIndependence = default,
		in Vk.Bool32 shaderSignedZeroInfNanPreserveFloat16 = default,
		in Vk.Bool32 shaderSignedZeroInfNanPreserveFloat32 = default,
		in Vk.Bool32 shaderSignedZeroInfNanPreserveFloat64 = default,
		in Vk.Bool32 shaderDenormPreserveFloat16 = default,
		in Vk.Bool32 shaderDenormPreserveFloat32 = default,
		in Vk.Bool32 shaderDenormPreserveFloat64 = default,
		in Vk.Bool32 shaderDenormFlushToZeroFloat16 = default,
		in Vk.Bool32 shaderDenormFlushToZeroFloat32 = default,
		in Vk.Bool32 shaderDenormFlushToZeroFloat64 = default,
		in Vk.Bool32 shaderRoundingModeRTEFloat16 = default,
		in Vk.Bool32 shaderRoundingModeRTEFloat32 = default,
		in Vk.Bool32 shaderRoundingModeRTEFloat64 = default,
		in Vk.Bool32 shaderRoundingModeRTZFloat16 = default,
		in Vk.Bool32 shaderRoundingModeRTZFloat32 = default,
		in Vk.Bool32 shaderRoundingModeRTZFloat64 = default
	) {
		sType = TYPE;
		pNext = null;
		DenormBehaviorIndependence = denormBehaviorIndependence;
		RoundingModeIndependence = roundingModeIndependence;
		ShaderSignedZeroInfNanPreserveFloat16 = shaderSignedZeroInfNanPreserveFloat16;
		ShaderSignedZeroInfNanPreserveFloat32 = shaderSignedZeroInfNanPreserveFloat32;
		ShaderSignedZeroInfNanPreserveFloat64 = shaderSignedZeroInfNanPreserveFloat64;
		ShaderDenormPreserveFloat16 = shaderDenormPreserveFloat16;
		ShaderDenormPreserveFloat32 = shaderDenormPreserveFloat32;
		ShaderDenormPreserveFloat64 = shaderDenormPreserveFloat64;
		ShaderDenormFlushToZeroFloat16 = shaderDenormFlushToZeroFloat16;
		ShaderDenormFlushToZeroFloat32 = shaderDenormFlushToZeroFloat32;
		ShaderDenormFlushToZeroFloat64 = shaderDenormFlushToZeroFloat64;
		ShaderRoundingModeRTEFloat16 = shaderRoundingModeRTEFloat16;
		ShaderRoundingModeRTEFloat32 = shaderRoundingModeRTEFloat32;
		ShaderRoundingModeRTEFloat64 = shaderRoundingModeRTEFloat64;
		ShaderRoundingModeRTZFloat16 = shaderRoundingModeRTZFloat16;
		ShaderRoundingModeRTZFloat32 = shaderRoundingModeRTZFloat32;
		ShaderRoundingModeRTZFloat64 = shaderRoundingModeRTZFloat64;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceFloatControlsProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceFloatControlsProperties>.Equals(PhysicalDeviceFloatControlsProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DenormBehaviorIndependence.GetHashCode() ^ RoundingModeIndependence.GetHashCode()
			^ ShaderSignedZeroInfNanPreserveFloat16.GetHashCode() ^ ShaderSignedZeroInfNanPreserveFloat32.GetHashCode() ^ ShaderSignedZeroInfNanPreserveFloat64.GetHashCode() ^ ShaderDenormPreserveFloat16.GetHashCode()
			^ ShaderDenormPreserveFloat32.GetHashCode() ^ ShaderDenormPreserveFloat64.GetHashCode() ^ ShaderDenormFlushToZeroFloat16.GetHashCode() ^ ShaderDenormFlushToZeroFloat32.GetHashCode()
			^ ShaderDenormFlushToZeroFloat64.GetHashCode() ^ ShaderRoundingModeRTEFloat16.GetHashCode() ^ ShaderRoundingModeRTEFloat32.GetHashCode() ^ ShaderRoundingModeRTEFloat64.GetHashCode()
			^ ShaderRoundingModeRTZFloat16.GetHashCode() ^ ShaderRoundingModeRTZFloat32.GetHashCode() ^ ShaderRoundingModeRTZFloat64.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceFloatControlsProperties l, in PhysicalDeviceFloatControlsProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DenormBehaviorIndependence == r.DenormBehaviorIndependence) && (l.RoundingModeIndependence == r.RoundingModeIndependence)
			&& (l.ShaderSignedZeroInfNanPreserveFloat16 == r.ShaderSignedZeroInfNanPreserveFloat16) && (l.ShaderSignedZeroInfNanPreserveFloat32 == r.ShaderSignedZeroInfNanPreserveFloat32) && (l.ShaderSignedZeroInfNanPreserveFloat64 == r.ShaderSignedZeroInfNanPreserveFloat64) && (l.ShaderDenormPreserveFloat16 == r.ShaderDenormPreserveFloat16)
			&& (l.ShaderDenormPreserveFloat32 == r.ShaderDenormPreserveFloat32) && (l.ShaderDenormPreserveFloat64 == r.ShaderDenormPreserveFloat64) && (l.ShaderDenormFlushToZeroFloat16 == r.ShaderDenormFlushToZeroFloat16) && (l.ShaderDenormFlushToZeroFloat32 == r.ShaderDenormFlushToZeroFloat32)
			&& (l.ShaderDenormFlushToZeroFloat64 == r.ShaderDenormFlushToZeroFloat64) && (l.ShaderRoundingModeRTEFloat16 == r.ShaderRoundingModeRTEFloat16) && (l.ShaderRoundingModeRTEFloat32 == r.ShaderRoundingModeRTEFloat32) && (l.ShaderRoundingModeRTEFloat64 == r.ShaderRoundingModeRTEFloat64)
			&& (l.ShaderRoundingModeRTZFloat16 == r.ShaderRoundingModeRTZFloat16) && (l.ShaderRoundingModeRTZFloat32 == r.ShaderRoundingModeRTZFloat32) && (l.ShaderRoundingModeRTZFloat64 == r.ShaderRoundingModeRTZFloat64)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceFloatControlsProperties l, in PhysicalDeviceFloatControlsProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DenormBehaviorIndependence != r.DenormBehaviorIndependence) || (l.RoundingModeIndependence != r.RoundingModeIndependence)
			|| (l.ShaderSignedZeroInfNanPreserveFloat16 != r.ShaderSignedZeroInfNanPreserveFloat16) || (l.ShaderSignedZeroInfNanPreserveFloat32 != r.ShaderSignedZeroInfNanPreserveFloat32) || (l.ShaderSignedZeroInfNanPreserveFloat64 != r.ShaderSignedZeroInfNanPreserveFloat64) || (l.ShaderDenormPreserveFloat16 != r.ShaderDenormPreserveFloat16)
			|| (l.ShaderDenormPreserveFloat32 != r.ShaderDenormPreserveFloat32) || (l.ShaderDenormPreserveFloat64 != r.ShaderDenormPreserveFloat64) || (l.ShaderDenormFlushToZeroFloat16 != r.ShaderDenormFlushToZeroFloat16) || (l.ShaderDenormFlushToZeroFloat32 != r.ShaderDenormFlushToZeroFloat32)
			|| (l.ShaderDenormFlushToZeroFloat64 != r.ShaderDenormFlushToZeroFloat64) || (l.ShaderRoundingModeRTEFloat16 != r.ShaderRoundingModeRTEFloat16) || (l.ShaderRoundingModeRTEFloat32 != r.ShaderRoundingModeRTEFloat32) || (l.ShaderRoundingModeRTEFloat64 != r.ShaderRoundingModeRTEFloat64)
			|| (l.ShaderRoundingModeRTZFloat16 != r.ShaderRoundingModeRTZFloat16) || (l.ShaderRoundingModeRTZFloat32 != r.ShaderRoundingModeRTZFloat32) || (l.ShaderRoundingModeRTZFloat64 != r.ShaderRoundingModeRTZFloat64)
			;
	}


	/// <summary>Creates a new PhysicalDeviceFloatControlsProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceFloatControlsProperties value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceHostQueryResetFeatures : IEquatable<PhysicalDeviceHostQueryResetFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceHostQueryResetFeatures;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 HostQueryReset;
	public PhysicalDeviceHostQueryResetFeatures(
		in Vk.Bool32 hostQueryReset = default
	) {
		sType = TYPE;
		pNext = null;
		HostQueryReset = hostQueryReset;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceHostQueryResetFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceHostQueryResetFeatures>.Equals(PhysicalDeviceHostQueryResetFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ HostQueryReset.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceHostQueryResetFeatures l, in PhysicalDeviceHostQueryResetFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.HostQueryReset == r.HostQueryReset)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceHostQueryResetFeatures l, in PhysicalDeviceHostQueryResetFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.HostQueryReset != r.HostQueryReset)
			;
	}


	/// <summary>Creates a new PhysicalDeviceHostQueryResetFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceHostQueryResetFeatures value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceDescriptorIndexingFeatures : IEquatable<PhysicalDeviceDescriptorIndexingFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceDescriptorIndexingFeatures;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 ShaderInputAttachmentArrayDynamicIndexing;
	public Vk.Bool32 ShaderUniformTexelBufferArrayDynamicIndexing;
	public Vk.Bool32 ShaderStorageTexelBufferArrayDynamicIndexing;
	public Vk.Bool32 ShaderUniformBufferArrayNonUniformIndexing;
	public Vk.Bool32 ShaderSampledImageArrayNonUniformIndexing;
	public Vk.Bool32 ShaderStorageBufferArrayNonUniformIndexing;
	public Vk.Bool32 ShaderStorageImageArrayNonUniformIndexing;
	public Vk.Bool32 ShaderInputAttachmentArrayNonUniformIndexing;
	public Vk.Bool32 ShaderUniformTexelBufferArrayNonUniformIndexing;
	public Vk.Bool32 ShaderStorageTexelBufferArrayNonUniformIndexing;
	public Vk.Bool32 DescriptorBindingUniformBufferUpdateAfterBind;
	public Vk.Bool32 DescriptorBindingSampledImageUpdateAfterBind;
	public Vk.Bool32 DescriptorBindingStorageImageUpdateAfterBind;
	public Vk.Bool32 DescriptorBindingStorageBufferUpdateAfterBind;
	public Vk.Bool32 DescriptorBindingUniformTexelBufferUpdateAfterBind;
	public Vk.Bool32 DescriptorBindingStorageTexelBufferUpdateAfterBind;
	public Vk.Bool32 DescriptorBindingUpdateUnusedWhilePending;
	public Vk.Bool32 DescriptorBindingPartiallyBound;
	public Vk.Bool32 DescriptorBindingVariableDescriptorCount;
	public Vk.Bool32 RuntimeDescriptorArray;
	public PhysicalDeviceDescriptorIndexingFeatures(
		in Vk.Bool32 shaderInputAttachmentArrayDynamicIndexing = default,
		in Vk.Bool32 shaderUniformTexelBufferArrayDynamicIndexing = default,
		in Vk.Bool32 shaderStorageTexelBufferArrayDynamicIndexing = default,
		in Vk.Bool32 shaderUniformBufferArrayNonUniformIndexing = default,
		in Vk.Bool32 shaderSampledImageArrayNonUniformIndexing = default,
		in Vk.Bool32 shaderStorageBufferArrayNonUniformIndexing = default,
		in Vk.Bool32 shaderStorageImageArrayNonUniformIndexing = default,
		in Vk.Bool32 shaderInputAttachmentArrayNonUniformIndexing = default,
		in Vk.Bool32 shaderUniformTexelBufferArrayNonUniformIndexing = default,
		in Vk.Bool32 shaderStorageTexelBufferArrayNonUniformIndexing = default,
		in Vk.Bool32 descriptorBindingUniformBufferUpdateAfterBind = default,
		in Vk.Bool32 descriptorBindingSampledImageUpdateAfterBind = default,
		in Vk.Bool32 descriptorBindingStorageImageUpdateAfterBind = default,
		in Vk.Bool32 descriptorBindingStorageBufferUpdateAfterBind = default,
		in Vk.Bool32 descriptorBindingUniformTexelBufferUpdateAfterBind = default,
		in Vk.Bool32 descriptorBindingStorageTexelBufferUpdateAfterBind = default,
		in Vk.Bool32 descriptorBindingUpdateUnusedWhilePending = default,
		in Vk.Bool32 descriptorBindingPartiallyBound = default,
		in Vk.Bool32 descriptorBindingVariableDescriptorCount = default,
		in Vk.Bool32 runtimeDescriptorArray = default
	) {
		sType = TYPE;
		pNext = null;
		ShaderInputAttachmentArrayDynamicIndexing = shaderInputAttachmentArrayDynamicIndexing;
		ShaderUniformTexelBufferArrayDynamicIndexing = shaderUniformTexelBufferArrayDynamicIndexing;
		ShaderStorageTexelBufferArrayDynamicIndexing = shaderStorageTexelBufferArrayDynamicIndexing;
		ShaderUniformBufferArrayNonUniformIndexing = shaderUniformBufferArrayNonUniformIndexing;
		ShaderSampledImageArrayNonUniformIndexing = shaderSampledImageArrayNonUniformIndexing;
		ShaderStorageBufferArrayNonUniformIndexing = shaderStorageBufferArrayNonUniformIndexing;
		ShaderStorageImageArrayNonUniformIndexing = shaderStorageImageArrayNonUniformIndexing;
		ShaderInputAttachmentArrayNonUniformIndexing = shaderInputAttachmentArrayNonUniformIndexing;
		ShaderUniformTexelBufferArrayNonUniformIndexing = shaderUniformTexelBufferArrayNonUniformIndexing;
		ShaderStorageTexelBufferArrayNonUniformIndexing = shaderStorageTexelBufferArrayNonUniformIndexing;
		DescriptorBindingUniformBufferUpdateAfterBind = descriptorBindingUniformBufferUpdateAfterBind;
		DescriptorBindingSampledImageUpdateAfterBind = descriptorBindingSampledImageUpdateAfterBind;
		DescriptorBindingStorageImageUpdateAfterBind = descriptorBindingStorageImageUpdateAfterBind;
		DescriptorBindingStorageBufferUpdateAfterBind = descriptorBindingStorageBufferUpdateAfterBind;
		DescriptorBindingUniformTexelBufferUpdateAfterBind = descriptorBindingUniformTexelBufferUpdateAfterBind;
		DescriptorBindingStorageTexelBufferUpdateAfterBind = descriptorBindingStorageTexelBufferUpdateAfterBind;
		DescriptorBindingUpdateUnusedWhilePending = descriptorBindingUpdateUnusedWhilePending;
		DescriptorBindingPartiallyBound = descriptorBindingPartiallyBound;
		DescriptorBindingVariableDescriptorCount = descriptorBindingVariableDescriptorCount;
		RuntimeDescriptorArray = runtimeDescriptorArray;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceDescriptorIndexingFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceDescriptorIndexingFeatures>.Equals(PhysicalDeviceDescriptorIndexingFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ShaderInputAttachmentArrayDynamicIndexing.GetHashCode() ^ ShaderUniformTexelBufferArrayDynamicIndexing.GetHashCode()
			^ ShaderStorageTexelBufferArrayDynamicIndexing.GetHashCode() ^ ShaderUniformBufferArrayNonUniformIndexing.GetHashCode() ^ ShaderSampledImageArrayNonUniformIndexing.GetHashCode() ^ ShaderStorageBufferArrayNonUniformIndexing.GetHashCode()
			^ ShaderStorageImageArrayNonUniformIndexing.GetHashCode() ^ ShaderInputAttachmentArrayNonUniformIndexing.GetHashCode() ^ ShaderUniformTexelBufferArrayNonUniformIndexing.GetHashCode() ^ ShaderStorageTexelBufferArrayNonUniformIndexing.GetHashCode()
			^ DescriptorBindingUniformBufferUpdateAfterBind.GetHashCode() ^ DescriptorBindingSampledImageUpdateAfterBind.GetHashCode() ^ DescriptorBindingStorageImageUpdateAfterBind.GetHashCode() ^ DescriptorBindingStorageBufferUpdateAfterBind.GetHashCode()
			^ DescriptorBindingUniformTexelBufferUpdateAfterBind.GetHashCode() ^ DescriptorBindingStorageTexelBufferUpdateAfterBind.GetHashCode() ^ DescriptorBindingUpdateUnusedWhilePending.GetHashCode() ^ DescriptorBindingPartiallyBound.GetHashCode()
			^ DescriptorBindingVariableDescriptorCount.GetHashCode() ^ RuntimeDescriptorArray.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceDescriptorIndexingFeatures l, in PhysicalDeviceDescriptorIndexingFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ShaderInputAttachmentArrayDynamicIndexing == r.ShaderInputAttachmentArrayDynamicIndexing) && (l.ShaderUniformTexelBufferArrayDynamicIndexing == r.ShaderUniformTexelBufferArrayDynamicIndexing)
			&& (l.ShaderStorageTexelBufferArrayDynamicIndexing == r.ShaderStorageTexelBufferArrayDynamicIndexing) && (l.ShaderUniformBufferArrayNonUniformIndexing == r.ShaderUniformBufferArrayNonUniformIndexing) && (l.ShaderSampledImageArrayNonUniformIndexing == r.ShaderSampledImageArrayNonUniformIndexing) && (l.ShaderStorageBufferArrayNonUniformIndexing == r.ShaderStorageBufferArrayNonUniformIndexing)
			&& (l.ShaderStorageImageArrayNonUniformIndexing == r.ShaderStorageImageArrayNonUniformIndexing) && (l.ShaderInputAttachmentArrayNonUniformIndexing == r.ShaderInputAttachmentArrayNonUniformIndexing) && (l.ShaderUniformTexelBufferArrayNonUniformIndexing == r.ShaderUniformTexelBufferArrayNonUniformIndexing) && (l.ShaderStorageTexelBufferArrayNonUniformIndexing == r.ShaderStorageTexelBufferArrayNonUniformIndexing)
			&& (l.DescriptorBindingUniformBufferUpdateAfterBind == r.DescriptorBindingUniformBufferUpdateAfterBind) && (l.DescriptorBindingSampledImageUpdateAfterBind == r.DescriptorBindingSampledImageUpdateAfterBind) && (l.DescriptorBindingStorageImageUpdateAfterBind == r.DescriptorBindingStorageImageUpdateAfterBind) && (l.DescriptorBindingStorageBufferUpdateAfterBind == r.DescriptorBindingStorageBufferUpdateAfterBind)
			&& (l.DescriptorBindingUniformTexelBufferUpdateAfterBind == r.DescriptorBindingUniformTexelBufferUpdateAfterBind) && (l.DescriptorBindingStorageTexelBufferUpdateAfterBind == r.DescriptorBindingStorageTexelBufferUpdateAfterBind) && (l.DescriptorBindingUpdateUnusedWhilePending == r.DescriptorBindingUpdateUnusedWhilePending) && (l.DescriptorBindingPartiallyBound == r.DescriptorBindingPartiallyBound)
			&& (l.DescriptorBindingVariableDescriptorCount == r.DescriptorBindingVariableDescriptorCount) && (l.RuntimeDescriptorArray == r.RuntimeDescriptorArray)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceDescriptorIndexingFeatures l, in PhysicalDeviceDescriptorIndexingFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ShaderInputAttachmentArrayDynamicIndexing != r.ShaderInputAttachmentArrayDynamicIndexing) || (l.ShaderUniformTexelBufferArrayDynamicIndexing != r.ShaderUniformTexelBufferArrayDynamicIndexing)
			|| (l.ShaderStorageTexelBufferArrayDynamicIndexing != r.ShaderStorageTexelBufferArrayDynamicIndexing) || (l.ShaderUniformBufferArrayNonUniformIndexing != r.ShaderUniformBufferArrayNonUniformIndexing) || (l.ShaderSampledImageArrayNonUniformIndexing != r.ShaderSampledImageArrayNonUniformIndexing) || (l.ShaderStorageBufferArrayNonUniformIndexing != r.ShaderStorageBufferArrayNonUniformIndexing)
			|| (l.ShaderStorageImageArrayNonUniformIndexing != r.ShaderStorageImageArrayNonUniformIndexing) || (l.ShaderInputAttachmentArrayNonUniformIndexing != r.ShaderInputAttachmentArrayNonUniformIndexing) || (l.ShaderUniformTexelBufferArrayNonUniformIndexing != r.ShaderUniformTexelBufferArrayNonUniformIndexing) || (l.ShaderStorageTexelBufferArrayNonUniformIndexing != r.ShaderStorageTexelBufferArrayNonUniformIndexing)
			|| (l.DescriptorBindingUniformBufferUpdateAfterBind != r.DescriptorBindingUniformBufferUpdateAfterBind) || (l.DescriptorBindingSampledImageUpdateAfterBind != r.DescriptorBindingSampledImageUpdateAfterBind) || (l.DescriptorBindingStorageImageUpdateAfterBind != r.DescriptorBindingStorageImageUpdateAfterBind) || (l.DescriptorBindingStorageBufferUpdateAfterBind != r.DescriptorBindingStorageBufferUpdateAfterBind)
			|| (l.DescriptorBindingUniformTexelBufferUpdateAfterBind != r.DescriptorBindingUniformTexelBufferUpdateAfterBind) || (l.DescriptorBindingStorageTexelBufferUpdateAfterBind != r.DescriptorBindingStorageTexelBufferUpdateAfterBind) || (l.DescriptorBindingUpdateUnusedWhilePending != r.DescriptorBindingUpdateUnusedWhilePending) || (l.DescriptorBindingPartiallyBound != r.DescriptorBindingPartiallyBound)
			|| (l.DescriptorBindingVariableDescriptorCount != r.DescriptorBindingVariableDescriptorCount) || (l.RuntimeDescriptorArray != r.RuntimeDescriptorArray)
			;
	}


	/// <summary>Creates a new PhysicalDeviceDescriptorIndexingFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceDescriptorIndexingFeatures value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceDescriptorIndexingProperties : IEquatable<PhysicalDeviceDescriptorIndexingProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceDescriptorIndexingProperties;

	public Vk.StructureType sType;
	public void* pNext;
	public uint MaxUpdateAfterBindDescriptorsInAllPools;
	public Vk.Bool32 ShaderUniformBufferArrayNonUniformIndexingNative;
	public Vk.Bool32 ShaderSampledImageArrayNonUniformIndexingNative;
	public Vk.Bool32 ShaderStorageBufferArrayNonUniformIndexingNative;
	public Vk.Bool32 ShaderStorageImageArrayNonUniformIndexingNative;
	public Vk.Bool32 ShaderInputAttachmentArrayNonUniformIndexingNative;
	public Vk.Bool32 RobustBufferAccessUpdateAfterBind;
	public Vk.Bool32 QuadDivergentImplicitLod;
	public uint MaxPerStageDescriptorUpdateAfterBindSamplers;
	public uint MaxPerStageDescriptorUpdateAfterBindUniformBuffers;
	public uint MaxPerStageDescriptorUpdateAfterBindStorageBuffers;
	public uint MaxPerStageDescriptorUpdateAfterBindSampledImages;
	public uint MaxPerStageDescriptorUpdateAfterBindStorageImages;
	public uint MaxPerStageDescriptorUpdateAfterBindInputAttachments;
	public uint MaxPerStageUpdateAfterBindResources;
	public uint MaxDescriptorSetUpdateAfterBindSamplers;
	public uint MaxDescriptorSetUpdateAfterBindUniformBuffers;
	public uint MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic;
	public uint MaxDescriptorSetUpdateAfterBindStorageBuffers;
	public uint MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic;
	public uint MaxDescriptorSetUpdateAfterBindSampledImages;
	public uint MaxDescriptorSetUpdateAfterBindStorageImages;
	public uint MaxDescriptorSetUpdateAfterBindInputAttachments;
	public PhysicalDeviceDescriptorIndexingProperties(
		uint maxUpdateAfterBindDescriptorsInAllPools = default,
		in Vk.Bool32 shaderUniformBufferArrayNonUniformIndexingNative = default,
		in Vk.Bool32 shaderSampledImageArrayNonUniformIndexingNative = default,
		in Vk.Bool32 shaderStorageBufferArrayNonUniformIndexingNative = default,
		in Vk.Bool32 shaderStorageImageArrayNonUniformIndexingNative = default,
		in Vk.Bool32 shaderInputAttachmentArrayNonUniformIndexingNative = default,
		in Vk.Bool32 robustBufferAccessUpdateAfterBind = default,
		in Vk.Bool32 quadDivergentImplicitLod = default,
		uint maxPerStageDescriptorUpdateAfterBindSamplers = default,
		uint maxPerStageDescriptorUpdateAfterBindUniformBuffers = default,
		uint maxPerStageDescriptorUpdateAfterBindStorageBuffers = default,
		uint maxPerStageDescriptorUpdateAfterBindSampledImages = default,
		uint maxPerStageDescriptorUpdateAfterBindStorageImages = default,
		uint maxPerStageDescriptorUpdateAfterBindInputAttachments = default,
		uint maxPerStageUpdateAfterBindResources = default,
		uint maxDescriptorSetUpdateAfterBindSamplers = default,
		uint maxDescriptorSetUpdateAfterBindUniformBuffers = default,
		uint maxDescriptorSetUpdateAfterBindUniformBuffersDynamic = default,
		uint maxDescriptorSetUpdateAfterBindStorageBuffers = default,
		uint maxDescriptorSetUpdateAfterBindStorageBuffersDynamic = default,
		uint maxDescriptorSetUpdateAfterBindSampledImages = default,
		uint maxDescriptorSetUpdateAfterBindStorageImages = default,
		uint maxDescriptorSetUpdateAfterBindInputAttachments = default
	) {
		sType = TYPE;
		pNext = null;
		MaxUpdateAfterBindDescriptorsInAllPools = maxUpdateAfterBindDescriptorsInAllPools;
		ShaderUniformBufferArrayNonUniformIndexingNative = shaderUniformBufferArrayNonUniformIndexingNative;
		ShaderSampledImageArrayNonUniformIndexingNative = shaderSampledImageArrayNonUniformIndexingNative;
		ShaderStorageBufferArrayNonUniformIndexingNative = shaderStorageBufferArrayNonUniformIndexingNative;
		ShaderStorageImageArrayNonUniformIndexingNative = shaderStorageImageArrayNonUniformIndexingNative;
		ShaderInputAttachmentArrayNonUniformIndexingNative = shaderInputAttachmentArrayNonUniformIndexingNative;
		RobustBufferAccessUpdateAfterBind = robustBufferAccessUpdateAfterBind;
		QuadDivergentImplicitLod = quadDivergentImplicitLod;
		MaxPerStageDescriptorUpdateAfterBindSamplers = maxPerStageDescriptorUpdateAfterBindSamplers;
		MaxPerStageDescriptorUpdateAfterBindUniformBuffers = maxPerStageDescriptorUpdateAfterBindUniformBuffers;
		MaxPerStageDescriptorUpdateAfterBindStorageBuffers = maxPerStageDescriptorUpdateAfterBindStorageBuffers;
		MaxPerStageDescriptorUpdateAfterBindSampledImages = maxPerStageDescriptorUpdateAfterBindSampledImages;
		MaxPerStageDescriptorUpdateAfterBindStorageImages = maxPerStageDescriptorUpdateAfterBindStorageImages;
		MaxPerStageDescriptorUpdateAfterBindInputAttachments = maxPerStageDescriptorUpdateAfterBindInputAttachments;
		MaxPerStageUpdateAfterBindResources = maxPerStageUpdateAfterBindResources;
		MaxDescriptorSetUpdateAfterBindSamplers = maxDescriptorSetUpdateAfterBindSamplers;
		MaxDescriptorSetUpdateAfterBindUniformBuffers = maxDescriptorSetUpdateAfterBindUniformBuffers;
		MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic = maxDescriptorSetUpdateAfterBindUniformBuffersDynamic;
		MaxDescriptorSetUpdateAfterBindStorageBuffers = maxDescriptorSetUpdateAfterBindStorageBuffers;
		MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic = maxDescriptorSetUpdateAfterBindStorageBuffersDynamic;
		MaxDescriptorSetUpdateAfterBindSampledImages = maxDescriptorSetUpdateAfterBindSampledImages;
		MaxDescriptorSetUpdateAfterBindStorageImages = maxDescriptorSetUpdateAfterBindStorageImages;
		MaxDescriptorSetUpdateAfterBindInputAttachments = maxDescriptorSetUpdateAfterBindInputAttachments;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceDescriptorIndexingProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceDescriptorIndexingProperties>.Equals(PhysicalDeviceDescriptorIndexingProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MaxUpdateAfterBindDescriptorsInAllPools.GetHashCode() ^ ShaderUniformBufferArrayNonUniformIndexingNative.GetHashCode()
			^ ShaderSampledImageArrayNonUniformIndexingNative.GetHashCode() ^ ShaderStorageBufferArrayNonUniformIndexingNative.GetHashCode() ^ ShaderStorageImageArrayNonUniformIndexingNative.GetHashCode() ^ ShaderInputAttachmentArrayNonUniformIndexingNative.GetHashCode()
			^ RobustBufferAccessUpdateAfterBind.GetHashCode() ^ QuadDivergentImplicitLod.GetHashCode() ^ MaxPerStageDescriptorUpdateAfterBindSamplers.GetHashCode() ^ MaxPerStageDescriptorUpdateAfterBindUniformBuffers.GetHashCode()
			^ MaxPerStageDescriptorUpdateAfterBindStorageBuffers.GetHashCode() ^ MaxPerStageDescriptorUpdateAfterBindSampledImages.GetHashCode() ^ MaxPerStageDescriptorUpdateAfterBindStorageImages.GetHashCode() ^ MaxPerStageDescriptorUpdateAfterBindInputAttachments.GetHashCode()
			^ MaxPerStageUpdateAfterBindResources.GetHashCode() ^ MaxDescriptorSetUpdateAfterBindSamplers.GetHashCode() ^ MaxDescriptorSetUpdateAfterBindUniformBuffers.GetHashCode() ^ MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic.GetHashCode()
			^ MaxDescriptorSetUpdateAfterBindStorageBuffers.GetHashCode() ^ MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic.GetHashCode() ^ MaxDescriptorSetUpdateAfterBindSampledImages.GetHashCode() ^ MaxDescriptorSetUpdateAfterBindStorageImages.GetHashCode()
			^ MaxDescriptorSetUpdateAfterBindInputAttachments.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceDescriptorIndexingProperties l, in PhysicalDeviceDescriptorIndexingProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MaxUpdateAfterBindDescriptorsInAllPools == r.MaxUpdateAfterBindDescriptorsInAllPools) && (l.ShaderUniformBufferArrayNonUniformIndexingNative == r.ShaderUniformBufferArrayNonUniformIndexingNative)
			&& (l.ShaderSampledImageArrayNonUniformIndexingNative == r.ShaderSampledImageArrayNonUniformIndexingNative) && (l.ShaderStorageBufferArrayNonUniformIndexingNative == r.ShaderStorageBufferArrayNonUniformIndexingNative) && (l.ShaderStorageImageArrayNonUniformIndexingNative == r.ShaderStorageImageArrayNonUniformIndexingNative) && (l.ShaderInputAttachmentArrayNonUniformIndexingNative == r.ShaderInputAttachmentArrayNonUniformIndexingNative)
			&& (l.RobustBufferAccessUpdateAfterBind == r.RobustBufferAccessUpdateAfterBind) && (l.QuadDivergentImplicitLod == r.QuadDivergentImplicitLod) && (l.MaxPerStageDescriptorUpdateAfterBindSamplers == r.MaxPerStageDescriptorUpdateAfterBindSamplers) && (l.MaxPerStageDescriptorUpdateAfterBindUniformBuffers == r.MaxPerStageDescriptorUpdateAfterBindUniformBuffers)
			&& (l.MaxPerStageDescriptorUpdateAfterBindStorageBuffers == r.MaxPerStageDescriptorUpdateAfterBindStorageBuffers) && (l.MaxPerStageDescriptorUpdateAfterBindSampledImages == r.MaxPerStageDescriptorUpdateAfterBindSampledImages) && (l.MaxPerStageDescriptorUpdateAfterBindStorageImages == r.MaxPerStageDescriptorUpdateAfterBindStorageImages) && (l.MaxPerStageDescriptorUpdateAfterBindInputAttachments == r.MaxPerStageDescriptorUpdateAfterBindInputAttachments)
			&& (l.MaxPerStageUpdateAfterBindResources == r.MaxPerStageUpdateAfterBindResources) && (l.MaxDescriptorSetUpdateAfterBindSamplers == r.MaxDescriptorSetUpdateAfterBindSamplers) && (l.MaxDescriptorSetUpdateAfterBindUniformBuffers == r.MaxDescriptorSetUpdateAfterBindUniformBuffers) && (l.MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic == r.MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic)
			&& (l.MaxDescriptorSetUpdateAfterBindStorageBuffers == r.MaxDescriptorSetUpdateAfterBindStorageBuffers) && (l.MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic == r.MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic) && (l.MaxDescriptorSetUpdateAfterBindSampledImages == r.MaxDescriptorSetUpdateAfterBindSampledImages) && (l.MaxDescriptorSetUpdateAfterBindStorageImages == r.MaxDescriptorSetUpdateAfterBindStorageImages)
			&& (l.MaxDescriptorSetUpdateAfterBindInputAttachments == r.MaxDescriptorSetUpdateAfterBindInputAttachments)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceDescriptorIndexingProperties l, in PhysicalDeviceDescriptorIndexingProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MaxUpdateAfterBindDescriptorsInAllPools != r.MaxUpdateAfterBindDescriptorsInAllPools) || (l.ShaderUniformBufferArrayNonUniformIndexingNative != r.ShaderUniformBufferArrayNonUniformIndexingNative)
			|| (l.ShaderSampledImageArrayNonUniformIndexingNative != r.ShaderSampledImageArrayNonUniformIndexingNative) || (l.ShaderStorageBufferArrayNonUniformIndexingNative != r.ShaderStorageBufferArrayNonUniformIndexingNative) || (l.ShaderStorageImageArrayNonUniformIndexingNative != r.ShaderStorageImageArrayNonUniformIndexingNative) || (l.ShaderInputAttachmentArrayNonUniformIndexingNative != r.ShaderInputAttachmentArrayNonUniformIndexingNative)
			|| (l.RobustBufferAccessUpdateAfterBind != r.RobustBufferAccessUpdateAfterBind) || (l.QuadDivergentImplicitLod != r.QuadDivergentImplicitLod) || (l.MaxPerStageDescriptorUpdateAfterBindSamplers != r.MaxPerStageDescriptorUpdateAfterBindSamplers) || (l.MaxPerStageDescriptorUpdateAfterBindUniformBuffers != r.MaxPerStageDescriptorUpdateAfterBindUniformBuffers)
			|| (l.MaxPerStageDescriptorUpdateAfterBindStorageBuffers != r.MaxPerStageDescriptorUpdateAfterBindStorageBuffers) || (l.MaxPerStageDescriptorUpdateAfterBindSampledImages != r.MaxPerStageDescriptorUpdateAfterBindSampledImages) || (l.MaxPerStageDescriptorUpdateAfterBindStorageImages != r.MaxPerStageDescriptorUpdateAfterBindStorageImages) || (l.MaxPerStageDescriptorUpdateAfterBindInputAttachments != r.MaxPerStageDescriptorUpdateAfterBindInputAttachments)
			|| (l.MaxPerStageUpdateAfterBindResources != r.MaxPerStageUpdateAfterBindResources) || (l.MaxDescriptorSetUpdateAfterBindSamplers != r.MaxDescriptorSetUpdateAfterBindSamplers) || (l.MaxDescriptorSetUpdateAfterBindUniformBuffers != r.MaxDescriptorSetUpdateAfterBindUniformBuffers) || (l.MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic != r.MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic)
			|| (l.MaxDescriptorSetUpdateAfterBindStorageBuffers != r.MaxDescriptorSetUpdateAfterBindStorageBuffers) || (l.MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic != r.MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic) || (l.MaxDescriptorSetUpdateAfterBindSampledImages != r.MaxDescriptorSetUpdateAfterBindSampledImages) || (l.MaxDescriptorSetUpdateAfterBindStorageImages != r.MaxDescriptorSetUpdateAfterBindStorageImages)
			|| (l.MaxDescriptorSetUpdateAfterBindInputAttachments != r.MaxDescriptorSetUpdateAfterBindInputAttachments)
			;
	}


	/// <summary>Creates a new PhysicalDeviceDescriptorIndexingProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceDescriptorIndexingProperties value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DescriptorSetLayoutBindingFlagsCreateInfo : IEquatable<DescriptorSetLayoutBindingFlagsCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DescriptorSetLayoutBindingFlagsCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public uint BindingCount;
	public Vk.DescriptorBindingFlags* BindingFlags;
	public DescriptorSetLayoutBindingFlagsCreateInfo(
		uint bindingCount = default,
		in Vk.DescriptorBindingFlags* bindingFlags = default
	) {
		sType = TYPE;
		pNext = null;
		BindingCount = bindingCount;
		BindingFlags = bindingFlags;
	}


	public readonly override bool Equals(object? obj) => (obj is DescriptorSetLayoutBindingFlagsCreateInfo o) && (this == o);
	readonly bool IEquatable<DescriptorSetLayoutBindingFlagsCreateInfo>.Equals(DescriptorSetLayoutBindingFlagsCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ BindingCount.GetHashCode() ^ ((ulong)BindingFlags).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DescriptorSetLayoutBindingFlagsCreateInfo l, in DescriptorSetLayoutBindingFlagsCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.BindingCount == r.BindingCount) && (l.BindingFlags == r.BindingFlags)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DescriptorSetLayoutBindingFlagsCreateInfo l, in DescriptorSetLayoutBindingFlagsCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.BindingCount != r.BindingCount) || (l.BindingFlags != r.BindingFlags)
			;
	}


	/// <summary>Creates a new DescriptorSetLayoutBindingFlagsCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DescriptorSetLayoutBindingFlagsCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DescriptorSetVariableDescriptorCountAllocateInfo : IEquatable<DescriptorSetVariableDescriptorCountAllocateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DescriptorSetVariableDescriptorCountAllocateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public uint DescriptorSetCount;
	public uint* DescriptorCounts;
	public DescriptorSetVariableDescriptorCountAllocateInfo(
		uint descriptorSetCount = default,
		uint* descriptorCounts = default
	) {
		sType = TYPE;
		pNext = null;
		DescriptorSetCount = descriptorSetCount;
		DescriptorCounts = descriptorCounts;
	}


	public readonly override bool Equals(object? obj) => (obj is DescriptorSetVariableDescriptorCountAllocateInfo o) && (this == o);
	readonly bool IEquatable<DescriptorSetVariableDescriptorCountAllocateInfo>.Equals(DescriptorSetVariableDescriptorCountAllocateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DescriptorSetCount.GetHashCode() ^ ((ulong)DescriptorCounts).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DescriptorSetVariableDescriptorCountAllocateInfo l, in DescriptorSetVariableDescriptorCountAllocateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DescriptorSetCount == r.DescriptorSetCount) && (l.DescriptorCounts == r.DescriptorCounts)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DescriptorSetVariableDescriptorCountAllocateInfo l, in DescriptorSetVariableDescriptorCountAllocateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DescriptorSetCount != r.DescriptorSetCount) || (l.DescriptorCounts != r.DescriptorCounts)
			;
	}


	/// <summary>Creates a new DescriptorSetVariableDescriptorCountAllocateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DescriptorSetVariableDescriptorCountAllocateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DescriptorSetVariableDescriptorCountLayoutSupport : IEquatable<DescriptorSetVariableDescriptorCountLayoutSupport>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DescriptorSetVariableDescriptorCountLayoutSupport;

	public Vk.StructureType sType;
	public void* pNext;
	public uint MaxVariableDescriptorCount;
	public DescriptorSetVariableDescriptorCountLayoutSupport(
		uint maxVariableDescriptorCount = default
	) {
		sType = TYPE;
		pNext = null;
		MaxVariableDescriptorCount = maxVariableDescriptorCount;
	}


	public readonly override bool Equals(object? obj) => (obj is DescriptorSetVariableDescriptorCountLayoutSupport o) && (this == o);
	readonly bool IEquatable<DescriptorSetVariableDescriptorCountLayoutSupport>.Equals(DescriptorSetVariableDescriptorCountLayoutSupport obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MaxVariableDescriptorCount.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DescriptorSetVariableDescriptorCountLayoutSupport l, in DescriptorSetVariableDescriptorCountLayoutSupport r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MaxVariableDescriptorCount == r.MaxVariableDescriptorCount)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DescriptorSetVariableDescriptorCountLayoutSupport l, in DescriptorSetVariableDescriptorCountLayoutSupport r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MaxVariableDescriptorCount != r.MaxVariableDescriptorCount)
			;
	}


	/// <summary>Creates a new DescriptorSetVariableDescriptorCountLayoutSupport value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DescriptorSetVariableDescriptorCountLayoutSupport value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct AttachmentDescription2 : IEquatable<AttachmentDescription2>
{
	public const Vk.StructureType TYPE = Vk.StructureType.AttachmentDescription2;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.AttachmentDescriptionFlags Flags;
	public Vk.Format Format;
	public Vk.SampleCountFlags Samples;
	public Vk.AttachmentLoadOp LoadOp;
	public Vk.AttachmentStoreOp StoreOp;
	public Vk.AttachmentLoadOp StencilLoadOp;
	public Vk.AttachmentStoreOp StencilStoreOp;
	public Vk.ImageLayout InitialLayout;
	public Vk.ImageLayout FinalLayout;
	public AttachmentDescription2(
		in Vk.AttachmentDescriptionFlags flags = default,
		in Vk.Format format = default,
		in Vk.SampleCountFlags samples = default,
		in Vk.AttachmentLoadOp loadOp = default,
		in Vk.AttachmentStoreOp storeOp = default,
		in Vk.AttachmentLoadOp stencilLoadOp = default,
		in Vk.AttachmentStoreOp stencilStoreOp = default,
		in Vk.ImageLayout initialLayout = default,
		in Vk.ImageLayout finalLayout = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		Format = format;
		Samples = samples;
		LoadOp = loadOp;
		StoreOp = storeOp;
		StencilLoadOp = stencilLoadOp;
		StencilStoreOp = stencilStoreOp;
		InitialLayout = initialLayout;
		FinalLayout = finalLayout;
	}


	public readonly override bool Equals(object? obj) => (obj is AttachmentDescription2 o) && (this == o);
	readonly bool IEquatable<AttachmentDescription2>.Equals(AttachmentDescription2 obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ Format.GetHashCode()
			^ Samples.GetHashCode() ^ LoadOp.GetHashCode() ^ StoreOp.GetHashCode() ^ StencilLoadOp.GetHashCode()
			^ StencilStoreOp.GetHashCode() ^ InitialLayout.GetHashCode() ^ FinalLayout.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in AttachmentDescription2 l, in AttachmentDescription2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.Format == r.Format)
			&& (l.Samples == r.Samples) && (l.LoadOp == r.LoadOp) && (l.StoreOp == r.StoreOp) && (l.StencilLoadOp == r.StencilLoadOp)
			&& (l.StencilStoreOp == r.StencilStoreOp) && (l.InitialLayout == r.InitialLayout) && (l.FinalLayout == r.FinalLayout)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in AttachmentDescription2 l, in AttachmentDescription2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.Format != r.Format)
			|| (l.Samples != r.Samples) || (l.LoadOp != r.LoadOp) || (l.StoreOp != r.StoreOp) || (l.StencilLoadOp != r.StencilLoadOp)
			|| (l.StencilStoreOp != r.StencilStoreOp) || (l.InitialLayout != r.InitialLayout) || (l.FinalLayout != r.FinalLayout)
			;
	}


	/// <summary>Creates a new AttachmentDescription2 value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out AttachmentDescription2 value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct AttachmentReference2 : IEquatable<AttachmentReference2>
{
	public const Vk.StructureType TYPE = Vk.StructureType.AttachmentReference2;

	public Vk.StructureType sType;
	public void* pNext;
	public uint Attachment;
	public Vk.ImageLayout Layout;
	public Vk.ImageAspectFlags AspectMask;
	public AttachmentReference2(
		uint attachment = default,
		in Vk.ImageLayout layout = default,
		in Vk.ImageAspectFlags aspectMask = default
	) {
		sType = TYPE;
		pNext = null;
		Attachment = attachment;
		Layout = layout;
		AspectMask = aspectMask;
	}


	public readonly override bool Equals(object? obj) => (obj is AttachmentReference2 o) && (this == o);
	readonly bool IEquatable<AttachmentReference2>.Equals(AttachmentReference2 obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Attachment.GetHashCode() ^ Layout.GetHashCode()
			^ AspectMask.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in AttachmentReference2 l, in AttachmentReference2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Attachment == r.Attachment) && (l.Layout == r.Layout)
			&& (l.AspectMask == r.AspectMask)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in AttachmentReference2 l, in AttachmentReference2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Attachment != r.Attachment) || (l.Layout != r.Layout)
			|| (l.AspectMask != r.AspectMask)
			;
	}


	/// <summary>Creates a new AttachmentReference2 value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out AttachmentReference2 value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SubpassDescription2 : IEquatable<SubpassDescription2>
{
	public const Vk.StructureType TYPE = Vk.StructureType.SubpassDescription2;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.SubpassDescriptionFlags Flags;
	public Vk.PipelineBindPoint PipelineBindPoint;
	public uint ViewMask;
	public uint InputAttachmentCount;
	public Vk.AttachmentReference2* InputAttachments;
	public uint ColorAttachmentCount;
	public Vk.AttachmentReference2* ColorAttachments;
	public Vk.AttachmentReference2* ResolveAttachments;
	public Vk.AttachmentReference2* DepthStencilAttachment;
	public uint PreserveAttachmentCount;
	public uint* PreserveAttachments;
	public SubpassDescription2(
		in Vk.SubpassDescriptionFlags flags = default,
		in Vk.PipelineBindPoint pipelineBindPoint = default,
		uint viewMask = default,
		uint inputAttachmentCount = default,
		in Vk.AttachmentReference2* inputAttachments = default,
		uint colorAttachmentCount = default,
		in Vk.AttachmentReference2* colorAttachments = default,
		in Vk.AttachmentReference2* resolveAttachments = default,
		in Vk.AttachmentReference2* depthStencilAttachment = default,
		uint preserveAttachmentCount = default,
		uint* preserveAttachments = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		PipelineBindPoint = pipelineBindPoint;
		ViewMask = viewMask;
		InputAttachmentCount = inputAttachmentCount;
		InputAttachments = inputAttachments;
		ColorAttachmentCount = colorAttachmentCount;
		ColorAttachments = colorAttachments;
		ResolveAttachments = resolveAttachments;
		DepthStencilAttachment = depthStencilAttachment;
		PreserveAttachmentCount = preserveAttachmentCount;
		PreserveAttachments = preserveAttachments;
	}


	public readonly override bool Equals(object? obj) => (obj is SubpassDescription2 o) && (this == o);
	readonly bool IEquatable<SubpassDescription2>.Equals(SubpassDescription2 obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ PipelineBindPoint.GetHashCode()
			^ ViewMask.GetHashCode() ^ InputAttachmentCount.GetHashCode() ^ ((ulong)InputAttachments).GetHashCode() ^ ColorAttachmentCount.GetHashCode()
			^ ((ulong)ColorAttachments).GetHashCode() ^ ((ulong)ResolveAttachments).GetHashCode() ^ ((ulong)DepthStencilAttachment).GetHashCode() ^ PreserveAttachmentCount.GetHashCode()
			^ ((ulong)PreserveAttachments).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SubpassDescription2 l, in SubpassDescription2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.PipelineBindPoint == r.PipelineBindPoint)
			&& (l.ViewMask == r.ViewMask) && (l.InputAttachmentCount == r.InputAttachmentCount) && (l.InputAttachments == r.InputAttachments) && (l.ColorAttachmentCount == r.ColorAttachmentCount)
			&& (l.ColorAttachments == r.ColorAttachments) && (l.ResolveAttachments == r.ResolveAttachments) && (l.DepthStencilAttachment == r.DepthStencilAttachment) && (l.PreserveAttachmentCount == r.PreserveAttachmentCount)
			&& (l.PreserveAttachments == r.PreserveAttachments)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SubpassDescription2 l, in SubpassDescription2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.PipelineBindPoint != r.PipelineBindPoint)
			|| (l.ViewMask != r.ViewMask) || (l.InputAttachmentCount != r.InputAttachmentCount) || (l.InputAttachments != r.InputAttachments) || (l.ColorAttachmentCount != r.ColorAttachmentCount)
			|| (l.ColorAttachments != r.ColorAttachments) || (l.ResolveAttachments != r.ResolveAttachments) || (l.DepthStencilAttachment != r.DepthStencilAttachment) || (l.PreserveAttachmentCount != r.PreserveAttachmentCount)
			|| (l.PreserveAttachments != r.PreserveAttachments)
			;
	}


	/// <summary>Creates a new SubpassDescription2 value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SubpassDescription2 value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SubpassDependency2 : IEquatable<SubpassDependency2>
{
	public const Vk.StructureType TYPE = Vk.StructureType.SubpassDependency2;

	public Vk.StructureType sType;
	public void* pNext;
	public uint SrcSubpass;
	public uint DstSubpass;
	public Vk.PipelineStageFlags SrcStageMask;
	public Vk.PipelineStageFlags DstStageMask;
	public Vk.AccessFlags SrcAccessMask;
	public Vk.AccessFlags DstAccessMask;
	public Vk.DependencyFlags DependencyFlags;
	public int ViewOffset;
	public SubpassDependency2(
		uint srcSubpass = default,
		uint dstSubpass = default,
		in Vk.PipelineStageFlags srcStageMask = default,
		in Vk.PipelineStageFlags dstStageMask = default,
		in Vk.AccessFlags srcAccessMask = default,
		in Vk.AccessFlags dstAccessMask = default,
		in Vk.DependencyFlags dependencyFlags = default,
		int viewOffset = default
	) {
		sType = TYPE;
		pNext = null;
		SrcSubpass = srcSubpass;
		DstSubpass = dstSubpass;
		SrcStageMask = srcStageMask;
		DstStageMask = dstStageMask;
		SrcAccessMask = srcAccessMask;
		DstAccessMask = dstAccessMask;
		DependencyFlags = dependencyFlags;
		ViewOffset = viewOffset;
	}


	public readonly override bool Equals(object? obj) => (obj is SubpassDependency2 o) && (this == o);
	readonly bool IEquatable<SubpassDependency2>.Equals(SubpassDependency2 obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SrcSubpass.GetHashCode() ^ DstSubpass.GetHashCode()
			^ SrcStageMask.GetHashCode() ^ DstStageMask.GetHashCode() ^ SrcAccessMask.GetHashCode() ^ DstAccessMask.GetHashCode()
			^ DependencyFlags.GetHashCode() ^ ViewOffset.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SubpassDependency2 l, in SubpassDependency2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SrcSubpass == r.SrcSubpass) && (l.DstSubpass == r.DstSubpass)
			&& (l.SrcStageMask == r.SrcStageMask) && (l.DstStageMask == r.DstStageMask) && (l.SrcAccessMask == r.SrcAccessMask) && (l.DstAccessMask == r.DstAccessMask)
			&& (l.DependencyFlags == r.DependencyFlags) && (l.ViewOffset == r.ViewOffset)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SubpassDependency2 l, in SubpassDependency2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SrcSubpass != r.SrcSubpass) || (l.DstSubpass != r.DstSubpass)
			|| (l.SrcStageMask != r.SrcStageMask) || (l.DstStageMask != r.DstStageMask) || (l.SrcAccessMask != r.SrcAccessMask) || (l.DstAccessMask != r.DstAccessMask)
			|| (l.DependencyFlags != r.DependencyFlags) || (l.ViewOffset != r.ViewOffset)
			;
	}


	/// <summary>Creates a new SubpassDependency2 value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SubpassDependency2 value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct RenderPassCreateInfo2 : IEquatable<RenderPassCreateInfo2>
{
	public const Vk.StructureType TYPE = Vk.StructureType.RenderPassCreateInfo2;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.RenderPassCreateFlags Flags;
	public uint AttachmentCount;
	public Vk.AttachmentDescription2* Attachments;
	public uint SubpassCount;
	public Vk.SubpassDescription2* Subpasses;
	public uint DependencyCount;
	public Vk.SubpassDependency2* Dependencies;
	public uint CorrelatedViewMaskCount;
	public uint* CorrelatedViewMasks;
	public RenderPassCreateInfo2(
		in Vk.RenderPassCreateFlags flags = default,
		uint attachmentCount = default,
		in Vk.AttachmentDescription2* attachments = default,
		uint subpassCount = default,
		in Vk.SubpassDescription2* subpasses = default,
		uint dependencyCount = default,
		in Vk.SubpassDependency2* dependencies = default,
		uint correlatedViewMaskCount = default,
		uint* correlatedViewMasks = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		AttachmentCount = attachmentCount;
		Attachments = attachments;
		SubpassCount = subpassCount;
		Subpasses = subpasses;
		DependencyCount = dependencyCount;
		Dependencies = dependencies;
		CorrelatedViewMaskCount = correlatedViewMaskCount;
		CorrelatedViewMasks = correlatedViewMasks;
	}


	public readonly override bool Equals(object? obj) => (obj is RenderPassCreateInfo2 o) && (this == o);
	readonly bool IEquatable<RenderPassCreateInfo2>.Equals(RenderPassCreateInfo2 obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ AttachmentCount.GetHashCode()
			^ ((ulong)Attachments).GetHashCode() ^ SubpassCount.GetHashCode() ^ ((ulong)Subpasses).GetHashCode() ^ DependencyCount.GetHashCode()
			^ ((ulong)Dependencies).GetHashCode() ^ CorrelatedViewMaskCount.GetHashCode() ^ ((ulong)CorrelatedViewMasks).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in RenderPassCreateInfo2 l, in RenderPassCreateInfo2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.AttachmentCount == r.AttachmentCount)
			&& (l.Attachments == r.Attachments) && (l.SubpassCount == r.SubpassCount) && (l.Subpasses == r.Subpasses) && (l.DependencyCount == r.DependencyCount)
			&& (l.Dependencies == r.Dependencies) && (l.CorrelatedViewMaskCount == r.CorrelatedViewMaskCount) && (l.CorrelatedViewMasks == r.CorrelatedViewMasks)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in RenderPassCreateInfo2 l, in RenderPassCreateInfo2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.AttachmentCount != r.AttachmentCount)
			|| (l.Attachments != r.Attachments) || (l.SubpassCount != r.SubpassCount) || (l.Subpasses != r.Subpasses) || (l.DependencyCount != r.DependencyCount)
			|| (l.Dependencies != r.Dependencies) || (l.CorrelatedViewMaskCount != r.CorrelatedViewMaskCount) || (l.CorrelatedViewMasks != r.CorrelatedViewMasks)
			;
	}


	/// <summary>Creates a new RenderPassCreateInfo2 value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out RenderPassCreateInfo2 value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SubpassBeginInfo : IEquatable<SubpassBeginInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.SubpassBeginInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.SubpassContents Contents;
	public SubpassBeginInfo(
		in Vk.SubpassContents contents = default
	) {
		sType = TYPE;
		pNext = null;
		Contents = contents;
	}


	public readonly override bool Equals(object? obj) => (obj is SubpassBeginInfo o) && (this == o);
	readonly bool IEquatable<SubpassBeginInfo>.Equals(SubpassBeginInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Contents.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SubpassBeginInfo l, in SubpassBeginInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Contents == r.Contents)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SubpassBeginInfo l, in SubpassBeginInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Contents != r.Contents)
			;
	}


	/// <summary>Creates a new SubpassBeginInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SubpassBeginInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SubpassEndInfo : IEquatable<SubpassEndInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.SubpassEndInfo;

	public Vk.StructureType sType;
	public void* pNext;

	public readonly override bool Equals(object? obj) => (obj is SubpassEndInfo o) && (this == o);
	readonly bool IEquatable<SubpassEndInfo>.Equals(SubpassEndInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SubpassEndInfo l, in SubpassEndInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SubpassEndInfo l, in SubpassEndInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext)
			;
	}


	/// <summary>Creates a new SubpassEndInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SubpassEndInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceTimelineSemaphoreFeatures : IEquatable<PhysicalDeviceTimelineSemaphoreFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceTimelineSemaphoreFeatures;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 TimelineSemaphore;
	public PhysicalDeviceTimelineSemaphoreFeatures(
		in Vk.Bool32 timelineSemaphore = default
	) {
		sType = TYPE;
		pNext = null;
		TimelineSemaphore = timelineSemaphore;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceTimelineSemaphoreFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceTimelineSemaphoreFeatures>.Equals(PhysicalDeviceTimelineSemaphoreFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ TimelineSemaphore.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceTimelineSemaphoreFeatures l, in PhysicalDeviceTimelineSemaphoreFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.TimelineSemaphore == r.TimelineSemaphore)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceTimelineSemaphoreFeatures l, in PhysicalDeviceTimelineSemaphoreFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.TimelineSemaphore != r.TimelineSemaphore)
			;
	}


	/// <summary>Creates a new PhysicalDeviceTimelineSemaphoreFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceTimelineSemaphoreFeatures value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceTimelineSemaphoreProperties : IEquatable<PhysicalDeviceTimelineSemaphoreProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceTimelineSemaphoreProperties;

	public Vk.StructureType sType;
	public void* pNext;
	public ulong MaxTimelineSemaphoreValueDifference;
	public PhysicalDeviceTimelineSemaphoreProperties(
		ulong maxTimelineSemaphoreValueDifference = default
	) {
		sType = TYPE;
		pNext = null;
		MaxTimelineSemaphoreValueDifference = maxTimelineSemaphoreValueDifference;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceTimelineSemaphoreProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceTimelineSemaphoreProperties>.Equals(PhysicalDeviceTimelineSemaphoreProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MaxTimelineSemaphoreValueDifference.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceTimelineSemaphoreProperties l, in PhysicalDeviceTimelineSemaphoreProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MaxTimelineSemaphoreValueDifference == r.MaxTimelineSemaphoreValueDifference)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceTimelineSemaphoreProperties l, in PhysicalDeviceTimelineSemaphoreProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MaxTimelineSemaphoreValueDifference != r.MaxTimelineSemaphoreValueDifference)
			;
	}


	/// <summary>Creates a new PhysicalDeviceTimelineSemaphoreProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceTimelineSemaphoreProperties value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SemaphoreTypeCreateInfo : IEquatable<SemaphoreTypeCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.SemaphoreTypeCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.SemaphoreType SemaphoreType;
	public ulong InitialValue;
	public SemaphoreTypeCreateInfo(
		in Vk.SemaphoreType semaphoreType = default,
		ulong initialValue = default
	) {
		sType = TYPE;
		pNext = null;
		SemaphoreType = semaphoreType;
		InitialValue = initialValue;
	}


	public readonly override bool Equals(object? obj) => (obj is SemaphoreTypeCreateInfo o) && (this == o);
	readonly bool IEquatable<SemaphoreTypeCreateInfo>.Equals(SemaphoreTypeCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SemaphoreType.GetHashCode() ^ InitialValue.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SemaphoreTypeCreateInfo l, in SemaphoreTypeCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SemaphoreType == r.SemaphoreType) && (l.InitialValue == r.InitialValue)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SemaphoreTypeCreateInfo l, in SemaphoreTypeCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SemaphoreType != r.SemaphoreType) || (l.InitialValue != r.InitialValue)
			;
	}


	/// <summary>Creates a new SemaphoreTypeCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SemaphoreTypeCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct TimelineSemaphoreSubmitInfo : IEquatable<TimelineSemaphoreSubmitInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.TimelineSemaphoreSubmitInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public uint WaitSemaphoreValueCount;
	public ulong* WaitSemaphoreValues;
	public uint SignalSemaphoreValueCount;
	public ulong* SignalSemaphoreValues;
	public TimelineSemaphoreSubmitInfo(
		uint waitSemaphoreValueCount = default,
		ulong* waitSemaphoreValues = default,
		uint signalSemaphoreValueCount = default,
		ulong* signalSemaphoreValues = default
	) {
		sType = TYPE;
		pNext = null;
		WaitSemaphoreValueCount = waitSemaphoreValueCount;
		WaitSemaphoreValues = waitSemaphoreValues;
		SignalSemaphoreValueCount = signalSemaphoreValueCount;
		SignalSemaphoreValues = signalSemaphoreValues;
	}


	public readonly override bool Equals(object? obj) => (obj is TimelineSemaphoreSubmitInfo o) && (this == o);
	readonly bool IEquatable<TimelineSemaphoreSubmitInfo>.Equals(TimelineSemaphoreSubmitInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ WaitSemaphoreValueCount.GetHashCode() ^ ((ulong)WaitSemaphoreValues).GetHashCode()
			^ SignalSemaphoreValueCount.GetHashCode() ^ ((ulong)SignalSemaphoreValues).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in TimelineSemaphoreSubmitInfo l, in TimelineSemaphoreSubmitInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.WaitSemaphoreValueCount == r.WaitSemaphoreValueCount) && (l.WaitSemaphoreValues == r.WaitSemaphoreValues)
			&& (l.SignalSemaphoreValueCount == r.SignalSemaphoreValueCount) && (l.SignalSemaphoreValues == r.SignalSemaphoreValues)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in TimelineSemaphoreSubmitInfo l, in TimelineSemaphoreSubmitInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.WaitSemaphoreValueCount != r.WaitSemaphoreValueCount) || (l.WaitSemaphoreValues != r.WaitSemaphoreValues)
			|| (l.SignalSemaphoreValueCount != r.SignalSemaphoreValueCount) || (l.SignalSemaphoreValues != r.SignalSemaphoreValues)
			;
	}


	/// <summary>Creates a new TimelineSemaphoreSubmitInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out TimelineSemaphoreSubmitInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SemaphoreWaitInfo : IEquatable<SemaphoreWaitInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.SemaphoreWaitInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.SemaphoreWaitFlags Flags;
	public uint SemaphoreCount;
	public Vk.Handle<Vk.Semaphore>* Semaphores;
	public ulong* Values;
	public SemaphoreWaitInfo(
		in Vk.SemaphoreWaitFlags flags = default,
		uint semaphoreCount = default,
		in Vk.Handle<Vk.Semaphore>* semaphores = default,
		ulong* values = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		SemaphoreCount = semaphoreCount;
		Semaphores = semaphores;
		Values = values;
	}


	public readonly override bool Equals(object? obj) => (obj is SemaphoreWaitInfo o) && (this == o);
	readonly bool IEquatable<SemaphoreWaitInfo>.Equals(SemaphoreWaitInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ SemaphoreCount.GetHashCode()
			^ ((ulong)Semaphores).GetHashCode() ^ ((ulong)Values).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SemaphoreWaitInfo l, in SemaphoreWaitInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.SemaphoreCount == r.SemaphoreCount)
			&& (l.Semaphores == r.Semaphores) && (l.Values == r.Values)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SemaphoreWaitInfo l, in SemaphoreWaitInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.SemaphoreCount != r.SemaphoreCount)
			|| (l.Semaphores != r.Semaphores) || (l.Values != r.Values)
			;
	}


	/// <summary>Creates a new SemaphoreWaitInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SemaphoreWaitInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SemaphoreSignalInfo : IEquatable<SemaphoreSignalInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.SemaphoreSignalInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Handle<Vk.Semaphore> Semaphore;
	public ulong Value;
	public SemaphoreSignalInfo(
		in Vk.Handle<Vk.Semaphore> semaphore = default,
		ulong value = default
	) {
		sType = TYPE;
		pNext = null;
		Semaphore = semaphore;
		Value = value;
	}


	public readonly override bool Equals(object? obj) => (obj is SemaphoreSignalInfo o) && (this == o);
	readonly bool IEquatable<SemaphoreSignalInfo>.Equals(SemaphoreSignalInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Semaphore.GetHashCode() ^ Value.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SemaphoreSignalInfo l, in SemaphoreSignalInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Semaphore == r.Semaphore) && (l.Value == r.Value)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SemaphoreSignalInfo l, in SemaphoreSignalInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Semaphore != r.Semaphore) || (l.Value != r.Value)
			;
	}


	/// <summary>Creates a new SemaphoreSignalInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SemaphoreSignalInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDevice8BitStorageFeatures : IEquatable<PhysicalDevice8BitStorageFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDevice8BitStorageFeatures;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 StorageBuffer8BitAccess;
	public Vk.Bool32 UniformAndStorageBuffer8BitAccess;
	public Vk.Bool32 StoragePushConstant8;
	public PhysicalDevice8BitStorageFeatures(
		in Vk.Bool32 storageBuffer8BitAccess = default,
		in Vk.Bool32 uniformAndStorageBuffer8BitAccess = default,
		in Vk.Bool32 storagePushConstant8 = default
	) {
		sType = TYPE;
		pNext = null;
		StorageBuffer8BitAccess = storageBuffer8BitAccess;
		UniformAndStorageBuffer8BitAccess = uniformAndStorageBuffer8BitAccess;
		StoragePushConstant8 = storagePushConstant8;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDevice8BitStorageFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDevice8BitStorageFeatures>.Equals(PhysicalDevice8BitStorageFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ StorageBuffer8BitAccess.GetHashCode() ^ UniformAndStorageBuffer8BitAccess.GetHashCode()
			^ StoragePushConstant8.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDevice8BitStorageFeatures l, in PhysicalDevice8BitStorageFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.StorageBuffer8BitAccess == r.StorageBuffer8BitAccess) && (l.UniformAndStorageBuffer8BitAccess == r.UniformAndStorageBuffer8BitAccess)
			&& (l.StoragePushConstant8 == r.StoragePushConstant8)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDevice8BitStorageFeatures l, in PhysicalDevice8BitStorageFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.StorageBuffer8BitAccess != r.StorageBuffer8BitAccess) || (l.UniformAndStorageBuffer8BitAccess != r.UniformAndStorageBuffer8BitAccess)
			|| (l.StoragePushConstant8 != r.StoragePushConstant8)
			;
	}


	/// <summary>Creates a new PhysicalDevice8BitStorageFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDevice8BitStorageFeatures value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceVulkanMemoryModelFeatures : IEquatable<PhysicalDeviceVulkanMemoryModelFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceVulkanMemoryModelFeatures;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 VulkanMemoryModel;
	public Vk.Bool32 VulkanMemoryModelDeviceScope;
	public Vk.Bool32 VulkanMemoryModelAvailabilityVisibilityChains;
	public PhysicalDeviceVulkanMemoryModelFeatures(
		in Vk.Bool32 vulkanMemoryModel = default,
		in Vk.Bool32 vulkanMemoryModelDeviceScope = default,
		in Vk.Bool32 vulkanMemoryModelAvailabilityVisibilityChains = default
	) {
		sType = TYPE;
		pNext = null;
		VulkanMemoryModel = vulkanMemoryModel;
		VulkanMemoryModelDeviceScope = vulkanMemoryModelDeviceScope;
		VulkanMemoryModelAvailabilityVisibilityChains = vulkanMemoryModelAvailabilityVisibilityChains;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceVulkanMemoryModelFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceVulkanMemoryModelFeatures>.Equals(PhysicalDeviceVulkanMemoryModelFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ VulkanMemoryModel.GetHashCode() ^ VulkanMemoryModelDeviceScope.GetHashCode()
			^ VulkanMemoryModelAvailabilityVisibilityChains.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceVulkanMemoryModelFeatures l, in PhysicalDeviceVulkanMemoryModelFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.VulkanMemoryModel == r.VulkanMemoryModel) && (l.VulkanMemoryModelDeviceScope == r.VulkanMemoryModelDeviceScope)
			&& (l.VulkanMemoryModelAvailabilityVisibilityChains == r.VulkanMemoryModelAvailabilityVisibilityChains)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceVulkanMemoryModelFeatures l, in PhysicalDeviceVulkanMemoryModelFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.VulkanMemoryModel != r.VulkanMemoryModel) || (l.VulkanMemoryModelDeviceScope != r.VulkanMemoryModelDeviceScope)
			|| (l.VulkanMemoryModelAvailabilityVisibilityChains != r.VulkanMemoryModelAvailabilityVisibilityChains)
			;
	}


	/// <summary>Creates a new PhysicalDeviceVulkanMemoryModelFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceVulkanMemoryModelFeatures value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceShaderAtomicInt64Features : IEquatable<PhysicalDeviceShaderAtomicInt64Features>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceShaderAtomicInt64Features;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 ShaderBufferInt64Atomics;
	public Vk.Bool32 ShaderSharedInt64Atomics;
	public PhysicalDeviceShaderAtomicInt64Features(
		in Vk.Bool32 shaderBufferInt64Atomics = default,
		in Vk.Bool32 shaderSharedInt64Atomics = default
	) {
		sType = TYPE;
		pNext = null;
		ShaderBufferInt64Atomics = shaderBufferInt64Atomics;
		ShaderSharedInt64Atomics = shaderSharedInt64Atomics;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceShaderAtomicInt64Features o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceShaderAtomicInt64Features>.Equals(PhysicalDeviceShaderAtomicInt64Features obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ShaderBufferInt64Atomics.GetHashCode() ^ ShaderSharedInt64Atomics.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceShaderAtomicInt64Features l, in PhysicalDeviceShaderAtomicInt64Features r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ShaderBufferInt64Atomics == r.ShaderBufferInt64Atomics) && (l.ShaderSharedInt64Atomics == r.ShaderSharedInt64Atomics)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceShaderAtomicInt64Features l, in PhysicalDeviceShaderAtomicInt64Features r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ShaderBufferInt64Atomics != r.ShaderBufferInt64Atomics) || (l.ShaderSharedInt64Atomics != r.ShaderSharedInt64Atomics)
			;
	}


	/// <summary>Creates a new PhysicalDeviceShaderAtomicInt64Features value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceShaderAtomicInt64Features value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceDepthStencilResolveProperties : IEquatable<PhysicalDeviceDepthStencilResolveProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceDepthStencilResolveProperties;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.ResolveModeFlags SupportedDepthResolveModes;
	public Vk.ResolveModeFlags SupportedStencilResolveModes;
	public Vk.Bool32 IndependentResolveNone;
	public Vk.Bool32 IndependentResolve;
	public PhysicalDeviceDepthStencilResolveProperties(
		in Vk.ResolveModeFlags supportedDepthResolveModes = default,
		in Vk.ResolveModeFlags supportedStencilResolveModes = default,
		in Vk.Bool32 independentResolveNone = default,
		in Vk.Bool32 independentResolve = default
	) {
		sType = TYPE;
		pNext = null;
		SupportedDepthResolveModes = supportedDepthResolveModes;
		SupportedStencilResolveModes = supportedStencilResolveModes;
		IndependentResolveNone = independentResolveNone;
		IndependentResolve = independentResolve;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceDepthStencilResolveProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceDepthStencilResolveProperties>.Equals(PhysicalDeviceDepthStencilResolveProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SupportedDepthResolveModes.GetHashCode() ^ SupportedStencilResolveModes.GetHashCode()
			^ IndependentResolveNone.GetHashCode() ^ IndependentResolve.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceDepthStencilResolveProperties l, in PhysicalDeviceDepthStencilResolveProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SupportedDepthResolveModes == r.SupportedDepthResolveModes) && (l.SupportedStencilResolveModes == r.SupportedStencilResolveModes)
			&& (l.IndependentResolveNone == r.IndependentResolveNone) && (l.IndependentResolve == r.IndependentResolve)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceDepthStencilResolveProperties l, in PhysicalDeviceDepthStencilResolveProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SupportedDepthResolveModes != r.SupportedDepthResolveModes) || (l.SupportedStencilResolveModes != r.SupportedStencilResolveModes)
			|| (l.IndependentResolveNone != r.IndependentResolveNone) || (l.IndependentResolve != r.IndependentResolve)
			;
	}


	/// <summary>Creates a new PhysicalDeviceDepthStencilResolveProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceDepthStencilResolveProperties value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SubpassDescriptionDepthStencilResolve : IEquatable<SubpassDescriptionDepthStencilResolve>
{
	public const Vk.StructureType TYPE = Vk.StructureType.SubpassDescriptionDepthStencilResolve;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.ResolveModeFlags DepthResolveMode;
	public Vk.ResolveModeFlags StencilResolveMode;
	public Vk.AttachmentReference2* DepthStencilResolveAttachment;
	public SubpassDescriptionDepthStencilResolve(
		in Vk.ResolveModeFlags depthResolveMode = default,
		in Vk.ResolveModeFlags stencilResolveMode = default,
		in Vk.AttachmentReference2* depthStencilResolveAttachment = default
	) {
		sType = TYPE;
		pNext = null;
		DepthResolveMode = depthResolveMode;
		StencilResolveMode = stencilResolveMode;
		DepthStencilResolveAttachment = depthStencilResolveAttachment;
	}


	public readonly override bool Equals(object? obj) => (obj is SubpassDescriptionDepthStencilResolve o) && (this == o);
	readonly bool IEquatable<SubpassDescriptionDepthStencilResolve>.Equals(SubpassDescriptionDepthStencilResolve obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DepthResolveMode.GetHashCode() ^ StencilResolveMode.GetHashCode()
			^ ((ulong)DepthStencilResolveAttachment).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SubpassDescriptionDepthStencilResolve l, in SubpassDescriptionDepthStencilResolve r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DepthResolveMode == r.DepthResolveMode) && (l.StencilResolveMode == r.StencilResolveMode)
			&& (l.DepthStencilResolveAttachment == r.DepthStencilResolveAttachment)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SubpassDescriptionDepthStencilResolve l, in SubpassDescriptionDepthStencilResolve r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DepthResolveMode != r.DepthResolveMode) || (l.StencilResolveMode != r.StencilResolveMode)
			|| (l.DepthStencilResolveAttachment != r.DepthStencilResolveAttachment)
			;
	}


	/// <summary>Creates a new SubpassDescriptionDepthStencilResolve value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SubpassDescriptionDepthStencilResolve value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ImageStencilUsageCreateInfo : IEquatable<ImageStencilUsageCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ImageStencilUsageCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.ImageUsageFlags StencilUsage;
	public ImageStencilUsageCreateInfo(
		in Vk.ImageUsageFlags stencilUsage = default
	) {
		sType = TYPE;
		pNext = null;
		StencilUsage = stencilUsage;
	}


	public readonly override bool Equals(object? obj) => (obj is ImageStencilUsageCreateInfo o) && (this == o);
	readonly bool IEquatable<ImageStencilUsageCreateInfo>.Equals(ImageStencilUsageCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ StencilUsage.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ImageStencilUsageCreateInfo l, in ImageStencilUsageCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.StencilUsage == r.StencilUsage)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ImageStencilUsageCreateInfo l, in ImageStencilUsageCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.StencilUsage != r.StencilUsage)
			;
	}


	/// <summary>Creates a new ImageStencilUsageCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ImageStencilUsageCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceScalarBlockLayoutFeatures : IEquatable<PhysicalDeviceScalarBlockLayoutFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceScalarBlockLayoutFeatures;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 ScalarBlockLayout;
	public PhysicalDeviceScalarBlockLayoutFeatures(
		in Vk.Bool32 scalarBlockLayout = default
	) {
		sType = TYPE;
		pNext = null;
		ScalarBlockLayout = scalarBlockLayout;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceScalarBlockLayoutFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceScalarBlockLayoutFeatures>.Equals(PhysicalDeviceScalarBlockLayoutFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ScalarBlockLayout.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceScalarBlockLayoutFeatures l, in PhysicalDeviceScalarBlockLayoutFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ScalarBlockLayout == r.ScalarBlockLayout)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceScalarBlockLayoutFeatures l, in PhysicalDeviceScalarBlockLayoutFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ScalarBlockLayout != r.ScalarBlockLayout)
			;
	}


	/// <summary>Creates a new PhysicalDeviceScalarBlockLayoutFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceScalarBlockLayoutFeatures value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceUniformBufferStandardLayoutFeatures : IEquatable<PhysicalDeviceUniformBufferStandardLayoutFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceUniformBufferStandardLayoutFeatures;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 UniformBufferStandardLayout;
	public PhysicalDeviceUniformBufferStandardLayoutFeatures(
		in Vk.Bool32 uniformBufferStandardLayout = default
	) {
		sType = TYPE;
		pNext = null;
		UniformBufferStandardLayout = uniformBufferStandardLayout;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceUniformBufferStandardLayoutFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceUniformBufferStandardLayoutFeatures>.Equals(PhysicalDeviceUniformBufferStandardLayoutFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ UniformBufferStandardLayout.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceUniformBufferStandardLayoutFeatures l, in PhysicalDeviceUniformBufferStandardLayoutFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.UniformBufferStandardLayout == r.UniformBufferStandardLayout)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceUniformBufferStandardLayoutFeatures l, in PhysicalDeviceUniformBufferStandardLayoutFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.UniformBufferStandardLayout != r.UniformBufferStandardLayout)
			;
	}


	/// <summary>Creates a new PhysicalDeviceUniformBufferStandardLayoutFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceUniformBufferStandardLayoutFeatures value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceBufferDeviceAddressFeatures : IEquatable<PhysicalDeviceBufferDeviceAddressFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceBufferDeviceAddressFeatures;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 BufferDeviceAddress;
	public Vk.Bool32 BufferDeviceAddressCaptureReplay;
	public Vk.Bool32 BufferDeviceAddressMultiDevice;
	public PhysicalDeviceBufferDeviceAddressFeatures(
		in Vk.Bool32 bufferDeviceAddress = default,
		in Vk.Bool32 bufferDeviceAddressCaptureReplay = default,
		in Vk.Bool32 bufferDeviceAddressMultiDevice = default
	) {
		sType = TYPE;
		pNext = null;
		BufferDeviceAddress = bufferDeviceAddress;
		BufferDeviceAddressCaptureReplay = bufferDeviceAddressCaptureReplay;
		BufferDeviceAddressMultiDevice = bufferDeviceAddressMultiDevice;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceBufferDeviceAddressFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceBufferDeviceAddressFeatures>.Equals(PhysicalDeviceBufferDeviceAddressFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ BufferDeviceAddress.GetHashCode() ^ BufferDeviceAddressCaptureReplay.GetHashCode()
			^ BufferDeviceAddressMultiDevice.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceBufferDeviceAddressFeatures l, in PhysicalDeviceBufferDeviceAddressFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.BufferDeviceAddress == r.BufferDeviceAddress) && (l.BufferDeviceAddressCaptureReplay == r.BufferDeviceAddressCaptureReplay)
			&& (l.BufferDeviceAddressMultiDevice == r.BufferDeviceAddressMultiDevice)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceBufferDeviceAddressFeatures l, in PhysicalDeviceBufferDeviceAddressFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.BufferDeviceAddress != r.BufferDeviceAddress) || (l.BufferDeviceAddressCaptureReplay != r.BufferDeviceAddressCaptureReplay)
			|| (l.BufferDeviceAddressMultiDevice != r.BufferDeviceAddressMultiDevice)
			;
	}


	/// <summary>Creates a new PhysicalDeviceBufferDeviceAddressFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceBufferDeviceAddressFeatures value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct BufferDeviceAddressInfo : IEquatable<BufferDeviceAddressInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.BufferDeviceAddressInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Handle<Vk.Buffer> Buffer;
	public BufferDeviceAddressInfo(
		in Vk.Handle<Vk.Buffer> buffer = default
	) {
		sType = TYPE;
		pNext = null;
		Buffer = buffer;
	}


	public readonly override bool Equals(object? obj) => (obj is BufferDeviceAddressInfo o) && (this == o);
	readonly bool IEquatable<BufferDeviceAddressInfo>.Equals(BufferDeviceAddressInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Buffer.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in BufferDeviceAddressInfo l, in BufferDeviceAddressInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Buffer == r.Buffer)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in BufferDeviceAddressInfo l, in BufferDeviceAddressInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Buffer != r.Buffer)
			;
	}


	/// <summary>Creates a new BufferDeviceAddressInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out BufferDeviceAddressInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct BufferOpaqueCaptureAddressCreateInfo : IEquatable<BufferOpaqueCaptureAddressCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.BufferOpaqueCaptureAddressCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public ulong OpaqueCaptureAddress;
	public BufferOpaqueCaptureAddressCreateInfo(
		ulong opaqueCaptureAddress = default
	) {
		sType = TYPE;
		pNext = null;
		OpaqueCaptureAddress = opaqueCaptureAddress;
	}


	public readonly override bool Equals(object? obj) => (obj is BufferOpaqueCaptureAddressCreateInfo o) && (this == o);
	readonly bool IEquatable<BufferOpaqueCaptureAddressCreateInfo>.Equals(BufferOpaqueCaptureAddressCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ OpaqueCaptureAddress.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in BufferOpaqueCaptureAddressCreateInfo l, in BufferOpaqueCaptureAddressCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.OpaqueCaptureAddress == r.OpaqueCaptureAddress)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in BufferOpaqueCaptureAddressCreateInfo l, in BufferOpaqueCaptureAddressCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.OpaqueCaptureAddress != r.OpaqueCaptureAddress)
			;
	}


	/// <summary>Creates a new BufferOpaqueCaptureAddressCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out BufferOpaqueCaptureAddressCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceImagelessFramebufferFeatures : IEquatable<PhysicalDeviceImagelessFramebufferFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceImagelessFramebufferFeatures;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 ImagelessFramebuffer;
	public PhysicalDeviceImagelessFramebufferFeatures(
		in Vk.Bool32 imagelessFramebuffer = default
	) {
		sType = TYPE;
		pNext = null;
		ImagelessFramebuffer = imagelessFramebuffer;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceImagelessFramebufferFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceImagelessFramebufferFeatures>.Equals(PhysicalDeviceImagelessFramebufferFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ImagelessFramebuffer.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceImagelessFramebufferFeatures l, in PhysicalDeviceImagelessFramebufferFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ImagelessFramebuffer == r.ImagelessFramebuffer)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceImagelessFramebufferFeatures l, in PhysicalDeviceImagelessFramebufferFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ImagelessFramebuffer != r.ImagelessFramebuffer)
			;
	}


	/// <summary>Creates a new PhysicalDeviceImagelessFramebufferFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceImagelessFramebufferFeatures value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct FramebufferAttachmentsCreateInfo : IEquatable<FramebufferAttachmentsCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.FramebufferAttachmentsCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public uint AttachmentImageInfoCount;
	public Vk.FramebufferAttachmentImageInfo* AttachmentImageInfos;
	public FramebufferAttachmentsCreateInfo(
		uint attachmentImageInfoCount = default,
		in Vk.FramebufferAttachmentImageInfo* attachmentImageInfos = default
	) {
		sType = TYPE;
		pNext = null;
		AttachmentImageInfoCount = attachmentImageInfoCount;
		AttachmentImageInfos = attachmentImageInfos;
	}


	public readonly override bool Equals(object? obj) => (obj is FramebufferAttachmentsCreateInfo o) && (this == o);
	readonly bool IEquatable<FramebufferAttachmentsCreateInfo>.Equals(FramebufferAttachmentsCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ AttachmentImageInfoCount.GetHashCode() ^ ((ulong)AttachmentImageInfos).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in FramebufferAttachmentsCreateInfo l, in FramebufferAttachmentsCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.AttachmentImageInfoCount == r.AttachmentImageInfoCount) && (l.AttachmentImageInfos == r.AttachmentImageInfos)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in FramebufferAttachmentsCreateInfo l, in FramebufferAttachmentsCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.AttachmentImageInfoCount != r.AttachmentImageInfoCount) || (l.AttachmentImageInfos != r.AttachmentImageInfos)
			;
	}


	/// <summary>Creates a new FramebufferAttachmentsCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out FramebufferAttachmentsCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct FramebufferAttachmentImageInfo : IEquatable<FramebufferAttachmentImageInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.FramebufferAttachmentImageInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.ImageCreateFlags Flags;
	public Vk.ImageUsageFlags Usage;
	public uint Width;
	public uint Height;
	public uint LayerCount;
	public uint ViewFormatCount;
	public Vk.Format* ViewFormats;
	public FramebufferAttachmentImageInfo(
		in Vk.ImageCreateFlags flags = default,
		in Vk.ImageUsageFlags usage = default,
		uint width = default,
		uint height = default,
		uint layerCount = default,
		uint viewFormatCount = default,
		in Vk.Format* viewFormats = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		Usage = usage;
		Width = width;
		Height = height;
		LayerCount = layerCount;
		ViewFormatCount = viewFormatCount;
		ViewFormats = viewFormats;
	}


	public readonly override bool Equals(object? obj) => (obj is FramebufferAttachmentImageInfo o) && (this == o);
	readonly bool IEquatable<FramebufferAttachmentImageInfo>.Equals(FramebufferAttachmentImageInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ Usage.GetHashCode()
			^ Width.GetHashCode() ^ Height.GetHashCode() ^ LayerCount.GetHashCode() ^ ViewFormatCount.GetHashCode()
			^ ((ulong)ViewFormats).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in FramebufferAttachmentImageInfo l, in FramebufferAttachmentImageInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.Usage == r.Usage)
			&& (l.Width == r.Width) && (l.Height == r.Height) && (l.LayerCount == r.LayerCount) && (l.ViewFormatCount == r.ViewFormatCount)
			&& (l.ViewFormats == r.ViewFormats)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in FramebufferAttachmentImageInfo l, in FramebufferAttachmentImageInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.Usage != r.Usage)
			|| (l.Width != r.Width) || (l.Height != r.Height) || (l.LayerCount != r.LayerCount) || (l.ViewFormatCount != r.ViewFormatCount)
			|| (l.ViewFormats != r.ViewFormats)
			;
	}


	/// <summary>Creates a new FramebufferAttachmentImageInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out FramebufferAttachmentImageInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct RenderPassAttachmentBeginInfo : IEquatable<RenderPassAttachmentBeginInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.RenderPassAttachmentBeginInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public uint AttachmentCount;
	public Vk.Handle<Vk.ImageView>* Attachments;
	public RenderPassAttachmentBeginInfo(
		uint attachmentCount = default,
		in Vk.Handle<Vk.ImageView>* attachments = default
	) {
		sType = TYPE;
		pNext = null;
		AttachmentCount = attachmentCount;
		Attachments = attachments;
	}


	public readonly override bool Equals(object? obj) => (obj is RenderPassAttachmentBeginInfo o) && (this == o);
	readonly bool IEquatable<RenderPassAttachmentBeginInfo>.Equals(RenderPassAttachmentBeginInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ AttachmentCount.GetHashCode() ^ ((ulong)Attachments).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in RenderPassAttachmentBeginInfo l, in RenderPassAttachmentBeginInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.AttachmentCount == r.AttachmentCount) && (l.Attachments == r.Attachments)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in RenderPassAttachmentBeginInfo l, in RenderPassAttachmentBeginInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.AttachmentCount != r.AttachmentCount) || (l.Attachments != r.Attachments)
			;
	}


	/// <summary>Creates a new RenderPassAttachmentBeginInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out RenderPassAttachmentBeginInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceSeparateDepthStencilLayoutsFeatures : IEquatable<PhysicalDeviceSeparateDepthStencilLayoutsFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceSeparateDepthStencilLayoutsFeatures;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 SeparateDepthStencilLayouts;
	public PhysicalDeviceSeparateDepthStencilLayoutsFeatures(
		in Vk.Bool32 separateDepthStencilLayouts = default
	) {
		sType = TYPE;
		pNext = null;
		SeparateDepthStencilLayouts = separateDepthStencilLayouts;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceSeparateDepthStencilLayoutsFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceSeparateDepthStencilLayoutsFeatures>.Equals(PhysicalDeviceSeparateDepthStencilLayoutsFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SeparateDepthStencilLayouts.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceSeparateDepthStencilLayoutsFeatures l, in PhysicalDeviceSeparateDepthStencilLayoutsFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SeparateDepthStencilLayouts == r.SeparateDepthStencilLayouts)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceSeparateDepthStencilLayoutsFeatures l, in PhysicalDeviceSeparateDepthStencilLayoutsFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SeparateDepthStencilLayouts != r.SeparateDepthStencilLayouts)
			;
	}


	/// <summary>Creates a new PhysicalDeviceSeparateDepthStencilLayoutsFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceSeparateDepthStencilLayoutsFeatures value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct AttachmentReferenceStencilLayout : IEquatable<AttachmentReferenceStencilLayout>
{
	public const Vk.StructureType TYPE = Vk.StructureType.AttachmentReferenceStencilLayout;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.ImageLayout StencilLayout;
	public AttachmentReferenceStencilLayout(
		in Vk.ImageLayout stencilLayout = default
	) {
		sType = TYPE;
		pNext = null;
		StencilLayout = stencilLayout;
	}


	public readonly override bool Equals(object? obj) => (obj is AttachmentReferenceStencilLayout o) && (this == o);
	readonly bool IEquatable<AttachmentReferenceStencilLayout>.Equals(AttachmentReferenceStencilLayout obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ StencilLayout.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in AttachmentReferenceStencilLayout l, in AttachmentReferenceStencilLayout r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.StencilLayout == r.StencilLayout)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in AttachmentReferenceStencilLayout l, in AttachmentReferenceStencilLayout r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.StencilLayout != r.StencilLayout)
			;
	}


	/// <summary>Creates a new AttachmentReferenceStencilLayout value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out AttachmentReferenceStencilLayout value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct AttachmentDescriptionStencilLayout : IEquatable<AttachmentDescriptionStencilLayout>
{
	public const Vk.StructureType TYPE = Vk.StructureType.AttachmentDescriptionStencilLayout;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.ImageLayout StencilInitialLayout;
	public Vk.ImageLayout StencilFinalLayout;
	public AttachmentDescriptionStencilLayout(
		in Vk.ImageLayout stencilInitialLayout = default,
		in Vk.ImageLayout stencilFinalLayout = default
	) {
		sType = TYPE;
		pNext = null;
		StencilInitialLayout = stencilInitialLayout;
		StencilFinalLayout = stencilFinalLayout;
	}


	public readonly override bool Equals(object? obj) => (obj is AttachmentDescriptionStencilLayout o) && (this == o);
	readonly bool IEquatable<AttachmentDescriptionStencilLayout>.Equals(AttachmentDescriptionStencilLayout obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ StencilInitialLayout.GetHashCode() ^ StencilFinalLayout.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in AttachmentDescriptionStencilLayout l, in AttachmentDescriptionStencilLayout r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.StencilInitialLayout == r.StencilInitialLayout) && (l.StencilFinalLayout == r.StencilFinalLayout)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in AttachmentDescriptionStencilLayout l, in AttachmentDescriptionStencilLayout r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.StencilInitialLayout != r.StencilInitialLayout) || (l.StencilFinalLayout != r.StencilFinalLayout)
			;
	}


	/// <summary>Creates a new AttachmentDescriptionStencilLayout value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out AttachmentDescriptionStencilLayout value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct MemoryOpaqueCaptureAddressAllocateInfo : IEquatable<MemoryOpaqueCaptureAddressAllocateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.MemoryOpaqueCaptureAddressAllocateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public ulong OpaqueCaptureAddress;
	public MemoryOpaqueCaptureAddressAllocateInfo(
		ulong opaqueCaptureAddress = default
	) {
		sType = TYPE;
		pNext = null;
		OpaqueCaptureAddress = opaqueCaptureAddress;
	}


	public readonly override bool Equals(object? obj) => (obj is MemoryOpaqueCaptureAddressAllocateInfo o) && (this == o);
	readonly bool IEquatable<MemoryOpaqueCaptureAddressAllocateInfo>.Equals(MemoryOpaqueCaptureAddressAllocateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ OpaqueCaptureAddress.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in MemoryOpaqueCaptureAddressAllocateInfo l, in MemoryOpaqueCaptureAddressAllocateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.OpaqueCaptureAddress == r.OpaqueCaptureAddress)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in MemoryOpaqueCaptureAddressAllocateInfo l, in MemoryOpaqueCaptureAddressAllocateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.OpaqueCaptureAddress != r.OpaqueCaptureAddress)
			;
	}


	/// <summary>Creates a new MemoryOpaqueCaptureAddressAllocateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out MemoryOpaqueCaptureAddressAllocateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DeviceMemoryOpaqueCaptureAddressInfo : IEquatable<DeviceMemoryOpaqueCaptureAddressInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DeviceMemoryOpaqueCaptureAddressInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Handle<Vk.DeviceMemory> Memory;
	public DeviceMemoryOpaqueCaptureAddressInfo(
		in Vk.Handle<Vk.DeviceMemory> memory = default
	) {
		sType = TYPE;
		pNext = null;
		Memory = memory;
	}


	public readonly override bool Equals(object? obj) => (obj is DeviceMemoryOpaqueCaptureAddressInfo o) && (this == o);
	readonly bool IEquatable<DeviceMemoryOpaqueCaptureAddressInfo>.Equals(DeviceMemoryOpaqueCaptureAddressInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Memory.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DeviceMemoryOpaqueCaptureAddressInfo l, in DeviceMemoryOpaqueCaptureAddressInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Memory == r.Memory)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DeviceMemoryOpaqueCaptureAddressInfo l, in DeviceMemoryOpaqueCaptureAddressInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Memory != r.Memory)
			;
	}


	/// <summary>Creates a new DeviceMemoryOpaqueCaptureAddressInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DeviceMemoryOpaqueCaptureAddressInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceVulkan11Features : IEquatable<PhysicalDeviceVulkan11Features>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceVulkan11Features;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 StorageBuffer16BitAccess;
	public Vk.Bool32 UniformAndStorageBuffer16BitAccess;
	public Vk.Bool32 StoragePushConstant16;
	public Vk.Bool32 StorageInputOutput16;
	public Vk.Bool32 Multiview;
	public Vk.Bool32 MultiviewGeometryShader;
	public Vk.Bool32 MultiviewTessellationShader;
	public Vk.Bool32 VariablePointersStorageBuffer;
	public Vk.Bool32 VariablePointers;
	public Vk.Bool32 ProtectedMemory;
	public Vk.Bool32 SamplerYcbcrConversion;
	public Vk.Bool32 ShaderDrawParameters;
	public PhysicalDeviceVulkan11Features(
		in Vk.Bool32 storageBuffer16BitAccess = default,
		in Vk.Bool32 uniformAndStorageBuffer16BitAccess = default,
		in Vk.Bool32 storagePushConstant16 = default,
		in Vk.Bool32 storageInputOutput16 = default,
		in Vk.Bool32 multiview = default,
		in Vk.Bool32 multiviewGeometryShader = default,
		in Vk.Bool32 multiviewTessellationShader = default,
		in Vk.Bool32 variablePointersStorageBuffer = default,
		in Vk.Bool32 variablePointers = default,
		in Vk.Bool32 protectedMemory = default,
		in Vk.Bool32 samplerYcbcrConversion = default,
		in Vk.Bool32 shaderDrawParameters = default
	) {
		sType = TYPE;
		pNext = null;
		StorageBuffer16BitAccess = storageBuffer16BitAccess;
		UniformAndStorageBuffer16BitAccess = uniformAndStorageBuffer16BitAccess;
		StoragePushConstant16 = storagePushConstant16;
		StorageInputOutput16 = storageInputOutput16;
		Multiview = multiview;
		MultiviewGeometryShader = multiviewGeometryShader;
		MultiviewTessellationShader = multiviewTessellationShader;
		VariablePointersStorageBuffer = variablePointersStorageBuffer;
		VariablePointers = variablePointers;
		ProtectedMemory = protectedMemory;
		SamplerYcbcrConversion = samplerYcbcrConversion;
		ShaderDrawParameters = shaderDrawParameters;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceVulkan11Features o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceVulkan11Features>.Equals(PhysicalDeviceVulkan11Features obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ StorageBuffer16BitAccess.GetHashCode() ^ UniformAndStorageBuffer16BitAccess.GetHashCode()
			^ StoragePushConstant16.GetHashCode() ^ StorageInputOutput16.GetHashCode() ^ Multiview.GetHashCode() ^ MultiviewGeometryShader.GetHashCode()
			^ MultiviewTessellationShader.GetHashCode() ^ VariablePointersStorageBuffer.GetHashCode() ^ VariablePointers.GetHashCode() ^ ProtectedMemory.GetHashCode()
			^ SamplerYcbcrConversion.GetHashCode() ^ ShaderDrawParameters.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceVulkan11Features l, in PhysicalDeviceVulkan11Features r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.StorageBuffer16BitAccess == r.StorageBuffer16BitAccess) && (l.UniformAndStorageBuffer16BitAccess == r.UniformAndStorageBuffer16BitAccess)
			&& (l.StoragePushConstant16 == r.StoragePushConstant16) && (l.StorageInputOutput16 == r.StorageInputOutput16) && (l.Multiview == r.Multiview) && (l.MultiviewGeometryShader == r.MultiviewGeometryShader)
			&& (l.MultiviewTessellationShader == r.MultiviewTessellationShader) && (l.VariablePointersStorageBuffer == r.VariablePointersStorageBuffer) && (l.VariablePointers == r.VariablePointers) && (l.ProtectedMemory == r.ProtectedMemory)
			&& (l.SamplerYcbcrConversion == r.SamplerYcbcrConversion) && (l.ShaderDrawParameters == r.ShaderDrawParameters)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceVulkan11Features l, in PhysicalDeviceVulkan11Features r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.StorageBuffer16BitAccess != r.StorageBuffer16BitAccess) || (l.UniformAndStorageBuffer16BitAccess != r.UniformAndStorageBuffer16BitAccess)
			|| (l.StoragePushConstant16 != r.StoragePushConstant16) || (l.StorageInputOutput16 != r.StorageInputOutput16) || (l.Multiview != r.Multiview) || (l.MultiviewGeometryShader != r.MultiviewGeometryShader)
			|| (l.MultiviewTessellationShader != r.MultiviewTessellationShader) || (l.VariablePointersStorageBuffer != r.VariablePointersStorageBuffer) || (l.VariablePointers != r.VariablePointers) || (l.ProtectedMemory != r.ProtectedMemory)
			|| (l.SamplerYcbcrConversion != r.SamplerYcbcrConversion) || (l.ShaderDrawParameters != r.ShaderDrawParameters)
			;
	}


	/// <summary>Creates a new PhysicalDeviceVulkan11Features value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceVulkan11Features value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceVulkan11Properties : IEquatable<PhysicalDeviceVulkan11Properties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceVulkan11Properties;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.UUID DeviceUUID;
	public Vk.UUID DriverUUID;
	public Vk.LUID DeviceLUID;
	public uint DeviceNodeMask;
	public Vk.Bool32 DeviceLUIDValid;
	public uint SubgroupSize;
	public Vk.ShaderStageFlags SubgroupSupportedStages;
	public Vk.SubgroupFeatureFlags SubgroupSupportedOperations;
	public Vk.Bool32 SubgroupQuadOperationsInAllStages;
	public Vk.PointClippingBehavior PointClippingBehavior;
	public uint MaxMultiviewViewCount;
	public uint MaxMultiviewInstanceIndex;
	public Vk.Bool32 ProtectedNoFault;
	public uint MaxPerSetDescriptors;
	public Vk.DeviceSize MaxMemoryAllocationSize;
	public PhysicalDeviceVulkan11Properties(
		in Vk.UUID deviceUUID = default,
		in Vk.UUID driverUUID = default,
		in Vk.LUID deviceLUID = default,
		uint deviceNodeMask = default,
		in Vk.Bool32 deviceLUIDValid = default,
		uint subgroupSize = default,
		in Vk.ShaderStageFlags subgroupSupportedStages = default,
		in Vk.SubgroupFeatureFlags subgroupSupportedOperations = default,
		in Vk.Bool32 subgroupQuadOperationsInAllStages = default,
		in Vk.PointClippingBehavior pointClippingBehavior = default,
		uint maxMultiviewViewCount = default,
		uint maxMultiviewInstanceIndex = default,
		in Vk.Bool32 protectedNoFault = default,
		uint maxPerSetDescriptors = default,
		in Vk.DeviceSize maxMemoryAllocationSize = default
	) {
		sType = TYPE;
		pNext = null;
		DeviceUUID = deviceUUID;
		DriverUUID = driverUUID;
		DeviceLUID = deviceLUID;
		DeviceNodeMask = deviceNodeMask;
		DeviceLUIDValid = deviceLUIDValid;
		SubgroupSize = subgroupSize;
		SubgroupSupportedStages = subgroupSupportedStages;
		SubgroupSupportedOperations = subgroupSupportedOperations;
		SubgroupQuadOperationsInAllStages = subgroupQuadOperationsInAllStages;
		PointClippingBehavior = pointClippingBehavior;
		MaxMultiviewViewCount = maxMultiviewViewCount;
		MaxMultiviewInstanceIndex = maxMultiviewInstanceIndex;
		ProtectedNoFault = protectedNoFault;
		MaxPerSetDescriptors = maxPerSetDescriptors;
		MaxMemoryAllocationSize = maxMemoryAllocationSize;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceVulkan11Properties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceVulkan11Properties>.Equals(PhysicalDeviceVulkan11Properties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DeviceUUID.GetHashCode() ^ DriverUUID.GetHashCode()
			^ DeviceLUID.GetHashCode() ^ DeviceNodeMask.GetHashCode() ^ DeviceLUIDValid.GetHashCode() ^ SubgroupSize.GetHashCode()
			^ SubgroupSupportedStages.GetHashCode() ^ SubgroupSupportedOperations.GetHashCode() ^ SubgroupQuadOperationsInAllStages.GetHashCode() ^ PointClippingBehavior.GetHashCode()
			^ MaxMultiviewViewCount.GetHashCode() ^ MaxMultiviewInstanceIndex.GetHashCode() ^ ProtectedNoFault.GetHashCode() ^ MaxPerSetDescriptors.GetHashCode()
			^ MaxMemoryAllocationSize.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceVulkan11Properties l, in PhysicalDeviceVulkan11Properties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DeviceUUID == r.DeviceUUID) && (l.DriverUUID == r.DriverUUID)
			&& (l.DeviceLUID == r.DeviceLUID) && (l.DeviceNodeMask == r.DeviceNodeMask) && (l.DeviceLUIDValid == r.DeviceLUIDValid) && (l.SubgroupSize == r.SubgroupSize)
			&& (l.SubgroupSupportedStages == r.SubgroupSupportedStages) && (l.SubgroupSupportedOperations == r.SubgroupSupportedOperations) && (l.SubgroupQuadOperationsInAllStages == r.SubgroupQuadOperationsInAllStages) && (l.PointClippingBehavior == r.PointClippingBehavior)
			&& (l.MaxMultiviewViewCount == r.MaxMultiviewViewCount) && (l.MaxMultiviewInstanceIndex == r.MaxMultiviewInstanceIndex) && (l.ProtectedNoFault == r.ProtectedNoFault) && (l.MaxPerSetDescriptors == r.MaxPerSetDescriptors)
			&& (l.MaxMemoryAllocationSize == r.MaxMemoryAllocationSize)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceVulkan11Properties l, in PhysicalDeviceVulkan11Properties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DeviceUUID != r.DeviceUUID) || (l.DriverUUID != r.DriverUUID)
			|| (l.DeviceLUID != r.DeviceLUID) || (l.DeviceNodeMask != r.DeviceNodeMask) || (l.DeviceLUIDValid != r.DeviceLUIDValid) || (l.SubgroupSize != r.SubgroupSize)
			|| (l.SubgroupSupportedStages != r.SubgroupSupportedStages) || (l.SubgroupSupportedOperations != r.SubgroupSupportedOperations) || (l.SubgroupQuadOperationsInAllStages != r.SubgroupQuadOperationsInAllStages) || (l.PointClippingBehavior != r.PointClippingBehavior)
			|| (l.MaxMultiviewViewCount != r.MaxMultiviewViewCount) || (l.MaxMultiviewInstanceIndex != r.MaxMultiviewInstanceIndex) || (l.ProtectedNoFault != r.ProtectedNoFault) || (l.MaxPerSetDescriptors != r.MaxPerSetDescriptors)
			|| (l.MaxMemoryAllocationSize != r.MaxMemoryAllocationSize)
			;
	}


	/// <summary>Creates a new PhysicalDeviceVulkan11Properties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceVulkan11Properties value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceVulkan12Features : IEquatable<PhysicalDeviceVulkan12Features>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceVulkan12Features;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 SamplerMirrorClampToEdge;
	public Vk.Bool32 DrawIndirectCount;
	public Vk.Bool32 StorageBuffer8BitAccess;
	public Vk.Bool32 UniformAndStorageBuffer8BitAccess;
	public Vk.Bool32 StoragePushConstant8;
	public Vk.Bool32 ShaderBufferInt64Atomics;
	public Vk.Bool32 ShaderSharedInt64Atomics;
	public Vk.Bool32 ShaderFloat16;
	public Vk.Bool32 ShaderInt8;
	public Vk.Bool32 DescriptorIndexing;
	public Vk.Bool32 ShaderInputAttachmentArrayDynamicIndexing;
	public Vk.Bool32 ShaderUniformTexelBufferArrayDynamicIndexing;
	public Vk.Bool32 ShaderStorageTexelBufferArrayDynamicIndexing;
	public Vk.Bool32 ShaderUniformBufferArrayNonUniformIndexing;
	public Vk.Bool32 ShaderSampledImageArrayNonUniformIndexing;
	public Vk.Bool32 ShaderStorageBufferArrayNonUniformIndexing;
	public Vk.Bool32 ShaderStorageImageArrayNonUniformIndexing;
	public Vk.Bool32 ShaderInputAttachmentArrayNonUniformIndexing;
	public Vk.Bool32 ShaderUniformTexelBufferArrayNonUniformIndexing;
	public Vk.Bool32 ShaderStorageTexelBufferArrayNonUniformIndexing;
	public Vk.Bool32 DescriptorBindingUniformBufferUpdateAfterBind;
	public Vk.Bool32 DescriptorBindingSampledImageUpdateAfterBind;
	public Vk.Bool32 DescriptorBindingStorageImageUpdateAfterBind;
	public Vk.Bool32 DescriptorBindingStorageBufferUpdateAfterBind;
	public Vk.Bool32 DescriptorBindingUniformTexelBufferUpdateAfterBind;
	public Vk.Bool32 DescriptorBindingStorageTexelBufferUpdateAfterBind;
	public Vk.Bool32 DescriptorBindingUpdateUnusedWhilePending;
	public Vk.Bool32 DescriptorBindingPartiallyBound;
	public Vk.Bool32 DescriptorBindingVariableDescriptorCount;
	public Vk.Bool32 RuntimeDescriptorArray;
	public Vk.Bool32 SamplerFilterMinmax;
	public Vk.Bool32 ScalarBlockLayout;
	public Vk.Bool32 ImagelessFramebuffer;
	public Vk.Bool32 UniformBufferStandardLayout;
	public Vk.Bool32 ShaderSubgroupExtendedTypes;
	public Vk.Bool32 SeparateDepthStencilLayouts;
	public Vk.Bool32 HostQueryReset;
	public Vk.Bool32 TimelineSemaphore;
	public Vk.Bool32 BufferDeviceAddress;
	public Vk.Bool32 BufferDeviceAddressCaptureReplay;
	public Vk.Bool32 BufferDeviceAddressMultiDevice;
	public Vk.Bool32 VulkanMemoryModel;
	public Vk.Bool32 VulkanMemoryModelDeviceScope;
	public Vk.Bool32 VulkanMemoryModelAvailabilityVisibilityChains;
	public Vk.Bool32 ShaderOutputViewportIndex;
	public Vk.Bool32 ShaderOutputLayer;
	public Vk.Bool32 SubgroupBroadcastDynamicId;
	public PhysicalDeviceVulkan12Features(
		in Vk.Bool32 samplerMirrorClampToEdge = default,
		in Vk.Bool32 drawIndirectCount = default,
		in Vk.Bool32 storageBuffer8BitAccess = default,
		in Vk.Bool32 uniformAndStorageBuffer8BitAccess = default,
		in Vk.Bool32 storagePushConstant8 = default,
		in Vk.Bool32 shaderBufferInt64Atomics = default,
		in Vk.Bool32 shaderSharedInt64Atomics = default,
		in Vk.Bool32 shaderFloat16 = default,
		in Vk.Bool32 shaderInt8 = default,
		in Vk.Bool32 descriptorIndexing = default,
		in Vk.Bool32 shaderInputAttachmentArrayDynamicIndexing = default,
		in Vk.Bool32 shaderUniformTexelBufferArrayDynamicIndexing = default,
		in Vk.Bool32 shaderStorageTexelBufferArrayDynamicIndexing = default,
		in Vk.Bool32 shaderUniformBufferArrayNonUniformIndexing = default,
		in Vk.Bool32 shaderSampledImageArrayNonUniformIndexing = default,
		in Vk.Bool32 shaderStorageBufferArrayNonUniformIndexing = default,
		in Vk.Bool32 shaderStorageImageArrayNonUniformIndexing = default,
		in Vk.Bool32 shaderInputAttachmentArrayNonUniformIndexing = default,
		in Vk.Bool32 shaderUniformTexelBufferArrayNonUniformIndexing = default,
		in Vk.Bool32 shaderStorageTexelBufferArrayNonUniformIndexing = default,
		in Vk.Bool32 descriptorBindingUniformBufferUpdateAfterBind = default,
		in Vk.Bool32 descriptorBindingSampledImageUpdateAfterBind = default,
		in Vk.Bool32 descriptorBindingStorageImageUpdateAfterBind = default,
		in Vk.Bool32 descriptorBindingStorageBufferUpdateAfterBind = default,
		in Vk.Bool32 descriptorBindingUniformTexelBufferUpdateAfterBind = default,
		in Vk.Bool32 descriptorBindingStorageTexelBufferUpdateAfterBind = default,
		in Vk.Bool32 descriptorBindingUpdateUnusedWhilePending = default,
		in Vk.Bool32 descriptorBindingPartiallyBound = default,
		in Vk.Bool32 descriptorBindingVariableDescriptorCount = default,
		in Vk.Bool32 runtimeDescriptorArray = default,
		in Vk.Bool32 samplerFilterMinmax = default,
		in Vk.Bool32 scalarBlockLayout = default,
		in Vk.Bool32 imagelessFramebuffer = default,
		in Vk.Bool32 uniformBufferStandardLayout = default,
		in Vk.Bool32 shaderSubgroupExtendedTypes = default,
		in Vk.Bool32 separateDepthStencilLayouts = default,
		in Vk.Bool32 hostQueryReset = default,
		in Vk.Bool32 timelineSemaphore = default,
		in Vk.Bool32 bufferDeviceAddress = default,
		in Vk.Bool32 bufferDeviceAddressCaptureReplay = default,
		in Vk.Bool32 bufferDeviceAddressMultiDevice = default,
		in Vk.Bool32 vulkanMemoryModel = default,
		in Vk.Bool32 vulkanMemoryModelDeviceScope = default,
		in Vk.Bool32 vulkanMemoryModelAvailabilityVisibilityChains = default,
		in Vk.Bool32 shaderOutputViewportIndex = default,
		in Vk.Bool32 shaderOutputLayer = default,
		in Vk.Bool32 subgroupBroadcastDynamicId = default
	) {
		sType = TYPE;
		pNext = null;
		SamplerMirrorClampToEdge = samplerMirrorClampToEdge;
		DrawIndirectCount = drawIndirectCount;
		StorageBuffer8BitAccess = storageBuffer8BitAccess;
		UniformAndStorageBuffer8BitAccess = uniformAndStorageBuffer8BitAccess;
		StoragePushConstant8 = storagePushConstant8;
		ShaderBufferInt64Atomics = shaderBufferInt64Atomics;
		ShaderSharedInt64Atomics = shaderSharedInt64Atomics;
		ShaderFloat16 = shaderFloat16;
		ShaderInt8 = shaderInt8;
		DescriptorIndexing = descriptorIndexing;
		ShaderInputAttachmentArrayDynamicIndexing = shaderInputAttachmentArrayDynamicIndexing;
		ShaderUniformTexelBufferArrayDynamicIndexing = shaderUniformTexelBufferArrayDynamicIndexing;
		ShaderStorageTexelBufferArrayDynamicIndexing = shaderStorageTexelBufferArrayDynamicIndexing;
		ShaderUniformBufferArrayNonUniformIndexing = shaderUniformBufferArrayNonUniformIndexing;
		ShaderSampledImageArrayNonUniformIndexing = shaderSampledImageArrayNonUniformIndexing;
		ShaderStorageBufferArrayNonUniformIndexing = shaderStorageBufferArrayNonUniformIndexing;
		ShaderStorageImageArrayNonUniformIndexing = shaderStorageImageArrayNonUniformIndexing;
		ShaderInputAttachmentArrayNonUniformIndexing = shaderInputAttachmentArrayNonUniformIndexing;
		ShaderUniformTexelBufferArrayNonUniformIndexing = shaderUniformTexelBufferArrayNonUniformIndexing;
		ShaderStorageTexelBufferArrayNonUniformIndexing = shaderStorageTexelBufferArrayNonUniformIndexing;
		DescriptorBindingUniformBufferUpdateAfterBind = descriptorBindingUniformBufferUpdateAfterBind;
		DescriptorBindingSampledImageUpdateAfterBind = descriptorBindingSampledImageUpdateAfterBind;
		DescriptorBindingStorageImageUpdateAfterBind = descriptorBindingStorageImageUpdateAfterBind;
		DescriptorBindingStorageBufferUpdateAfterBind = descriptorBindingStorageBufferUpdateAfterBind;
		DescriptorBindingUniformTexelBufferUpdateAfterBind = descriptorBindingUniformTexelBufferUpdateAfterBind;
		DescriptorBindingStorageTexelBufferUpdateAfterBind = descriptorBindingStorageTexelBufferUpdateAfterBind;
		DescriptorBindingUpdateUnusedWhilePending = descriptorBindingUpdateUnusedWhilePending;
		DescriptorBindingPartiallyBound = descriptorBindingPartiallyBound;
		DescriptorBindingVariableDescriptorCount = descriptorBindingVariableDescriptorCount;
		RuntimeDescriptorArray = runtimeDescriptorArray;
		SamplerFilterMinmax = samplerFilterMinmax;
		ScalarBlockLayout = scalarBlockLayout;
		ImagelessFramebuffer = imagelessFramebuffer;
		UniformBufferStandardLayout = uniformBufferStandardLayout;
		ShaderSubgroupExtendedTypes = shaderSubgroupExtendedTypes;
		SeparateDepthStencilLayouts = separateDepthStencilLayouts;
		HostQueryReset = hostQueryReset;
		TimelineSemaphore = timelineSemaphore;
		BufferDeviceAddress = bufferDeviceAddress;
		BufferDeviceAddressCaptureReplay = bufferDeviceAddressCaptureReplay;
		BufferDeviceAddressMultiDevice = bufferDeviceAddressMultiDevice;
		VulkanMemoryModel = vulkanMemoryModel;
		VulkanMemoryModelDeviceScope = vulkanMemoryModelDeviceScope;
		VulkanMemoryModelAvailabilityVisibilityChains = vulkanMemoryModelAvailabilityVisibilityChains;
		ShaderOutputViewportIndex = shaderOutputViewportIndex;
		ShaderOutputLayer = shaderOutputLayer;
		SubgroupBroadcastDynamicId = subgroupBroadcastDynamicId;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceVulkan12Features o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceVulkan12Features>.Equals(PhysicalDeviceVulkan12Features obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SamplerMirrorClampToEdge.GetHashCode() ^ DrawIndirectCount.GetHashCode()
			^ StorageBuffer8BitAccess.GetHashCode() ^ UniformAndStorageBuffer8BitAccess.GetHashCode() ^ StoragePushConstant8.GetHashCode() ^ ShaderBufferInt64Atomics.GetHashCode()
			^ ShaderSharedInt64Atomics.GetHashCode() ^ ShaderFloat16.GetHashCode() ^ ShaderInt8.GetHashCode() ^ DescriptorIndexing.GetHashCode()
			^ ShaderInputAttachmentArrayDynamicIndexing.GetHashCode() ^ ShaderUniformTexelBufferArrayDynamicIndexing.GetHashCode() ^ ShaderStorageTexelBufferArrayDynamicIndexing.GetHashCode() ^ ShaderUniformBufferArrayNonUniformIndexing.GetHashCode()
			^ ShaderSampledImageArrayNonUniformIndexing.GetHashCode() ^ ShaderStorageBufferArrayNonUniformIndexing.GetHashCode() ^ ShaderStorageImageArrayNonUniformIndexing.GetHashCode() ^ ShaderInputAttachmentArrayNonUniformIndexing.GetHashCode()
			^ ShaderUniformTexelBufferArrayNonUniformIndexing.GetHashCode() ^ ShaderStorageTexelBufferArrayNonUniformIndexing.GetHashCode() ^ DescriptorBindingUniformBufferUpdateAfterBind.GetHashCode() ^ DescriptorBindingSampledImageUpdateAfterBind.GetHashCode()
			^ DescriptorBindingStorageImageUpdateAfterBind.GetHashCode() ^ DescriptorBindingStorageBufferUpdateAfterBind.GetHashCode() ^ DescriptorBindingUniformTexelBufferUpdateAfterBind.GetHashCode() ^ DescriptorBindingStorageTexelBufferUpdateAfterBind.GetHashCode()
			^ DescriptorBindingUpdateUnusedWhilePending.GetHashCode() ^ DescriptorBindingPartiallyBound.GetHashCode() ^ DescriptorBindingVariableDescriptorCount.GetHashCode() ^ RuntimeDescriptorArray.GetHashCode()
			^ SamplerFilterMinmax.GetHashCode() ^ ScalarBlockLayout.GetHashCode() ^ ImagelessFramebuffer.GetHashCode() ^ UniformBufferStandardLayout.GetHashCode()
			^ ShaderSubgroupExtendedTypes.GetHashCode() ^ SeparateDepthStencilLayouts.GetHashCode() ^ HostQueryReset.GetHashCode() ^ TimelineSemaphore.GetHashCode()
			^ BufferDeviceAddress.GetHashCode() ^ BufferDeviceAddressCaptureReplay.GetHashCode() ^ BufferDeviceAddressMultiDevice.GetHashCode() ^ VulkanMemoryModel.GetHashCode()
			^ VulkanMemoryModelDeviceScope.GetHashCode() ^ VulkanMemoryModelAvailabilityVisibilityChains.GetHashCode() ^ ShaderOutputViewportIndex.GetHashCode() ^ ShaderOutputLayer.GetHashCode()
			^ SubgroupBroadcastDynamicId.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceVulkan12Features l, in PhysicalDeviceVulkan12Features r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SamplerMirrorClampToEdge == r.SamplerMirrorClampToEdge) && (l.DrawIndirectCount == r.DrawIndirectCount)
			&& (l.StorageBuffer8BitAccess == r.StorageBuffer8BitAccess) && (l.UniformAndStorageBuffer8BitAccess == r.UniformAndStorageBuffer8BitAccess) && (l.StoragePushConstant8 == r.StoragePushConstant8) && (l.ShaderBufferInt64Atomics == r.ShaderBufferInt64Atomics)
			&& (l.ShaderSharedInt64Atomics == r.ShaderSharedInt64Atomics) && (l.ShaderFloat16 == r.ShaderFloat16) && (l.ShaderInt8 == r.ShaderInt8) && (l.DescriptorIndexing == r.DescriptorIndexing)
			&& (l.ShaderInputAttachmentArrayDynamicIndexing == r.ShaderInputAttachmentArrayDynamicIndexing) && (l.ShaderUniformTexelBufferArrayDynamicIndexing == r.ShaderUniformTexelBufferArrayDynamicIndexing) && (l.ShaderStorageTexelBufferArrayDynamicIndexing == r.ShaderStorageTexelBufferArrayDynamicIndexing) && (l.ShaderUniformBufferArrayNonUniformIndexing == r.ShaderUniformBufferArrayNonUniformIndexing)
			&& (l.ShaderSampledImageArrayNonUniformIndexing == r.ShaderSampledImageArrayNonUniformIndexing) && (l.ShaderStorageBufferArrayNonUniformIndexing == r.ShaderStorageBufferArrayNonUniformIndexing) && (l.ShaderStorageImageArrayNonUniformIndexing == r.ShaderStorageImageArrayNonUniformIndexing) && (l.ShaderInputAttachmentArrayNonUniformIndexing == r.ShaderInputAttachmentArrayNonUniformIndexing)
			&& (l.ShaderUniformTexelBufferArrayNonUniformIndexing == r.ShaderUniformTexelBufferArrayNonUniformIndexing) && (l.ShaderStorageTexelBufferArrayNonUniformIndexing == r.ShaderStorageTexelBufferArrayNonUniformIndexing) && (l.DescriptorBindingUniformBufferUpdateAfterBind == r.DescriptorBindingUniformBufferUpdateAfterBind) && (l.DescriptorBindingSampledImageUpdateAfterBind == r.DescriptorBindingSampledImageUpdateAfterBind)
			&& (l.DescriptorBindingStorageImageUpdateAfterBind == r.DescriptorBindingStorageImageUpdateAfterBind) && (l.DescriptorBindingStorageBufferUpdateAfterBind == r.DescriptorBindingStorageBufferUpdateAfterBind) && (l.DescriptorBindingUniformTexelBufferUpdateAfterBind == r.DescriptorBindingUniformTexelBufferUpdateAfterBind) && (l.DescriptorBindingStorageTexelBufferUpdateAfterBind == r.DescriptorBindingStorageTexelBufferUpdateAfterBind)
			&& (l.DescriptorBindingUpdateUnusedWhilePending == r.DescriptorBindingUpdateUnusedWhilePending) && (l.DescriptorBindingPartiallyBound == r.DescriptorBindingPartiallyBound) && (l.DescriptorBindingVariableDescriptorCount == r.DescriptorBindingVariableDescriptorCount) && (l.RuntimeDescriptorArray == r.RuntimeDescriptorArray)
			&& (l.SamplerFilterMinmax == r.SamplerFilterMinmax) && (l.ScalarBlockLayout == r.ScalarBlockLayout) && (l.ImagelessFramebuffer == r.ImagelessFramebuffer) && (l.UniformBufferStandardLayout == r.UniformBufferStandardLayout)
			&& (l.ShaderSubgroupExtendedTypes == r.ShaderSubgroupExtendedTypes) && (l.SeparateDepthStencilLayouts == r.SeparateDepthStencilLayouts) && (l.HostQueryReset == r.HostQueryReset) && (l.TimelineSemaphore == r.TimelineSemaphore)
			&& (l.BufferDeviceAddress == r.BufferDeviceAddress) && (l.BufferDeviceAddressCaptureReplay == r.BufferDeviceAddressCaptureReplay) && (l.BufferDeviceAddressMultiDevice == r.BufferDeviceAddressMultiDevice) && (l.VulkanMemoryModel == r.VulkanMemoryModel)
			&& (l.VulkanMemoryModelDeviceScope == r.VulkanMemoryModelDeviceScope) && (l.VulkanMemoryModelAvailabilityVisibilityChains == r.VulkanMemoryModelAvailabilityVisibilityChains) && (l.ShaderOutputViewportIndex == r.ShaderOutputViewportIndex) && (l.ShaderOutputLayer == r.ShaderOutputLayer)
			&& (l.SubgroupBroadcastDynamicId == r.SubgroupBroadcastDynamicId)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceVulkan12Features l, in PhysicalDeviceVulkan12Features r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SamplerMirrorClampToEdge != r.SamplerMirrorClampToEdge) || (l.DrawIndirectCount != r.DrawIndirectCount)
			|| (l.StorageBuffer8BitAccess != r.StorageBuffer8BitAccess) || (l.UniformAndStorageBuffer8BitAccess != r.UniformAndStorageBuffer8BitAccess) || (l.StoragePushConstant8 != r.StoragePushConstant8) || (l.ShaderBufferInt64Atomics != r.ShaderBufferInt64Atomics)
			|| (l.ShaderSharedInt64Atomics != r.ShaderSharedInt64Atomics) || (l.ShaderFloat16 != r.ShaderFloat16) || (l.ShaderInt8 != r.ShaderInt8) || (l.DescriptorIndexing != r.DescriptorIndexing)
			|| (l.ShaderInputAttachmentArrayDynamicIndexing != r.ShaderInputAttachmentArrayDynamicIndexing) || (l.ShaderUniformTexelBufferArrayDynamicIndexing != r.ShaderUniformTexelBufferArrayDynamicIndexing) || (l.ShaderStorageTexelBufferArrayDynamicIndexing != r.ShaderStorageTexelBufferArrayDynamicIndexing) || (l.ShaderUniformBufferArrayNonUniformIndexing != r.ShaderUniformBufferArrayNonUniformIndexing)
			|| (l.ShaderSampledImageArrayNonUniformIndexing != r.ShaderSampledImageArrayNonUniformIndexing) || (l.ShaderStorageBufferArrayNonUniformIndexing != r.ShaderStorageBufferArrayNonUniformIndexing) || (l.ShaderStorageImageArrayNonUniformIndexing != r.ShaderStorageImageArrayNonUniformIndexing) || (l.ShaderInputAttachmentArrayNonUniformIndexing != r.ShaderInputAttachmentArrayNonUniformIndexing)
			|| (l.ShaderUniformTexelBufferArrayNonUniformIndexing != r.ShaderUniformTexelBufferArrayNonUniformIndexing) || (l.ShaderStorageTexelBufferArrayNonUniformIndexing != r.ShaderStorageTexelBufferArrayNonUniformIndexing) || (l.DescriptorBindingUniformBufferUpdateAfterBind != r.DescriptorBindingUniformBufferUpdateAfterBind) || (l.DescriptorBindingSampledImageUpdateAfterBind != r.DescriptorBindingSampledImageUpdateAfterBind)
			|| (l.DescriptorBindingStorageImageUpdateAfterBind != r.DescriptorBindingStorageImageUpdateAfterBind) || (l.DescriptorBindingStorageBufferUpdateAfterBind != r.DescriptorBindingStorageBufferUpdateAfterBind) || (l.DescriptorBindingUniformTexelBufferUpdateAfterBind != r.DescriptorBindingUniformTexelBufferUpdateAfterBind) || (l.DescriptorBindingStorageTexelBufferUpdateAfterBind != r.DescriptorBindingStorageTexelBufferUpdateAfterBind)
			|| (l.DescriptorBindingUpdateUnusedWhilePending != r.DescriptorBindingUpdateUnusedWhilePending) || (l.DescriptorBindingPartiallyBound != r.DescriptorBindingPartiallyBound) || (l.DescriptorBindingVariableDescriptorCount != r.DescriptorBindingVariableDescriptorCount) || (l.RuntimeDescriptorArray != r.RuntimeDescriptorArray)
			|| (l.SamplerFilterMinmax != r.SamplerFilterMinmax) || (l.ScalarBlockLayout != r.ScalarBlockLayout) || (l.ImagelessFramebuffer != r.ImagelessFramebuffer) || (l.UniformBufferStandardLayout != r.UniformBufferStandardLayout)
			|| (l.ShaderSubgroupExtendedTypes != r.ShaderSubgroupExtendedTypes) || (l.SeparateDepthStencilLayouts != r.SeparateDepthStencilLayouts) || (l.HostQueryReset != r.HostQueryReset) || (l.TimelineSemaphore != r.TimelineSemaphore)
			|| (l.BufferDeviceAddress != r.BufferDeviceAddress) || (l.BufferDeviceAddressCaptureReplay != r.BufferDeviceAddressCaptureReplay) || (l.BufferDeviceAddressMultiDevice != r.BufferDeviceAddressMultiDevice) || (l.VulkanMemoryModel != r.VulkanMemoryModel)
			|| (l.VulkanMemoryModelDeviceScope != r.VulkanMemoryModelDeviceScope) || (l.VulkanMemoryModelAvailabilityVisibilityChains != r.VulkanMemoryModelAvailabilityVisibilityChains) || (l.ShaderOutputViewportIndex != r.ShaderOutputViewportIndex) || (l.ShaderOutputLayer != r.ShaderOutputLayer)
			|| (l.SubgroupBroadcastDynamicId != r.SubgroupBroadcastDynamicId)
			;
	}


	/// <summary>Creates a new PhysicalDeviceVulkan12Features value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceVulkan12Features value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceVulkan12Properties : IEquatable<PhysicalDeviceVulkan12Properties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceVulkan12Properties;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.DriverId DriverID;
	public Vk.FixedString DriverName;
	public Vk.FixedString DriverInfo;
	public Vk.ConformanceVersion ConformanceVersion;
	public Vk.ShaderFloatControlsIndependence DenormBehaviorIndependence;
	public Vk.ShaderFloatControlsIndependence RoundingModeIndependence;
	public Vk.Bool32 ShaderSignedZeroInfNanPreserveFloat16;
	public Vk.Bool32 ShaderSignedZeroInfNanPreserveFloat32;
	public Vk.Bool32 ShaderSignedZeroInfNanPreserveFloat64;
	public Vk.Bool32 ShaderDenormPreserveFloat16;
	public Vk.Bool32 ShaderDenormPreserveFloat32;
	public Vk.Bool32 ShaderDenormPreserveFloat64;
	public Vk.Bool32 ShaderDenormFlushToZeroFloat16;
	public Vk.Bool32 ShaderDenormFlushToZeroFloat32;
	public Vk.Bool32 ShaderDenormFlushToZeroFloat64;
	public Vk.Bool32 ShaderRoundingModeRTEFloat16;
	public Vk.Bool32 ShaderRoundingModeRTEFloat32;
	public Vk.Bool32 ShaderRoundingModeRTEFloat64;
	public Vk.Bool32 ShaderRoundingModeRTZFloat16;
	public Vk.Bool32 ShaderRoundingModeRTZFloat32;
	public Vk.Bool32 ShaderRoundingModeRTZFloat64;
	public uint MaxUpdateAfterBindDescriptorsInAllPools;
	public Vk.Bool32 ShaderUniformBufferArrayNonUniformIndexingNative;
	public Vk.Bool32 ShaderSampledImageArrayNonUniformIndexingNative;
	public Vk.Bool32 ShaderStorageBufferArrayNonUniformIndexingNative;
	public Vk.Bool32 ShaderStorageImageArrayNonUniformIndexingNative;
	public Vk.Bool32 ShaderInputAttachmentArrayNonUniformIndexingNative;
	public Vk.Bool32 RobustBufferAccessUpdateAfterBind;
	public Vk.Bool32 QuadDivergentImplicitLod;
	public uint MaxPerStageDescriptorUpdateAfterBindSamplers;
	public uint MaxPerStageDescriptorUpdateAfterBindUniformBuffers;
	public uint MaxPerStageDescriptorUpdateAfterBindStorageBuffers;
	public uint MaxPerStageDescriptorUpdateAfterBindSampledImages;
	public uint MaxPerStageDescriptorUpdateAfterBindStorageImages;
	public uint MaxPerStageDescriptorUpdateAfterBindInputAttachments;
	public uint MaxPerStageUpdateAfterBindResources;
	public uint MaxDescriptorSetUpdateAfterBindSamplers;
	public uint MaxDescriptorSetUpdateAfterBindUniformBuffers;
	public uint MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic;
	public uint MaxDescriptorSetUpdateAfterBindStorageBuffers;
	public uint MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic;
	public uint MaxDescriptorSetUpdateAfterBindSampledImages;
	public uint MaxDescriptorSetUpdateAfterBindStorageImages;
	public uint MaxDescriptorSetUpdateAfterBindInputAttachments;
	public Vk.ResolveModeFlags SupportedDepthResolveModes;
	public Vk.ResolveModeFlags SupportedStencilResolveModes;
	public Vk.Bool32 IndependentResolveNone;
	public Vk.Bool32 IndependentResolve;
	public Vk.Bool32 FilterMinmaxSingleComponentFormats;
	public Vk.Bool32 FilterMinmaxImageComponentMapping;
	public ulong MaxTimelineSemaphoreValueDifference;
	public Vk.SampleCountFlags FramebufferIntegerColorSampleCounts;
	public PhysicalDeviceVulkan12Properties(
		in Vk.DriverId driverID = default,
		in Vk.FixedString driverName = default,
		in Vk.FixedString driverInfo = default,
		in Vk.ConformanceVersion conformanceVersion = default,
		in Vk.ShaderFloatControlsIndependence denormBehaviorIndependence = default,
		in Vk.ShaderFloatControlsIndependence roundingModeIndependence = default,
		in Vk.Bool32 shaderSignedZeroInfNanPreserveFloat16 = default,
		in Vk.Bool32 shaderSignedZeroInfNanPreserveFloat32 = default,
		in Vk.Bool32 shaderSignedZeroInfNanPreserveFloat64 = default,
		in Vk.Bool32 shaderDenormPreserveFloat16 = default,
		in Vk.Bool32 shaderDenormPreserveFloat32 = default,
		in Vk.Bool32 shaderDenormPreserveFloat64 = default,
		in Vk.Bool32 shaderDenormFlushToZeroFloat16 = default,
		in Vk.Bool32 shaderDenormFlushToZeroFloat32 = default,
		in Vk.Bool32 shaderDenormFlushToZeroFloat64 = default,
		in Vk.Bool32 shaderRoundingModeRTEFloat16 = default,
		in Vk.Bool32 shaderRoundingModeRTEFloat32 = default,
		in Vk.Bool32 shaderRoundingModeRTEFloat64 = default,
		in Vk.Bool32 shaderRoundingModeRTZFloat16 = default,
		in Vk.Bool32 shaderRoundingModeRTZFloat32 = default,
		in Vk.Bool32 shaderRoundingModeRTZFloat64 = default,
		uint maxUpdateAfterBindDescriptorsInAllPools = default,
		in Vk.Bool32 shaderUniformBufferArrayNonUniformIndexingNative = default,
		in Vk.Bool32 shaderSampledImageArrayNonUniformIndexingNative = default,
		in Vk.Bool32 shaderStorageBufferArrayNonUniformIndexingNative = default,
		in Vk.Bool32 shaderStorageImageArrayNonUniformIndexingNative = default,
		in Vk.Bool32 shaderInputAttachmentArrayNonUniformIndexingNative = default,
		in Vk.Bool32 robustBufferAccessUpdateAfterBind = default,
		in Vk.Bool32 quadDivergentImplicitLod = default,
		uint maxPerStageDescriptorUpdateAfterBindSamplers = default,
		uint maxPerStageDescriptorUpdateAfterBindUniformBuffers = default,
		uint maxPerStageDescriptorUpdateAfterBindStorageBuffers = default,
		uint maxPerStageDescriptorUpdateAfterBindSampledImages = default,
		uint maxPerStageDescriptorUpdateAfterBindStorageImages = default,
		uint maxPerStageDescriptorUpdateAfterBindInputAttachments = default,
		uint maxPerStageUpdateAfterBindResources = default,
		uint maxDescriptorSetUpdateAfterBindSamplers = default,
		uint maxDescriptorSetUpdateAfterBindUniformBuffers = default,
		uint maxDescriptorSetUpdateAfterBindUniformBuffersDynamic = default,
		uint maxDescriptorSetUpdateAfterBindStorageBuffers = default,
		uint maxDescriptorSetUpdateAfterBindStorageBuffersDynamic = default,
		uint maxDescriptorSetUpdateAfterBindSampledImages = default,
		uint maxDescriptorSetUpdateAfterBindStorageImages = default,
		uint maxDescriptorSetUpdateAfterBindInputAttachments = default,
		in Vk.ResolveModeFlags supportedDepthResolveModes = default,
		in Vk.ResolveModeFlags supportedStencilResolveModes = default,
		in Vk.Bool32 independentResolveNone = default,
		in Vk.Bool32 independentResolve = default,
		in Vk.Bool32 filterMinmaxSingleComponentFormats = default,
		in Vk.Bool32 filterMinmaxImageComponentMapping = default,
		ulong maxTimelineSemaphoreValueDifference = default,
		in Vk.SampleCountFlags framebufferIntegerColorSampleCounts = default
	) {
		sType = TYPE;
		pNext = null;
		DriverID = driverID;
		DriverName = driverName;
		DriverInfo = driverInfo;
		ConformanceVersion = conformanceVersion;
		DenormBehaviorIndependence = denormBehaviorIndependence;
		RoundingModeIndependence = roundingModeIndependence;
		ShaderSignedZeroInfNanPreserveFloat16 = shaderSignedZeroInfNanPreserveFloat16;
		ShaderSignedZeroInfNanPreserveFloat32 = shaderSignedZeroInfNanPreserveFloat32;
		ShaderSignedZeroInfNanPreserveFloat64 = shaderSignedZeroInfNanPreserveFloat64;
		ShaderDenormPreserveFloat16 = shaderDenormPreserveFloat16;
		ShaderDenormPreserveFloat32 = shaderDenormPreserveFloat32;
		ShaderDenormPreserveFloat64 = shaderDenormPreserveFloat64;
		ShaderDenormFlushToZeroFloat16 = shaderDenormFlushToZeroFloat16;
		ShaderDenormFlushToZeroFloat32 = shaderDenormFlushToZeroFloat32;
		ShaderDenormFlushToZeroFloat64 = shaderDenormFlushToZeroFloat64;
		ShaderRoundingModeRTEFloat16 = shaderRoundingModeRTEFloat16;
		ShaderRoundingModeRTEFloat32 = shaderRoundingModeRTEFloat32;
		ShaderRoundingModeRTEFloat64 = shaderRoundingModeRTEFloat64;
		ShaderRoundingModeRTZFloat16 = shaderRoundingModeRTZFloat16;
		ShaderRoundingModeRTZFloat32 = shaderRoundingModeRTZFloat32;
		ShaderRoundingModeRTZFloat64 = shaderRoundingModeRTZFloat64;
		MaxUpdateAfterBindDescriptorsInAllPools = maxUpdateAfterBindDescriptorsInAllPools;
		ShaderUniformBufferArrayNonUniformIndexingNative = shaderUniformBufferArrayNonUniformIndexingNative;
		ShaderSampledImageArrayNonUniformIndexingNative = shaderSampledImageArrayNonUniformIndexingNative;
		ShaderStorageBufferArrayNonUniformIndexingNative = shaderStorageBufferArrayNonUniformIndexingNative;
		ShaderStorageImageArrayNonUniformIndexingNative = shaderStorageImageArrayNonUniformIndexingNative;
		ShaderInputAttachmentArrayNonUniformIndexingNative = shaderInputAttachmentArrayNonUniformIndexingNative;
		RobustBufferAccessUpdateAfterBind = robustBufferAccessUpdateAfterBind;
		QuadDivergentImplicitLod = quadDivergentImplicitLod;
		MaxPerStageDescriptorUpdateAfterBindSamplers = maxPerStageDescriptorUpdateAfterBindSamplers;
		MaxPerStageDescriptorUpdateAfterBindUniformBuffers = maxPerStageDescriptorUpdateAfterBindUniformBuffers;
		MaxPerStageDescriptorUpdateAfterBindStorageBuffers = maxPerStageDescriptorUpdateAfterBindStorageBuffers;
		MaxPerStageDescriptorUpdateAfterBindSampledImages = maxPerStageDescriptorUpdateAfterBindSampledImages;
		MaxPerStageDescriptorUpdateAfterBindStorageImages = maxPerStageDescriptorUpdateAfterBindStorageImages;
		MaxPerStageDescriptorUpdateAfterBindInputAttachments = maxPerStageDescriptorUpdateAfterBindInputAttachments;
		MaxPerStageUpdateAfterBindResources = maxPerStageUpdateAfterBindResources;
		MaxDescriptorSetUpdateAfterBindSamplers = maxDescriptorSetUpdateAfterBindSamplers;
		MaxDescriptorSetUpdateAfterBindUniformBuffers = maxDescriptorSetUpdateAfterBindUniformBuffers;
		MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic = maxDescriptorSetUpdateAfterBindUniformBuffersDynamic;
		MaxDescriptorSetUpdateAfterBindStorageBuffers = maxDescriptorSetUpdateAfterBindStorageBuffers;
		MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic = maxDescriptorSetUpdateAfterBindStorageBuffersDynamic;
		MaxDescriptorSetUpdateAfterBindSampledImages = maxDescriptorSetUpdateAfterBindSampledImages;
		MaxDescriptorSetUpdateAfterBindStorageImages = maxDescriptorSetUpdateAfterBindStorageImages;
		MaxDescriptorSetUpdateAfterBindInputAttachments = maxDescriptorSetUpdateAfterBindInputAttachments;
		SupportedDepthResolveModes = supportedDepthResolveModes;
		SupportedStencilResolveModes = supportedStencilResolveModes;
		IndependentResolveNone = independentResolveNone;
		IndependentResolve = independentResolve;
		FilterMinmaxSingleComponentFormats = filterMinmaxSingleComponentFormats;
		FilterMinmaxImageComponentMapping = filterMinmaxImageComponentMapping;
		MaxTimelineSemaphoreValueDifference = maxTimelineSemaphoreValueDifference;
		FramebufferIntegerColorSampleCounts = framebufferIntegerColorSampleCounts;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceVulkan12Properties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceVulkan12Properties>.Equals(PhysicalDeviceVulkan12Properties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DriverID.GetHashCode() ^ DriverName.GetHashCode()
			^ DriverInfo.GetHashCode() ^ ConformanceVersion.GetHashCode() ^ DenormBehaviorIndependence.GetHashCode() ^ RoundingModeIndependence.GetHashCode()
			^ ShaderSignedZeroInfNanPreserveFloat16.GetHashCode() ^ ShaderSignedZeroInfNanPreserveFloat32.GetHashCode() ^ ShaderSignedZeroInfNanPreserveFloat64.GetHashCode() ^ ShaderDenormPreserveFloat16.GetHashCode()
			^ ShaderDenormPreserveFloat32.GetHashCode() ^ ShaderDenormPreserveFloat64.GetHashCode() ^ ShaderDenormFlushToZeroFloat16.GetHashCode() ^ ShaderDenormFlushToZeroFloat32.GetHashCode()
			^ ShaderDenormFlushToZeroFloat64.GetHashCode() ^ ShaderRoundingModeRTEFloat16.GetHashCode() ^ ShaderRoundingModeRTEFloat32.GetHashCode() ^ ShaderRoundingModeRTEFloat64.GetHashCode()
			^ ShaderRoundingModeRTZFloat16.GetHashCode() ^ ShaderRoundingModeRTZFloat32.GetHashCode() ^ ShaderRoundingModeRTZFloat64.GetHashCode() ^ MaxUpdateAfterBindDescriptorsInAllPools.GetHashCode()
			^ ShaderUniformBufferArrayNonUniformIndexingNative.GetHashCode() ^ ShaderSampledImageArrayNonUniformIndexingNative.GetHashCode() ^ ShaderStorageBufferArrayNonUniformIndexingNative.GetHashCode() ^ ShaderStorageImageArrayNonUniformIndexingNative.GetHashCode()
			^ ShaderInputAttachmentArrayNonUniformIndexingNative.GetHashCode() ^ RobustBufferAccessUpdateAfterBind.GetHashCode() ^ QuadDivergentImplicitLod.GetHashCode() ^ MaxPerStageDescriptorUpdateAfterBindSamplers.GetHashCode()
			^ MaxPerStageDescriptorUpdateAfterBindUniformBuffers.GetHashCode() ^ MaxPerStageDescriptorUpdateAfterBindStorageBuffers.GetHashCode() ^ MaxPerStageDescriptorUpdateAfterBindSampledImages.GetHashCode() ^ MaxPerStageDescriptorUpdateAfterBindStorageImages.GetHashCode()
			^ MaxPerStageDescriptorUpdateAfterBindInputAttachments.GetHashCode() ^ MaxPerStageUpdateAfterBindResources.GetHashCode() ^ MaxDescriptorSetUpdateAfterBindSamplers.GetHashCode() ^ MaxDescriptorSetUpdateAfterBindUniformBuffers.GetHashCode()
			^ MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic.GetHashCode() ^ MaxDescriptorSetUpdateAfterBindStorageBuffers.GetHashCode() ^ MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic.GetHashCode() ^ MaxDescriptorSetUpdateAfterBindSampledImages.GetHashCode()
			^ MaxDescriptorSetUpdateAfterBindStorageImages.GetHashCode() ^ MaxDescriptorSetUpdateAfterBindInputAttachments.GetHashCode() ^ SupportedDepthResolveModes.GetHashCode() ^ SupportedStencilResolveModes.GetHashCode()
			^ IndependentResolveNone.GetHashCode() ^ IndependentResolve.GetHashCode() ^ FilterMinmaxSingleComponentFormats.GetHashCode() ^ FilterMinmaxImageComponentMapping.GetHashCode()
			^ MaxTimelineSemaphoreValueDifference.GetHashCode() ^ FramebufferIntegerColorSampleCounts.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceVulkan12Properties l, in PhysicalDeviceVulkan12Properties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DriverID == r.DriverID) && (l.DriverName == r.DriverName)
			&& (l.DriverInfo == r.DriverInfo) && (l.ConformanceVersion == r.ConformanceVersion) && (l.DenormBehaviorIndependence == r.DenormBehaviorIndependence) && (l.RoundingModeIndependence == r.RoundingModeIndependence)
			&& (l.ShaderSignedZeroInfNanPreserveFloat16 == r.ShaderSignedZeroInfNanPreserveFloat16) && (l.ShaderSignedZeroInfNanPreserveFloat32 == r.ShaderSignedZeroInfNanPreserveFloat32) && (l.ShaderSignedZeroInfNanPreserveFloat64 == r.ShaderSignedZeroInfNanPreserveFloat64) && (l.ShaderDenormPreserveFloat16 == r.ShaderDenormPreserveFloat16)
			&& (l.ShaderDenormPreserveFloat32 == r.ShaderDenormPreserveFloat32) && (l.ShaderDenormPreserveFloat64 == r.ShaderDenormPreserveFloat64) && (l.ShaderDenormFlushToZeroFloat16 == r.ShaderDenormFlushToZeroFloat16) && (l.ShaderDenormFlushToZeroFloat32 == r.ShaderDenormFlushToZeroFloat32)
			&& (l.ShaderDenormFlushToZeroFloat64 == r.ShaderDenormFlushToZeroFloat64) && (l.ShaderRoundingModeRTEFloat16 == r.ShaderRoundingModeRTEFloat16) && (l.ShaderRoundingModeRTEFloat32 == r.ShaderRoundingModeRTEFloat32) && (l.ShaderRoundingModeRTEFloat64 == r.ShaderRoundingModeRTEFloat64)
			&& (l.ShaderRoundingModeRTZFloat16 == r.ShaderRoundingModeRTZFloat16) && (l.ShaderRoundingModeRTZFloat32 == r.ShaderRoundingModeRTZFloat32) && (l.ShaderRoundingModeRTZFloat64 == r.ShaderRoundingModeRTZFloat64) && (l.MaxUpdateAfterBindDescriptorsInAllPools == r.MaxUpdateAfterBindDescriptorsInAllPools)
			&& (l.ShaderUniformBufferArrayNonUniformIndexingNative == r.ShaderUniformBufferArrayNonUniformIndexingNative) && (l.ShaderSampledImageArrayNonUniformIndexingNative == r.ShaderSampledImageArrayNonUniformIndexingNative) && (l.ShaderStorageBufferArrayNonUniformIndexingNative == r.ShaderStorageBufferArrayNonUniformIndexingNative) && (l.ShaderStorageImageArrayNonUniformIndexingNative == r.ShaderStorageImageArrayNonUniformIndexingNative)
			&& (l.ShaderInputAttachmentArrayNonUniformIndexingNative == r.ShaderInputAttachmentArrayNonUniformIndexingNative) && (l.RobustBufferAccessUpdateAfterBind == r.RobustBufferAccessUpdateAfterBind) && (l.QuadDivergentImplicitLod == r.QuadDivergentImplicitLod) && (l.MaxPerStageDescriptorUpdateAfterBindSamplers == r.MaxPerStageDescriptorUpdateAfterBindSamplers)
			&& (l.MaxPerStageDescriptorUpdateAfterBindUniformBuffers == r.MaxPerStageDescriptorUpdateAfterBindUniformBuffers) && (l.MaxPerStageDescriptorUpdateAfterBindStorageBuffers == r.MaxPerStageDescriptorUpdateAfterBindStorageBuffers) && (l.MaxPerStageDescriptorUpdateAfterBindSampledImages == r.MaxPerStageDescriptorUpdateAfterBindSampledImages) && (l.MaxPerStageDescriptorUpdateAfterBindStorageImages == r.MaxPerStageDescriptorUpdateAfterBindStorageImages)
			&& (l.MaxPerStageDescriptorUpdateAfterBindInputAttachments == r.MaxPerStageDescriptorUpdateAfterBindInputAttachments) && (l.MaxPerStageUpdateAfterBindResources == r.MaxPerStageUpdateAfterBindResources) && (l.MaxDescriptorSetUpdateAfterBindSamplers == r.MaxDescriptorSetUpdateAfterBindSamplers) && (l.MaxDescriptorSetUpdateAfterBindUniformBuffers == r.MaxDescriptorSetUpdateAfterBindUniformBuffers)
			&& (l.MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic == r.MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic) && (l.MaxDescriptorSetUpdateAfterBindStorageBuffers == r.MaxDescriptorSetUpdateAfterBindStorageBuffers) && (l.MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic == r.MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic) && (l.MaxDescriptorSetUpdateAfterBindSampledImages == r.MaxDescriptorSetUpdateAfterBindSampledImages)
			&& (l.MaxDescriptorSetUpdateAfterBindStorageImages == r.MaxDescriptorSetUpdateAfterBindStorageImages) && (l.MaxDescriptorSetUpdateAfterBindInputAttachments == r.MaxDescriptorSetUpdateAfterBindInputAttachments) && (l.SupportedDepthResolveModes == r.SupportedDepthResolveModes) && (l.SupportedStencilResolveModes == r.SupportedStencilResolveModes)
			&& (l.IndependentResolveNone == r.IndependentResolveNone) && (l.IndependentResolve == r.IndependentResolve) && (l.FilterMinmaxSingleComponentFormats == r.FilterMinmaxSingleComponentFormats) && (l.FilterMinmaxImageComponentMapping == r.FilterMinmaxImageComponentMapping)
			&& (l.MaxTimelineSemaphoreValueDifference == r.MaxTimelineSemaphoreValueDifference) && (l.FramebufferIntegerColorSampleCounts == r.FramebufferIntegerColorSampleCounts)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceVulkan12Properties l, in PhysicalDeviceVulkan12Properties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DriverID != r.DriverID) || (l.DriverName != r.DriverName)
			|| (l.DriverInfo != r.DriverInfo) || (l.ConformanceVersion != r.ConformanceVersion) || (l.DenormBehaviorIndependence != r.DenormBehaviorIndependence) || (l.RoundingModeIndependence != r.RoundingModeIndependence)
			|| (l.ShaderSignedZeroInfNanPreserveFloat16 != r.ShaderSignedZeroInfNanPreserveFloat16) || (l.ShaderSignedZeroInfNanPreserveFloat32 != r.ShaderSignedZeroInfNanPreserveFloat32) || (l.ShaderSignedZeroInfNanPreserveFloat64 != r.ShaderSignedZeroInfNanPreserveFloat64) || (l.ShaderDenormPreserveFloat16 != r.ShaderDenormPreserveFloat16)
			|| (l.ShaderDenormPreserveFloat32 != r.ShaderDenormPreserveFloat32) || (l.ShaderDenormPreserveFloat64 != r.ShaderDenormPreserveFloat64) || (l.ShaderDenormFlushToZeroFloat16 != r.ShaderDenormFlushToZeroFloat16) || (l.ShaderDenormFlushToZeroFloat32 != r.ShaderDenormFlushToZeroFloat32)
			|| (l.ShaderDenormFlushToZeroFloat64 != r.ShaderDenormFlushToZeroFloat64) || (l.ShaderRoundingModeRTEFloat16 != r.ShaderRoundingModeRTEFloat16) || (l.ShaderRoundingModeRTEFloat32 != r.ShaderRoundingModeRTEFloat32) || (l.ShaderRoundingModeRTEFloat64 != r.ShaderRoundingModeRTEFloat64)
			|| (l.ShaderRoundingModeRTZFloat16 != r.ShaderRoundingModeRTZFloat16) || (l.ShaderRoundingModeRTZFloat32 != r.ShaderRoundingModeRTZFloat32) || (l.ShaderRoundingModeRTZFloat64 != r.ShaderRoundingModeRTZFloat64) || (l.MaxUpdateAfterBindDescriptorsInAllPools != r.MaxUpdateAfterBindDescriptorsInAllPools)
			|| (l.ShaderUniformBufferArrayNonUniformIndexingNative != r.ShaderUniformBufferArrayNonUniformIndexingNative) || (l.ShaderSampledImageArrayNonUniformIndexingNative != r.ShaderSampledImageArrayNonUniformIndexingNative) || (l.ShaderStorageBufferArrayNonUniformIndexingNative != r.ShaderStorageBufferArrayNonUniformIndexingNative) || (l.ShaderStorageImageArrayNonUniformIndexingNative != r.ShaderStorageImageArrayNonUniformIndexingNative)
			|| (l.ShaderInputAttachmentArrayNonUniformIndexingNative != r.ShaderInputAttachmentArrayNonUniformIndexingNative) || (l.RobustBufferAccessUpdateAfterBind != r.RobustBufferAccessUpdateAfterBind) || (l.QuadDivergentImplicitLod != r.QuadDivergentImplicitLod) || (l.MaxPerStageDescriptorUpdateAfterBindSamplers != r.MaxPerStageDescriptorUpdateAfterBindSamplers)
			|| (l.MaxPerStageDescriptorUpdateAfterBindUniformBuffers != r.MaxPerStageDescriptorUpdateAfterBindUniformBuffers) || (l.MaxPerStageDescriptorUpdateAfterBindStorageBuffers != r.MaxPerStageDescriptorUpdateAfterBindStorageBuffers) || (l.MaxPerStageDescriptorUpdateAfterBindSampledImages != r.MaxPerStageDescriptorUpdateAfterBindSampledImages) || (l.MaxPerStageDescriptorUpdateAfterBindStorageImages != r.MaxPerStageDescriptorUpdateAfterBindStorageImages)
			|| (l.MaxPerStageDescriptorUpdateAfterBindInputAttachments != r.MaxPerStageDescriptorUpdateAfterBindInputAttachments) || (l.MaxPerStageUpdateAfterBindResources != r.MaxPerStageUpdateAfterBindResources) || (l.MaxDescriptorSetUpdateAfterBindSamplers != r.MaxDescriptorSetUpdateAfterBindSamplers) || (l.MaxDescriptorSetUpdateAfterBindUniformBuffers != r.MaxDescriptorSetUpdateAfterBindUniformBuffers)
			|| (l.MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic != r.MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic) || (l.MaxDescriptorSetUpdateAfterBindStorageBuffers != r.MaxDescriptorSetUpdateAfterBindStorageBuffers) || (l.MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic != r.MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic) || (l.MaxDescriptorSetUpdateAfterBindSampledImages != r.MaxDescriptorSetUpdateAfterBindSampledImages)
			|| (l.MaxDescriptorSetUpdateAfterBindStorageImages != r.MaxDescriptorSetUpdateAfterBindStorageImages) || (l.MaxDescriptorSetUpdateAfterBindInputAttachments != r.MaxDescriptorSetUpdateAfterBindInputAttachments) || (l.SupportedDepthResolveModes != r.SupportedDepthResolveModes) || (l.SupportedStencilResolveModes != r.SupportedStencilResolveModes)
			|| (l.IndependentResolveNone != r.IndependentResolveNone) || (l.IndependentResolve != r.IndependentResolve) || (l.FilterMinmaxSingleComponentFormats != r.FilterMinmaxSingleComponentFormats) || (l.FilterMinmaxImageComponentMapping != r.FilterMinmaxImageComponentMapping)
			|| (l.MaxTimelineSemaphoreValueDifference != r.MaxTimelineSemaphoreValueDifference) || (l.FramebufferIntegerColorSampleCounts != r.FramebufferIntegerColorSampleCounts)
			;
	}


	/// <summary>Creates a new PhysicalDeviceVulkan12Properties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceVulkan12Properties value) => value = new() { sType = TYPE };
}

} // namespace Vk
