/*
 * MIT License - Copyright(c) 2020 Sean Moss
 * This file is subject to the terms and conditions of the MIT License, the text of which can be found in the 'LICENSE'
 * file at the root of this repository, or online at <https://opensource.org/licenses/MIT>.
 */

/// This file was generated by VVKGen. Edits to this file will be lost on next generation.

using System;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;

namespace Vulkan
{

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkRefreshCycleDurationGOOGLE : IEquatable<VkRefreshCycleDurationGOOGLE>
{
	public ulong RefreshDuration;

	public VkRefreshCycleDurationGOOGLE(
		ulong refreshDuration = default
	) {
		RefreshDuration = refreshDuration;
	}

	public readonly override bool Equals(object? o) => (o is VkRefreshCycleDurationGOOGLE s) && (this == s);
	readonly bool IEquatable<VkRefreshCycleDurationGOOGLE>.Equals(VkRefreshCycleDurationGOOGLE o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			RefreshDuration.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkRefreshCycleDurationGOOGLE l, in VkRefreshCycleDurationGOOGLE r)
	{
		return
			(l.RefreshDuration == r.RefreshDuration)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkRefreshCycleDurationGOOGLE l, in VkRefreshCycleDurationGOOGLE r)
	{
		return
			(l.RefreshDuration != r.RefreshDuration)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkRefreshCycleDurationGOOGLE s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPastPresentationTimingGOOGLE : IEquatable<VkPastPresentationTimingGOOGLE>
{
	public uint PresentID;
	public ulong DesiredPresentTime;
	public ulong ActualPresentTime;
	public ulong EarliestPresentTime;
	public ulong PresentMargin;

	public VkPastPresentationTimingGOOGLE(
		uint presentID = default,
		ulong desiredPresentTime = default,
		ulong actualPresentTime = default,
		ulong earliestPresentTime = default,
		ulong presentMargin = default
	) {
		PresentID = presentID;
		DesiredPresentTime = desiredPresentTime;
		ActualPresentTime = actualPresentTime;
		EarliestPresentTime = earliestPresentTime;
		PresentMargin = presentMargin;
	}

	public readonly override bool Equals(object? o) => (o is VkPastPresentationTimingGOOGLE s) && (this == s);
	readonly bool IEquatable<VkPastPresentationTimingGOOGLE>.Equals(VkPastPresentationTimingGOOGLE o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			PresentID.GetHashCode() ^ DesiredPresentTime.GetHashCode() ^ ActualPresentTime.GetHashCode() ^ EarliestPresentTime.GetHashCode()
			^ PresentMargin.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPastPresentationTimingGOOGLE l, in VkPastPresentationTimingGOOGLE r)
	{
		return
			(l.PresentID == r.PresentID) && (l.DesiredPresentTime == r.DesiredPresentTime) && (l.ActualPresentTime == r.ActualPresentTime) && (l.EarliestPresentTime == r.EarliestPresentTime)
			&& (l.PresentMargin == r.PresentMargin)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPastPresentationTimingGOOGLE l, in VkPastPresentationTimingGOOGLE r)
	{
		return
			(l.PresentID != r.PresentID) || (l.DesiredPresentTime != r.DesiredPresentTime) || (l.ActualPresentTime != r.ActualPresentTime) || (l.EarliestPresentTime != r.EarliestPresentTime)
			|| (l.PresentMargin != r.PresentMargin)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPastPresentationTimingGOOGLE s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPresentTimesInfoGOOGLE : IEquatable<VkPresentTimesInfoGOOGLE>
{
	public const VkStructureType TYPE = VkStructureType.PresentTimesInfoGoogle;

	public VkStructureType sType;
	public void* pNext;
	public uint SwapchainCount;
	public VkPresentTimeGOOGLE* Times;

	public VkPresentTimesInfoGOOGLE(
		uint swapchainCount = default,
		VkPresentTimeGOOGLE* times = default
	) {
		sType = TYPE;
		pNext = null;
		SwapchainCount = swapchainCount;
		Times = times;
	}

	public readonly override bool Equals(object? o) => (o is VkPresentTimesInfoGOOGLE s) && (this == s);
	readonly bool IEquatable<VkPresentTimesInfoGOOGLE>.Equals(VkPresentTimesInfoGOOGLE o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SwapchainCount.GetHashCode() ^ ((ulong)Times).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPresentTimesInfoGOOGLE l, in VkPresentTimesInfoGOOGLE r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SwapchainCount == r.SwapchainCount) && (l.Times == r.Times)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPresentTimesInfoGOOGLE l, in VkPresentTimesInfoGOOGLE r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SwapchainCount != r.SwapchainCount) || (l.Times != r.Times)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPresentTimesInfoGOOGLE s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPresentTimeGOOGLE : IEquatable<VkPresentTimeGOOGLE>
{
	public uint PresentID;
	public ulong DesiredPresentTime;

	public VkPresentTimeGOOGLE(
		uint presentID = default,
		ulong desiredPresentTime = default
	) {
		PresentID = presentID;
		DesiredPresentTime = desiredPresentTime;
	}

	public readonly override bool Equals(object? o) => (o is VkPresentTimeGOOGLE s) && (this == s);
	readonly bool IEquatable<VkPresentTimeGOOGLE>.Equals(VkPresentTimeGOOGLE o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			PresentID.GetHashCode() ^ DesiredPresentTime.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPresentTimeGOOGLE l, in VkPresentTimeGOOGLE r)
	{
		return
			(l.PresentID == r.PresentID) && (l.DesiredPresentTime == r.DesiredPresentTime)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPresentTimeGOOGLE l, in VkPresentTimeGOOGLE r)
	{
		return
			(l.PresentID != r.PresentID) || (l.DesiredPresentTime != r.DesiredPresentTime)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPresentTimeGOOGLE s) => s = new();
}


} // namespace Vulkan

