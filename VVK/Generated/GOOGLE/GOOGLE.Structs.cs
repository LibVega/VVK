/*
 * MIT License - Copyright(c) 2020 Sean Moss
 * This file is subject to the terms and conditions of the MIT License, the text of which can be found in the 'LICENSE'
 * file at the root of this repository, or online at<https://opensource.org/licenses/MIT>.
 */

/// This file was generated by VVKGen. Edits to this file will be lost on next generation.

using System;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;


namespace Vk.GOOGLE
{

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct RefreshCycleDuration : IEquatable<RefreshCycleDuration>
{
	public ulong RefreshDuration;

	public readonly override bool Equals(object? obj) => (obj is RefreshCycleDuration o) && (this == o);
	readonly bool IEquatable<RefreshCycleDuration>.Equals(RefreshCycleDuration obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (ulong* ptr = &RefreshDuration) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<RefreshCycleDuration>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in RefreshCycleDuration l, in RefreshCycleDuration r)
	{
		fixed (RefreshCycleDuration* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<RefreshCycleDuration>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<RefreshCycleDuration>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in RefreshCycleDuration l, in RefreshCycleDuration r)
	{
		fixed (RefreshCycleDuration* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<RefreshCycleDuration>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<RefreshCycleDuration>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}

}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PastPresentationTiming : IEquatable<PastPresentationTiming>
{
	public uint PresentID;
	public ulong DesiredPresentTime;
	public ulong ActualPresentTime;
	public ulong EarliestPresentTime;
	public ulong PresentMargin;

	public readonly override bool Equals(object? obj) => (obj is PastPresentationTiming o) && (this == o);
	readonly bool IEquatable<PastPresentationTiming>.Equals(PastPresentationTiming obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (uint* ptr = &PresentID) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<PastPresentationTiming>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in PastPresentationTiming l, in PastPresentationTiming r)
	{
		fixed (PastPresentationTiming* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<PastPresentationTiming>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<PastPresentationTiming>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in PastPresentationTiming l, in PastPresentationTiming r)
	{
		fixed (PastPresentationTiming* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<PastPresentationTiming>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<PastPresentationTiming>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}

}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PresentTimesInfo : IEquatable<PresentTimesInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PresentTimesInfoGOOGLE;

	public Vk.StructureType sType;
	public void* pNext;
	public uint SwapchainCount;
	public Vk.GOOGLE.PresentTime* Times;

	public readonly override bool Equals(object? obj) => (obj is PresentTimesInfo o) && (this == o);
	readonly bool IEquatable<PresentTimesInfo>.Equals(PresentTimesInfo obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (Vk.StructureType* ptr = &sType) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<PresentTimesInfo>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in PresentTimesInfo l, in PresentTimesInfo r)
	{
		fixed (PresentTimesInfo* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<PresentTimesInfo>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<PresentTimesInfo>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in PresentTimesInfo l, in PresentTimesInfo r)
	{
		fixed (PresentTimesInfo* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<PresentTimesInfo>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<PresentTimesInfo>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}


	/// <summary>Creates a new PresentTimesInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PresentTimesInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PresentTimesInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PresentTime : IEquatable<PresentTime>
{
	public uint PresentID;
	public ulong DesiredPresentTime;

	public readonly override bool Equals(object? obj) => (obj is PresentTime o) && (this == o);
	readonly bool IEquatable<PresentTime>.Equals(PresentTime obj) => (this == obj);
	public readonly override int GetHashCode()
	{
		fixed (uint* ptr = &PresentID) {
			return VVK.Hasher.HashBytes(ptr, (uint)Unsafe.SizeOf<PresentTime>());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (in PresentTime l, in PresentTime r)
	{
		fixed (PresentTime* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<PresentTime>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<PresentTime>());
			return lb.SequenceCompareTo(rb) == 0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (in PresentTime l, in PresentTime r)
	{
		fixed (PresentTime* lp = &l, rp = &r) {
			ReadOnlySpan<byte> lb = new((byte*)lp, Unsafe.SizeOf<PresentTime>());
			ReadOnlySpan<byte> rb = new((byte*)rp, Unsafe.SizeOf<PresentTime>());
			return lb.SequenceCompareTo(rb) != 0;
		}
	}

}

} // namespace Vk.GOOGLE
