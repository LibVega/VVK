/*
 * MIT License - Copyright(c) 2020 Sean Moss
 * This file is subject to the terms and conditions of the MIT License, the text of which can be found in the 'LICENSE'
 * file at the root of this repository, or online at <https://opensource.org/licenses/MIT>.
 */

/// This file was generated by VVKGen. Edits to this file will be lost on next generation.

using System;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;

namespace Vulkan
{

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkOffset2D : IEquatable<VkOffset2D>
{
	public int X;
	public int Y;

	public VkOffset2D(
		int x = default,
		int y = default
	) {
		X = x;
		Y = y;
	}

	public readonly override bool Equals(object? o) => (o is VkOffset2D s) && (this == s);
	readonly bool IEquatable<VkOffset2D>.Equals(VkOffset2D o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			X.GetHashCode() ^ Y.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkOffset2D l, in VkOffset2D r)
	{
		return
			(l.X == r.X) && (l.Y == r.Y)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkOffset2D l, in VkOffset2D r)
	{
		return
			(l.X != r.X) || (l.Y != r.Y)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkOffset2D s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkOffset3D : IEquatable<VkOffset3D>
{
	public int X;
	public int Y;
	public int Z;

	public VkOffset3D(
		int x = default,
		int y = default,
		int z = default
	) {
		X = x;
		Y = y;
		Z = z;
	}

	public readonly override bool Equals(object? o) => (o is VkOffset3D s) && (this == s);
	readonly bool IEquatable<VkOffset3D>.Equals(VkOffset3D o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			X.GetHashCode() ^ Y.GetHashCode() ^ Z.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkOffset3D l, in VkOffset3D r)
	{
		return
			(l.X == r.X) && (l.Y == r.Y) && (l.Z == r.Z)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkOffset3D l, in VkOffset3D r)
	{
		return
			(l.X != r.X) || (l.Y != r.Y) || (l.Z != r.Z)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkOffset3D s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkExtent2D : IEquatable<VkExtent2D>
{
	public uint Width;
	public uint Height;

	public VkExtent2D(
		uint width = default,
		uint height = default
	) {
		Width = width;
		Height = height;
	}

	public readonly override bool Equals(object? o) => (o is VkExtent2D s) && (this == s);
	readonly bool IEquatable<VkExtent2D>.Equals(VkExtent2D o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Width.GetHashCode() ^ Height.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkExtent2D l, in VkExtent2D r)
	{
		return
			(l.Width == r.Width) && (l.Height == r.Height)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkExtent2D l, in VkExtent2D r)
	{
		return
			(l.Width != r.Width) || (l.Height != r.Height)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkExtent2D s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkExtent3D : IEquatable<VkExtent3D>
{
	public uint Width;
	public uint Height;
	public uint Depth;

	public VkExtent3D(
		uint width = default,
		uint height = default,
		uint depth = default
	) {
		Width = width;
		Height = height;
		Depth = depth;
	}

	public readonly override bool Equals(object? o) => (o is VkExtent3D s) && (this == s);
	readonly bool IEquatable<VkExtent3D>.Equals(VkExtent3D o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Width.GetHashCode() ^ Height.GetHashCode() ^ Depth.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkExtent3D l, in VkExtent3D r)
	{
		return
			(l.Width == r.Width) && (l.Height == r.Height) && (l.Depth == r.Depth)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkExtent3D l, in VkExtent3D r)
	{
		return
			(l.Width != r.Width) || (l.Height != r.Height) || (l.Depth != r.Depth)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkExtent3D s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkViewport : IEquatable<VkViewport>
{
	public float X;
	public float Y;
	public float Width;
	public float Height;
	public float MinDepth;
	public float MaxDepth;

	public VkViewport(
		float x = default,
		float y = default,
		float width = default,
		float height = default,
		float minDepth = default,
		float maxDepth = default
	) {
		X = x;
		Y = y;
		Width = width;
		Height = height;
		MinDepth = minDepth;
		MaxDepth = maxDepth;
	}

	public readonly override bool Equals(object? o) => (o is VkViewport s) && (this == s);
	readonly bool IEquatable<VkViewport>.Equals(VkViewport o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			X.GetHashCode() ^ Y.GetHashCode() ^ Width.GetHashCode() ^ Height.GetHashCode()
			^ MinDepth.GetHashCode() ^ MaxDepth.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkViewport l, in VkViewport r)
	{
		return
			(l.X == r.X) && (l.Y == r.Y) && (l.Width == r.Width) && (l.Height == r.Height)
			&& (l.MinDepth == r.MinDepth) && (l.MaxDepth == r.MaxDepth)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkViewport l, in VkViewport r)
	{
		return
			(l.X != r.X) || (l.Y != r.Y) || (l.Width != r.Width) || (l.Height != r.Height)
			|| (l.MinDepth != r.MinDepth) || (l.MaxDepth != r.MaxDepth)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkViewport s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkRect2D : IEquatable<VkRect2D>
{
	public VkOffset2D Offset;
	public VkExtent2D Extent;

	public VkRect2D(
		VkOffset2D offset = default,
		VkExtent2D extent = default
	) {
		Offset = offset;
		Extent = extent;
	}

	public readonly override bool Equals(object? o) => (o is VkRect2D s) && (this == s);
	readonly bool IEquatable<VkRect2D>.Equals(VkRect2D o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Offset.GetHashCode() ^ Extent.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkRect2D l, in VkRect2D r)
	{
		return
			(l.Offset == r.Offset) && (l.Extent == r.Extent)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkRect2D l, in VkRect2D r)
	{
		return
			(l.Offset != r.Offset) || (l.Extent != r.Extent)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkRect2D s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkClearRect : IEquatable<VkClearRect>
{
	public VkRect2D Rect;
	public uint BaseArrayLayer;
	public uint LayerCount;

	public VkClearRect(
		VkRect2D rect = default,
		uint baseArrayLayer = default,
		uint layerCount = default
	) {
		Rect = rect;
		BaseArrayLayer = baseArrayLayer;
		LayerCount = layerCount;
	}

	public readonly override bool Equals(object? o) => (o is VkClearRect s) && (this == s);
	readonly bool IEquatable<VkClearRect>.Equals(VkClearRect o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Rect.GetHashCode() ^ BaseArrayLayer.GetHashCode() ^ LayerCount.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkClearRect l, in VkClearRect r)
	{
		return
			(l.Rect == r.Rect) && (l.BaseArrayLayer == r.BaseArrayLayer) && (l.LayerCount == r.LayerCount)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkClearRect l, in VkClearRect r)
	{
		return
			(l.Rect != r.Rect) || (l.BaseArrayLayer != r.BaseArrayLayer) || (l.LayerCount != r.LayerCount)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkClearRect s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkComponentMapping : IEquatable<VkComponentMapping>
{
	public VkComponentSwizzle R;
	public VkComponentSwizzle G;
	public VkComponentSwizzle B;
	public VkComponentSwizzle A;

	public VkComponentMapping(
		VkComponentSwizzle r = default,
		VkComponentSwizzle g = default,
		VkComponentSwizzle b = default,
		VkComponentSwizzle a = default
	) {
		R = r;
		G = g;
		B = b;
		A = a;
	}

	public readonly override bool Equals(object? o) => (o is VkComponentMapping s) && (this == s);
	readonly bool IEquatable<VkComponentMapping>.Equals(VkComponentMapping o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			R.GetHashCode() ^ G.GetHashCode() ^ B.GetHashCode() ^ A.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkComponentMapping l, in VkComponentMapping r)
	{
		return
			(l.R == r.R) && (l.G == r.G) && (l.B == r.B) && (l.A == r.A)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkComponentMapping l, in VkComponentMapping r)
	{
		return
			(l.R != r.R) || (l.G != r.G) || (l.B != r.B) || (l.A != r.A)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkComponentMapping s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceProperties : IEquatable<VkPhysicalDeviceProperties>
{
	public uint ApiVersion;
	public uint DriverVersion;
	public uint VendorID;
	public uint DeviceID;
	public VkPhysicalDeviceType DeviceType;
	public VVK.PhysicalDeviceName DeviceName;
	public VVK.UUID PipelineCacheUUID;
	public VkPhysicalDeviceLimits Limits;
	public VkPhysicalDeviceSparseProperties SparseProperties;

	public VkPhysicalDeviceProperties(
		uint apiVersion = default,
		uint driverVersion = default,
		uint vendorID = default,
		uint deviceID = default,
		VkPhysicalDeviceType deviceType = default,
		VVK.PhysicalDeviceName deviceName = default,
		VVK.UUID pipelineCacheUUID = default,
		VkPhysicalDeviceLimits limits = default,
		VkPhysicalDeviceSparseProperties sparseProperties = default
	) {
		ApiVersion = apiVersion;
		DriverVersion = driverVersion;
		VendorID = vendorID;
		DeviceID = deviceID;
		DeviceType = deviceType;
		DeviceName = deviceName;
		PipelineCacheUUID = pipelineCacheUUID;
		Limits = limits;
		SparseProperties = sparseProperties;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceProperties s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceProperties>.Equals(VkPhysicalDeviceProperties o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			ApiVersion.GetHashCode() ^ DriverVersion.GetHashCode() ^ VendorID.GetHashCode() ^ DeviceID.GetHashCode()
			^ DeviceType.GetHashCode() ^ DeviceName.GetHashCode() ^ PipelineCacheUUID.GetHashCode() ^ Limits.GetHashCode()
			^ SparseProperties.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceProperties l, in VkPhysicalDeviceProperties r)
	{
		return
			(l.ApiVersion == r.ApiVersion) && (l.DriverVersion == r.DriverVersion) && (l.VendorID == r.VendorID) && (l.DeviceID == r.DeviceID)
			&& (l.DeviceType == r.DeviceType) && (l.DeviceName == r.DeviceName) && (l.PipelineCacheUUID == r.PipelineCacheUUID) && (l.Limits == r.Limits)
			&& (l.SparseProperties == r.SparseProperties)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceProperties l, in VkPhysicalDeviceProperties r)
	{
		return
			(l.ApiVersion != r.ApiVersion) || (l.DriverVersion != r.DriverVersion) || (l.VendorID != r.VendorID) || (l.DeviceID != r.DeviceID)
			|| (l.DeviceType != r.DeviceType) || (l.DeviceName != r.DeviceName) || (l.PipelineCacheUUID != r.PipelineCacheUUID) || (l.Limits != r.Limits)
			|| (l.SparseProperties != r.SparseProperties)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceProperties s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkExtensionProperties : IEquatable<VkExtensionProperties>
{
	public VVK.ExtensionName ExtensionName;
	public uint SpecVersion;

	public VkExtensionProperties(
		VVK.ExtensionName extensionName = default,
		uint specVersion = default
	) {
		ExtensionName = extensionName;
		SpecVersion = specVersion;
	}

	public readonly override bool Equals(object? o) => (o is VkExtensionProperties s) && (this == s);
	readonly bool IEquatable<VkExtensionProperties>.Equals(VkExtensionProperties o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			ExtensionName.GetHashCode() ^ SpecVersion.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkExtensionProperties l, in VkExtensionProperties r)
	{
		return
			(l.ExtensionName == r.ExtensionName) && (l.SpecVersion == r.SpecVersion)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkExtensionProperties l, in VkExtensionProperties r)
	{
		return
			(l.ExtensionName != r.ExtensionName) || (l.SpecVersion != r.SpecVersion)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkExtensionProperties s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkLayerProperties : IEquatable<VkLayerProperties>
{
	public VVK.ExtensionName LayerName;
	public uint SpecVersion;
	public uint ImplementationVersion;
	public VVK.Description Description;

	public VkLayerProperties(
		VVK.ExtensionName layerName = default,
		uint specVersion = default,
		uint implementationVersion = default,
		VVK.Description description = default
	) {
		LayerName = layerName;
		SpecVersion = specVersion;
		ImplementationVersion = implementationVersion;
		Description = description;
	}

	public readonly override bool Equals(object? o) => (o is VkLayerProperties s) && (this == s);
	readonly bool IEquatable<VkLayerProperties>.Equals(VkLayerProperties o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			LayerName.GetHashCode() ^ SpecVersion.GetHashCode() ^ ImplementationVersion.GetHashCode() ^ Description.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkLayerProperties l, in VkLayerProperties r)
	{
		return
			(l.LayerName == r.LayerName) && (l.SpecVersion == r.SpecVersion) && (l.ImplementationVersion == r.ImplementationVersion) && (l.Description == r.Description)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkLayerProperties l, in VkLayerProperties r)
	{
		return
			(l.LayerName != r.LayerName) || (l.SpecVersion != r.SpecVersion) || (l.ImplementationVersion != r.ImplementationVersion) || (l.Description != r.Description)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkLayerProperties s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkApplicationInfo : IEquatable<VkApplicationInfo>
{
	public const VkStructureType TYPE = VkStructureType.ApplicationInfo;

	public VkStructureType sType;
	public void* pNext;
	public byte* ApplicationName;
	public uint ApplicationVersion;
	public byte* EngineName;
	public uint EngineVersion;
	public uint ApiVersion;

	public VkApplicationInfo(
		byte* applicationName = default,
		uint applicationVersion = default,
		byte* engineName = default,
		uint engineVersion = default,
		uint apiVersion = default
	) {
		sType = TYPE;
		pNext = null;
		ApplicationName = applicationName;
		ApplicationVersion = applicationVersion;
		EngineName = engineName;
		EngineVersion = engineVersion;
		ApiVersion = apiVersion;
	}

	public readonly override bool Equals(object? o) => (o is VkApplicationInfo s) && (this == s);
	readonly bool IEquatable<VkApplicationInfo>.Equals(VkApplicationInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ((ulong)ApplicationName).GetHashCode() ^ ApplicationVersion.GetHashCode()
			^ ((ulong)EngineName).GetHashCode() ^ EngineVersion.GetHashCode() ^ ApiVersion.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkApplicationInfo l, in VkApplicationInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ApplicationName == r.ApplicationName) && (l.ApplicationVersion == r.ApplicationVersion)
			&& (l.EngineName == r.EngineName) && (l.EngineVersion == r.EngineVersion) && (l.ApiVersion == r.ApiVersion)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkApplicationInfo l, in VkApplicationInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ApplicationName != r.ApplicationName) || (l.ApplicationVersion != r.ApplicationVersion)
			|| (l.EngineName != r.EngineName) || (l.EngineVersion != r.EngineVersion) || (l.ApiVersion != r.ApiVersion)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkApplicationInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkAllocationCallbacks : IEquatable<VkAllocationCallbacks>
{
	public void* UserData;
	public delegate* managed<void*, ulong, ulong, VkSystemAllocationScope, void*> Allocation;
	public delegate* managed<void*, void*, ulong, ulong, VkSystemAllocationScope, void*> Reallocation;
	public delegate* managed<void*, void*, void> Free;
	public delegate* managed<void*, ulong, VkInternalAllocationType, VkSystemAllocationScope, void> InternalAllocation;
	public delegate* managed<void*, ulong, VkInternalAllocationType, VkSystemAllocationScope, void> InternalFree;

	public VkAllocationCallbacks(
		void* userData = default,
		delegate* managed<void*, ulong, ulong, VkSystemAllocationScope, void*> allocation = default,
		delegate* managed<void*, void*, ulong, ulong, VkSystemAllocationScope, void*> reallocation = default,
		delegate* managed<void*, void*, void> free = default,
		delegate* managed<void*, ulong, VkInternalAllocationType, VkSystemAllocationScope, void> internalAllocation = default,
		delegate* managed<void*, ulong, VkInternalAllocationType, VkSystemAllocationScope, void> internalFree = default
	) {
		UserData = userData;
		Allocation = allocation;
		Reallocation = reallocation;
		Free = free;
		InternalAllocation = internalAllocation;
		InternalFree = internalFree;
	}

	public readonly override bool Equals(object? o) => (o is VkAllocationCallbacks s) && (this == s);
	readonly bool IEquatable<VkAllocationCallbacks>.Equals(VkAllocationCallbacks o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			((ulong)UserData).GetHashCode() ^ ((ulong)Allocation).GetHashCode() ^ ((ulong)Reallocation).GetHashCode() ^ ((ulong)Free).GetHashCode()
			^ ((ulong)InternalAllocation).GetHashCode() ^ ((ulong)InternalFree).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkAllocationCallbacks l, in VkAllocationCallbacks r)
	{
		return
			(l.UserData == r.UserData) && (l.Allocation == r.Allocation) && (l.Reallocation == r.Reallocation) && (l.Free == r.Free)
			&& (l.InternalAllocation == r.InternalAllocation) && (l.InternalFree == r.InternalFree)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkAllocationCallbacks l, in VkAllocationCallbacks r)
	{
		return
			(l.UserData != r.UserData) || (l.Allocation != r.Allocation) || (l.Reallocation != r.Reallocation) || (l.Free != r.Free)
			|| (l.InternalAllocation != r.InternalAllocation) || (l.InternalFree != r.InternalFree)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkAllocationCallbacks s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDeviceQueueCreateInfo : IEquatable<VkDeviceQueueCreateInfo>
{
	public const VkStructureType TYPE = VkStructureType.DeviceQueueCreateInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkDeviceQueueCreateFlags Flags;
	public uint QueueFamilyIndex;
	public uint QueueCount;
	public float* QueuePriorities;

	public VkDeviceQueueCreateInfo(
		VkDeviceQueueCreateFlags flags = default,
		uint queueFamilyIndex = default,
		uint queueCount = default,
		float* queuePriorities = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		QueueFamilyIndex = queueFamilyIndex;
		QueueCount = queueCount;
		QueuePriorities = queuePriorities;
	}

	public readonly override bool Equals(object? o) => (o is VkDeviceQueueCreateInfo s) && (this == s);
	readonly bool IEquatable<VkDeviceQueueCreateInfo>.Equals(VkDeviceQueueCreateInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ QueueFamilyIndex.GetHashCode()
			^ QueueCount.GetHashCode() ^ ((ulong)QueuePriorities).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDeviceQueueCreateInfo l, in VkDeviceQueueCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.QueueFamilyIndex == r.QueueFamilyIndex)
			&& (l.QueueCount == r.QueueCount) && (l.QueuePriorities == r.QueuePriorities)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDeviceQueueCreateInfo l, in VkDeviceQueueCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.QueueFamilyIndex != r.QueueFamilyIndex)
			|| (l.QueueCount != r.QueueCount) || (l.QueuePriorities != r.QueuePriorities)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDeviceQueueCreateInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDeviceCreateInfo : IEquatable<VkDeviceCreateInfo>
{
	public const VkStructureType TYPE = VkStructureType.DeviceCreateInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkDeviceCreateFlags Flags;
	public uint QueueCreateInfoCount;
	public VkDeviceQueueCreateInfo* QueueCreateInfos;
	public uint EnabledLayerCount;
	public byte** EnabledLayerNames;
	public uint EnabledExtensionCount;
	public byte** EnabledExtensionNames;
	public VkPhysicalDeviceFeatures* EnabledFeatures;

	public VkDeviceCreateInfo(
		VkDeviceCreateFlags flags = default,
		uint queueCreateInfoCount = default,
		VkDeviceQueueCreateInfo* queueCreateInfos = default,
		uint enabledLayerCount = default,
		byte** enabledLayerNames = default,
		uint enabledExtensionCount = default,
		byte** enabledExtensionNames = default,
		VkPhysicalDeviceFeatures* enabledFeatures = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		QueueCreateInfoCount = queueCreateInfoCount;
		QueueCreateInfos = queueCreateInfos;
		EnabledLayerCount = enabledLayerCount;
		EnabledLayerNames = enabledLayerNames;
		EnabledExtensionCount = enabledExtensionCount;
		EnabledExtensionNames = enabledExtensionNames;
		EnabledFeatures = enabledFeatures;
	}

	public readonly override bool Equals(object? o) => (o is VkDeviceCreateInfo s) && (this == s);
	readonly bool IEquatable<VkDeviceCreateInfo>.Equals(VkDeviceCreateInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ QueueCreateInfoCount.GetHashCode()
			^ ((ulong)QueueCreateInfos).GetHashCode() ^ EnabledLayerCount.GetHashCode() ^ ((ulong)EnabledLayerNames).GetHashCode() ^ EnabledExtensionCount.GetHashCode()
			^ ((ulong)EnabledExtensionNames).GetHashCode() ^ ((ulong)EnabledFeatures).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDeviceCreateInfo l, in VkDeviceCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.QueueCreateInfoCount == r.QueueCreateInfoCount)
			&& (l.QueueCreateInfos == r.QueueCreateInfos) && (l.EnabledLayerCount == r.EnabledLayerCount) && (l.EnabledLayerNames == r.EnabledLayerNames) && (l.EnabledExtensionCount == r.EnabledExtensionCount)
			&& (l.EnabledExtensionNames == r.EnabledExtensionNames) && (l.EnabledFeatures == r.EnabledFeatures)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDeviceCreateInfo l, in VkDeviceCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.QueueCreateInfoCount != r.QueueCreateInfoCount)
			|| (l.QueueCreateInfos != r.QueueCreateInfos) || (l.EnabledLayerCount != r.EnabledLayerCount) || (l.EnabledLayerNames != r.EnabledLayerNames) || (l.EnabledExtensionCount != r.EnabledExtensionCount)
			|| (l.EnabledExtensionNames != r.EnabledExtensionNames) || (l.EnabledFeatures != r.EnabledFeatures)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDeviceCreateInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkInstanceCreateInfo : IEquatable<VkInstanceCreateInfo>
{
	public const VkStructureType TYPE = VkStructureType.InstanceCreateInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkInstanceCreateFlags Flags;
	public VkApplicationInfo* ApplicationInfo;
	public uint EnabledLayerCount;
	public byte** EnabledLayerNames;
	public uint EnabledExtensionCount;
	public byte** EnabledExtensionNames;

	public VkInstanceCreateInfo(
		VkInstanceCreateFlags flags = default,
		VkApplicationInfo* applicationInfo = default,
		uint enabledLayerCount = default,
		byte** enabledLayerNames = default,
		uint enabledExtensionCount = default,
		byte** enabledExtensionNames = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		ApplicationInfo = applicationInfo;
		EnabledLayerCount = enabledLayerCount;
		EnabledLayerNames = enabledLayerNames;
		EnabledExtensionCount = enabledExtensionCount;
		EnabledExtensionNames = enabledExtensionNames;
	}

	public readonly override bool Equals(object? o) => (o is VkInstanceCreateInfo s) && (this == s);
	readonly bool IEquatable<VkInstanceCreateInfo>.Equals(VkInstanceCreateInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ ((ulong)ApplicationInfo).GetHashCode()
			^ EnabledLayerCount.GetHashCode() ^ ((ulong)EnabledLayerNames).GetHashCode() ^ EnabledExtensionCount.GetHashCode() ^ ((ulong)EnabledExtensionNames).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkInstanceCreateInfo l, in VkInstanceCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.ApplicationInfo == r.ApplicationInfo)
			&& (l.EnabledLayerCount == r.EnabledLayerCount) && (l.EnabledLayerNames == r.EnabledLayerNames) && (l.EnabledExtensionCount == r.EnabledExtensionCount) && (l.EnabledExtensionNames == r.EnabledExtensionNames)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkInstanceCreateInfo l, in VkInstanceCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.ApplicationInfo != r.ApplicationInfo)
			|| (l.EnabledLayerCount != r.EnabledLayerCount) || (l.EnabledLayerNames != r.EnabledLayerNames) || (l.EnabledExtensionCount != r.EnabledExtensionCount) || (l.EnabledExtensionNames != r.EnabledExtensionNames)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkInstanceCreateInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkQueueFamilyProperties : IEquatable<VkQueueFamilyProperties>
{
	public VkQueueFlags QueueFlags;
	public uint QueueCount;
	public uint TimestampValidBits;
	public VkExtent3D MinImageTransferGranularity;

	public VkQueueFamilyProperties(
		VkQueueFlags queueFlags = default,
		uint queueCount = default,
		uint timestampValidBits = default,
		VkExtent3D minImageTransferGranularity = default
	) {
		QueueFlags = queueFlags;
		QueueCount = queueCount;
		TimestampValidBits = timestampValidBits;
		MinImageTransferGranularity = minImageTransferGranularity;
	}

	public readonly override bool Equals(object? o) => (o is VkQueueFamilyProperties s) && (this == s);
	readonly bool IEquatable<VkQueueFamilyProperties>.Equals(VkQueueFamilyProperties o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			QueueFlags.GetHashCode() ^ QueueCount.GetHashCode() ^ TimestampValidBits.GetHashCode() ^ MinImageTransferGranularity.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkQueueFamilyProperties l, in VkQueueFamilyProperties r)
	{
		return
			(l.QueueFlags == r.QueueFlags) && (l.QueueCount == r.QueueCount) && (l.TimestampValidBits == r.TimestampValidBits) && (l.MinImageTransferGranularity == r.MinImageTransferGranularity)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkQueueFamilyProperties l, in VkQueueFamilyProperties r)
	{
		return
			(l.QueueFlags != r.QueueFlags) || (l.QueueCount != r.QueueCount) || (l.TimestampValidBits != r.TimestampValidBits) || (l.MinImageTransferGranularity != r.MinImageTransferGranularity)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkQueueFamilyProperties s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceMemoryProperties : IEquatable<VkPhysicalDeviceMemoryProperties>
{
	public uint MemoryTypeCount;
	public VkMemoryType MemoryTypes_0;
	public VkMemoryType MemoryTypes_1;
	public VkMemoryType MemoryTypes_2;
	public VkMemoryType MemoryTypes_3;
	public VkMemoryType MemoryTypes_4;
	public VkMemoryType MemoryTypes_5;
	public VkMemoryType MemoryTypes_6;
	public VkMemoryType MemoryTypes_7;
	public VkMemoryType MemoryTypes_8;
	public VkMemoryType MemoryTypes_9;
	public VkMemoryType MemoryTypes_10;
	public VkMemoryType MemoryTypes_11;
	public VkMemoryType MemoryTypes_12;
	public VkMemoryType MemoryTypes_13;
	public VkMemoryType MemoryTypes_14;
	public VkMemoryType MemoryTypes_15;
	public VkMemoryType MemoryTypes_16;
	public VkMemoryType MemoryTypes_17;
	public VkMemoryType MemoryTypes_18;
	public VkMemoryType MemoryTypes_19;
	public VkMemoryType MemoryTypes_20;
	public VkMemoryType MemoryTypes_21;
	public VkMemoryType MemoryTypes_22;
	public VkMemoryType MemoryTypes_23;
	public VkMemoryType MemoryTypes_24;
	public VkMemoryType MemoryTypes_25;
	public VkMemoryType MemoryTypes_26;
	public VkMemoryType MemoryTypes_27;
	public VkMemoryType MemoryTypes_28;
	public VkMemoryType MemoryTypes_29;
	public VkMemoryType MemoryTypes_30;
	public VkMemoryType MemoryTypes_31;
	public uint MemoryHeapCount;
	public VkMemoryHeap MemoryHeaps_0;
	public VkMemoryHeap MemoryHeaps_1;
	public VkMemoryHeap MemoryHeaps_2;
	public VkMemoryHeap MemoryHeaps_3;
	public VkMemoryHeap MemoryHeaps_4;
	public VkMemoryHeap MemoryHeaps_5;
	public VkMemoryHeap MemoryHeaps_6;
	public VkMemoryHeap MemoryHeaps_7;
	public VkMemoryHeap MemoryHeaps_8;
	public VkMemoryHeap MemoryHeaps_9;
	public VkMemoryHeap MemoryHeaps_10;
	public VkMemoryHeap MemoryHeaps_11;
	public VkMemoryHeap MemoryHeaps_12;
	public VkMemoryHeap MemoryHeaps_13;
	public VkMemoryHeap MemoryHeaps_14;
	public VkMemoryHeap MemoryHeaps_15;

	public VkPhysicalDeviceMemoryProperties(
		uint memoryTypeCount = default,
		VkMemoryType memoryTypes_0 = default,
		VkMemoryType memoryTypes_1 = default,
		VkMemoryType memoryTypes_2 = default,
		VkMemoryType memoryTypes_3 = default,
		VkMemoryType memoryTypes_4 = default,
		VkMemoryType memoryTypes_5 = default,
		VkMemoryType memoryTypes_6 = default,
		VkMemoryType memoryTypes_7 = default,
		VkMemoryType memoryTypes_8 = default,
		VkMemoryType memoryTypes_9 = default,
		VkMemoryType memoryTypes_10 = default,
		VkMemoryType memoryTypes_11 = default,
		VkMemoryType memoryTypes_12 = default,
		VkMemoryType memoryTypes_13 = default,
		VkMemoryType memoryTypes_14 = default,
		VkMemoryType memoryTypes_15 = default,
		VkMemoryType memoryTypes_16 = default,
		VkMemoryType memoryTypes_17 = default,
		VkMemoryType memoryTypes_18 = default,
		VkMemoryType memoryTypes_19 = default,
		VkMemoryType memoryTypes_20 = default,
		VkMemoryType memoryTypes_21 = default,
		VkMemoryType memoryTypes_22 = default,
		VkMemoryType memoryTypes_23 = default,
		VkMemoryType memoryTypes_24 = default,
		VkMemoryType memoryTypes_25 = default,
		VkMemoryType memoryTypes_26 = default,
		VkMemoryType memoryTypes_27 = default,
		VkMemoryType memoryTypes_28 = default,
		VkMemoryType memoryTypes_29 = default,
		VkMemoryType memoryTypes_30 = default,
		VkMemoryType memoryTypes_31 = default,
		uint memoryHeapCount = default,
		VkMemoryHeap memoryHeaps_0 = default,
		VkMemoryHeap memoryHeaps_1 = default,
		VkMemoryHeap memoryHeaps_2 = default,
		VkMemoryHeap memoryHeaps_3 = default,
		VkMemoryHeap memoryHeaps_4 = default,
		VkMemoryHeap memoryHeaps_5 = default,
		VkMemoryHeap memoryHeaps_6 = default,
		VkMemoryHeap memoryHeaps_7 = default,
		VkMemoryHeap memoryHeaps_8 = default,
		VkMemoryHeap memoryHeaps_9 = default,
		VkMemoryHeap memoryHeaps_10 = default,
		VkMemoryHeap memoryHeaps_11 = default,
		VkMemoryHeap memoryHeaps_12 = default,
		VkMemoryHeap memoryHeaps_13 = default,
		VkMemoryHeap memoryHeaps_14 = default,
		VkMemoryHeap memoryHeaps_15 = default
	) {
		MemoryTypeCount = memoryTypeCount;
		MemoryTypes_0 = memoryTypes_0;
		MemoryTypes_1 = memoryTypes_1;
		MemoryTypes_2 = memoryTypes_2;
		MemoryTypes_3 = memoryTypes_3;
		MemoryTypes_4 = memoryTypes_4;
		MemoryTypes_5 = memoryTypes_5;
		MemoryTypes_6 = memoryTypes_6;
		MemoryTypes_7 = memoryTypes_7;
		MemoryTypes_8 = memoryTypes_8;
		MemoryTypes_9 = memoryTypes_9;
		MemoryTypes_10 = memoryTypes_10;
		MemoryTypes_11 = memoryTypes_11;
		MemoryTypes_12 = memoryTypes_12;
		MemoryTypes_13 = memoryTypes_13;
		MemoryTypes_14 = memoryTypes_14;
		MemoryTypes_15 = memoryTypes_15;
		MemoryTypes_16 = memoryTypes_16;
		MemoryTypes_17 = memoryTypes_17;
		MemoryTypes_18 = memoryTypes_18;
		MemoryTypes_19 = memoryTypes_19;
		MemoryTypes_20 = memoryTypes_20;
		MemoryTypes_21 = memoryTypes_21;
		MemoryTypes_22 = memoryTypes_22;
		MemoryTypes_23 = memoryTypes_23;
		MemoryTypes_24 = memoryTypes_24;
		MemoryTypes_25 = memoryTypes_25;
		MemoryTypes_26 = memoryTypes_26;
		MemoryTypes_27 = memoryTypes_27;
		MemoryTypes_28 = memoryTypes_28;
		MemoryTypes_29 = memoryTypes_29;
		MemoryTypes_30 = memoryTypes_30;
		MemoryTypes_31 = memoryTypes_31;
		MemoryHeapCount = memoryHeapCount;
		MemoryHeaps_0 = memoryHeaps_0;
		MemoryHeaps_1 = memoryHeaps_1;
		MemoryHeaps_2 = memoryHeaps_2;
		MemoryHeaps_3 = memoryHeaps_3;
		MemoryHeaps_4 = memoryHeaps_4;
		MemoryHeaps_5 = memoryHeaps_5;
		MemoryHeaps_6 = memoryHeaps_6;
		MemoryHeaps_7 = memoryHeaps_7;
		MemoryHeaps_8 = memoryHeaps_8;
		MemoryHeaps_9 = memoryHeaps_9;
		MemoryHeaps_10 = memoryHeaps_10;
		MemoryHeaps_11 = memoryHeaps_11;
		MemoryHeaps_12 = memoryHeaps_12;
		MemoryHeaps_13 = memoryHeaps_13;
		MemoryHeaps_14 = memoryHeaps_14;
		MemoryHeaps_15 = memoryHeaps_15;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceMemoryProperties s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceMemoryProperties>.Equals(VkPhysicalDeviceMemoryProperties o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			MemoryTypeCount.GetHashCode() ^ MemoryTypes_0.GetHashCode() ^ MemoryTypes_1.GetHashCode() ^ MemoryTypes_2.GetHashCode()
			^ MemoryTypes_3.GetHashCode() ^ MemoryTypes_4.GetHashCode() ^ MemoryTypes_5.GetHashCode() ^ MemoryTypes_6.GetHashCode()
			^ MemoryTypes_7.GetHashCode() ^ MemoryTypes_8.GetHashCode() ^ MemoryTypes_9.GetHashCode() ^ MemoryTypes_10.GetHashCode()
			^ MemoryTypes_11.GetHashCode() ^ MemoryTypes_12.GetHashCode() ^ MemoryTypes_13.GetHashCode() ^ MemoryTypes_14.GetHashCode()
			^ MemoryTypes_15.GetHashCode() ^ MemoryTypes_16.GetHashCode() ^ MemoryTypes_17.GetHashCode() ^ MemoryTypes_18.GetHashCode()
			^ MemoryTypes_19.GetHashCode() ^ MemoryTypes_20.GetHashCode() ^ MemoryTypes_21.GetHashCode() ^ MemoryTypes_22.GetHashCode()
			^ MemoryTypes_23.GetHashCode() ^ MemoryTypes_24.GetHashCode() ^ MemoryTypes_25.GetHashCode() ^ MemoryTypes_26.GetHashCode()
			^ MemoryTypes_27.GetHashCode() ^ MemoryTypes_28.GetHashCode() ^ MemoryTypes_29.GetHashCode() ^ MemoryTypes_30.GetHashCode()
			^ MemoryTypes_31.GetHashCode() ^ MemoryHeapCount.GetHashCode() ^ MemoryHeaps_0.GetHashCode() ^ MemoryHeaps_1.GetHashCode()
			^ MemoryHeaps_2.GetHashCode() ^ MemoryHeaps_3.GetHashCode() ^ MemoryHeaps_4.GetHashCode() ^ MemoryHeaps_5.GetHashCode()
			^ MemoryHeaps_6.GetHashCode() ^ MemoryHeaps_7.GetHashCode() ^ MemoryHeaps_8.GetHashCode() ^ MemoryHeaps_9.GetHashCode()
			^ MemoryHeaps_10.GetHashCode() ^ MemoryHeaps_11.GetHashCode() ^ MemoryHeaps_12.GetHashCode() ^ MemoryHeaps_13.GetHashCode()
			^ MemoryHeaps_14.GetHashCode() ^ MemoryHeaps_15.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceMemoryProperties l, in VkPhysicalDeviceMemoryProperties r)
	{
		return
			(l.MemoryTypeCount == r.MemoryTypeCount) && (l.MemoryTypes_0 == r.MemoryTypes_0) && (l.MemoryTypes_1 == r.MemoryTypes_1) && (l.MemoryTypes_2 == r.MemoryTypes_2)
			&& (l.MemoryTypes_3 == r.MemoryTypes_3) && (l.MemoryTypes_4 == r.MemoryTypes_4) && (l.MemoryTypes_5 == r.MemoryTypes_5) && (l.MemoryTypes_6 == r.MemoryTypes_6)
			&& (l.MemoryTypes_7 == r.MemoryTypes_7) && (l.MemoryTypes_8 == r.MemoryTypes_8) && (l.MemoryTypes_9 == r.MemoryTypes_9) && (l.MemoryTypes_10 == r.MemoryTypes_10)
			&& (l.MemoryTypes_11 == r.MemoryTypes_11) && (l.MemoryTypes_12 == r.MemoryTypes_12) && (l.MemoryTypes_13 == r.MemoryTypes_13) && (l.MemoryTypes_14 == r.MemoryTypes_14)
			&& (l.MemoryTypes_15 == r.MemoryTypes_15) && (l.MemoryTypes_16 == r.MemoryTypes_16) && (l.MemoryTypes_17 == r.MemoryTypes_17) && (l.MemoryTypes_18 == r.MemoryTypes_18)
			&& (l.MemoryTypes_19 == r.MemoryTypes_19) && (l.MemoryTypes_20 == r.MemoryTypes_20) && (l.MemoryTypes_21 == r.MemoryTypes_21) && (l.MemoryTypes_22 == r.MemoryTypes_22)
			&& (l.MemoryTypes_23 == r.MemoryTypes_23) && (l.MemoryTypes_24 == r.MemoryTypes_24) && (l.MemoryTypes_25 == r.MemoryTypes_25) && (l.MemoryTypes_26 == r.MemoryTypes_26)
			&& (l.MemoryTypes_27 == r.MemoryTypes_27) && (l.MemoryTypes_28 == r.MemoryTypes_28) && (l.MemoryTypes_29 == r.MemoryTypes_29) && (l.MemoryTypes_30 == r.MemoryTypes_30)
			&& (l.MemoryTypes_31 == r.MemoryTypes_31) && (l.MemoryHeapCount == r.MemoryHeapCount) && (l.MemoryHeaps_0 == r.MemoryHeaps_0) && (l.MemoryHeaps_1 == r.MemoryHeaps_1)
			&& (l.MemoryHeaps_2 == r.MemoryHeaps_2) && (l.MemoryHeaps_3 == r.MemoryHeaps_3) && (l.MemoryHeaps_4 == r.MemoryHeaps_4) && (l.MemoryHeaps_5 == r.MemoryHeaps_5)
			&& (l.MemoryHeaps_6 == r.MemoryHeaps_6) && (l.MemoryHeaps_7 == r.MemoryHeaps_7) && (l.MemoryHeaps_8 == r.MemoryHeaps_8) && (l.MemoryHeaps_9 == r.MemoryHeaps_9)
			&& (l.MemoryHeaps_10 == r.MemoryHeaps_10) && (l.MemoryHeaps_11 == r.MemoryHeaps_11) && (l.MemoryHeaps_12 == r.MemoryHeaps_12) && (l.MemoryHeaps_13 == r.MemoryHeaps_13)
			&& (l.MemoryHeaps_14 == r.MemoryHeaps_14) && (l.MemoryHeaps_15 == r.MemoryHeaps_15)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceMemoryProperties l, in VkPhysicalDeviceMemoryProperties r)
	{
		return
			(l.MemoryTypeCount != r.MemoryTypeCount) || (l.MemoryTypes_0 != r.MemoryTypes_0) || (l.MemoryTypes_1 != r.MemoryTypes_1) || (l.MemoryTypes_2 != r.MemoryTypes_2)
			|| (l.MemoryTypes_3 != r.MemoryTypes_3) || (l.MemoryTypes_4 != r.MemoryTypes_4) || (l.MemoryTypes_5 != r.MemoryTypes_5) || (l.MemoryTypes_6 != r.MemoryTypes_6)
			|| (l.MemoryTypes_7 != r.MemoryTypes_7) || (l.MemoryTypes_8 != r.MemoryTypes_8) || (l.MemoryTypes_9 != r.MemoryTypes_9) || (l.MemoryTypes_10 != r.MemoryTypes_10)
			|| (l.MemoryTypes_11 != r.MemoryTypes_11) || (l.MemoryTypes_12 != r.MemoryTypes_12) || (l.MemoryTypes_13 != r.MemoryTypes_13) || (l.MemoryTypes_14 != r.MemoryTypes_14)
			|| (l.MemoryTypes_15 != r.MemoryTypes_15) || (l.MemoryTypes_16 != r.MemoryTypes_16) || (l.MemoryTypes_17 != r.MemoryTypes_17) || (l.MemoryTypes_18 != r.MemoryTypes_18)
			|| (l.MemoryTypes_19 != r.MemoryTypes_19) || (l.MemoryTypes_20 != r.MemoryTypes_20) || (l.MemoryTypes_21 != r.MemoryTypes_21) || (l.MemoryTypes_22 != r.MemoryTypes_22)
			|| (l.MemoryTypes_23 != r.MemoryTypes_23) || (l.MemoryTypes_24 != r.MemoryTypes_24) || (l.MemoryTypes_25 != r.MemoryTypes_25) || (l.MemoryTypes_26 != r.MemoryTypes_26)
			|| (l.MemoryTypes_27 != r.MemoryTypes_27) || (l.MemoryTypes_28 != r.MemoryTypes_28) || (l.MemoryTypes_29 != r.MemoryTypes_29) || (l.MemoryTypes_30 != r.MemoryTypes_30)
			|| (l.MemoryTypes_31 != r.MemoryTypes_31) || (l.MemoryHeapCount != r.MemoryHeapCount) || (l.MemoryHeaps_0 != r.MemoryHeaps_0) || (l.MemoryHeaps_1 != r.MemoryHeaps_1)
			|| (l.MemoryHeaps_2 != r.MemoryHeaps_2) || (l.MemoryHeaps_3 != r.MemoryHeaps_3) || (l.MemoryHeaps_4 != r.MemoryHeaps_4) || (l.MemoryHeaps_5 != r.MemoryHeaps_5)
			|| (l.MemoryHeaps_6 != r.MemoryHeaps_6) || (l.MemoryHeaps_7 != r.MemoryHeaps_7) || (l.MemoryHeaps_8 != r.MemoryHeaps_8) || (l.MemoryHeaps_9 != r.MemoryHeaps_9)
			|| (l.MemoryHeaps_10 != r.MemoryHeaps_10) || (l.MemoryHeaps_11 != r.MemoryHeaps_11) || (l.MemoryHeaps_12 != r.MemoryHeaps_12) || (l.MemoryHeaps_13 != r.MemoryHeaps_13)
			|| (l.MemoryHeaps_14 != r.MemoryHeaps_14) || (l.MemoryHeaps_15 != r.MemoryHeaps_15)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceMemoryProperties s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkMemoryAllocateInfo : IEquatable<VkMemoryAllocateInfo>
{
	public const VkStructureType TYPE = VkStructureType.MemoryAllocateInfo;

	public VkStructureType sType;
	public void* pNext;
	public ulong AllocationSize;
	public uint MemoryTypeIndex;

	public VkMemoryAllocateInfo(
		ulong allocationSize = default,
		uint memoryTypeIndex = default
	) {
		sType = TYPE;
		pNext = null;
		AllocationSize = allocationSize;
		MemoryTypeIndex = memoryTypeIndex;
	}

	public readonly override bool Equals(object? o) => (o is VkMemoryAllocateInfo s) && (this == s);
	readonly bool IEquatable<VkMemoryAllocateInfo>.Equals(VkMemoryAllocateInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ AllocationSize.GetHashCode() ^ MemoryTypeIndex.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkMemoryAllocateInfo l, in VkMemoryAllocateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.AllocationSize == r.AllocationSize) && (l.MemoryTypeIndex == r.MemoryTypeIndex)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkMemoryAllocateInfo l, in VkMemoryAllocateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.AllocationSize != r.AllocationSize) || (l.MemoryTypeIndex != r.MemoryTypeIndex)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkMemoryAllocateInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkMemoryRequirements : IEquatable<VkMemoryRequirements>
{
	public ulong Size;
	public ulong Alignment;
	public uint MemoryTypeBits;

	public VkMemoryRequirements(
		ulong size = default,
		ulong alignment = default,
		uint memoryTypeBits = default
	) {
		Size = size;
		Alignment = alignment;
		MemoryTypeBits = memoryTypeBits;
	}

	public readonly override bool Equals(object? o) => (o is VkMemoryRequirements s) && (this == s);
	readonly bool IEquatable<VkMemoryRequirements>.Equals(VkMemoryRequirements o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Size.GetHashCode() ^ Alignment.GetHashCode() ^ MemoryTypeBits.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkMemoryRequirements l, in VkMemoryRequirements r)
	{
		return
			(l.Size == r.Size) && (l.Alignment == r.Alignment) && (l.MemoryTypeBits == r.MemoryTypeBits)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkMemoryRequirements l, in VkMemoryRequirements r)
	{
		return
			(l.Size != r.Size) || (l.Alignment != r.Alignment) || (l.MemoryTypeBits != r.MemoryTypeBits)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkMemoryRequirements s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkSparseImageFormatProperties : IEquatable<VkSparseImageFormatProperties>
{
	public VkImageAspectFlags AspectMask;
	public VkExtent3D ImageGranularity;
	public VkSparseImageFormatFlags Flags;

	public VkSparseImageFormatProperties(
		VkImageAspectFlags aspectMask = default,
		VkExtent3D imageGranularity = default,
		VkSparseImageFormatFlags flags = default
	) {
		AspectMask = aspectMask;
		ImageGranularity = imageGranularity;
		Flags = flags;
	}

	public readonly override bool Equals(object? o) => (o is VkSparseImageFormatProperties s) && (this == s);
	readonly bool IEquatable<VkSparseImageFormatProperties>.Equals(VkSparseImageFormatProperties o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			AspectMask.GetHashCode() ^ ImageGranularity.GetHashCode() ^ Flags.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkSparseImageFormatProperties l, in VkSparseImageFormatProperties r)
	{
		return
			(l.AspectMask == r.AspectMask) && (l.ImageGranularity == r.ImageGranularity) && (l.Flags == r.Flags)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkSparseImageFormatProperties l, in VkSparseImageFormatProperties r)
	{
		return
			(l.AspectMask != r.AspectMask) || (l.ImageGranularity != r.ImageGranularity) || (l.Flags != r.Flags)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkSparseImageFormatProperties s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkSparseImageMemoryRequirements : IEquatable<VkSparseImageMemoryRequirements>
{
	public VkSparseImageFormatProperties FormatProperties;
	public uint ImageMipTailFirstLod;
	public ulong ImageMipTailSize;
	public ulong ImageMipTailOffset;
	public ulong ImageMipTailStride;

	public VkSparseImageMemoryRequirements(
		VkSparseImageFormatProperties formatProperties = default,
		uint imageMipTailFirstLod = default,
		ulong imageMipTailSize = default,
		ulong imageMipTailOffset = default,
		ulong imageMipTailStride = default
	) {
		FormatProperties = formatProperties;
		ImageMipTailFirstLod = imageMipTailFirstLod;
		ImageMipTailSize = imageMipTailSize;
		ImageMipTailOffset = imageMipTailOffset;
		ImageMipTailStride = imageMipTailStride;
	}

	public readonly override bool Equals(object? o) => (o is VkSparseImageMemoryRequirements s) && (this == s);
	readonly bool IEquatable<VkSparseImageMemoryRequirements>.Equals(VkSparseImageMemoryRequirements o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			FormatProperties.GetHashCode() ^ ImageMipTailFirstLod.GetHashCode() ^ ImageMipTailSize.GetHashCode() ^ ImageMipTailOffset.GetHashCode()
			^ ImageMipTailStride.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkSparseImageMemoryRequirements l, in VkSparseImageMemoryRequirements r)
	{
		return
			(l.FormatProperties == r.FormatProperties) && (l.ImageMipTailFirstLod == r.ImageMipTailFirstLod) && (l.ImageMipTailSize == r.ImageMipTailSize) && (l.ImageMipTailOffset == r.ImageMipTailOffset)
			&& (l.ImageMipTailStride == r.ImageMipTailStride)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkSparseImageMemoryRequirements l, in VkSparseImageMemoryRequirements r)
	{
		return
			(l.FormatProperties != r.FormatProperties) || (l.ImageMipTailFirstLod != r.ImageMipTailFirstLod) || (l.ImageMipTailSize != r.ImageMipTailSize) || (l.ImageMipTailOffset != r.ImageMipTailOffset)
			|| (l.ImageMipTailStride != r.ImageMipTailStride)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkSparseImageMemoryRequirements s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkMemoryType : IEquatable<VkMemoryType>
{
	public VkMemoryPropertyFlags PropertyFlags;
	public uint HeapIndex;

	public VkMemoryType(
		VkMemoryPropertyFlags propertyFlags = default,
		uint heapIndex = default
	) {
		PropertyFlags = propertyFlags;
		HeapIndex = heapIndex;
	}

	public readonly override bool Equals(object? o) => (o is VkMemoryType s) && (this == s);
	readonly bool IEquatable<VkMemoryType>.Equals(VkMemoryType o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			PropertyFlags.GetHashCode() ^ HeapIndex.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkMemoryType l, in VkMemoryType r)
	{
		return
			(l.PropertyFlags == r.PropertyFlags) && (l.HeapIndex == r.HeapIndex)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkMemoryType l, in VkMemoryType r)
	{
		return
			(l.PropertyFlags != r.PropertyFlags) || (l.HeapIndex != r.HeapIndex)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkMemoryType s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkMemoryHeap : IEquatable<VkMemoryHeap>
{
	public ulong Size;
	public VkMemoryHeapFlags Flags;

	public VkMemoryHeap(
		ulong size = default,
		VkMemoryHeapFlags flags = default
	) {
		Size = size;
		Flags = flags;
	}

	public readonly override bool Equals(object? o) => (o is VkMemoryHeap s) && (this == s);
	readonly bool IEquatable<VkMemoryHeap>.Equals(VkMemoryHeap o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Size.GetHashCode() ^ Flags.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkMemoryHeap l, in VkMemoryHeap r)
	{
		return
			(l.Size == r.Size) && (l.Flags == r.Flags)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkMemoryHeap l, in VkMemoryHeap r)
	{
		return
			(l.Size != r.Size) || (l.Flags != r.Flags)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkMemoryHeap s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkMappedMemoryRange : IEquatable<VkMappedMemoryRange>
{
	public const VkStructureType TYPE = VkStructureType.MappedMemoryRange;

	public VkStructureType sType;
	public void* pNext;
	public VulkanHandle<VkDeviceMemory> Memory;
	public ulong Offset;
	public ulong Size;

	public VkMappedMemoryRange(
		VulkanHandle<VkDeviceMemory> memory = default,
		ulong offset = default,
		ulong size = default
	) {
		sType = TYPE;
		pNext = null;
		Memory = memory;
		Offset = offset;
		Size = size;
	}

	public readonly override bool Equals(object? o) => (o is VkMappedMemoryRange s) && (this == s);
	readonly bool IEquatable<VkMappedMemoryRange>.Equals(VkMappedMemoryRange o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Memory.GetHashCode() ^ Offset.GetHashCode()
			^ Size.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkMappedMemoryRange l, in VkMappedMemoryRange r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Memory == r.Memory) && (l.Offset == r.Offset)
			&& (l.Size == r.Size)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkMappedMemoryRange l, in VkMappedMemoryRange r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Memory != r.Memory) || (l.Offset != r.Offset)
			|| (l.Size != r.Size)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkMappedMemoryRange s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkFormatProperties : IEquatable<VkFormatProperties>
{
	public VkFormatFeatureFlags LinearTilingFeatures;
	public VkFormatFeatureFlags OptimalTilingFeatures;
	public VkFormatFeatureFlags BufferFeatures;

	public VkFormatProperties(
		VkFormatFeatureFlags linearTilingFeatures = default,
		VkFormatFeatureFlags optimalTilingFeatures = default,
		VkFormatFeatureFlags bufferFeatures = default
	) {
		LinearTilingFeatures = linearTilingFeatures;
		OptimalTilingFeatures = optimalTilingFeatures;
		BufferFeatures = bufferFeatures;
	}

	public readonly override bool Equals(object? o) => (o is VkFormatProperties s) && (this == s);
	readonly bool IEquatable<VkFormatProperties>.Equals(VkFormatProperties o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			LinearTilingFeatures.GetHashCode() ^ OptimalTilingFeatures.GetHashCode() ^ BufferFeatures.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkFormatProperties l, in VkFormatProperties r)
	{
		return
			(l.LinearTilingFeatures == r.LinearTilingFeatures) && (l.OptimalTilingFeatures == r.OptimalTilingFeatures) && (l.BufferFeatures == r.BufferFeatures)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkFormatProperties l, in VkFormatProperties r)
	{
		return
			(l.LinearTilingFeatures != r.LinearTilingFeatures) || (l.OptimalTilingFeatures != r.OptimalTilingFeatures) || (l.BufferFeatures != r.BufferFeatures)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkFormatProperties s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkImageFormatProperties : IEquatable<VkImageFormatProperties>
{
	public VkExtent3D MaxExtent;
	public uint MaxMipLevels;
	public uint MaxArrayLayers;
	public VkSampleCountFlags SampleCounts;
	public ulong MaxResourceSize;

	public VkImageFormatProperties(
		VkExtent3D maxExtent = default,
		uint maxMipLevels = default,
		uint maxArrayLayers = default,
		VkSampleCountFlags sampleCounts = default,
		ulong maxResourceSize = default
	) {
		MaxExtent = maxExtent;
		MaxMipLevels = maxMipLevels;
		MaxArrayLayers = maxArrayLayers;
		SampleCounts = sampleCounts;
		MaxResourceSize = maxResourceSize;
	}

	public readonly override bool Equals(object? o) => (o is VkImageFormatProperties s) && (this == s);
	readonly bool IEquatable<VkImageFormatProperties>.Equals(VkImageFormatProperties o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			MaxExtent.GetHashCode() ^ MaxMipLevels.GetHashCode() ^ MaxArrayLayers.GetHashCode() ^ SampleCounts.GetHashCode()
			^ MaxResourceSize.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkImageFormatProperties l, in VkImageFormatProperties r)
	{
		return
			(l.MaxExtent == r.MaxExtent) && (l.MaxMipLevels == r.MaxMipLevels) && (l.MaxArrayLayers == r.MaxArrayLayers) && (l.SampleCounts == r.SampleCounts)
			&& (l.MaxResourceSize == r.MaxResourceSize)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkImageFormatProperties l, in VkImageFormatProperties r)
	{
		return
			(l.MaxExtent != r.MaxExtent) || (l.MaxMipLevels != r.MaxMipLevels) || (l.MaxArrayLayers != r.MaxArrayLayers) || (l.SampleCounts != r.SampleCounts)
			|| (l.MaxResourceSize != r.MaxResourceSize)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkImageFormatProperties s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDescriptorBufferInfo : IEquatable<VkDescriptorBufferInfo>
{
	public VulkanHandle<VkBuffer> Buffer;
	public ulong Offset;
	public ulong Range;

	public VkDescriptorBufferInfo(
		VulkanHandle<VkBuffer> buffer = default,
		ulong offset = default,
		ulong range = default
	) {
		Buffer = buffer;
		Offset = offset;
		Range = range;
	}

	public readonly override bool Equals(object? o) => (o is VkDescriptorBufferInfo s) && (this == s);
	readonly bool IEquatable<VkDescriptorBufferInfo>.Equals(VkDescriptorBufferInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Buffer.GetHashCode() ^ Offset.GetHashCode() ^ Range.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDescriptorBufferInfo l, in VkDescriptorBufferInfo r)
	{
		return
			(l.Buffer == r.Buffer) && (l.Offset == r.Offset) && (l.Range == r.Range)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDescriptorBufferInfo l, in VkDescriptorBufferInfo r)
	{
		return
			(l.Buffer != r.Buffer) || (l.Offset != r.Offset) || (l.Range != r.Range)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDescriptorBufferInfo s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDescriptorImageInfo : IEquatable<VkDescriptorImageInfo>
{
	public VulkanHandle<VkSampler> Sampler;
	public VulkanHandle<VkImageView> ImageView;
	public VkImageLayout ImageLayout;

	public VkDescriptorImageInfo(
		VulkanHandle<VkSampler> sampler = default,
		VulkanHandle<VkImageView> imageView = default,
		VkImageLayout imageLayout = default
	) {
		Sampler = sampler;
		ImageView = imageView;
		ImageLayout = imageLayout;
	}

	public readonly override bool Equals(object? o) => (o is VkDescriptorImageInfo s) && (this == s);
	readonly bool IEquatable<VkDescriptorImageInfo>.Equals(VkDescriptorImageInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Sampler.GetHashCode() ^ ImageView.GetHashCode() ^ ImageLayout.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDescriptorImageInfo l, in VkDescriptorImageInfo r)
	{
		return
			(l.Sampler == r.Sampler) && (l.ImageView == r.ImageView) && (l.ImageLayout == r.ImageLayout)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDescriptorImageInfo l, in VkDescriptorImageInfo r)
	{
		return
			(l.Sampler != r.Sampler) || (l.ImageView != r.ImageView) || (l.ImageLayout != r.ImageLayout)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDescriptorImageInfo s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkWriteDescriptorSet : IEquatable<VkWriteDescriptorSet>
{
	public const VkStructureType TYPE = VkStructureType.WriteDescriptorSet;

	public VkStructureType sType;
	public void* pNext;
	public VulkanHandle<VkDescriptorSet> DstSet;
	public uint DstBinding;
	public uint DstArrayElement;
	public uint DescriptorCount;
	public VkDescriptorType DescriptorType;
	public VkDescriptorImageInfo* ImageInfo;
	public VkDescriptorBufferInfo* BufferInfo;
	public VulkanHandle<VkBufferView>* TexelBufferView;

	public VkWriteDescriptorSet(
		VulkanHandle<VkDescriptorSet> dstSet = default,
		uint dstBinding = default,
		uint dstArrayElement = default,
		uint descriptorCount = default,
		VkDescriptorType descriptorType = default,
		VkDescriptorImageInfo* imageInfo = default,
		VkDescriptorBufferInfo* bufferInfo = default,
		VulkanHandle<VkBufferView>* texelBufferView = default
	) {
		sType = TYPE;
		pNext = null;
		DstSet = dstSet;
		DstBinding = dstBinding;
		DstArrayElement = dstArrayElement;
		DescriptorCount = descriptorCount;
		DescriptorType = descriptorType;
		ImageInfo = imageInfo;
		BufferInfo = bufferInfo;
		TexelBufferView = texelBufferView;
	}

	public readonly override bool Equals(object? o) => (o is VkWriteDescriptorSet s) && (this == s);
	readonly bool IEquatable<VkWriteDescriptorSet>.Equals(VkWriteDescriptorSet o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DstSet.GetHashCode() ^ DstBinding.GetHashCode()
			^ DstArrayElement.GetHashCode() ^ DescriptorCount.GetHashCode() ^ DescriptorType.GetHashCode() ^ ((ulong)ImageInfo).GetHashCode()
			^ ((ulong)BufferInfo).GetHashCode() ^ ((ulong)TexelBufferView).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkWriteDescriptorSet l, in VkWriteDescriptorSet r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DstSet == r.DstSet) && (l.DstBinding == r.DstBinding)
			&& (l.DstArrayElement == r.DstArrayElement) && (l.DescriptorCount == r.DescriptorCount) && (l.DescriptorType == r.DescriptorType) && (l.ImageInfo == r.ImageInfo)
			&& (l.BufferInfo == r.BufferInfo) && (l.TexelBufferView == r.TexelBufferView)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkWriteDescriptorSet l, in VkWriteDescriptorSet r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DstSet != r.DstSet) || (l.DstBinding != r.DstBinding)
			|| (l.DstArrayElement != r.DstArrayElement) || (l.DescriptorCount != r.DescriptorCount) || (l.DescriptorType != r.DescriptorType) || (l.ImageInfo != r.ImageInfo)
			|| (l.BufferInfo != r.BufferInfo) || (l.TexelBufferView != r.TexelBufferView)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkWriteDescriptorSet s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkCopyDescriptorSet : IEquatable<VkCopyDescriptorSet>
{
	public const VkStructureType TYPE = VkStructureType.CopyDescriptorSet;

	public VkStructureType sType;
	public void* pNext;
	public VulkanHandle<VkDescriptorSet> SrcSet;
	public uint SrcBinding;
	public uint SrcArrayElement;
	public VulkanHandle<VkDescriptorSet> DstSet;
	public uint DstBinding;
	public uint DstArrayElement;
	public uint DescriptorCount;

	public VkCopyDescriptorSet(
		VulkanHandle<VkDescriptorSet> srcSet = default,
		uint srcBinding = default,
		uint srcArrayElement = default,
		VulkanHandle<VkDescriptorSet> dstSet = default,
		uint dstBinding = default,
		uint dstArrayElement = default,
		uint descriptorCount = default
	) {
		sType = TYPE;
		pNext = null;
		SrcSet = srcSet;
		SrcBinding = srcBinding;
		SrcArrayElement = srcArrayElement;
		DstSet = dstSet;
		DstBinding = dstBinding;
		DstArrayElement = dstArrayElement;
		DescriptorCount = descriptorCount;
	}

	public readonly override bool Equals(object? o) => (o is VkCopyDescriptorSet s) && (this == s);
	readonly bool IEquatable<VkCopyDescriptorSet>.Equals(VkCopyDescriptorSet o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SrcSet.GetHashCode() ^ SrcBinding.GetHashCode()
			^ SrcArrayElement.GetHashCode() ^ DstSet.GetHashCode() ^ DstBinding.GetHashCode() ^ DstArrayElement.GetHashCode()
			^ DescriptorCount.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkCopyDescriptorSet l, in VkCopyDescriptorSet r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SrcSet == r.SrcSet) && (l.SrcBinding == r.SrcBinding)
			&& (l.SrcArrayElement == r.SrcArrayElement) && (l.DstSet == r.DstSet) && (l.DstBinding == r.DstBinding) && (l.DstArrayElement == r.DstArrayElement)
			&& (l.DescriptorCount == r.DescriptorCount)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkCopyDescriptorSet l, in VkCopyDescriptorSet r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SrcSet != r.SrcSet) || (l.SrcBinding != r.SrcBinding)
			|| (l.SrcArrayElement != r.SrcArrayElement) || (l.DstSet != r.DstSet) || (l.DstBinding != r.DstBinding) || (l.DstArrayElement != r.DstArrayElement)
			|| (l.DescriptorCount != r.DescriptorCount)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkCopyDescriptorSet s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkBufferCreateInfo : IEquatable<VkBufferCreateInfo>
{
	public const VkStructureType TYPE = VkStructureType.BufferCreateInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkBufferCreateFlags Flags;
	public ulong Size;
	public VkBufferUsageFlags Usage;
	public VkSharingMode SharingMode;
	public uint QueueFamilyIndexCount;
	public uint* QueueFamilyIndices;

	public VkBufferCreateInfo(
		VkBufferCreateFlags flags = default,
		ulong size = default,
		VkBufferUsageFlags usage = default,
		VkSharingMode sharingMode = default,
		uint queueFamilyIndexCount = default,
		uint* queueFamilyIndices = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		Size = size;
		Usage = usage;
		SharingMode = sharingMode;
		QueueFamilyIndexCount = queueFamilyIndexCount;
		QueueFamilyIndices = queueFamilyIndices;
	}

	public readonly override bool Equals(object? o) => (o is VkBufferCreateInfo s) && (this == s);
	readonly bool IEquatable<VkBufferCreateInfo>.Equals(VkBufferCreateInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ Size.GetHashCode()
			^ Usage.GetHashCode() ^ SharingMode.GetHashCode() ^ QueueFamilyIndexCount.GetHashCode() ^ ((ulong)QueueFamilyIndices).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkBufferCreateInfo l, in VkBufferCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.Size == r.Size)
			&& (l.Usage == r.Usage) && (l.SharingMode == r.SharingMode) && (l.QueueFamilyIndexCount == r.QueueFamilyIndexCount) && (l.QueueFamilyIndices == r.QueueFamilyIndices)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkBufferCreateInfo l, in VkBufferCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.Size != r.Size)
			|| (l.Usage != r.Usage) || (l.SharingMode != r.SharingMode) || (l.QueueFamilyIndexCount != r.QueueFamilyIndexCount) || (l.QueueFamilyIndices != r.QueueFamilyIndices)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkBufferCreateInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkBufferViewCreateInfo : IEquatable<VkBufferViewCreateInfo>
{
	public const VkStructureType TYPE = VkStructureType.BufferViewCreateInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkBufferViewCreateFlags Flags;
	public VulkanHandle<VkBuffer> Buffer;
	public VkFormat Format;
	public ulong Offset;
	public ulong Range;

	public VkBufferViewCreateInfo(
		VkBufferViewCreateFlags flags = default,
		VulkanHandle<VkBuffer> buffer = default,
		VkFormat format = default,
		ulong offset = default,
		ulong range = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		Buffer = buffer;
		Format = format;
		Offset = offset;
		Range = range;
	}

	public readonly override bool Equals(object? o) => (o is VkBufferViewCreateInfo s) && (this == s);
	readonly bool IEquatable<VkBufferViewCreateInfo>.Equals(VkBufferViewCreateInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ Buffer.GetHashCode()
			^ Format.GetHashCode() ^ Offset.GetHashCode() ^ Range.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkBufferViewCreateInfo l, in VkBufferViewCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.Buffer == r.Buffer)
			&& (l.Format == r.Format) && (l.Offset == r.Offset) && (l.Range == r.Range)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkBufferViewCreateInfo l, in VkBufferViewCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.Buffer != r.Buffer)
			|| (l.Format != r.Format) || (l.Offset != r.Offset) || (l.Range != r.Range)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkBufferViewCreateInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkImageSubresource : IEquatable<VkImageSubresource>
{
	public VkImageAspectFlags AspectMask;
	public uint MipLevel;
	public uint ArrayLayer;

	public VkImageSubresource(
		VkImageAspectFlags aspectMask = default,
		uint mipLevel = default,
		uint arrayLayer = default
	) {
		AspectMask = aspectMask;
		MipLevel = mipLevel;
		ArrayLayer = arrayLayer;
	}

	public readonly override bool Equals(object? o) => (o is VkImageSubresource s) && (this == s);
	readonly bool IEquatable<VkImageSubresource>.Equals(VkImageSubresource o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			AspectMask.GetHashCode() ^ MipLevel.GetHashCode() ^ ArrayLayer.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkImageSubresource l, in VkImageSubresource r)
	{
		return
			(l.AspectMask == r.AspectMask) && (l.MipLevel == r.MipLevel) && (l.ArrayLayer == r.ArrayLayer)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkImageSubresource l, in VkImageSubresource r)
	{
		return
			(l.AspectMask != r.AspectMask) || (l.MipLevel != r.MipLevel) || (l.ArrayLayer != r.ArrayLayer)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkImageSubresource s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkImageSubresourceLayers : IEquatable<VkImageSubresourceLayers>
{
	public VkImageAspectFlags AspectMask;
	public uint MipLevel;
	public uint BaseArrayLayer;
	public uint LayerCount;

	public VkImageSubresourceLayers(
		VkImageAspectFlags aspectMask = default,
		uint mipLevel = default,
		uint baseArrayLayer = default,
		uint layerCount = default
	) {
		AspectMask = aspectMask;
		MipLevel = mipLevel;
		BaseArrayLayer = baseArrayLayer;
		LayerCount = layerCount;
	}

	public readonly override bool Equals(object? o) => (o is VkImageSubresourceLayers s) && (this == s);
	readonly bool IEquatable<VkImageSubresourceLayers>.Equals(VkImageSubresourceLayers o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			AspectMask.GetHashCode() ^ MipLevel.GetHashCode() ^ BaseArrayLayer.GetHashCode() ^ LayerCount.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkImageSubresourceLayers l, in VkImageSubresourceLayers r)
	{
		return
			(l.AspectMask == r.AspectMask) && (l.MipLevel == r.MipLevel) && (l.BaseArrayLayer == r.BaseArrayLayer) && (l.LayerCount == r.LayerCount)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkImageSubresourceLayers l, in VkImageSubresourceLayers r)
	{
		return
			(l.AspectMask != r.AspectMask) || (l.MipLevel != r.MipLevel) || (l.BaseArrayLayer != r.BaseArrayLayer) || (l.LayerCount != r.LayerCount)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkImageSubresourceLayers s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkImageSubresourceRange : IEquatable<VkImageSubresourceRange>
{
	public VkImageAspectFlags AspectMask;
	public uint BaseMipLevel;
	public uint LevelCount;
	public uint BaseArrayLayer;
	public uint LayerCount;

	public VkImageSubresourceRange(
		VkImageAspectFlags aspectMask = default,
		uint baseMipLevel = default,
		uint levelCount = default,
		uint baseArrayLayer = default,
		uint layerCount = default
	) {
		AspectMask = aspectMask;
		BaseMipLevel = baseMipLevel;
		LevelCount = levelCount;
		BaseArrayLayer = baseArrayLayer;
		LayerCount = layerCount;
	}

	public readonly override bool Equals(object? o) => (o is VkImageSubresourceRange s) && (this == s);
	readonly bool IEquatable<VkImageSubresourceRange>.Equals(VkImageSubresourceRange o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			AspectMask.GetHashCode() ^ BaseMipLevel.GetHashCode() ^ LevelCount.GetHashCode() ^ BaseArrayLayer.GetHashCode()
			^ LayerCount.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkImageSubresourceRange l, in VkImageSubresourceRange r)
	{
		return
			(l.AspectMask == r.AspectMask) && (l.BaseMipLevel == r.BaseMipLevel) && (l.LevelCount == r.LevelCount) && (l.BaseArrayLayer == r.BaseArrayLayer)
			&& (l.LayerCount == r.LayerCount)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkImageSubresourceRange l, in VkImageSubresourceRange r)
	{
		return
			(l.AspectMask != r.AspectMask) || (l.BaseMipLevel != r.BaseMipLevel) || (l.LevelCount != r.LevelCount) || (l.BaseArrayLayer != r.BaseArrayLayer)
			|| (l.LayerCount != r.LayerCount)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkImageSubresourceRange s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkMemoryBarrier : IEquatable<VkMemoryBarrier>
{
	public const VkStructureType TYPE = VkStructureType.MemoryBarrier;

	public VkStructureType sType;
	public void* pNext;
	public VkAccessFlags SrcAccessMask;
	public VkAccessFlags DstAccessMask;

	public VkMemoryBarrier(
		VkAccessFlags srcAccessMask = default,
		VkAccessFlags dstAccessMask = default
	) {
		sType = TYPE;
		pNext = null;
		SrcAccessMask = srcAccessMask;
		DstAccessMask = dstAccessMask;
	}

	public readonly override bool Equals(object? o) => (o is VkMemoryBarrier s) && (this == s);
	readonly bool IEquatable<VkMemoryBarrier>.Equals(VkMemoryBarrier o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SrcAccessMask.GetHashCode() ^ DstAccessMask.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkMemoryBarrier l, in VkMemoryBarrier r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SrcAccessMask == r.SrcAccessMask) && (l.DstAccessMask == r.DstAccessMask)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkMemoryBarrier l, in VkMemoryBarrier r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SrcAccessMask != r.SrcAccessMask) || (l.DstAccessMask != r.DstAccessMask)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkMemoryBarrier s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkBufferMemoryBarrier : IEquatable<VkBufferMemoryBarrier>
{
	public const VkStructureType TYPE = VkStructureType.BufferMemoryBarrier;

	public VkStructureType sType;
	public void* pNext;
	public VkAccessFlags SrcAccessMask;
	public VkAccessFlags DstAccessMask;
	public uint SrcQueueFamilyIndex;
	public uint DstQueueFamilyIndex;
	public VulkanHandle<VkBuffer> Buffer;
	public ulong Offset;
	public ulong Size;

	public VkBufferMemoryBarrier(
		VkAccessFlags srcAccessMask = default,
		VkAccessFlags dstAccessMask = default,
		uint srcQueueFamilyIndex = default,
		uint dstQueueFamilyIndex = default,
		VulkanHandle<VkBuffer> buffer = default,
		ulong offset = default,
		ulong size = default
	) {
		sType = TYPE;
		pNext = null;
		SrcAccessMask = srcAccessMask;
		DstAccessMask = dstAccessMask;
		SrcQueueFamilyIndex = srcQueueFamilyIndex;
		DstQueueFamilyIndex = dstQueueFamilyIndex;
		Buffer = buffer;
		Offset = offset;
		Size = size;
	}

	public readonly override bool Equals(object? o) => (o is VkBufferMemoryBarrier s) && (this == s);
	readonly bool IEquatable<VkBufferMemoryBarrier>.Equals(VkBufferMemoryBarrier o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SrcAccessMask.GetHashCode() ^ DstAccessMask.GetHashCode()
			^ SrcQueueFamilyIndex.GetHashCode() ^ DstQueueFamilyIndex.GetHashCode() ^ Buffer.GetHashCode() ^ Offset.GetHashCode()
			^ Size.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkBufferMemoryBarrier l, in VkBufferMemoryBarrier r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SrcAccessMask == r.SrcAccessMask) && (l.DstAccessMask == r.DstAccessMask)
			&& (l.SrcQueueFamilyIndex == r.SrcQueueFamilyIndex) && (l.DstQueueFamilyIndex == r.DstQueueFamilyIndex) && (l.Buffer == r.Buffer) && (l.Offset == r.Offset)
			&& (l.Size == r.Size)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkBufferMemoryBarrier l, in VkBufferMemoryBarrier r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SrcAccessMask != r.SrcAccessMask) || (l.DstAccessMask != r.DstAccessMask)
			|| (l.SrcQueueFamilyIndex != r.SrcQueueFamilyIndex) || (l.DstQueueFamilyIndex != r.DstQueueFamilyIndex) || (l.Buffer != r.Buffer) || (l.Offset != r.Offset)
			|| (l.Size != r.Size)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkBufferMemoryBarrier s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkImageMemoryBarrier : IEquatable<VkImageMemoryBarrier>
{
	public const VkStructureType TYPE = VkStructureType.ImageMemoryBarrier;

	public VkStructureType sType;
	public void* pNext;
	public VkAccessFlags SrcAccessMask;
	public VkAccessFlags DstAccessMask;
	public VkImageLayout OldLayout;
	public VkImageLayout NewLayout;
	public uint SrcQueueFamilyIndex;
	public uint DstQueueFamilyIndex;
	public VulkanHandle<VkImage> Image;
	public VkImageSubresourceRange SubresourceRange;

	public VkImageMemoryBarrier(
		VkAccessFlags srcAccessMask = default,
		VkAccessFlags dstAccessMask = default,
		VkImageLayout oldLayout = default,
		VkImageLayout newLayout = default,
		uint srcQueueFamilyIndex = default,
		uint dstQueueFamilyIndex = default,
		VulkanHandle<VkImage> image = default,
		VkImageSubresourceRange subresourceRange = default
	) {
		sType = TYPE;
		pNext = null;
		SrcAccessMask = srcAccessMask;
		DstAccessMask = dstAccessMask;
		OldLayout = oldLayout;
		NewLayout = newLayout;
		SrcQueueFamilyIndex = srcQueueFamilyIndex;
		DstQueueFamilyIndex = dstQueueFamilyIndex;
		Image = image;
		SubresourceRange = subresourceRange;
	}

	public readonly override bool Equals(object? o) => (o is VkImageMemoryBarrier s) && (this == s);
	readonly bool IEquatable<VkImageMemoryBarrier>.Equals(VkImageMemoryBarrier o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SrcAccessMask.GetHashCode() ^ DstAccessMask.GetHashCode()
			^ OldLayout.GetHashCode() ^ NewLayout.GetHashCode() ^ SrcQueueFamilyIndex.GetHashCode() ^ DstQueueFamilyIndex.GetHashCode()
			^ Image.GetHashCode() ^ SubresourceRange.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkImageMemoryBarrier l, in VkImageMemoryBarrier r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SrcAccessMask == r.SrcAccessMask) && (l.DstAccessMask == r.DstAccessMask)
			&& (l.OldLayout == r.OldLayout) && (l.NewLayout == r.NewLayout) && (l.SrcQueueFamilyIndex == r.SrcQueueFamilyIndex) && (l.DstQueueFamilyIndex == r.DstQueueFamilyIndex)
			&& (l.Image == r.Image) && (l.SubresourceRange == r.SubresourceRange)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkImageMemoryBarrier l, in VkImageMemoryBarrier r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SrcAccessMask != r.SrcAccessMask) || (l.DstAccessMask != r.DstAccessMask)
			|| (l.OldLayout != r.OldLayout) || (l.NewLayout != r.NewLayout) || (l.SrcQueueFamilyIndex != r.SrcQueueFamilyIndex) || (l.DstQueueFamilyIndex != r.DstQueueFamilyIndex)
			|| (l.Image != r.Image) || (l.SubresourceRange != r.SubresourceRange)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkImageMemoryBarrier s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkImageCreateInfo : IEquatable<VkImageCreateInfo>
{
	public const VkStructureType TYPE = VkStructureType.ImageCreateInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkImageCreateFlags Flags;
	public VkImageType ImageType;
	public VkFormat Format;
	public VkExtent3D Extent;
	public uint MipLevels;
	public uint ArrayLayers;
	public VkSampleCountFlags Samples;
	public VkImageTiling Tiling;
	public VkImageUsageFlags Usage;
	public VkSharingMode SharingMode;
	public uint QueueFamilyIndexCount;
	public uint* QueueFamilyIndices;
	public VkImageLayout InitialLayout;

	public VkImageCreateInfo(
		VkImageCreateFlags flags = default,
		VkImageType imageType = default,
		VkFormat format = default,
		VkExtent3D extent = default,
		uint mipLevels = default,
		uint arrayLayers = default,
		VkSampleCountFlags samples = default,
		VkImageTiling tiling = default,
		VkImageUsageFlags usage = default,
		VkSharingMode sharingMode = default,
		uint queueFamilyIndexCount = default,
		uint* queueFamilyIndices = default,
		VkImageLayout initialLayout = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		ImageType = imageType;
		Format = format;
		Extent = extent;
		MipLevels = mipLevels;
		ArrayLayers = arrayLayers;
		Samples = samples;
		Tiling = tiling;
		Usage = usage;
		SharingMode = sharingMode;
		QueueFamilyIndexCount = queueFamilyIndexCount;
		QueueFamilyIndices = queueFamilyIndices;
		InitialLayout = initialLayout;
	}

	public readonly override bool Equals(object? o) => (o is VkImageCreateInfo s) && (this == s);
	readonly bool IEquatable<VkImageCreateInfo>.Equals(VkImageCreateInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ ImageType.GetHashCode()
			^ Format.GetHashCode() ^ Extent.GetHashCode() ^ MipLevels.GetHashCode() ^ ArrayLayers.GetHashCode()
			^ Samples.GetHashCode() ^ Tiling.GetHashCode() ^ Usage.GetHashCode() ^ SharingMode.GetHashCode()
			^ QueueFamilyIndexCount.GetHashCode() ^ ((ulong)QueueFamilyIndices).GetHashCode() ^ InitialLayout.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkImageCreateInfo l, in VkImageCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.ImageType == r.ImageType)
			&& (l.Format == r.Format) && (l.Extent == r.Extent) && (l.MipLevels == r.MipLevels) && (l.ArrayLayers == r.ArrayLayers)
			&& (l.Samples == r.Samples) && (l.Tiling == r.Tiling) && (l.Usage == r.Usage) && (l.SharingMode == r.SharingMode)
			&& (l.QueueFamilyIndexCount == r.QueueFamilyIndexCount) && (l.QueueFamilyIndices == r.QueueFamilyIndices) && (l.InitialLayout == r.InitialLayout)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkImageCreateInfo l, in VkImageCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.ImageType != r.ImageType)
			|| (l.Format != r.Format) || (l.Extent != r.Extent) || (l.MipLevels != r.MipLevels) || (l.ArrayLayers != r.ArrayLayers)
			|| (l.Samples != r.Samples) || (l.Tiling != r.Tiling) || (l.Usage != r.Usage) || (l.SharingMode != r.SharingMode)
			|| (l.QueueFamilyIndexCount != r.QueueFamilyIndexCount) || (l.QueueFamilyIndices != r.QueueFamilyIndices) || (l.InitialLayout != r.InitialLayout)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkImageCreateInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkSubresourceLayout : IEquatable<VkSubresourceLayout>
{
	public ulong Offset;
	public ulong Size;
	public ulong RowPitch;
	public ulong ArrayPitch;
	public ulong DepthPitch;

	public VkSubresourceLayout(
		ulong offset = default,
		ulong size = default,
		ulong rowPitch = default,
		ulong arrayPitch = default,
		ulong depthPitch = default
	) {
		Offset = offset;
		Size = size;
		RowPitch = rowPitch;
		ArrayPitch = arrayPitch;
		DepthPitch = depthPitch;
	}

	public readonly override bool Equals(object? o) => (o is VkSubresourceLayout s) && (this == s);
	readonly bool IEquatable<VkSubresourceLayout>.Equals(VkSubresourceLayout o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Offset.GetHashCode() ^ Size.GetHashCode() ^ RowPitch.GetHashCode() ^ ArrayPitch.GetHashCode()
			^ DepthPitch.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkSubresourceLayout l, in VkSubresourceLayout r)
	{
		return
			(l.Offset == r.Offset) && (l.Size == r.Size) && (l.RowPitch == r.RowPitch) && (l.ArrayPitch == r.ArrayPitch)
			&& (l.DepthPitch == r.DepthPitch)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkSubresourceLayout l, in VkSubresourceLayout r)
	{
		return
			(l.Offset != r.Offset) || (l.Size != r.Size) || (l.RowPitch != r.RowPitch) || (l.ArrayPitch != r.ArrayPitch)
			|| (l.DepthPitch != r.DepthPitch)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkSubresourceLayout s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkImageViewCreateInfo : IEquatable<VkImageViewCreateInfo>
{
	public const VkStructureType TYPE = VkStructureType.ImageViewCreateInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkImageViewCreateFlags Flags;
	public VulkanHandle<VkImage> Image;
	public VkImageViewType ViewType;
	public VkFormat Format;
	public VkComponentMapping Components;
	public VkImageSubresourceRange SubresourceRange;

	public VkImageViewCreateInfo(
		VkImageViewCreateFlags flags = default,
		VulkanHandle<VkImage> image = default,
		VkImageViewType viewType = default,
		VkFormat format = default,
		VkComponentMapping components = default,
		VkImageSubresourceRange subresourceRange = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		Image = image;
		ViewType = viewType;
		Format = format;
		Components = components;
		SubresourceRange = subresourceRange;
	}

	public readonly override bool Equals(object? o) => (o is VkImageViewCreateInfo s) && (this == s);
	readonly bool IEquatable<VkImageViewCreateInfo>.Equals(VkImageViewCreateInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ Image.GetHashCode()
			^ ViewType.GetHashCode() ^ Format.GetHashCode() ^ Components.GetHashCode() ^ SubresourceRange.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkImageViewCreateInfo l, in VkImageViewCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.Image == r.Image)
			&& (l.ViewType == r.ViewType) && (l.Format == r.Format) && (l.Components == r.Components) && (l.SubresourceRange == r.SubresourceRange)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkImageViewCreateInfo l, in VkImageViewCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.Image != r.Image)
			|| (l.ViewType != r.ViewType) || (l.Format != r.Format) || (l.Components != r.Components) || (l.SubresourceRange != r.SubresourceRange)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkImageViewCreateInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkBufferCopy : IEquatable<VkBufferCopy>
{
	public ulong SrcOffset;
	public ulong DstOffset;
	public ulong Size;

	public VkBufferCopy(
		ulong srcOffset = default,
		ulong dstOffset = default,
		ulong size = default
	) {
		SrcOffset = srcOffset;
		DstOffset = dstOffset;
		Size = size;
	}

	public readonly override bool Equals(object? o) => (o is VkBufferCopy s) && (this == s);
	readonly bool IEquatable<VkBufferCopy>.Equals(VkBufferCopy o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			SrcOffset.GetHashCode() ^ DstOffset.GetHashCode() ^ Size.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkBufferCopy l, in VkBufferCopy r)
	{
		return
			(l.SrcOffset == r.SrcOffset) && (l.DstOffset == r.DstOffset) && (l.Size == r.Size)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkBufferCopy l, in VkBufferCopy r)
	{
		return
			(l.SrcOffset != r.SrcOffset) || (l.DstOffset != r.DstOffset) || (l.Size != r.Size)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkBufferCopy s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkSparseMemoryBind : IEquatable<VkSparseMemoryBind>
{
	public ulong ResourceOffset;
	public ulong Size;
	public VulkanHandle<VkDeviceMemory> Memory;
	public ulong MemoryOffset;
	public VkSparseMemoryBindFlags Flags;

	public VkSparseMemoryBind(
		ulong resourceOffset = default,
		ulong size = default,
		VulkanHandle<VkDeviceMemory> memory = default,
		ulong memoryOffset = default,
		VkSparseMemoryBindFlags flags = default
	) {
		ResourceOffset = resourceOffset;
		Size = size;
		Memory = memory;
		MemoryOffset = memoryOffset;
		Flags = flags;
	}

	public readonly override bool Equals(object? o) => (o is VkSparseMemoryBind s) && (this == s);
	readonly bool IEquatable<VkSparseMemoryBind>.Equals(VkSparseMemoryBind o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			ResourceOffset.GetHashCode() ^ Size.GetHashCode() ^ Memory.GetHashCode() ^ MemoryOffset.GetHashCode()
			^ Flags.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkSparseMemoryBind l, in VkSparseMemoryBind r)
	{
		return
			(l.ResourceOffset == r.ResourceOffset) && (l.Size == r.Size) && (l.Memory == r.Memory) && (l.MemoryOffset == r.MemoryOffset)
			&& (l.Flags == r.Flags)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkSparseMemoryBind l, in VkSparseMemoryBind r)
	{
		return
			(l.ResourceOffset != r.ResourceOffset) || (l.Size != r.Size) || (l.Memory != r.Memory) || (l.MemoryOffset != r.MemoryOffset)
			|| (l.Flags != r.Flags)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkSparseMemoryBind s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkSparseImageMemoryBind : IEquatable<VkSparseImageMemoryBind>
{
	public VkImageSubresource Subresource;
	public VkOffset3D Offset;
	public VkExtent3D Extent;
	public VulkanHandle<VkDeviceMemory> Memory;
	public ulong MemoryOffset;
	public VkSparseMemoryBindFlags Flags;

	public VkSparseImageMemoryBind(
		VkImageSubresource subresource = default,
		VkOffset3D offset = default,
		VkExtent3D extent = default,
		VulkanHandle<VkDeviceMemory> memory = default,
		ulong memoryOffset = default,
		VkSparseMemoryBindFlags flags = default
	) {
		Subresource = subresource;
		Offset = offset;
		Extent = extent;
		Memory = memory;
		MemoryOffset = memoryOffset;
		Flags = flags;
	}

	public readonly override bool Equals(object? o) => (o is VkSparseImageMemoryBind s) && (this == s);
	readonly bool IEquatable<VkSparseImageMemoryBind>.Equals(VkSparseImageMemoryBind o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Subresource.GetHashCode() ^ Offset.GetHashCode() ^ Extent.GetHashCode() ^ Memory.GetHashCode()
			^ MemoryOffset.GetHashCode() ^ Flags.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkSparseImageMemoryBind l, in VkSparseImageMemoryBind r)
	{
		return
			(l.Subresource == r.Subresource) && (l.Offset == r.Offset) && (l.Extent == r.Extent) && (l.Memory == r.Memory)
			&& (l.MemoryOffset == r.MemoryOffset) && (l.Flags == r.Flags)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkSparseImageMemoryBind l, in VkSparseImageMemoryBind r)
	{
		return
			(l.Subresource != r.Subresource) || (l.Offset != r.Offset) || (l.Extent != r.Extent) || (l.Memory != r.Memory)
			|| (l.MemoryOffset != r.MemoryOffset) || (l.Flags != r.Flags)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkSparseImageMemoryBind s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkSparseBufferMemoryBindInfo : IEquatable<VkSparseBufferMemoryBindInfo>
{
	public VulkanHandle<VkBuffer> Buffer;
	public uint BindCount;
	public VkSparseMemoryBind* Binds;

	public VkSparseBufferMemoryBindInfo(
		VulkanHandle<VkBuffer> buffer = default,
		uint bindCount = default,
		VkSparseMemoryBind* binds = default
	) {
		Buffer = buffer;
		BindCount = bindCount;
		Binds = binds;
	}

	public readonly override bool Equals(object? o) => (o is VkSparseBufferMemoryBindInfo s) && (this == s);
	readonly bool IEquatable<VkSparseBufferMemoryBindInfo>.Equals(VkSparseBufferMemoryBindInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Buffer.GetHashCode() ^ BindCount.GetHashCode() ^ ((ulong)Binds).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkSparseBufferMemoryBindInfo l, in VkSparseBufferMemoryBindInfo r)
	{
		return
			(l.Buffer == r.Buffer) && (l.BindCount == r.BindCount) && (l.Binds == r.Binds)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkSparseBufferMemoryBindInfo l, in VkSparseBufferMemoryBindInfo r)
	{
		return
			(l.Buffer != r.Buffer) || (l.BindCount != r.BindCount) || (l.Binds != r.Binds)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkSparseBufferMemoryBindInfo s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkSparseImageOpaqueMemoryBindInfo : IEquatable<VkSparseImageOpaqueMemoryBindInfo>
{
	public VulkanHandle<VkImage> Image;
	public uint BindCount;
	public VkSparseMemoryBind* Binds;

	public VkSparseImageOpaqueMemoryBindInfo(
		VulkanHandle<VkImage> image = default,
		uint bindCount = default,
		VkSparseMemoryBind* binds = default
	) {
		Image = image;
		BindCount = bindCount;
		Binds = binds;
	}

	public readonly override bool Equals(object? o) => (o is VkSparseImageOpaqueMemoryBindInfo s) && (this == s);
	readonly bool IEquatable<VkSparseImageOpaqueMemoryBindInfo>.Equals(VkSparseImageOpaqueMemoryBindInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Image.GetHashCode() ^ BindCount.GetHashCode() ^ ((ulong)Binds).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkSparseImageOpaqueMemoryBindInfo l, in VkSparseImageOpaqueMemoryBindInfo r)
	{
		return
			(l.Image == r.Image) && (l.BindCount == r.BindCount) && (l.Binds == r.Binds)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkSparseImageOpaqueMemoryBindInfo l, in VkSparseImageOpaqueMemoryBindInfo r)
	{
		return
			(l.Image != r.Image) || (l.BindCount != r.BindCount) || (l.Binds != r.Binds)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkSparseImageOpaqueMemoryBindInfo s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkSparseImageMemoryBindInfo : IEquatable<VkSparseImageMemoryBindInfo>
{
	public VulkanHandle<VkImage> Image;
	public uint BindCount;
	public VkSparseImageMemoryBind* Binds;

	public VkSparseImageMemoryBindInfo(
		VulkanHandle<VkImage> image = default,
		uint bindCount = default,
		VkSparseImageMemoryBind* binds = default
	) {
		Image = image;
		BindCount = bindCount;
		Binds = binds;
	}

	public readonly override bool Equals(object? o) => (o is VkSparseImageMemoryBindInfo s) && (this == s);
	readonly bool IEquatable<VkSparseImageMemoryBindInfo>.Equals(VkSparseImageMemoryBindInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Image.GetHashCode() ^ BindCount.GetHashCode() ^ ((ulong)Binds).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkSparseImageMemoryBindInfo l, in VkSparseImageMemoryBindInfo r)
	{
		return
			(l.Image == r.Image) && (l.BindCount == r.BindCount) && (l.Binds == r.Binds)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkSparseImageMemoryBindInfo l, in VkSparseImageMemoryBindInfo r)
	{
		return
			(l.Image != r.Image) || (l.BindCount != r.BindCount) || (l.Binds != r.Binds)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkSparseImageMemoryBindInfo s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkBindSparseInfo : IEquatable<VkBindSparseInfo>
{
	public const VkStructureType TYPE = VkStructureType.BindSparseInfo;

	public VkStructureType sType;
	public void* pNext;
	public uint WaitSemaphoreCount;
	public VulkanHandle<VkSemaphore>* WaitSemaphores;
	public uint BufferBindCount;
	public VkSparseBufferMemoryBindInfo* BufferBinds;
	public uint ImageOpaqueBindCount;
	public VkSparseImageOpaqueMemoryBindInfo* ImageOpaqueBinds;
	public uint ImageBindCount;
	public VkSparseImageMemoryBindInfo* ImageBinds;
	public uint SignalSemaphoreCount;
	public VulkanHandle<VkSemaphore>* SignalSemaphores;

	public VkBindSparseInfo(
		uint waitSemaphoreCount = default,
		VulkanHandle<VkSemaphore>* waitSemaphores = default,
		uint bufferBindCount = default,
		VkSparseBufferMemoryBindInfo* bufferBinds = default,
		uint imageOpaqueBindCount = default,
		VkSparseImageOpaqueMemoryBindInfo* imageOpaqueBinds = default,
		uint imageBindCount = default,
		VkSparseImageMemoryBindInfo* imageBinds = default,
		uint signalSemaphoreCount = default,
		VulkanHandle<VkSemaphore>* signalSemaphores = default
	) {
		sType = TYPE;
		pNext = null;
		WaitSemaphoreCount = waitSemaphoreCount;
		WaitSemaphores = waitSemaphores;
		BufferBindCount = bufferBindCount;
		BufferBinds = bufferBinds;
		ImageOpaqueBindCount = imageOpaqueBindCount;
		ImageOpaqueBinds = imageOpaqueBinds;
		ImageBindCount = imageBindCount;
		ImageBinds = imageBinds;
		SignalSemaphoreCount = signalSemaphoreCount;
		SignalSemaphores = signalSemaphores;
	}

	public readonly override bool Equals(object? o) => (o is VkBindSparseInfo s) && (this == s);
	readonly bool IEquatable<VkBindSparseInfo>.Equals(VkBindSparseInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ WaitSemaphoreCount.GetHashCode() ^ ((ulong)WaitSemaphores).GetHashCode()
			^ BufferBindCount.GetHashCode() ^ ((ulong)BufferBinds).GetHashCode() ^ ImageOpaqueBindCount.GetHashCode() ^ ((ulong)ImageOpaqueBinds).GetHashCode()
			^ ImageBindCount.GetHashCode() ^ ((ulong)ImageBinds).GetHashCode() ^ SignalSemaphoreCount.GetHashCode() ^ ((ulong)SignalSemaphores).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkBindSparseInfo l, in VkBindSparseInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.WaitSemaphoreCount == r.WaitSemaphoreCount) && (l.WaitSemaphores == r.WaitSemaphores)
			&& (l.BufferBindCount == r.BufferBindCount) && (l.BufferBinds == r.BufferBinds) && (l.ImageOpaqueBindCount == r.ImageOpaqueBindCount) && (l.ImageOpaqueBinds == r.ImageOpaqueBinds)
			&& (l.ImageBindCount == r.ImageBindCount) && (l.ImageBinds == r.ImageBinds) && (l.SignalSemaphoreCount == r.SignalSemaphoreCount) && (l.SignalSemaphores == r.SignalSemaphores)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkBindSparseInfo l, in VkBindSparseInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.WaitSemaphoreCount != r.WaitSemaphoreCount) || (l.WaitSemaphores != r.WaitSemaphores)
			|| (l.BufferBindCount != r.BufferBindCount) || (l.BufferBinds != r.BufferBinds) || (l.ImageOpaqueBindCount != r.ImageOpaqueBindCount) || (l.ImageOpaqueBinds != r.ImageOpaqueBinds)
			|| (l.ImageBindCount != r.ImageBindCount) || (l.ImageBinds != r.ImageBinds) || (l.SignalSemaphoreCount != r.SignalSemaphoreCount) || (l.SignalSemaphores != r.SignalSemaphores)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkBindSparseInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkImageCopy : IEquatable<VkImageCopy>
{
	public VkImageSubresourceLayers SrcSubresource;
	public VkOffset3D SrcOffset;
	public VkImageSubresourceLayers DstSubresource;
	public VkOffset3D DstOffset;
	public VkExtent3D Extent;

	public VkImageCopy(
		VkImageSubresourceLayers srcSubresource = default,
		VkOffset3D srcOffset = default,
		VkImageSubresourceLayers dstSubresource = default,
		VkOffset3D dstOffset = default,
		VkExtent3D extent = default
	) {
		SrcSubresource = srcSubresource;
		SrcOffset = srcOffset;
		DstSubresource = dstSubresource;
		DstOffset = dstOffset;
		Extent = extent;
	}

	public readonly override bool Equals(object? o) => (o is VkImageCopy s) && (this == s);
	readonly bool IEquatable<VkImageCopy>.Equals(VkImageCopy o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			SrcSubresource.GetHashCode() ^ SrcOffset.GetHashCode() ^ DstSubresource.GetHashCode() ^ DstOffset.GetHashCode()
			^ Extent.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkImageCopy l, in VkImageCopy r)
	{
		return
			(l.SrcSubresource == r.SrcSubresource) && (l.SrcOffset == r.SrcOffset) && (l.DstSubresource == r.DstSubresource) && (l.DstOffset == r.DstOffset)
			&& (l.Extent == r.Extent)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkImageCopy l, in VkImageCopy r)
	{
		return
			(l.SrcSubresource != r.SrcSubresource) || (l.SrcOffset != r.SrcOffset) || (l.DstSubresource != r.DstSubresource) || (l.DstOffset != r.DstOffset)
			|| (l.Extent != r.Extent)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkImageCopy s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkImageBlit : IEquatable<VkImageBlit>
{
	public VkImageSubresourceLayers SrcSubresource;
	public VkOffset3D SrcOffsets_0;
	public VkOffset3D SrcOffsets_1;
	public VkImageSubresourceLayers DstSubresource;
	public VkOffset3D DstOffsets_0;
	public VkOffset3D DstOffsets_1;

	public VkImageBlit(
		VkImageSubresourceLayers srcSubresource = default,
		VkOffset3D srcOffsets_0 = default,
		VkOffset3D srcOffsets_1 = default,
		VkImageSubresourceLayers dstSubresource = default,
		VkOffset3D dstOffsets_0 = default,
		VkOffset3D dstOffsets_1 = default
	) {
		SrcSubresource = srcSubresource;
		SrcOffsets_0 = srcOffsets_0;
		SrcOffsets_1 = srcOffsets_1;
		DstSubresource = dstSubresource;
		DstOffsets_0 = dstOffsets_0;
		DstOffsets_1 = dstOffsets_1;
	}

	public readonly override bool Equals(object? o) => (o is VkImageBlit s) && (this == s);
	readonly bool IEquatable<VkImageBlit>.Equals(VkImageBlit o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			SrcSubresource.GetHashCode() ^ SrcOffsets_0.GetHashCode() ^ SrcOffsets_1.GetHashCode() ^ DstSubresource.GetHashCode()
			^ DstOffsets_0.GetHashCode() ^ DstOffsets_1.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkImageBlit l, in VkImageBlit r)
	{
		return
			(l.SrcSubresource == r.SrcSubresource) && (l.SrcOffsets_0 == r.SrcOffsets_0) && (l.SrcOffsets_1 == r.SrcOffsets_1) && (l.DstSubresource == r.DstSubresource)
			&& (l.DstOffsets_0 == r.DstOffsets_0) && (l.DstOffsets_1 == r.DstOffsets_1)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkImageBlit l, in VkImageBlit r)
	{
		return
			(l.SrcSubresource != r.SrcSubresource) || (l.SrcOffsets_0 != r.SrcOffsets_0) || (l.SrcOffsets_1 != r.SrcOffsets_1) || (l.DstSubresource != r.DstSubresource)
			|| (l.DstOffsets_0 != r.DstOffsets_0) || (l.DstOffsets_1 != r.DstOffsets_1)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkImageBlit s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkBufferImageCopy : IEquatable<VkBufferImageCopy>
{
	public ulong BufferOffset;
	public uint BufferRowLength;
	public uint BufferImageHeight;
	public VkImageSubresourceLayers ImageSubresource;
	public VkOffset3D ImageOffset;
	public VkExtent3D ImageExtent;

	public VkBufferImageCopy(
		ulong bufferOffset = default,
		uint bufferRowLength = default,
		uint bufferImageHeight = default,
		VkImageSubresourceLayers imageSubresource = default,
		VkOffset3D imageOffset = default,
		VkExtent3D imageExtent = default
	) {
		BufferOffset = bufferOffset;
		BufferRowLength = bufferRowLength;
		BufferImageHeight = bufferImageHeight;
		ImageSubresource = imageSubresource;
		ImageOffset = imageOffset;
		ImageExtent = imageExtent;
	}

	public readonly override bool Equals(object? o) => (o is VkBufferImageCopy s) && (this == s);
	readonly bool IEquatable<VkBufferImageCopy>.Equals(VkBufferImageCopy o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			BufferOffset.GetHashCode() ^ BufferRowLength.GetHashCode() ^ BufferImageHeight.GetHashCode() ^ ImageSubresource.GetHashCode()
			^ ImageOffset.GetHashCode() ^ ImageExtent.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkBufferImageCopy l, in VkBufferImageCopy r)
	{
		return
			(l.BufferOffset == r.BufferOffset) && (l.BufferRowLength == r.BufferRowLength) && (l.BufferImageHeight == r.BufferImageHeight) && (l.ImageSubresource == r.ImageSubresource)
			&& (l.ImageOffset == r.ImageOffset) && (l.ImageExtent == r.ImageExtent)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkBufferImageCopy l, in VkBufferImageCopy r)
	{
		return
			(l.BufferOffset != r.BufferOffset) || (l.BufferRowLength != r.BufferRowLength) || (l.BufferImageHeight != r.BufferImageHeight) || (l.ImageSubresource != r.ImageSubresource)
			|| (l.ImageOffset != r.ImageOffset) || (l.ImageExtent != r.ImageExtent)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkBufferImageCopy s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkImageResolve : IEquatable<VkImageResolve>
{
	public VkImageSubresourceLayers SrcSubresource;
	public VkOffset3D SrcOffset;
	public VkImageSubresourceLayers DstSubresource;
	public VkOffset3D DstOffset;
	public VkExtent3D Extent;

	public VkImageResolve(
		VkImageSubresourceLayers srcSubresource = default,
		VkOffset3D srcOffset = default,
		VkImageSubresourceLayers dstSubresource = default,
		VkOffset3D dstOffset = default,
		VkExtent3D extent = default
	) {
		SrcSubresource = srcSubresource;
		SrcOffset = srcOffset;
		DstSubresource = dstSubresource;
		DstOffset = dstOffset;
		Extent = extent;
	}

	public readonly override bool Equals(object? o) => (o is VkImageResolve s) && (this == s);
	readonly bool IEquatable<VkImageResolve>.Equals(VkImageResolve o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			SrcSubresource.GetHashCode() ^ SrcOffset.GetHashCode() ^ DstSubresource.GetHashCode() ^ DstOffset.GetHashCode()
			^ Extent.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkImageResolve l, in VkImageResolve r)
	{
		return
			(l.SrcSubresource == r.SrcSubresource) && (l.SrcOffset == r.SrcOffset) && (l.DstSubresource == r.DstSubresource) && (l.DstOffset == r.DstOffset)
			&& (l.Extent == r.Extent)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkImageResolve l, in VkImageResolve r)
	{
		return
			(l.SrcSubresource != r.SrcSubresource) || (l.SrcOffset != r.SrcOffset) || (l.DstSubresource != r.DstSubresource) || (l.DstOffset != r.DstOffset)
			|| (l.Extent != r.Extent)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkImageResolve s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkShaderModuleCreateInfo : IEquatable<VkShaderModuleCreateInfo>
{
	public const VkStructureType TYPE = VkStructureType.ShaderModuleCreateInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkShaderModuleCreateFlags Flags;
	public ulong CodeSize;
	public uint* Code;

	public VkShaderModuleCreateInfo(
		VkShaderModuleCreateFlags flags = default,
		ulong codeSize = default,
		uint* code = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		CodeSize = codeSize;
		Code = code;
	}

	public readonly override bool Equals(object? o) => (o is VkShaderModuleCreateInfo s) && (this == s);
	readonly bool IEquatable<VkShaderModuleCreateInfo>.Equals(VkShaderModuleCreateInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ CodeSize.GetHashCode()
			^ ((ulong)Code).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkShaderModuleCreateInfo l, in VkShaderModuleCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.CodeSize == r.CodeSize)
			&& (l.Code == r.Code)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkShaderModuleCreateInfo l, in VkShaderModuleCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.CodeSize != r.CodeSize)
			|| (l.Code != r.Code)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkShaderModuleCreateInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDescriptorSetLayoutBinding : IEquatable<VkDescriptorSetLayoutBinding>
{
	public uint Binding;
	public VkDescriptorType DescriptorType;
	public uint DescriptorCount;
	public VkShaderStageFlags StageFlags;
	public VulkanHandle<VkSampler>* ImmutableSamplers;

	public VkDescriptorSetLayoutBinding(
		uint binding = default,
		VkDescriptorType descriptorType = default,
		uint descriptorCount = default,
		VkShaderStageFlags stageFlags = default,
		VulkanHandle<VkSampler>* immutableSamplers = default
	) {
		Binding = binding;
		DescriptorType = descriptorType;
		DescriptorCount = descriptorCount;
		StageFlags = stageFlags;
		ImmutableSamplers = immutableSamplers;
	}

	public readonly override bool Equals(object? o) => (o is VkDescriptorSetLayoutBinding s) && (this == s);
	readonly bool IEquatable<VkDescriptorSetLayoutBinding>.Equals(VkDescriptorSetLayoutBinding o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Binding.GetHashCode() ^ DescriptorType.GetHashCode() ^ DescriptorCount.GetHashCode() ^ StageFlags.GetHashCode()
			^ ((ulong)ImmutableSamplers).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDescriptorSetLayoutBinding l, in VkDescriptorSetLayoutBinding r)
	{
		return
			(l.Binding == r.Binding) && (l.DescriptorType == r.DescriptorType) && (l.DescriptorCount == r.DescriptorCount) && (l.StageFlags == r.StageFlags)
			&& (l.ImmutableSamplers == r.ImmutableSamplers)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDescriptorSetLayoutBinding l, in VkDescriptorSetLayoutBinding r)
	{
		return
			(l.Binding != r.Binding) || (l.DescriptorType != r.DescriptorType) || (l.DescriptorCount != r.DescriptorCount) || (l.StageFlags != r.StageFlags)
			|| (l.ImmutableSamplers != r.ImmutableSamplers)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDescriptorSetLayoutBinding s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDescriptorSetLayoutCreateInfo : IEquatable<VkDescriptorSetLayoutCreateInfo>
{
	public const VkStructureType TYPE = VkStructureType.DescriptorSetLayoutCreateInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkDescriptorSetLayoutCreateFlags Flags;
	public uint BindingCount;
	public VkDescriptorSetLayoutBinding* Bindings;

	public VkDescriptorSetLayoutCreateInfo(
		VkDescriptorSetLayoutCreateFlags flags = default,
		uint bindingCount = default,
		VkDescriptorSetLayoutBinding* bindings = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		BindingCount = bindingCount;
		Bindings = bindings;
	}

	public readonly override bool Equals(object? o) => (o is VkDescriptorSetLayoutCreateInfo s) && (this == s);
	readonly bool IEquatable<VkDescriptorSetLayoutCreateInfo>.Equals(VkDescriptorSetLayoutCreateInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ BindingCount.GetHashCode()
			^ ((ulong)Bindings).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDescriptorSetLayoutCreateInfo l, in VkDescriptorSetLayoutCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.BindingCount == r.BindingCount)
			&& (l.Bindings == r.Bindings)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDescriptorSetLayoutCreateInfo l, in VkDescriptorSetLayoutCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.BindingCount != r.BindingCount)
			|| (l.Bindings != r.Bindings)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDescriptorSetLayoutCreateInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDescriptorPoolSize : IEquatable<VkDescriptorPoolSize>
{
	public VkDescriptorType Type;
	public uint DescriptorCount;

	public VkDescriptorPoolSize(
		VkDescriptorType type = default,
		uint descriptorCount = default
	) {
		Type = type;
		DescriptorCount = descriptorCount;
	}

	public readonly override bool Equals(object? o) => (o is VkDescriptorPoolSize s) && (this == s);
	readonly bool IEquatable<VkDescriptorPoolSize>.Equals(VkDescriptorPoolSize o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Type.GetHashCode() ^ DescriptorCount.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDescriptorPoolSize l, in VkDescriptorPoolSize r)
	{
		return
			(l.Type == r.Type) && (l.DescriptorCount == r.DescriptorCount)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDescriptorPoolSize l, in VkDescriptorPoolSize r)
	{
		return
			(l.Type != r.Type) || (l.DescriptorCount != r.DescriptorCount)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDescriptorPoolSize s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDescriptorPoolCreateInfo : IEquatable<VkDescriptorPoolCreateInfo>
{
	public const VkStructureType TYPE = VkStructureType.DescriptorPoolCreateInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkDescriptorPoolCreateFlags Flags;
	public uint MaxSets;
	public uint PoolSizeCount;
	public VkDescriptorPoolSize* PoolSizes;

	public VkDescriptorPoolCreateInfo(
		VkDescriptorPoolCreateFlags flags = default,
		uint maxSets = default,
		uint poolSizeCount = default,
		VkDescriptorPoolSize* poolSizes = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		MaxSets = maxSets;
		PoolSizeCount = poolSizeCount;
		PoolSizes = poolSizes;
	}

	public readonly override bool Equals(object? o) => (o is VkDescriptorPoolCreateInfo s) && (this == s);
	readonly bool IEquatable<VkDescriptorPoolCreateInfo>.Equals(VkDescriptorPoolCreateInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ MaxSets.GetHashCode()
			^ PoolSizeCount.GetHashCode() ^ ((ulong)PoolSizes).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDescriptorPoolCreateInfo l, in VkDescriptorPoolCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.MaxSets == r.MaxSets)
			&& (l.PoolSizeCount == r.PoolSizeCount) && (l.PoolSizes == r.PoolSizes)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDescriptorPoolCreateInfo l, in VkDescriptorPoolCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.MaxSets != r.MaxSets)
			|| (l.PoolSizeCount != r.PoolSizeCount) || (l.PoolSizes != r.PoolSizes)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDescriptorPoolCreateInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDescriptorSetAllocateInfo : IEquatable<VkDescriptorSetAllocateInfo>
{
	public const VkStructureType TYPE = VkStructureType.DescriptorSetAllocateInfo;

	public VkStructureType sType;
	public void* pNext;
	public VulkanHandle<VkDescriptorPool> DescriptorPool;
	public uint DescriptorSetCount;
	public VulkanHandle<VkDescriptorSetLayout>* SetLayouts;

	public VkDescriptorSetAllocateInfo(
		VulkanHandle<VkDescriptorPool> descriptorPool = default,
		uint descriptorSetCount = default,
		VulkanHandle<VkDescriptorSetLayout>* setLayouts = default
	) {
		sType = TYPE;
		pNext = null;
		DescriptorPool = descriptorPool;
		DescriptorSetCount = descriptorSetCount;
		SetLayouts = setLayouts;
	}

	public readonly override bool Equals(object? o) => (o is VkDescriptorSetAllocateInfo s) && (this == s);
	readonly bool IEquatable<VkDescriptorSetAllocateInfo>.Equals(VkDescriptorSetAllocateInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DescriptorPool.GetHashCode() ^ DescriptorSetCount.GetHashCode()
			^ ((ulong)SetLayouts).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDescriptorSetAllocateInfo l, in VkDescriptorSetAllocateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DescriptorPool == r.DescriptorPool) && (l.DescriptorSetCount == r.DescriptorSetCount)
			&& (l.SetLayouts == r.SetLayouts)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDescriptorSetAllocateInfo l, in VkDescriptorSetAllocateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DescriptorPool != r.DescriptorPool) || (l.DescriptorSetCount != r.DescriptorSetCount)
			|| (l.SetLayouts != r.SetLayouts)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDescriptorSetAllocateInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkSpecializationMapEntry : IEquatable<VkSpecializationMapEntry>
{
	public uint ConstantID;
	public uint Offset;
	public ulong Size;

	public VkSpecializationMapEntry(
		uint constantID = default,
		uint offset = default,
		ulong size = default
	) {
		ConstantID = constantID;
		Offset = offset;
		Size = size;
	}

	public readonly override bool Equals(object? o) => (o is VkSpecializationMapEntry s) && (this == s);
	readonly bool IEquatable<VkSpecializationMapEntry>.Equals(VkSpecializationMapEntry o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			ConstantID.GetHashCode() ^ Offset.GetHashCode() ^ Size.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkSpecializationMapEntry l, in VkSpecializationMapEntry r)
	{
		return
			(l.ConstantID == r.ConstantID) && (l.Offset == r.Offset) && (l.Size == r.Size)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkSpecializationMapEntry l, in VkSpecializationMapEntry r)
	{
		return
			(l.ConstantID != r.ConstantID) || (l.Offset != r.Offset) || (l.Size != r.Size)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkSpecializationMapEntry s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkSpecializationInfo : IEquatable<VkSpecializationInfo>
{
	public uint MapEntryCount;
	public VkSpecializationMapEntry* MapEntries;
	public ulong DataSize;
	public void* Data;

	public VkSpecializationInfo(
		uint mapEntryCount = default,
		VkSpecializationMapEntry* mapEntries = default,
		ulong dataSize = default,
		void* data = default
	) {
		MapEntryCount = mapEntryCount;
		MapEntries = mapEntries;
		DataSize = dataSize;
		Data = data;
	}

	public readonly override bool Equals(object? o) => (o is VkSpecializationInfo s) && (this == s);
	readonly bool IEquatable<VkSpecializationInfo>.Equals(VkSpecializationInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			MapEntryCount.GetHashCode() ^ ((ulong)MapEntries).GetHashCode() ^ DataSize.GetHashCode() ^ ((ulong)Data).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkSpecializationInfo l, in VkSpecializationInfo r)
	{
		return
			(l.MapEntryCount == r.MapEntryCount) && (l.MapEntries == r.MapEntries) && (l.DataSize == r.DataSize) && (l.Data == r.Data)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkSpecializationInfo l, in VkSpecializationInfo r)
	{
		return
			(l.MapEntryCount != r.MapEntryCount) || (l.MapEntries != r.MapEntries) || (l.DataSize != r.DataSize) || (l.Data != r.Data)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkSpecializationInfo s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPipelineShaderStageCreateInfo : IEquatable<VkPipelineShaderStageCreateInfo>
{
	public const VkStructureType TYPE = VkStructureType.PipelineShaderStageCreateInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkPipelineShaderStageCreateFlags Flags;
	public VkShaderStageFlags Stage;
	public VulkanHandle<VkShaderModule> Module;
	public byte* Name;
	public VkSpecializationInfo* SpecializationInfo;

	public VkPipelineShaderStageCreateInfo(
		VkPipelineShaderStageCreateFlags flags = default,
		VkShaderStageFlags stage = default,
		VulkanHandle<VkShaderModule> module = default,
		byte* name = default,
		VkSpecializationInfo* specializationInfo = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		Stage = stage;
		Module = module;
		Name = name;
		SpecializationInfo = specializationInfo;
	}

	public readonly override bool Equals(object? o) => (o is VkPipelineShaderStageCreateInfo s) && (this == s);
	readonly bool IEquatable<VkPipelineShaderStageCreateInfo>.Equals(VkPipelineShaderStageCreateInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ Stage.GetHashCode()
			^ Module.GetHashCode() ^ ((ulong)Name).GetHashCode() ^ ((ulong)SpecializationInfo).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPipelineShaderStageCreateInfo l, in VkPipelineShaderStageCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.Stage == r.Stage)
			&& (l.Module == r.Module) && (l.Name == r.Name) && (l.SpecializationInfo == r.SpecializationInfo)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPipelineShaderStageCreateInfo l, in VkPipelineShaderStageCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.Stage != r.Stage)
			|| (l.Module != r.Module) || (l.Name != r.Name) || (l.SpecializationInfo != r.SpecializationInfo)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPipelineShaderStageCreateInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkComputePipelineCreateInfo : IEquatable<VkComputePipelineCreateInfo>
{
	public const VkStructureType TYPE = VkStructureType.ComputePipelineCreateInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkPipelineCreateFlags Flags;
	public VkPipelineShaderStageCreateInfo Stage;
	public VulkanHandle<VkPipelineLayout> Layout;
	public VulkanHandle<VkPipeline> BasePipelineHandle;
	public int BasePipelineIndex;

	public VkComputePipelineCreateInfo(
		VkPipelineCreateFlags flags = default,
		VkPipelineShaderStageCreateInfo stage = default,
		VulkanHandle<VkPipelineLayout> layout = default,
		VulkanHandle<VkPipeline> basePipelineHandle = default,
		int basePipelineIndex = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		Stage = stage;
		Layout = layout;
		BasePipelineHandle = basePipelineHandle;
		BasePipelineIndex = basePipelineIndex;
	}

	public readonly override bool Equals(object? o) => (o is VkComputePipelineCreateInfo s) && (this == s);
	readonly bool IEquatable<VkComputePipelineCreateInfo>.Equals(VkComputePipelineCreateInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ Stage.GetHashCode()
			^ Layout.GetHashCode() ^ BasePipelineHandle.GetHashCode() ^ BasePipelineIndex.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkComputePipelineCreateInfo l, in VkComputePipelineCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.Stage == r.Stage)
			&& (l.Layout == r.Layout) && (l.BasePipelineHandle == r.BasePipelineHandle) && (l.BasePipelineIndex == r.BasePipelineIndex)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkComputePipelineCreateInfo l, in VkComputePipelineCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.Stage != r.Stage)
			|| (l.Layout != r.Layout) || (l.BasePipelineHandle != r.BasePipelineHandle) || (l.BasePipelineIndex != r.BasePipelineIndex)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkComputePipelineCreateInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkVertexInputBindingDescription : IEquatable<VkVertexInputBindingDescription>
{
	public uint Binding;
	public uint Stride;
	public VkVertexInputRate InputRate;

	public VkVertexInputBindingDescription(
		uint binding = default,
		uint stride = default,
		VkVertexInputRate inputRate = default
	) {
		Binding = binding;
		Stride = stride;
		InputRate = inputRate;
	}

	public readonly override bool Equals(object? o) => (o is VkVertexInputBindingDescription s) && (this == s);
	readonly bool IEquatable<VkVertexInputBindingDescription>.Equals(VkVertexInputBindingDescription o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Binding.GetHashCode() ^ Stride.GetHashCode() ^ InputRate.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkVertexInputBindingDescription l, in VkVertexInputBindingDescription r)
	{
		return
			(l.Binding == r.Binding) && (l.Stride == r.Stride) && (l.InputRate == r.InputRate)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkVertexInputBindingDescription l, in VkVertexInputBindingDescription r)
	{
		return
			(l.Binding != r.Binding) || (l.Stride != r.Stride) || (l.InputRate != r.InputRate)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkVertexInputBindingDescription s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkVertexInputAttributeDescription : IEquatable<VkVertexInputAttributeDescription>
{
	public uint Location;
	public uint Binding;
	public VkFormat Format;
	public uint Offset;

	public VkVertexInputAttributeDescription(
		uint location = default,
		uint binding = default,
		VkFormat format = default,
		uint offset = default
	) {
		Location = location;
		Binding = binding;
		Format = format;
		Offset = offset;
	}

	public readonly override bool Equals(object? o) => (o is VkVertexInputAttributeDescription s) && (this == s);
	readonly bool IEquatable<VkVertexInputAttributeDescription>.Equals(VkVertexInputAttributeDescription o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Location.GetHashCode() ^ Binding.GetHashCode() ^ Format.GetHashCode() ^ Offset.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkVertexInputAttributeDescription l, in VkVertexInputAttributeDescription r)
	{
		return
			(l.Location == r.Location) && (l.Binding == r.Binding) && (l.Format == r.Format) && (l.Offset == r.Offset)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkVertexInputAttributeDescription l, in VkVertexInputAttributeDescription r)
	{
		return
			(l.Location != r.Location) || (l.Binding != r.Binding) || (l.Format != r.Format) || (l.Offset != r.Offset)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkVertexInputAttributeDescription s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPipelineVertexInputStateCreateInfo : IEquatable<VkPipelineVertexInputStateCreateInfo>
{
	public const VkStructureType TYPE = VkStructureType.PipelineVertexInputStateCreateInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkPipelineVertexInputStateCreateFlags Flags;
	public uint VertexBindingDescriptionCount;
	public VkVertexInputBindingDescription* VertexBindingDescriptions;
	public uint VertexAttributeDescriptionCount;
	public VkVertexInputAttributeDescription* VertexAttributeDescriptions;

	public VkPipelineVertexInputStateCreateInfo(
		VkPipelineVertexInputStateCreateFlags flags = default,
		uint vertexBindingDescriptionCount = default,
		VkVertexInputBindingDescription* vertexBindingDescriptions = default,
		uint vertexAttributeDescriptionCount = default,
		VkVertexInputAttributeDescription* vertexAttributeDescriptions = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		VertexBindingDescriptionCount = vertexBindingDescriptionCount;
		VertexBindingDescriptions = vertexBindingDescriptions;
		VertexAttributeDescriptionCount = vertexAttributeDescriptionCount;
		VertexAttributeDescriptions = vertexAttributeDescriptions;
	}

	public readonly override bool Equals(object? o) => (o is VkPipelineVertexInputStateCreateInfo s) && (this == s);
	readonly bool IEquatable<VkPipelineVertexInputStateCreateInfo>.Equals(VkPipelineVertexInputStateCreateInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ VertexBindingDescriptionCount.GetHashCode()
			^ ((ulong)VertexBindingDescriptions).GetHashCode() ^ VertexAttributeDescriptionCount.GetHashCode() ^ ((ulong)VertexAttributeDescriptions).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPipelineVertexInputStateCreateInfo l, in VkPipelineVertexInputStateCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.VertexBindingDescriptionCount == r.VertexBindingDescriptionCount)
			&& (l.VertexBindingDescriptions == r.VertexBindingDescriptions) && (l.VertexAttributeDescriptionCount == r.VertexAttributeDescriptionCount) && (l.VertexAttributeDescriptions == r.VertexAttributeDescriptions)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPipelineVertexInputStateCreateInfo l, in VkPipelineVertexInputStateCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.VertexBindingDescriptionCount != r.VertexBindingDescriptionCount)
			|| (l.VertexBindingDescriptions != r.VertexBindingDescriptions) || (l.VertexAttributeDescriptionCount != r.VertexAttributeDescriptionCount) || (l.VertexAttributeDescriptions != r.VertexAttributeDescriptions)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPipelineVertexInputStateCreateInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPipelineInputAssemblyStateCreateInfo : IEquatable<VkPipelineInputAssemblyStateCreateInfo>
{
	public const VkStructureType TYPE = VkStructureType.PipelineInputAssemblyStateCreateInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkPipelineInputAssemblyStateCreateFlags Flags;
	public VkPrimitiveTopology Topology;
	public VkBool32 PrimitiveRestartEnable;

	public VkPipelineInputAssemblyStateCreateInfo(
		VkPipelineInputAssemblyStateCreateFlags flags = default,
		VkPrimitiveTopology topology = default,
		VkBool32 primitiveRestartEnable = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		Topology = topology;
		PrimitiveRestartEnable = primitiveRestartEnable;
	}

	public readonly override bool Equals(object? o) => (o is VkPipelineInputAssemblyStateCreateInfo s) && (this == s);
	readonly bool IEquatable<VkPipelineInputAssemblyStateCreateInfo>.Equals(VkPipelineInputAssemblyStateCreateInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ Topology.GetHashCode()
			^ PrimitiveRestartEnable.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPipelineInputAssemblyStateCreateInfo l, in VkPipelineInputAssemblyStateCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.Topology == r.Topology)
			&& (l.PrimitiveRestartEnable == r.PrimitiveRestartEnable)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPipelineInputAssemblyStateCreateInfo l, in VkPipelineInputAssemblyStateCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.Topology != r.Topology)
			|| (l.PrimitiveRestartEnable != r.PrimitiveRestartEnable)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPipelineInputAssemblyStateCreateInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPipelineTessellationStateCreateInfo : IEquatable<VkPipelineTessellationStateCreateInfo>
{
	public const VkStructureType TYPE = VkStructureType.PipelineTessellationStateCreateInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkPipelineTessellationStateCreateFlags Flags;
	public uint PatchControlPoints;

	public VkPipelineTessellationStateCreateInfo(
		VkPipelineTessellationStateCreateFlags flags = default,
		uint patchControlPoints = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		PatchControlPoints = patchControlPoints;
	}

	public readonly override bool Equals(object? o) => (o is VkPipelineTessellationStateCreateInfo s) && (this == s);
	readonly bool IEquatable<VkPipelineTessellationStateCreateInfo>.Equals(VkPipelineTessellationStateCreateInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ PatchControlPoints.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPipelineTessellationStateCreateInfo l, in VkPipelineTessellationStateCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.PatchControlPoints == r.PatchControlPoints)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPipelineTessellationStateCreateInfo l, in VkPipelineTessellationStateCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.PatchControlPoints != r.PatchControlPoints)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPipelineTessellationStateCreateInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPipelineViewportStateCreateInfo : IEquatable<VkPipelineViewportStateCreateInfo>
{
	public const VkStructureType TYPE = VkStructureType.PipelineViewportStateCreateInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkPipelineViewportStateCreateFlags Flags;
	public uint ViewportCount;
	public VkViewport* Viewports;
	public uint ScissorCount;
	public VkRect2D* Scissors;

	public VkPipelineViewportStateCreateInfo(
		VkPipelineViewportStateCreateFlags flags = default,
		uint viewportCount = default,
		VkViewport* viewports = default,
		uint scissorCount = default,
		VkRect2D* scissors = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		ViewportCount = viewportCount;
		Viewports = viewports;
		ScissorCount = scissorCount;
		Scissors = scissors;
	}

	public readonly override bool Equals(object? o) => (o is VkPipelineViewportStateCreateInfo s) && (this == s);
	readonly bool IEquatable<VkPipelineViewportStateCreateInfo>.Equals(VkPipelineViewportStateCreateInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ ViewportCount.GetHashCode()
			^ ((ulong)Viewports).GetHashCode() ^ ScissorCount.GetHashCode() ^ ((ulong)Scissors).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPipelineViewportStateCreateInfo l, in VkPipelineViewportStateCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.ViewportCount == r.ViewportCount)
			&& (l.Viewports == r.Viewports) && (l.ScissorCount == r.ScissorCount) && (l.Scissors == r.Scissors)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPipelineViewportStateCreateInfo l, in VkPipelineViewportStateCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.ViewportCount != r.ViewportCount)
			|| (l.Viewports != r.Viewports) || (l.ScissorCount != r.ScissorCount) || (l.Scissors != r.Scissors)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPipelineViewportStateCreateInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPipelineRasterizationStateCreateInfo : IEquatable<VkPipelineRasterizationStateCreateInfo>
{
	public const VkStructureType TYPE = VkStructureType.PipelineRasterizationStateCreateInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkPipelineRasterizationStateCreateFlags Flags;
	public VkBool32 DepthClampEnable;
	public VkBool32 RasterizerDiscardEnable;
	public VkPolygonMode PolygonMode;
	public VkCullModeFlags CullMode;
	public VkFrontFace FrontFace;
	public VkBool32 DepthBiasEnable;
	public float DepthBiasConstantFactor;
	public float DepthBiasClamp;
	public float DepthBiasSlopeFactor;
	public float LineWidth;

	public VkPipelineRasterizationStateCreateInfo(
		VkPipelineRasterizationStateCreateFlags flags = default,
		VkBool32 depthClampEnable = default,
		VkBool32 rasterizerDiscardEnable = default,
		VkPolygonMode polygonMode = default,
		VkCullModeFlags cullMode = default,
		VkFrontFace frontFace = default,
		VkBool32 depthBiasEnable = default,
		float depthBiasConstantFactor = default,
		float depthBiasClamp = default,
		float depthBiasSlopeFactor = default,
		float lineWidth = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		DepthClampEnable = depthClampEnable;
		RasterizerDiscardEnable = rasterizerDiscardEnable;
		PolygonMode = polygonMode;
		CullMode = cullMode;
		FrontFace = frontFace;
		DepthBiasEnable = depthBiasEnable;
		DepthBiasConstantFactor = depthBiasConstantFactor;
		DepthBiasClamp = depthBiasClamp;
		DepthBiasSlopeFactor = depthBiasSlopeFactor;
		LineWidth = lineWidth;
	}

	public readonly override bool Equals(object? o) => (o is VkPipelineRasterizationStateCreateInfo s) && (this == s);
	readonly bool IEquatable<VkPipelineRasterizationStateCreateInfo>.Equals(VkPipelineRasterizationStateCreateInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ DepthClampEnable.GetHashCode()
			^ RasterizerDiscardEnable.GetHashCode() ^ PolygonMode.GetHashCode() ^ CullMode.GetHashCode() ^ FrontFace.GetHashCode()
			^ DepthBiasEnable.GetHashCode() ^ DepthBiasConstantFactor.GetHashCode() ^ DepthBiasClamp.GetHashCode() ^ DepthBiasSlopeFactor.GetHashCode()
			^ LineWidth.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPipelineRasterizationStateCreateInfo l, in VkPipelineRasterizationStateCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.DepthClampEnable == r.DepthClampEnable)
			&& (l.RasterizerDiscardEnable == r.RasterizerDiscardEnable) && (l.PolygonMode == r.PolygonMode) && (l.CullMode == r.CullMode) && (l.FrontFace == r.FrontFace)
			&& (l.DepthBiasEnable == r.DepthBiasEnable) && (l.DepthBiasConstantFactor == r.DepthBiasConstantFactor) && (l.DepthBiasClamp == r.DepthBiasClamp) && (l.DepthBiasSlopeFactor == r.DepthBiasSlopeFactor)
			&& (l.LineWidth == r.LineWidth)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPipelineRasterizationStateCreateInfo l, in VkPipelineRasterizationStateCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.DepthClampEnable != r.DepthClampEnable)
			|| (l.RasterizerDiscardEnable != r.RasterizerDiscardEnable) || (l.PolygonMode != r.PolygonMode) || (l.CullMode != r.CullMode) || (l.FrontFace != r.FrontFace)
			|| (l.DepthBiasEnable != r.DepthBiasEnable) || (l.DepthBiasConstantFactor != r.DepthBiasConstantFactor) || (l.DepthBiasClamp != r.DepthBiasClamp) || (l.DepthBiasSlopeFactor != r.DepthBiasSlopeFactor)
			|| (l.LineWidth != r.LineWidth)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPipelineRasterizationStateCreateInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPipelineMultisampleStateCreateInfo : IEquatable<VkPipelineMultisampleStateCreateInfo>
{
	public const VkStructureType TYPE = VkStructureType.PipelineMultisampleStateCreateInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkPipelineMultisampleStateCreateFlags Flags;
	public VkSampleCountFlags RasterizationSamples;
	public VkBool32 SampleShadingEnable;
	public float MinSampleShading;
	public uint* SampleMask;
	public VkBool32 AlphaToCoverageEnable;
	public VkBool32 AlphaToOneEnable;

	public VkPipelineMultisampleStateCreateInfo(
		VkPipelineMultisampleStateCreateFlags flags = default,
		VkSampleCountFlags rasterizationSamples = default,
		VkBool32 sampleShadingEnable = default,
		float minSampleShading = default,
		uint* sampleMask = default,
		VkBool32 alphaToCoverageEnable = default,
		VkBool32 alphaToOneEnable = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		RasterizationSamples = rasterizationSamples;
		SampleShadingEnable = sampleShadingEnable;
		MinSampleShading = minSampleShading;
		SampleMask = sampleMask;
		AlphaToCoverageEnable = alphaToCoverageEnable;
		AlphaToOneEnable = alphaToOneEnable;
	}

	public readonly override bool Equals(object? o) => (o is VkPipelineMultisampleStateCreateInfo s) && (this == s);
	readonly bool IEquatable<VkPipelineMultisampleStateCreateInfo>.Equals(VkPipelineMultisampleStateCreateInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ RasterizationSamples.GetHashCode()
			^ SampleShadingEnable.GetHashCode() ^ MinSampleShading.GetHashCode() ^ ((ulong)SampleMask).GetHashCode() ^ AlphaToCoverageEnable.GetHashCode()
			^ AlphaToOneEnable.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPipelineMultisampleStateCreateInfo l, in VkPipelineMultisampleStateCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.RasterizationSamples == r.RasterizationSamples)
			&& (l.SampleShadingEnable == r.SampleShadingEnable) && (l.MinSampleShading == r.MinSampleShading) && (l.SampleMask == r.SampleMask) && (l.AlphaToCoverageEnable == r.AlphaToCoverageEnable)
			&& (l.AlphaToOneEnable == r.AlphaToOneEnable)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPipelineMultisampleStateCreateInfo l, in VkPipelineMultisampleStateCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.RasterizationSamples != r.RasterizationSamples)
			|| (l.SampleShadingEnable != r.SampleShadingEnable) || (l.MinSampleShading != r.MinSampleShading) || (l.SampleMask != r.SampleMask) || (l.AlphaToCoverageEnable != r.AlphaToCoverageEnable)
			|| (l.AlphaToOneEnable != r.AlphaToOneEnable)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPipelineMultisampleStateCreateInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPipelineColorBlendAttachmentState : IEquatable<VkPipelineColorBlendAttachmentState>
{
	public VkBool32 BlendEnable;
	public VkBlendFactor SrcColorBlendFactor;
	public VkBlendFactor DstColorBlendFactor;
	public VkBlendOp ColorBlendOp;
	public VkBlendFactor SrcAlphaBlendFactor;
	public VkBlendFactor DstAlphaBlendFactor;
	public VkBlendOp AlphaBlendOp;
	public VkColorComponentFlags ColorWriteMask;

	public VkPipelineColorBlendAttachmentState(
		VkBool32 blendEnable = default,
		VkBlendFactor srcColorBlendFactor = default,
		VkBlendFactor dstColorBlendFactor = default,
		VkBlendOp colorBlendOp = default,
		VkBlendFactor srcAlphaBlendFactor = default,
		VkBlendFactor dstAlphaBlendFactor = default,
		VkBlendOp alphaBlendOp = default,
		VkColorComponentFlags colorWriteMask = default
	) {
		BlendEnable = blendEnable;
		SrcColorBlendFactor = srcColorBlendFactor;
		DstColorBlendFactor = dstColorBlendFactor;
		ColorBlendOp = colorBlendOp;
		SrcAlphaBlendFactor = srcAlphaBlendFactor;
		DstAlphaBlendFactor = dstAlphaBlendFactor;
		AlphaBlendOp = alphaBlendOp;
		ColorWriteMask = colorWriteMask;
	}

	public readonly override bool Equals(object? o) => (o is VkPipelineColorBlendAttachmentState s) && (this == s);
	readonly bool IEquatable<VkPipelineColorBlendAttachmentState>.Equals(VkPipelineColorBlendAttachmentState o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			BlendEnable.GetHashCode() ^ SrcColorBlendFactor.GetHashCode() ^ DstColorBlendFactor.GetHashCode() ^ ColorBlendOp.GetHashCode()
			^ SrcAlphaBlendFactor.GetHashCode() ^ DstAlphaBlendFactor.GetHashCode() ^ AlphaBlendOp.GetHashCode() ^ ColorWriteMask.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPipelineColorBlendAttachmentState l, in VkPipelineColorBlendAttachmentState r)
	{
		return
			(l.BlendEnable == r.BlendEnable) && (l.SrcColorBlendFactor == r.SrcColorBlendFactor) && (l.DstColorBlendFactor == r.DstColorBlendFactor) && (l.ColorBlendOp == r.ColorBlendOp)
			&& (l.SrcAlphaBlendFactor == r.SrcAlphaBlendFactor) && (l.DstAlphaBlendFactor == r.DstAlphaBlendFactor) && (l.AlphaBlendOp == r.AlphaBlendOp) && (l.ColorWriteMask == r.ColorWriteMask)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPipelineColorBlendAttachmentState l, in VkPipelineColorBlendAttachmentState r)
	{
		return
			(l.BlendEnable != r.BlendEnable) || (l.SrcColorBlendFactor != r.SrcColorBlendFactor) || (l.DstColorBlendFactor != r.DstColorBlendFactor) || (l.ColorBlendOp != r.ColorBlendOp)
			|| (l.SrcAlphaBlendFactor != r.SrcAlphaBlendFactor) || (l.DstAlphaBlendFactor != r.DstAlphaBlendFactor) || (l.AlphaBlendOp != r.AlphaBlendOp) || (l.ColorWriteMask != r.ColorWriteMask)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPipelineColorBlendAttachmentState s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPipelineColorBlendStateCreateInfo : IEquatable<VkPipelineColorBlendStateCreateInfo>
{
	public const VkStructureType TYPE = VkStructureType.PipelineColorBlendStateCreateInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkPipelineColorBlendStateCreateFlags Flags;
	public VkBool32 LogicOpEnable;
	public VkLogicOp LogicOp;
	public uint AttachmentCount;
	public VkPipelineColorBlendAttachmentState* Attachments;
	public fixed float BlendConstants[4];

	public VkPipelineColorBlendStateCreateInfo(
		VkPipelineColorBlendStateCreateFlags flags = default,
		VkBool32 logicOpEnable = default,
		VkLogicOp logicOp = default,
		uint attachmentCount = default,
		VkPipelineColorBlendAttachmentState* attachments = default,
		float blendConstants_0 = default,
		float blendConstants_1 = default,
		float blendConstants_2 = default,
		float blendConstants_3 = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		LogicOpEnable = logicOpEnable;
		LogicOp = logicOp;
		AttachmentCount = attachmentCount;
		Attachments = attachments;
		BlendConstants[0] = blendConstants_0;
		BlendConstants[1] = blendConstants_1;
		BlendConstants[2] = blendConstants_2;
		BlendConstants[3] = blendConstants_3;
	}

	public readonly override bool Equals(object? o) => (o is VkPipelineColorBlendStateCreateInfo s) && (this == s);
	readonly bool IEquatable<VkPipelineColorBlendStateCreateInfo>.Equals(VkPipelineColorBlendStateCreateInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ LogicOpEnable.GetHashCode()
			^ LogicOp.GetHashCode() ^ AttachmentCount.GetHashCode() ^ ((ulong)Attachments).GetHashCode() ^ BlendConstants[0].GetHashCode()
			^ BlendConstants[1].GetHashCode() ^ BlendConstants[2].GetHashCode() ^ BlendConstants[3].GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPipelineColorBlendStateCreateInfo l, in VkPipelineColorBlendStateCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.LogicOpEnable == r.LogicOpEnable)
			&& (l.LogicOp == r.LogicOp) && (l.AttachmentCount == r.AttachmentCount) && (l.Attachments == r.Attachments) && (l.BlendConstants[0] == r.BlendConstants[0])
			&& (l.BlendConstants[1] == r.BlendConstants[1]) && (l.BlendConstants[2] == r.BlendConstants[2]) && (l.BlendConstants[3] == r.BlendConstants[3])
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPipelineColorBlendStateCreateInfo l, in VkPipelineColorBlendStateCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.LogicOpEnable != r.LogicOpEnable)
			|| (l.LogicOp != r.LogicOp) || (l.AttachmentCount != r.AttachmentCount) || (l.Attachments != r.Attachments) || (l.BlendConstants[0] != r.BlendConstants[0])
			|| (l.BlendConstants[1] != r.BlendConstants[1]) || (l.BlendConstants[2] != r.BlendConstants[2]) || (l.BlendConstants[3] != r.BlendConstants[3])
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPipelineColorBlendStateCreateInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPipelineDynamicStateCreateInfo : IEquatable<VkPipelineDynamicStateCreateInfo>
{
	public const VkStructureType TYPE = VkStructureType.PipelineDynamicStateCreateInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkPipelineDynamicStateCreateFlags Flags;
	public uint DynamicStateCount;
	public VkDynamicState* DynamicStates;

	public VkPipelineDynamicStateCreateInfo(
		VkPipelineDynamicStateCreateFlags flags = default,
		uint dynamicStateCount = default,
		VkDynamicState* dynamicStates = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		DynamicStateCount = dynamicStateCount;
		DynamicStates = dynamicStates;
	}

	public readonly override bool Equals(object? o) => (o is VkPipelineDynamicStateCreateInfo s) && (this == s);
	readonly bool IEquatable<VkPipelineDynamicStateCreateInfo>.Equals(VkPipelineDynamicStateCreateInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ DynamicStateCount.GetHashCode()
			^ ((ulong)DynamicStates).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPipelineDynamicStateCreateInfo l, in VkPipelineDynamicStateCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.DynamicStateCount == r.DynamicStateCount)
			&& (l.DynamicStates == r.DynamicStates)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPipelineDynamicStateCreateInfo l, in VkPipelineDynamicStateCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.DynamicStateCount != r.DynamicStateCount)
			|| (l.DynamicStates != r.DynamicStates)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPipelineDynamicStateCreateInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkStencilOpState : IEquatable<VkStencilOpState>
{
	public VkStencilOp FailOp;
	public VkStencilOp PassOp;
	public VkStencilOp DepthFailOp;
	public VkCompareOp CompareOp;
	public uint CompareMask;
	public uint WriteMask;
	public uint Reference;

	public VkStencilOpState(
		VkStencilOp failOp = default,
		VkStencilOp passOp = default,
		VkStencilOp depthFailOp = default,
		VkCompareOp compareOp = default,
		uint compareMask = default,
		uint writeMask = default,
		uint reference = default
	) {
		FailOp = failOp;
		PassOp = passOp;
		DepthFailOp = depthFailOp;
		CompareOp = compareOp;
		CompareMask = compareMask;
		WriteMask = writeMask;
		Reference = reference;
	}

	public readonly override bool Equals(object? o) => (o is VkStencilOpState s) && (this == s);
	readonly bool IEquatable<VkStencilOpState>.Equals(VkStencilOpState o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			FailOp.GetHashCode() ^ PassOp.GetHashCode() ^ DepthFailOp.GetHashCode() ^ CompareOp.GetHashCode()
			^ CompareMask.GetHashCode() ^ WriteMask.GetHashCode() ^ Reference.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkStencilOpState l, in VkStencilOpState r)
	{
		return
			(l.FailOp == r.FailOp) && (l.PassOp == r.PassOp) && (l.DepthFailOp == r.DepthFailOp) && (l.CompareOp == r.CompareOp)
			&& (l.CompareMask == r.CompareMask) && (l.WriteMask == r.WriteMask) && (l.Reference == r.Reference)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkStencilOpState l, in VkStencilOpState r)
	{
		return
			(l.FailOp != r.FailOp) || (l.PassOp != r.PassOp) || (l.DepthFailOp != r.DepthFailOp) || (l.CompareOp != r.CompareOp)
			|| (l.CompareMask != r.CompareMask) || (l.WriteMask != r.WriteMask) || (l.Reference != r.Reference)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkStencilOpState s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPipelineDepthStencilStateCreateInfo : IEquatable<VkPipelineDepthStencilStateCreateInfo>
{
	public const VkStructureType TYPE = VkStructureType.PipelineDepthStencilStateCreateInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkPipelineDepthStencilStateCreateFlags Flags;
	public VkBool32 DepthTestEnable;
	public VkBool32 DepthWriteEnable;
	public VkCompareOp DepthCompareOp;
	public VkBool32 DepthBoundsTestEnable;
	public VkBool32 StencilTestEnable;
	public VkStencilOpState Front;
	public VkStencilOpState Back;
	public float MinDepthBounds;
	public float MaxDepthBounds;

	public VkPipelineDepthStencilStateCreateInfo(
		VkPipelineDepthStencilStateCreateFlags flags = default,
		VkBool32 depthTestEnable = default,
		VkBool32 depthWriteEnable = default,
		VkCompareOp depthCompareOp = default,
		VkBool32 depthBoundsTestEnable = default,
		VkBool32 stencilTestEnable = default,
		VkStencilOpState front = default,
		VkStencilOpState back = default,
		float minDepthBounds = default,
		float maxDepthBounds = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		DepthTestEnable = depthTestEnable;
		DepthWriteEnable = depthWriteEnable;
		DepthCompareOp = depthCompareOp;
		DepthBoundsTestEnable = depthBoundsTestEnable;
		StencilTestEnable = stencilTestEnable;
		Front = front;
		Back = back;
		MinDepthBounds = minDepthBounds;
		MaxDepthBounds = maxDepthBounds;
	}

	public readonly override bool Equals(object? o) => (o is VkPipelineDepthStencilStateCreateInfo s) && (this == s);
	readonly bool IEquatable<VkPipelineDepthStencilStateCreateInfo>.Equals(VkPipelineDepthStencilStateCreateInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ DepthTestEnable.GetHashCode()
			^ DepthWriteEnable.GetHashCode() ^ DepthCompareOp.GetHashCode() ^ DepthBoundsTestEnable.GetHashCode() ^ StencilTestEnable.GetHashCode()
			^ Front.GetHashCode() ^ Back.GetHashCode() ^ MinDepthBounds.GetHashCode() ^ MaxDepthBounds.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPipelineDepthStencilStateCreateInfo l, in VkPipelineDepthStencilStateCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.DepthTestEnable == r.DepthTestEnable)
			&& (l.DepthWriteEnable == r.DepthWriteEnable) && (l.DepthCompareOp == r.DepthCompareOp) && (l.DepthBoundsTestEnable == r.DepthBoundsTestEnable) && (l.StencilTestEnable == r.StencilTestEnable)
			&& (l.Front == r.Front) && (l.Back == r.Back) && (l.MinDepthBounds == r.MinDepthBounds) && (l.MaxDepthBounds == r.MaxDepthBounds)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPipelineDepthStencilStateCreateInfo l, in VkPipelineDepthStencilStateCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.DepthTestEnable != r.DepthTestEnable)
			|| (l.DepthWriteEnable != r.DepthWriteEnable) || (l.DepthCompareOp != r.DepthCompareOp) || (l.DepthBoundsTestEnable != r.DepthBoundsTestEnable) || (l.StencilTestEnable != r.StencilTestEnable)
			|| (l.Front != r.Front) || (l.Back != r.Back) || (l.MinDepthBounds != r.MinDepthBounds) || (l.MaxDepthBounds != r.MaxDepthBounds)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPipelineDepthStencilStateCreateInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkGraphicsPipelineCreateInfo : IEquatable<VkGraphicsPipelineCreateInfo>
{
	public const VkStructureType TYPE = VkStructureType.GraphicsPipelineCreateInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkPipelineCreateFlags Flags;
	public uint StageCount;
	public VkPipelineShaderStageCreateInfo* Stages;
	public VkPipelineVertexInputStateCreateInfo* VertexInputState;
	public VkPipelineInputAssemblyStateCreateInfo* InputAssemblyState;
	public VkPipelineTessellationStateCreateInfo* TessellationState;
	public VkPipelineViewportStateCreateInfo* ViewportState;
	public VkPipelineRasterizationStateCreateInfo* RasterizationState;
	public VkPipelineMultisampleStateCreateInfo* MultisampleState;
	public VkPipelineDepthStencilStateCreateInfo* DepthStencilState;
	public VkPipelineColorBlendStateCreateInfo* ColorBlendState;
	public VkPipelineDynamicStateCreateInfo* DynamicState;
	public VulkanHandle<VkPipelineLayout> Layout;
	public VulkanHandle<VkRenderPass> RenderPass;
	public uint Subpass;
	public VulkanHandle<VkPipeline> BasePipelineHandle;
	public int BasePipelineIndex;

	public VkGraphicsPipelineCreateInfo(
		VkPipelineCreateFlags flags = default,
		uint stageCount = default,
		VkPipelineShaderStageCreateInfo* stages = default,
		VkPipelineVertexInputStateCreateInfo* vertexInputState = default,
		VkPipelineInputAssemblyStateCreateInfo* inputAssemblyState = default,
		VkPipelineTessellationStateCreateInfo* tessellationState = default,
		VkPipelineViewportStateCreateInfo* viewportState = default,
		VkPipelineRasterizationStateCreateInfo* rasterizationState = default,
		VkPipelineMultisampleStateCreateInfo* multisampleState = default,
		VkPipelineDepthStencilStateCreateInfo* depthStencilState = default,
		VkPipelineColorBlendStateCreateInfo* colorBlendState = default,
		VkPipelineDynamicStateCreateInfo* dynamicState = default,
		VulkanHandle<VkPipelineLayout> layout = default,
		VulkanHandle<VkRenderPass> renderPass = default,
		uint subpass = default,
		VulkanHandle<VkPipeline> basePipelineHandle = default,
		int basePipelineIndex = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		StageCount = stageCount;
		Stages = stages;
		VertexInputState = vertexInputState;
		InputAssemblyState = inputAssemblyState;
		TessellationState = tessellationState;
		ViewportState = viewportState;
		RasterizationState = rasterizationState;
		MultisampleState = multisampleState;
		DepthStencilState = depthStencilState;
		ColorBlendState = colorBlendState;
		DynamicState = dynamicState;
		Layout = layout;
		RenderPass = renderPass;
		Subpass = subpass;
		BasePipelineHandle = basePipelineHandle;
		BasePipelineIndex = basePipelineIndex;
	}

	public readonly override bool Equals(object? o) => (o is VkGraphicsPipelineCreateInfo s) && (this == s);
	readonly bool IEquatable<VkGraphicsPipelineCreateInfo>.Equals(VkGraphicsPipelineCreateInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ StageCount.GetHashCode()
			^ ((ulong)Stages).GetHashCode() ^ ((ulong)VertexInputState).GetHashCode() ^ ((ulong)InputAssemblyState).GetHashCode() ^ ((ulong)TessellationState).GetHashCode()
			^ ((ulong)ViewportState).GetHashCode() ^ ((ulong)RasterizationState).GetHashCode() ^ ((ulong)MultisampleState).GetHashCode() ^ ((ulong)DepthStencilState).GetHashCode()
			^ ((ulong)ColorBlendState).GetHashCode() ^ ((ulong)DynamicState).GetHashCode() ^ Layout.GetHashCode() ^ RenderPass.GetHashCode()
			^ Subpass.GetHashCode() ^ BasePipelineHandle.GetHashCode() ^ BasePipelineIndex.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkGraphicsPipelineCreateInfo l, in VkGraphicsPipelineCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.StageCount == r.StageCount)
			&& (l.Stages == r.Stages) && (l.VertexInputState == r.VertexInputState) && (l.InputAssemblyState == r.InputAssemblyState) && (l.TessellationState == r.TessellationState)
			&& (l.ViewportState == r.ViewportState) && (l.RasterizationState == r.RasterizationState) && (l.MultisampleState == r.MultisampleState) && (l.DepthStencilState == r.DepthStencilState)
			&& (l.ColorBlendState == r.ColorBlendState) && (l.DynamicState == r.DynamicState) && (l.Layout == r.Layout) && (l.RenderPass == r.RenderPass)
			&& (l.Subpass == r.Subpass) && (l.BasePipelineHandle == r.BasePipelineHandle) && (l.BasePipelineIndex == r.BasePipelineIndex)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkGraphicsPipelineCreateInfo l, in VkGraphicsPipelineCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.StageCount != r.StageCount)
			|| (l.Stages != r.Stages) || (l.VertexInputState != r.VertexInputState) || (l.InputAssemblyState != r.InputAssemblyState) || (l.TessellationState != r.TessellationState)
			|| (l.ViewportState != r.ViewportState) || (l.RasterizationState != r.RasterizationState) || (l.MultisampleState != r.MultisampleState) || (l.DepthStencilState != r.DepthStencilState)
			|| (l.ColorBlendState != r.ColorBlendState) || (l.DynamicState != r.DynamicState) || (l.Layout != r.Layout) || (l.RenderPass != r.RenderPass)
			|| (l.Subpass != r.Subpass) || (l.BasePipelineHandle != r.BasePipelineHandle) || (l.BasePipelineIndex != r.BasePipelineIndex)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkGraphicsPipelineCreateInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPipelineCacheCreateInfo : IEquatable<VkPipelineCacheCreateInfo>
{
	public const VkStructureType TYPE = VkStructureType.PipelineCacheCreateInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkPipelineCacheCreateFlags Flags;
	public ulong InitialDataSize;
	public void* InitialData;

	public VkPipelineCacheCreateInfo(
		VkPipelineCacheCreateFlags flags = default,
		ulong initialDataSize = default,
		void* initialData = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		InitialDataSize = initialDataSize;
		InitialData = initialData;
	}

	public readonly override bool Equals(object? o) => (o is VkPipelineCacheCreateInfo s) && (this == s);
	readonly bool IEquatable<VkPipelineCacheCreateInfo>.Equals(VkPipelineCacheCreateInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ InitialDataSize.GetHashCode()
			^ ((ulong)InitialData).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPipelineCacheCreateInfo l, in VkPipelineCacheCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.InitialDataSize == r.InitialDataSize)
			&& (l.InitialData == r.InitialData)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPipelineCacheCreateInfo l, in VkPipelineCacheCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.InitialDataSize != r.InitialDataSize)
			|| (l.InitialData != r.InitialData)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPipelineCacheCreateInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPushConstantRange : IEquatable<VkPushConstantRange>
{
	public VkShaderStageFlags StageFlags;
	public uint Offset;
	public uint Size;

	public VkPushConstantRange(
		VkShaderStageFlags stageFlags = default,
		uint offset = default,
		uint size = default
	) {
		StageFlags = stageFlags;
		Offset = offset;
		Size = size;
	}

	public readonly override bool Equals(object? o) => (o is VkPushConstantRange s) && (this == s);
	readonly bool IEquatable<VkPushConstantRange>.Equals(VkPushConstantRange o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			StageFlags.GetHashCode() ^ Offset.GetHashCode() ^ Size.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPushConstantRange l, in VkPushConstantRange r)
	{
		return
			(l.StageFlags == r.StageFlags) && (l.Offset == r.Offset) && (l.Size == r.Size)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPushConstantRange l, in VkPushConstantRange r)
	{
		return
			(l.StageFlags != r.StageFlags) || (l.Offset != r.Offset) || (l.Size != r.Size)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPushConstantRange s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPipelineLayoutCreateInfo : IEquatable<VkPipelineLayoutCreateInfo>
{
	public const VkStructureType TYPE = VkStructureType.PipelineLayoutCreateInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkPipelineLayoutCreateFlags Flags;
	public uint SetLayoutCount;
	public VulkanHandle<VkDescriptorSetLayout>* SetLayouts;
	public uint PushConstantRangeCount;
	public VkPushConstantRange* PushConstantRanges;

	public VkPipelineLayoutCreateInfo(
		VkPipelineLayoutCreateFlags flags = default,
		uint setLayoutCount = default,
		VulkanHandle<VkDescriptorSetLayout>* setLayouts = default,
		uint pushConstantRangeCount = default,
		VkPushConstantRange* pushConstantRanges = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		SetLayoutCount = setLayoutCount;
		SetLayouts = setLayouts;
		PushConstantRangeCount = pushConstantRangeCount;
		PushConstantRanges = pushConstantRanges;
	}

	public readonly override bool Equals(object? o) => (o is VkPipelineLayoutCreateInfo s) && (this == s);
	readonly bool IEquatable<VkPipelineLayoutCreateInfo>.Equals(VkPipelineLayoutCreateInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ SetLayoutCount.GetHashCode()
			^ ((ulong)SetLayouts).GetHashCode() ^ PushConstantRangeCount.GetHashCode() ^ ((ulong)PushConstantRanges).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPipelineLayoutCreateInfo l, in VkPipelineLayoutCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.SetLayoutCount == r.SetLayoutCount)
			&& (l.SetLayouts == r.SetLayouts) && (l.PushConstantRangeCount == r.PushConstantRangeCount) && (l.PushConstantRanges == r.PushConstantRanges)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPipelineLayoutCreateInfo l, in VkPipelineLayoutCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.SetLayoutCount != r.SetLayoutCount)
			|| (l.SetLayouts != r.SetLayouts) || (l.PushConstantRangeCount != r.PushConstantRangeCount) || (l.PushConstantRanges != r.PushConstantRanges)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPipelineLayoutCreateInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkSamplerCreateInfo : IEquatable<VkSamplerCreateInfo>
{
	public const VkStructureType TYPE = VkStructureType.SamplerCreateInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkSamplerCreateFlags Flags;
	public VkFilter MagFilter;
	public VkFilter MinFilter;
	public VkSamplerMipmapMode MipmapMode;
	public VkSamplerAddressMode AddressModeU;
	public VkSamplerAddressMode AddressModeV;
	public VkSamplerAddressMode AddressModeW;
	public float MipLodBias;
	public VkBool32 AnisotropyEnable;
	public float MaxAnisotropy;
	public VkBool32 CompareEnable;
	public VkCompareOp CompareOp;
	public float MinLod;
	public float MaxLod;
	public VkBorderColor BorderColor;
	public VkBool32 UnnormalizedCoordinates;

	public VkSamplerCreateInfo(
		VkSamplerCreateFlags flags = default,
		VkFilter magFilter = default,
		VkFilter minFilter = default,
		VkSamplerMipmapMode mipmapMode = default,
		VkSamplerAddressMode addressModeU = default,
		VkSamplerAddressMode addressModeV = default,
		VkSamplerAddressMode addressModeW = default,
		float mipLodBias = default,
		VkBool32 anisotropyEnable = default,
		float maxAnisotropy = default,
		VkBool32 compareEnable = default,
		VkCompareOp compareOp = default,
		float minLod = default,
		float maxLod = default,
		VkBorderColor borderColor = default,
		VkBool32 unnormalizedCoordinates = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		MagFilter = magFilter;
		MinFilter = minFilter;
		MipmapMode = mipmapMode;
		AddressModeU = addressModeU;
		AddressModeV = addressModeV;
		AddressModeW = addressModeW;
		MipLodBias = mipLodBias;
		AnisotropyEnable = anisotropyEnable;
		MaxAnisotropy = maxAnisotropy;
		CompareEnable = compareEnable;
		CompareOp = compareOp;
		MinLod = minLod;
		MaxLod = maxLod;
		BorderColor = borderColor;
		UnnormalizedCoordinates = unnormalizedCoordinates;
	}

	public readonly override bool Equals(object? o) => (o is VkSamplerCreateInfo s) && (this == s);
	readonly bool IEquatable<VkSamplerCreateInfo>.Equals(VkSamplerCreateInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ MagFilter.GetHashCode()
			^ MinFilter.GetHashCode() ^ MipmapMode.GetHashCode() ^ AddressModeU.GetHashCode() ^ AddressModeV.GetHashCode()
			^ AddressModeW.GetHashCode() ^ MipLodBias.GetHashCode() ^ AnisotropyEnable.GetHashCode() ^ MaxAnisotropy.GetHashCode()
			^ CompareEnable.GetHashCode() ^ CompareOp.GetHashCode() ^ MinLod.GetHashCode() ^ MaxLod.GetHashCode()
			^ BorderColor.GetHashCode() ^ UnnormalizedCoordinates.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkSamplerCreateInfo l, in VkSamplerCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.MagFilter == r.MagFilter)
			&& (l.MinFilter == r.MinFilter) && (l.MipmapMode == r.MipmapMode) && (l.AddressModeU == r.AddressModeU) && (l.AddressModeV == r.AddressModeV)
			&& (l.AddressModeW == r.AddressModeW) && (l.MipLodBias == r.MipLodBias) && (l.AnisotropyEnable == r.AnisotropyEnable) && (l.MaxAnisotropy == r.MaxAnisotropy)
			&& (l.CompareEnable == r.CompareEnable) && (l.CompareOp == r.CompareOp) && (l.MinLod == r.MinLod) && (l.MaxLod == r.MaxLod)
			&& (l.BorderColor == r.BorderColor) && (l.UnnormalizedCoordinates == r.UnnormalizedCoordinates)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkSamplerCreateInfo l, in VkSamplerCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.MagFilter != r.MagFilter)
			|| (l.MinFilter != r.MinFilter) || (l.MipmapMode != r.MipmapMode) || (l.AddressModeU != r.AddressModeU) || (l.AddressModeV != r.AddressModeV)
			|| (l.AddressModeW != r.AddressModeW) || (l.MipLodBias != r.MipLodBias) || (l.AnisotropyEnable != r.AnisotropyEnable) || (l.MaxAnisotropy != r.MaxAnisotropy)
			|| (l.CompareEnable != r.CompareEnable) || (l.CompareOp != r.CompareOp) || (l.MinLod != r.MinLod) || (l.MaxLod != r.MaxLod)
			|| (l.BorderColor != r.BorderColor) || (l.UnnormalizedCoordinates != r.UnnormalizedCoordinates)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkSamplerCreateInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkCommandPoolCreateInfo : IEquatable<VkCommandPoolCreateInfo>
{
	public const VkStructureType TYPE = VkStructureType.CommandPoolCreateInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkCommandPoolCreateFlags Flags;
	public uint QueueFamilyIndex;

	public VkCommandPoolCreateInfo(
		VkCommandPoolCreateFlags flags = default,
		uint queueFamilyIndex = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		QueueFamilyIndex = queueFamilyIndex;
	}

	public readonly override bool Equals(object? o) => (o is VkCommandPoolCreateInfo s) && (this == s);
	readonly bool IEquatable<VkCommandPoolCreateInfo>.Equals(VkCommandPoolCreateInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ QueueFamilyIndex.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkCommandPoolCreateInfo l, in VkCommandPoolCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.QueueFamilyIndex == r.QueueFamilyIndex)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkCommandPoolCreateInfo l, in VkCommandPoolCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.QueueFamilyIndex != r.QueueFamilyIndex)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkCommandPoolCreateInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkCommandBufferAllocateInfo : IEquatable<VkCommandBufferAllocateInfo>
{
	public const VkStructureType TYPE = VkStructureType.CommandBufferAllocateInfo;

	public VkStructureType sType;
	public void* pNext;
	public VulkanHandle<VkCommandPool> CommandPool;
	public VkCommandBufferLevel Level;
	public uint CommandBufferCount;

	public VkCommandBufferAllocateInfo(
		VulkanHandle<VkCommandPool> commandPool = default,
		VkCommandBufferLevel level = default,
		uint commandBufferCount = default
	) {
		sType = TYPE;
		pNext = null;
		CommandPool = commandPool;
		Level = level;
		CommandBufferCount = commandBufferCount;
	}

	public readonly override bool Equals(object? o) => (o is VkCommandBufferAllocateInfo s) && (this == s);
	readonly bool IEquatable<VkCommandBufferAllocateInfo>.Equals(VkCommandBufferAllocateInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ CommandPool.GetHashCode() ^ Level.GetHashCode()
			^ CommandBufferCount.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkCommandBufferAllocateInfo l, in VkCommandBufferAllocateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.CommandPool == r.CommandPool) && (l.Level == r.Level)
			&& (l.CommandBufferCount == r.CommandBufferCount)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkCommandBufferAllocateInfo l, in VkCommandBufferAllocateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.CommandPool != r.CommandPool) || (l.Level != r.Level)
			|| (l.CommandBufferCount != r.CommandBufferCount)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkCommandBufferAllocateInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkCommandBufferInheritanceInfo : IEquatable<VkCommandBufferInheritanceInfo>
{
	public const VkStructureType TYPE = VkStructureType.CommandBufferInheritanceInfo;

	public VkStructureType sType;
	public void* pNext;
	public VulkanHandle<VkRenderPass> RenderPass;
	public uint Subpass;
	public VulkanHandle<VkFramebuffer> Framebuffer;
	public VkBool32 OcclusionQueryEnable;
	public VkQueryControlFlags QueryFlags;
	public VkQueryPipelineStatisticFlags PipelineStatistics;

	public VkCommandBufferInheritanceInfo(
		VulkanHandle<VkRenderPass> renderPass = default,
		uint subpass = default,
		VulkanHandle<VkFramebuffer> framebuffer = default,
		VkBool32 occlusionQueryEnable = default,
		VkQueryControlFlags queryFlags = default,
		VkQueryPipelineStatisticFlags pipelineStatistics = default
	) {
		sType = TYPE;
		pNext = null;
		RenderPass = renderPass;
		Subpass = subpass;
		Framebuffer = framebuffer;
		OcclusionQueryEnable = occlusionQueryEnable;
		QueryFlags = queryFlags;
		PipelineStatistics = pipelineStatistics;
	}

	public readonly override bool Equals(object? o) => (o is VkCommandBufferInheritanceInfo s) && (this == s);
	readonly bool IEquatable<VkCommandBufferInheritanceInfo>.Equals(VkCommandBufferInheritanceInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ RenderPass.GetHashCode() ^ Subpass.GetHashCode()
			^ Framebuffer.GetHashCode() ^ OcclusionQueryEnable.GetHashCode() ^ QueryFlags.GetHashCode() ^ PipelineStatistics.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkCommandBufferInheritanceInfo l, in VkCommandBufferInheritanceInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.RenderPass == r.RenderPass) && (l.Subpass == r.Subpass)
			&& (l.Framebuffer == r.Framebuffer) && (l.OcclusionQueryEnable == r.OcclusionQueryEnable) && (l.QueryFlags == r.QueryFlags) && (l.PipelineStatistics == r.PipelineStatistics)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkCommandBufferInheritanceInfo l, in VkCommandBufferInheritanceInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.RenderPass != r.RenderPass) || (l.Subpass != r.Subpass)
			|| (l.Framebuffer != r.Framebuffer) || (l.OcclusionQueryEnable != r.OcclusionQueryEnable) || (l.QueryFlags != r.QueryFlags) || (l.PipelineStatistics != r.PipelineStatistics)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkCommandBufferInheritanceInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkCommandBufferBeginInfo : IEquatable<VkCommandBufferBeginInfo>
{
	public const VkStructureType TYPE = VkStructureType.CommandBufferBeginInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkCommandBufferUsageFlags Flags;
	public VkCommandBufferInheritanceInfo* InheritanceInfo;

	public VkCommandBufferBeginInfo(
		VkCommandBufferUsageFlags flags = default,
		VkCommandBufferInheritanceInfo* inheritanceInfo = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		InheritanceInfo = inheritanceInfo;
	}

	public readonly override bool Equals(object? o) => (o is VkCommandBufferBeginInfo s) && (this == s);
	readonly bool IEquatable<VkCommandBufferBeginInfo>.Equals(VkCommandBufferBeginInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ ((ulong)InheritanceInfo).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkCommandBufferBeginInfo l, in VkCommandBufferBeginInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.InheritanceInfo == r.InheritanceInfo)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkCommandBufferBeginInfo l, in VkCommandBufferBeginInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.InheritanceInfo != r.InheritanceInfo)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkCommandBufferBeginInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkRenderPassBeginInfo : IEquatable<VkRenderPassBeginInfo>
{
	public const VkStructureType TYPE = VkStructureType.RenderPassBeginInfo;

	public VkStructureType sType;
	public void* pNext;
	public VulkanHandle<VkRenderPass> RenderPass;
	public VulkanHandle<VkFramebuffer> Framebuffer;
	public VkRect2D RenderArea;
	public uint ClearValueCount;
	public VkClearValue* ClearValues;

	public VkRenderPassBeginInfo(
		VulkanHandle<VkRenderPass> renderPass = default,
		VulkanHandle<VkFramebuffer> framebuffer = default,
		VkRect2D renderArea = default,
		uint clearValueCount = default,
		VkClearValue* clearValues = default
	) {
		sType = TYPE;
		pNext = null;
		RenderPass = renderPass;
		Framebuffer = framebuffer;
		RenderArea = renderArea;
		ClearValueCount = clearValueCount;
		ClearValues = clearValues;
	}

	public readonly override bool Equals(object? o) => (o is VkRenderPassBeginInfo s) && (this == s);
	readonly bool IEquatable<VkRenderPassBeginInfo>.Equals(VkRenderPassBeginInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ RenderPass.GetHashCode() ^ Framebuffer.GetHashCode()
			^ RenderArea.GetHashCode() ^ ClearValueCount.GetHashCode() ^ ((ulong)ClearValues).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkRenderPassBeginInfo l, in VkRenderPassBeginInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.RenderPass == r.RenderPass) && (l.Framebuffer == r.Framebuffer)
			&& (l.RenderArea == r.RenderArea) && (l.ClearValueCount == r.ClearValueCount) && (l.ClearValues == r.ClearValues)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkRenderPassBeginInfo l, in VkRenderPassBeginInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.RenderPass != r.RenderPass) || (l.Framebuffer != r.Framebuffer)
			|| (l.RenderArea != r.RenderArea) || (l.ClearValueCount != r.ClearValueCount) || (l.ClearValues != r.ClearValues)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkRenderPassBeginInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Explicit)]
public unsafe partial struct VkClearColorValue : IEquatable<VkClearColorValue>
{
	[FieldOffset(0)]
	public fixed float Float32[4];
	[FieldOffset(0)]
	public fixed int Int32[4];
	[FieldOffset(0)]
	public fixed uint Uint32[4];

	public VkClearColorValue(
		in float float32_0, 
		in float float32_1, 
		in float float32_2, 
		in float float32_3
	) {
		Float32[0] = float32_0;
		Float32[1] = float32_1;
		Float32[2] = float32_2;
		Float32[3] = float32_3;
	}

	public VkClearColorValue(
		in int int32_0, 
		in int int32_1, 
		in int int32_2, 
		in int int32_3
	) {
		Int32[0] = int32_0;
		Int32[1] = int32_1;
		Int32[2] = int32_2;
		Int32[3] = int32_3;
	}

	public VkClearColorValue(
		in uint uint32_0, 
		in uint uint32_1, 
		in uint uint32_2, 
		in uint uint32_3
	) {
		Uint32[0] = uint32_0;
		Uint32[1] = uint32_1;
		Uint32[2] = uint32_2;
		Uint32[3] = uint32_3;
	}

	public readonly override bool Equals(object? o) => (o is VkClearColorValue s) && (this == s);
	readonly bool IEquatable<VkClearColorValue>.Equals(VkClearColorValue o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Float32[0].GetHashCode() ^ Float32[1].GetHashCode() ^ Float32[2].GetHashCode() ^ Float32[3].GetHashCode()
			^ Int32[0].GetHashCode() ^ Int32[1].GetHashCode() ^ Int32[2].GetHashCode() ^ Int32[3].GetHashCode()
			^ Uint32[0].GetHashCode() ^ Uint32[1].GetHashCode() ^ Uint32[2].GetHashCode() ^ Uint32[3].GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkClearColorValue l, in VkClearColorValue r)
	{
		return
			(l.Float32[0] == r.Float32[0]) && (l.Float32[1] == r.Float32[1]) && (l.Float32[2] == r.Float32[2]) && (l.Float32[3] == r.Float32[3])
			&& (l.Int32[0] == r.Int32[0]) && (l.Int32[1] == r.Int32[1]) && (l.Int32[2] == r.Int32[2]) && (l.Int32[3] == r.Int32[3])
			&& (l.Uint32[0] == r.Uint32[0]) && (l.Uint32[1] == r.Uint32[1]) && (l.Uint32[2] == r.Uint32[2]) && (l.Uint32[3] == r.Uint32[3])
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkClearColorValue l, in VkClearColorValue r)
	{
		return
			(l.Float32[0] != r.Float32[0]) || (l.Float32[1] != r.Float32[1]) || (l.Float32[2] != r.Float32[2]) || (l.Float32[3] != r.Float32[3])
			|| (l.Int32[0] != r.Int32[0]) || (l.Int32[1] != r.Int32[1]) || (l.Int32[2] != r.Int32[2]) || (l.Int32[3] != r.Int32[3])
			|| (l.Uint32[0] != r.Uint32[0]) || (l.Uint32[1] != r.Uint32[1]) || (l.Uint32[2] != r.Uint32[2]) || (l.Uint32[3] != r.Uint32[3])
			;
	}

}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkClearDepthStencilValue : IEquatable<VkClearDepthStencilValue>
{
	public float Depth;
	public uint Stencil;

	public VkClearDepthStencilValue(
		float depth = default,
		uint stencil = default
	) {
		Depth = depth;
		Stencil = stencil;
	}

	public readonly override bool Equals(object? o) => (o is VkClearDepthStencilValue s) && (this == s);
	readonly bool IEquatable<VkClearDepthStencilValue>.Equals(VkClearDepthStencilValue o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Depth.GetHashCode() ^ Stencil.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkClearDepthStencilValue l, in VkClearDepthStencilValue r)
	{
		return
			(l.Depth == r.Depth) && (l.Stencil == r.Stencil)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkClearDepthStencilValue l, in VkClearDepthStencilValue r)
	{
		return
			(l.Depth != r.Depth) || (l.Stencil != r.Stencil)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkClearDepthStencilValue s) => s = new();
}

[StructLayout(LayoutKind.Explicit)]
public unsafe partial struct VkClearValue : IEquatable<VkClearValue>
{
	[FieldOffset(0)]
	public VkClearColorValue Color;
	[FieldOffset(0)]
	public VkClearDepthStencilValue DepthStencil;

	public VkClearValue(in VkClearColorValue color) : this() => Color = color;

	public VkClearValue(in VkClearDepthStencilValue depthStencil) : this() => DepthStencil = depthStencil;

	public readonly override bool Equals(object? o) => (o is VkClearValue s) && (this == s);
	readonly bool IEquatable<VkClearValue>.Equals(VkClearValue o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Color.GetHashCode() ^ DepthStencil.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkClearValue l, in VkClearValue r)
	{
		return
			(l.Color == r.Color) && (l.DepthStencil == r.DepthStencil)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkClearValue l, in VkClearValue r)
	{
		return
			(l.Color != r.Color) || (l.DepthStencil != r.DepthStencil)
			;
	}

}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkClearAttachment : IEquatable<VkClearAttachment>
{
	public VkImageAspectFlags AspectMask;
	public uint ColorAttachment;
	public VkClearValue ClearValue;

	public VkClearAttachment(
		VkImageAspectFlags aspectMask = default,
		uint colorAttachment = default,
		VkClearValue clearValue = default
	) {
		AspectMask = aspectMask;
		ColorAttachment = colorAttachment;
		ClearValue = clearValue;
	}

	public readonly override bool Equals(object? o) => (o is VkClearAttachment s) && (this == s);
	readonly bool IEquatable<VkClearAttachment>.Equals(VkClearAttachment o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			AspectMask.GetHashCode() ^ ColorAttachment.GetHashCode() ^ ClearValue.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkClearAttachment l, in VkClearAttachment r)
	{
		return
			(l.AspectMask == r.AspectMask) && (l.ColorAttachment == r.ColorAttachment) && (l.ClearValue == r.ClearValue)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkClearAttachment l, in VkClearAttachment r)
	{
		return
			(l.AspectMask != r.AspectMask) || (l.ColorAttachment != r.ColorAttachment) || (l.ClearValue != r.ClearValue)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkClearAttachment s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkAttachmentDescription : IEquatable<VkAttachmentDescription>
{
	public VkAttachmentDescriptionFlags Flags;
	public VkFormat Format;
	public VkSampleCountFlags Samples;
	public VkAttachmentLoadOp LoadOp;
	public VkAttachmentStoreOp StoreOp;
	public VkAttachmentLoadOp StencilLoadOp;
	public VkAttachmentStoreOp StencilStoreOp;
	public VkImageLayout InitialLayout;
	public VkImageLayout FinalLayout;

	public VkAttachmentDescription(
		VkAttachmentDescriptionFlags flags = default,
		VkFormat format = default,
		VkSampleCountFlags samples = default,
		VkAttachmentLoadOp loadOp = default,
		VkAttachmentStoreOp storeOp = default,
		VkAttachmentLoadOp stencilLoadOp = default,
		VkAttachmentStoreOp stencilStoreOp = default,
		VkImageLayout initialLayout = default,
		VkImageLayout finalLayout = default
	) {
		Flags = flags;
		Format = format;
		Samples = samples;
		LoadOp = loadOp;
		StoreOp = storeOp;
		StencilLoadOp = stencilLoadOp;
		StencilStoreOp = stencilStoreOp;
		InitialLayout = initialLayout;
		FinalLayout = finalLayout;
	}

	public readonly override bool Equals(object? o) => (o is VkAttachmentDescription s) && (this == s);
	readonly bool IEquatable<VkAttachmentDescription>.Equals(VkAttachmentDescription o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Flags.GetHashCode() ^ Format.GetHashCode() ^ Samples.GetHashCode() ^ LoadOp.GetHashCode()
			^ StoreOp.GetHashCode() ^ StencilLoadOp.GetHashCode() ^ StencilStoreOp.GetHashCode() ^ InitialLayout.GetHashCode()
			^ FinalLayout.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkAttachmentDescription l, in VkAttachmentDescription r)
	{
		return
			(l.Flags == r.Flags) && (l.Format == r.Format) && (l.Samples == r.Samples) && (l.LoadOp == r.LoadOp)
			&& (l.StoreOp == r.StoreOp) && (l.StencilLoadOp == r.StencilLoadOp) && (l.StencilStoreOp == r.StencilStoreOp) && (l.InitialLayout == r.InitialLayout)
			&& (l.FinalLayout == r.FinalLayout)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkAttachmentDescription l, in VkAttachmentDescription r)
	{
		return
			(l.Flags != r.Flags) || (l.Format != r.Format) || (l.Samples != r.Samples) || (l.LoadOp != r.LoadOp)
			|| (l.StoreOp != r.StoreOp) || (l.StencilLoadOp != r.StencilLoadOp) || (l.StencilStoreOp != r.StencilStoreOp) || (l.InitialLayout != r.InitialLayout)
			|| (l.FinalLayout != r.FinalLayout)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkAttachmentDescription s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkAttachmentReference : IEquatable<VkAttachmentReference>
{
	public uint Attachment;
	public VkImageLayout Layout;

	public VkAttachmentReference(
		uint attachment = default,
		VkImageLayout layout = default
	) {
		Attachment = attachment;
		Layout = layout;
	}

	public readonly override bool Equals(object? o) => (o is VkAttachmentReference s) && (this == s);
	readonly bool IEquatable<VkAttachmentReference>.Equals(VkAttachmentReference o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Attachment.GetHashCode() ^ Layout.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkAttachmentReference l, in VkAttachmentReference r)
	{
		return
			(l.Attachment == r.Attachment) && (l.Layout == r.Layout)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkAttachmentReference l, in VkAttachmentReference r)
	{
		return
			(l.Attachment != r.Attachment) || (l.Layout != r.Layout)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkAttachmentReference s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkSubpassDescription : IEquatable<VkSubpassDescription>
{
	public VkSubpassDescriptionFlags Flags;
	public VkPipelineBindPoint PipelineBindPoint;
	public uint InputAttachmentCount;
	public VkAttachmentReference* InputAttachments;
	public uint ColorAttachmentCount;
	public VkAttachmentReference* ColorAttachments;
	public VkAttachmentReference* ResolveAttachments;
	public VkAttachmentReference* DepthStencilAttachment;
	public uint PreserveAttachmentCount;
	public uint* PreserveAttachments;

	public VkSubpassDescription(
		VkSubpassDescriptionFlags flags = default,
		VkPipelineBindPoint pipelineBindPoint = default,
		uint inputAttachmentCount = default,
		VkAttachmentReference* inputAttachments = default,
		uint colorAttachmentCount = default,
		VkAttachmentReference* colorAttachments = default,
		VkAttachmentReference* resolveAttachments = default,
		VkAttachmentReference* depthStencilAttachment = default,
		uint preserveAttachmentCount = default,
		uint* preserveAttachments = default
	) {
		Flags = flags;
		PipelineBindPoint = pipelineBindPoint;
		InputAttachmentCount = inputAttachmentCount;
		InputAttachments = inputAttachments;
		ColorAttachmentCount = colorAttachmentCount;
		ColorAttachments = colorAttachments;
		ResolveAttachments = resolveAttachments;
		DepthStencilAttachment = depthStencilAttachment;
		PreserveAttachmentCount = preserveAttachmentCount;
		PreserveAttachments = preserveAttachments;
	}

	public readonly override bool Equals(object? o) => (o is VkSubpassDescription s) && (this == s);
	readonly bool IEquatable<VkSubpassDescription>.Equals(VkSubpassDescription o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Flags.GetHashCode() ^ PipelineBindPoint.GetHashCode() ^ InputAttachmentCount.GetHashCode() ^ ((ulong)InputAttachments).GetHashCode()
			^ ColorAttachmentCount.GetHashCode() ^ ((ulong)ColorAttachments).GetHashCode() ^ ((ulong)ResolveAttachments).GetHashCode() ^ ((ulong)DepthStencilAttachment).GetHashCode()
			^ PreserveAttachmentCount.GetHashCode() ^ ((ulong)PreserveAttachments).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkSubpassDescription l, in VkSubpassDescription r)
	{
		return
			(l.Flags == r.Flags) && (l.PipelineBindPoint == r.PipelineBindPoint) && (l.InputAttachmentCount == r.InputAttachmentCount) && (l.InputAttachments == r.InputAttachments)
			&& (l.ColorAttachmentCount == r.ColorAttachmentCount) && (l.ColorAttachments == r.ColorAttachments) && (l.ResolveAttachments == r.ResolveAttachments) && (l.DepthStencilAttachment == r.DepthStencilAttachment)
			&& (l.PreserveAttachmentCount == r.PreserveAttachmentCount) && (l.PreserveAttachments == r.PreserveAttachments)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkSubpassDescription l, in VkSubpassDescription r)
	{
		return
			(l.Flags != r.Flags) || (l.PipelineBindPoint != r.PipelineBindPoint) || (l.InputAttachmentCount != r.InputAttachmentCount) || (l.InputAttachments != r.InputAttachments)
			|| (l.ColorAttachmentCount != r.ColorAttachmentCount) || (l.ColorAttachments != r.ColorAttachments) || (l.ResolveAttachments != r.ResolveAttachments) || (l.DepthStencilAttachment != r.DepthStencilAttachment)
			|| (l.PreserveAttachmentCount != r.PreserveAttachmentCount) || (l.PreserveAttachments != r.PreserveAttachments)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkSubpassDescription s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkSubpassDependency : IEquatable<VkSubpassDependency>
{
	public uint SrcSubpass;
	public uint DstSubpass;
	public VkPipelineStageFlags SrcStageMask;
	public VkPipelineStageFlags DstStageMask;
	public VkAccessFlags SrcAccessMask;
	public VkAccessFlags DstAccessMask;
	public VkDependencyFlags DependencyFlags;

	public VkSubpassDependency(
		uint srcSubpass = default,
		uint dstSubpass = default,
		VkPipelineStageFlags srcStageMask = default,
		VkPipelineStageFlags dstStageMask = default,
		VkAccessFlags srcAccessMask = default,
		VkAccessFlags dstAccessMask = default,
		VkDependencyFlags dependencyFlags = default
	) {
		SrcSubpass = srcSubpass;
		DstSubpass = dstSubpass;
		SrcStageMask = srcStageMask;
		DstStageMask = dstStageMask;
		SrcAccessMask = srcAccessMask;
		DstAccessMask = dstAccessMask;
		DependencyFlags = dependencyFlags;
	}

	public readonly override bool Equals(object? o) => (o is VkSubpassDependency s) && (this == s);
	readonly bool IEquatable<VkSubpassDependency>.Equals(VkSubpassDependency o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			SrcSubpass.GetHashCode() ^ DstSubpass.GetHashCode() ^ SrcStageMask.GetHashCode() ^ DstStageMask.GetHashCode()
			^ SrcAccessMask.GetHashCode() ^ DstAccessMask.GetHashCode() ^ DependencyFlags.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkSubpassDependency l, in VkSubpassDependency r)
	{
		return
			(l.SrcSubpass == r.SrcSubpass) && (l.DstSubpass == r.DstSubpass) && (l.SrcStageMask == r.SrcStageMask) && (l.DstStageMask == r.DstStageMask)
			&& (l.SrcAccessMask == r.SrcAccessMask) && (l.DstAccessMask == r.DstAccessMask) && (l.DependencyFlags == r.DependencyFlags)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkSubpassDependency l, in VkSubpassDependency r)
	{
		return
			(l.SrcSubpass != r.SrcSubpass) || (l.DstSubpass != r.DstSubpass) || (l.SrcStageMask != r.SrcStageMask) || (l.DstStageMask != r.DstStageMask)
			|| (l.SrcAccessMask != r.SrcAccessMask) || (l.DstAccessMask != r.DstAccessMask) || (l.DependencyFlags != r.DependencyFlags)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkSubpassDependency s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkRenderPassCreateInfo : IEquatable<VkRenderPassCreateInfo>
{
	public const VkStructureType TYPE = VkStructureType.RenderPassCreateInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkRenderPassCreateFlags Flags;
	public uint AttachmentCount;
	public VkAttachmentDescription* Attachments;
	public uint SubpassCount;
	public VkSubpassDescription* Subpasses;
	public uint DependencyCount;
	public VkSubpassDependency* Dependencies;

	public VkRenderPassCreateInfo(
		VkRenderPassCreateFlags flags = default,
		uint attachmentCount = default,
		VkAttachmentDescription* attachments = default,
		uint subpassCount = default,
		VkSubpassDescription* subpasses = default,
		uint dependencyCount = default,
		VkSubpassDependency* dependencies = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		AttachmentCount = attachmentCount;
		Attachments = attachments;
		SubpassCount = subpassCount;
		Subpasses = subpasses;
		DependencyCount = dependencyCount;
		Dependencies = dependencies;
	}

	public readonly override bool Equals(object? o) => (o is VkRenderPassCreateInfo s) && (this == s);
	readonly bool IEquatable<VkRenderPassCreateInfo>.Equals(VkRenderPassCreateInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ AttachmentCount.GetHashCode()
			^ ((ulong)Attachments).GetHashCode() ^ SubpassCount.GetHashCode() ^ ((ulong)Subpasses).GetHashCode() ^ DependencyCount.GetHashCode()
			^ ((ulong)Dependencies).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkRenderPassCreateInfo l, in VkRenderPassCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.AttachmentCount == r.AttachmentCount)
			&& (l.Attachments == r.Attachments) && (l.SubpassCount == r.SubpassCount) && (l.Subpasses == r.Subpasses) && (l.DependencyCount == r.DependencyCount)
			&& (l.Dependencies == r.Dependencies)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkRenderPassCreateInfo l, in VkRenderPassCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.AttachmentCount != r.AttachmentCount)
			|| (l.Attachments != r.Attachments) || (l.SubpassCount != r.SubpassCount) || (l.Subpasses != r.Subpasses) || (l.DependencyCount != r.DependencyCount)
			|| (l.Dependencies != r.Dependencies)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkRenderPassCreateInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkEventCreateInfo : IEquatable<VkEventCreateInfo>
{
	public const VkStructureType TYPE = VkStructureType.EventCreateInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkEventCreateFlags Flags;

	public VkEventCreateInfo(
		VkEventCreateFlags flags = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
	}

	public readonly override bool Equals(object? o) => (o is VkEventCreateInfo s) && (this == s);
	readonly bool IEquatable<VkEventCreateInfo>.Equals(VkEventCreateInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkEventCreateInfo l, in VkEventCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkEventCreateInfo l, in VkEventCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkEventCreateInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkFenceCreateInfo : IEquatable<VkFenceCreateInfo>
{
	public const VkStructureType TYPE = VkStructureType.FenceCreateInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkFenceCreateFlags Flags;

	public VkFenceCreateInfo(
		VkFenceCreateFlags flags = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
	}

	public readonly override bool Equals(object? o) => (o is VkFenceCreateInfo s) && (this == s);
	readonly bool IEquatable<VkFenceCreateInfo>.Equals(VkFenceCreateInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkFenceCreateInfo l, in VkFenceCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkFenceCreateInfo l, in VkFenceCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkFenceCreateInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceFeatures : IEquatable<VkPhysicalDeviceFeatures>
{
	public VkBool32 RobustBufferAccess;
	public VkBool32 FullDrawIndexUint32;
	public VkBool32 ImageCubeArray;
	public VkBool32 IndependentBlend;
	public VkBool32 GeometryShader;
	public VkBool32 TessellationShader;
	public VkBool32 SampleRateShading;
	public VkBool32 DualSrcBlend;
	public VkBool32 LogicOp;
	public VkBool32 MultiDrawIndirect;
	public VkBool32 DrawIndirectFirstInstance;
	public VkBool32 DepthClamp;
	public VkBool32 DepthBiasClamp;
	public VkBool32 FillModeNonSolid;
	public VkBool32 DepthBounds;
	public VkBool32 WideLines;
	public VkBool32 LargePoints;
	public VkBool32 AlphaToOne;
	public VkBool32 MultiViewport;
	public VkBool32 SamplerAnisotropy;
	public VkBool32 TextureCompressionETC2;
	public VkBool32 TextureCompressionASTC_LDR;
	public VkBool32 TextureCompressionBC;
	public VkBool32 OcclusionQueryPrecise;
	public VkBool32 PipelineStatisticsQuery;
	public VkBool32 VertexPipelineStoresAndAtomics;
	public VkBool32 FragmentStoresAndAtomics;
	public VkBool32 ShaderTessellationAndGeometryPointSize;
	public VkBool32 ShaderImageGatherExtended;
	public VkBool32 ShaderStorageImageExtendedFormats;
	public VkBool32 ShaderStorageImageMultisample;
	public VkBool32 ShaderStorageImageReadWithoutFormat;
	public VkBool32 ShaderStorageImageWriteWithoutFormat;
	public VkBool32 ShaderUniformBufferArrayDynamicIndexing;
	public VkBool32 ShaderSampledImageArrayDynamicIndexing;
	public VkBool32 ShaderStorageBufferArrayDynamicIndexing;
	public VkBool32 ShaderStorageImageArrayDynamicIndexing;
	public VkBool32 ShaderClipDistance;
	public VkBool32 ShaderCullDistance;
	public VkBool32 ShaderFloat64;
	public VkBool32 ShaderInt64;
	public VkBool32 ShaderInt16;
	public VkBool32 ShaderResourceResidency;
	public VkBool32 ShaderResourceMinLod;
	public VkBool32 SparseBinding;
	public VkBool32 SparseResidencyBuffer;
	public VkBool32 SparseResidencyImage2D;
	public VkBool32 SparseResidencyImage3D;
	public VkBool32 SparseResidency2Samples;
	public VkBool32 SparseResidency4Samples;
	public VkBool32 SparseResidency8Samples;
	public VkBool32 SparseResidency16Samples;
	public VkBool32 SparseResidencyAliased;
	public VkBool32 VariableMultisampleRate;
	public VkBool32 InheritedQueries;

	public VkPhysicalDeviceFeatures(
		VkBool32 robustBufferAccess = default,
		VkBool32 fullDrawIndexUint32 = default,
		VkBool32 imageCubeArray = default,
		VkBool32 independentBlend = default,
		VkBool32 geometryShader = default,
		VkBool32 tessellationShader = default,
		VkBool32 sampleRateShading = default,
		VkBool32 dualSrcBlend = default,
		VkBool32 logicOp = default,
		VkBool32 multiDrawIndirect = default,
		VkBool32 drawIndirectFirstInstance = default,
		VkBool32 depthClamp = default,
		VkBool32 depthBiasClamp = default,
		VkBool32 fillModeNonSolid = default,
		VkBool32 depthBounds = default,
		VkBool32 wideLines = default,
		VkBool32 largePoints = default,
		VkBool32 alphaToOne = default,
		VkBool32 multiViewport = default,
		VkBool32 samplerAnisotropy = default,
		VkBool32 textureCompressionETC2 = default,
		VkBool32 textureCompressionASTC_LDR = default,
		VkBool32 textureCompressionBC = default,
		VkBool32 occlusionQueryPrecise = default,
		VkBool32 pipelineStatisticsQuery = default,
		VkBool32 vertexPipelineStoresAndAtomics = default,
		VkBool32 fragmentStoresAndAtomics = default,
		VkBool32 shaderTessellationAndGeometryPointSize = default,
		VkBool32 shaderImageGatherExtended = default,
		VkBool32 shaderStorageImageExtendedFormats = default,
		VkBool32 shaderStorageImageMultisample = default,
		VkBool32 shaderStorageImageReadWithoutFormat = default,
		VkBool32 shaderStorageImageWriteWithoutFormat = default,
		VkBool32 shaderUniformBufferArrayDynamicIndexing = default,
		VkBool32 shaderSampledImageArrayDynamicIndexing = default,
		VkBool32 shaderStorageBufferArrayDynamicIndexing = default,
		VkBool32 shaderStorageImageArrayDynamicIndexing = default,
		VkBool32 shaderClipDistance = default,
		VkBool32 shaderCullDistance = default,
		VkBool32 shaderFloat64 = default,
		VkBool32 shaderInt64 = default,
		VkBool32 shaderInt16 = default,
		VkBool32 shaderResourceResidency = default,
		VkBool32 shaderResourceMinLod = default,
		VkBool32 sparseBinding = default,
		VkBool32 sparseResidencyBuffer = default,
		VkBool32 sparseResidencyImage2D = default,
		VkBool32 sparseResidencyImage3D = default,
		VkBool32 sparseResidency2Samples = default,
		VkBool32 sparseResidency4Samples = default,
		VkBool32 sparseResidency8Samples = default,
		VkBool32 sparseResidency16Samples = default,
		VkBool32 sparseResidencyAliased = default,
		VkBool32 variableMultisampleRate = default,
		VkBool32 inheritedQueries = default
	) {
		RobustBufferAccess = robustBufferAccess;
		FullDrawIndexUint32 = fullDrawIndexUint32;
		ImageCubeArray = imageCubeArray;
		IndependentBlend = independentBlend;
		GeometryShader = geometryShader;
		TessellationShader = tessellationShader;
		SampleRateShading = sampleRateShading;
		DualSrcBlend = dualSrcBlend;
		LogicOp = logicOp;
		MultiDrawIndirect = multiDrawIndirect;
		DrawIndirectFirstInstance = drawIndirectFirstInstance;
		DepthClamp = depthClamp;
		DepthBiasClamp = depthBiasClamp;
		FillModeNonSolid = fillModeNonSolid;
		DepthBounds = depthBounds;
		WideLines = wideLines;
		LargePoints = largePoints;
		AlphaToOne = alphaToOne;
		MultiViewport = multiViewport;
		SamplerAnisotropy = samplerAnisotropy;
		TextureCompressionETC2 = textureCompressionETC2;
		TextureCompressionASTC_LDR = textureCompressionASTC_LDR;
		TextureCompressionBC = textureCompressionBC;
		OcclusionQueryPrecise = occlusionQueryPrecise;
		PipelineStatisticsQuery = pipelineStatisticsQuery;
		VertexPipelineStoresAndAtomics = vertexPipelineStoresAndAtomics;
		FragmentStoresAndAtomics = fragmentStoresAndAtomics;
		ShaderTessellationAndGeometryPointSize = shaderTessellationAndGeometryPointSize;
		ShaderImageGatherExtended = shaderImageGatherExtended;
		ShaderStorageImageExtendedFormats = shaderStorageImageExtendedFormats;
		ShaderStorageImageMultisample = shaderStorageImageMultisample;
		ShaderStorageImageReadWithoutFormat = shaderStorageImageReadWithoutFormat;
		ShaderStorageImageWriteWithoutFormat = shaderStorageImageWriteWithoutFormat;
		ShaderUniformBufferArrayDynamicIndexing = shaderUniformBufferArrayDynamicIndexing;
		ShaderSampledImageArrayDynamicIndexing = shaderSampledImageArrayDynamicIndexing;
		ShaderStorageBufferArrayDynamicIndexing = shaderStorageBufferArrayDynamicIndexing;
		ShaderStorageImageArrayDynamicIndexing = shaderStorageImageArrayDynamicIndexing;
		ShaderClipDistance = shaderClipDistance;
		ShaderCullDistance = shaderCullDistance;
		ShaderFloat64 = shaderFloat64;
		ShaderInt64 = shaderInt64;
		ShaderInt16 = shaderInt16;
		ShaderResourceResidency = shaderResourceResidency;
		ShaderResourceMinLod = shaderResourceMinLod;
		SparseBinding = sparseBinding;
		SparseResidencyBuffer = sparseResidencyBuffer;
		SparseResidencyImage2D = sparseResidencyImage2D;
		SparseResidencyImage3D = sparseResidencyImage3D;
		SparseResidency2Samples = sparseResidency2Samples;
		SparseResidency4Samples = sparseResidency4Samples;
		SparseResidency8Samples = sparseResidency8Samples;
		SparseResidency16Samples = sparseResidency16Samples;
		SparseResidencyAliased = sparseResidencyAliased;
		VariableMultisampleRate = variableMultisampleRate;
		InheritedQueries = inheritedQueries;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceFeatures s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceFeatures>.Equals(VkPhysicalDeviceFeatures o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			RobustBufferAccess.GetHashCode() ^ FullDrawIndexUint32.GetHashCode() ^ ImageCubeArray.GetHashCode() ^ IndependentBlend.GetHashCode()
			^ GeometryShader.GetHashCode() ^ TessellationShader.GetHashCode() ^ SampleRateShading.GetHashCode() ^ DualSrcBlend.GetHashCode()
			^ LogicOp.GetHashCode() ^ MultiDrawIndirect.GetHashCode() ^ DrawIndirectFirstInstance.GetHashCode() ^ DepthClamp.GetHashCode()
			^ DepthBiasClamp.GetHashCode() ^ FillModeNonSolid.GetHashCode() ^ DepthBounds.GetHashCode() ^ WideLines.GetHashCode()
			^ LargePoints.GetHashCode() ^ AlphaToOne.GetHashCode() ^ MultiViewport.GetHashCode() ^ SamplerAnisotropy.GetHashCode()
			^ TextureCompressionETC2.GetHashCode() ^ TextureCompressionASTC_LDR.GetHashCode() ^ TextureCompressionBC.GetHashCode() ^ OcclusionQueryPrecise.GetHashCode()
			^ PipelineStatisticsQuery.GetHashCode() ^ VertexPipelineStoresAndAtomics.GetHashCode() ^ FragmentStoresAndAtomics.GetHashCode() ^ ShaderTessellationAndGeometryPointSize.GetHashCode()
			^ ShaderImageGatherExtended.GetHashCode() ^ ShaderStorageImageExtendedFormats.GetHashCode() ^ ShaderStorageImageMultisample.GetHashCode() ^ ShaderStorageImageReadWithoutFormat.GetHashCode()
			^ ShaderStorageImageWriteWithoutFormat.GetHashCode() ^ ShaderUniformBufferArrayDynamicIndexing.GetHashCode() ^ ShaderSampledImageArrayDynamicIndexing.GetHashCode() ^ ShaderStorageBufferArrayDynamicIndexing.GetHashCode()
			^ ShaderStorageImageArrayDynamicIndexing.GetHashCode() ^ ShaderClipDistance.GetHashCode() ^ ShaderCullDistance.GetHashCode() ^ ShaderFloat64.GetHashCode()
			^ ShaderInt64.GetHashCode() ^ ShaderInt16.GetHashCode() ^ ShaderResourceResidency.GetHashCode() ^ ShaderResourceMinLod.GetHashCode()
			^ SparseBinding.GetHashCode() ^ SparseResidencyBuffer.GetHashCode() ^ SparseResidencyImage2D.GetHashCode() ^ SparseResidencyImage3D.GetHashCode()
			^ SparseResidency2Samples.GetHashCode() ^ SparseResidency4Samples.GetHashCode() ^ SparseResidency8Samples.GetHashCode() ^ SparseResidency16Samples.GetHashCode()
			^ SparseResidencyAliased.GetHashCode() ^ VariableMultisampleRate.GetHashCode() ^ InheritedQueries.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceFeatures l, in VkPhysicalDeviceFeatures r)
	{
		return
			(l.RobustBufferAccess == r.RobustBufferAccess) && (l.FullDrawIndexUint32 == r.FullDrawIndexUint32) && (l.ImageCubeArray == r.ImageCubeArray) && (l.IndependentBlend == r.IndependentBlend)
			&& (l.GeometryShader == r.GeometryShader) && (l.TessellationShader == r.TessellationShader) && (l.SampleRateShading == r.SampleRateShading) && (l.DualSrcBlend == r.DualSrcBlend)
			&& (l.LogicOp == r.LogicOp) && (l.MultiDrawIndirect == r.MultiDrawIndirect) && (l.DrawIndirectFirstInstance == r.DrawIndirectFirstInstance) && (l.DepthClamp == r.DepthClamp)
			&& (l.DepthBiasClamp == r.DepthBiasClamp) && (l.FillModeNonSolid == r.FillModeNonSolid) && (l.DepthBounds == r.DepthBounds) && (l.WideLines == r.WideLines)
			&& (l.LargePoints == r.LargePoints) && (l.AlphaToOne == r.AlphaToOne) && (l.MultiViewport == r.MultiViewport) && (l.SamplerAnisotropy == r.SamplerAnisotropy)
			&& (l.TextureCompressionETC2 == r.TextureCompressionETC2) && (l.TextureCompressionASTC_LDR == r.TextureCompressionASTC_LDR) && (l.TextureCompressionBC == r.TextureCompressionBC) && (l.OcclusionQueryPrecise == r.OcclusionQueryPrecise)
			&& (l.PipelineStatisticsQuery == r.PipelineStatisticsQuery) && (l.VertexPipelineStoresAndAtomics == r.VertexPipelineStoresAndAtomics) && (l.FragmentStoresAndAtomics == r.FragmentStoresAndAtomics) && (l.ShaderTessellationAndGeometryPointSize == r.ShaderTessellationAndGeometryPointSize)
			&& (l.ShaderImageGatherExtended == r.ShaderImageGatherExtended) && (l.ShaderStorageImageExtendedFormats == r.ShaderStorageImageExtendedFormats) && (l.ShaderStorageImageMultisample == r.ShaderStorageImageMultisample) && (l.ShaderStorageImageReadWithoutFormat == r.ShaderStorageImageReadWithoutFormat)
			&& (l.ShaderStorageImageWriteWithoutFormat == r.ShaderStorageImageWriteWithoutFormat) && (l.ShaderUniformBufferArrayDynamicIndexing == r.ShaderUniformBufferArrayDynamicIndexing) && (l.ShaderSampledImageArrayDynamicIndexing == r.ShaderSampledImageArrayDynamicIndexing) && (l.ShaderStorageBufferArrayDynamicIndexing == r.ShaderStorageBufferArrayDynamicIndexing)
			&& (l.ShaderStorageImageArrayDynamicIndexing == r.ShaderStorageImageArrayDynamicIndexing) && (l.ShaderClipDistance == r.ShaderClipDistance) && (l.ShaderCullDistance == r.ShaderCullDistance) && (l.ShaderFloat64 == r.ShaderFloat64)
			&& (l.ShaderInt64 == r.ShaderInt64) && (l.ShaderInt16 == r.ShaderInt16) && (l.ShaderResourceResidency == r.ShaderResourceResidency) && (l.ShaderResourceMinLod == r.ShaderResourceMinLod)
			&& (l.SparseBinding == r.SparseBinding) && (l.SparseResidencyBuffer == r.SparseResidencyBuffer) && (l.SparseResidencyImage2D == r.SparseResidencyImage2D) && (l.SparseResidencyImage3D == r.SparseResidencyImage3D)
			&& (l.SparseResidency2Samples == r.SparseResidency2Samples) && (l.SparseResidency4Samples == r.SparseResidency4Samples) && (l.SparseResidency8Samples == r.SparseResidency8Samples) && (l.SparseResidency16Samples == r.SparseResidency16Samples)
			&& (l.SparseResidencyAliased == r.SparseResidencyAliased) && (l.VariableMultisampleRate == r.VariableMultisampleRate) && (l.InheritedQueries == r.InheritedQueries)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceFeatures l, in VkPhysicalDeviceFeatures r)
	{
		return
			(l.RobustBufferAccess != r.RobustBufferAccess) || (l.FullDrawIndexUint32 != r.FullDrawIndexUint32) || (l.ImageCubeArray != r.ImageCubeArray) || (l.IndependentBlend != r.IndependentBlend)
			|| (l.GeometryShader != r.GeometryShader) || (l.TessellationShader != r.TessellationShader) || (l.SampleRateShading != r.SampleRateShading) || (l.DualSrcBlend != r.DualSrcBlend)
			|| (l.LogicOp != r.LogicOp) || (l.MultiDrawIndirect != r.MultiDrawIndirect) || (l.DrawIndirectFirstInstance != r.DrawIndirectFirstInstance) || (l.DepthClamp != r.DepthClamp)
			|| (l.DepthBiasClamp != r.DepthBiasClamp) || (l.FillModeNonSolid != r.FillModeNonSolid) || (l.DepthBounds != r.DepthBounds) || (l.WideLines != r.WideLines)
			|| (l.LargePoints != r.LargePoints) || (l.AlphaToOne != r.AlphaToOne) || (l.MultiViewport != r.MultiViewport) || (l.SamplerAnisotropy != r.SamplerAnisotropy)
			|| (l.TextureCompressionETC2 != r.TextureCompressionETC2) || (l.TextureCompressionASTC_LDR != r.TextureCompressionASTC_LDR) || (l.TextureCompressionBC != r.TextureCompressionBC) || (l.OcclusionQueryPrecise != r.OcclusionQueryPrecise)
			|| (l.PipelineStatisticsQuery != r.PipelineStatisticsQuery) || (l.VertexPipelineStoresAndAtomics != r.VertexPipelineStoresAndAtomics) || (l.FragmentStoresAndAtomics != r.FragmentStoresAndAtomics) || (l.ShaderTessellationAndGeometryPointSize != r.ShaderTessellationAndGeometryPointSize)
			|| (l.ShaderImageGatherExtended != r.ShaderImageGatherExtended) || (l.ShaderStorageImageExtendedFormats != r.ShaderStorageImageExtendedFormats) || (l.ShaderStorageImageMultisample != r.ShaderStorageImageMultisample) || (l.ShaderStorageImageReadWithoutFormat != r.ShaderStorageImageReadWithoutFormat)
			|| (l.ShaderStorageImageWriteWithoutFormat != r.ShaderStorageImageWriteWithoutFormat) || (l.ShaderUniformBufferArrayDynamicIndexing != r.ShaderUniformBufferArrayDynamicIndexing) || (l.ShaderSampledImageArrayDynamicIndexing != r.ShaderSampledImageArrayDynamicIndexing) || (l.ShaderStorageBufferArrayDynamicIndexing != r.ShaderStorageBufferArrayDynamicIndexing)
			|| (l.ShaderStorageImageArrayDynamicIndexing != r.ShaderStorageImageArrayDynamicIndexing) || (l.ShaderClipDistance != r.ShaderClipDistance) || (l.ShaderCullDistance != r.ShaderCullDistance) || (l.ShaderFloat64 != r.ShaderFloat64)
			|| (l.ShaderInt64 != r.ShaderInt64) || (l.ShaderInt16 != r.ShaderInt16) || (l.ShaderResourceResidency != r.ShaderResourceResidency) || (l.ShaderResourceMinLod != r.ShaderResourceMinLod)
			|| (l.SparseBinding != r.SparseBinding) || (l.SparseResidencyBuffer != r.SparseResidencyBuffer) || (l.SparseResidencyImage2D != r.SparseResidencyImage2D) || (l.SparseResidencyImage3D != r.SparseResidencyImage3D)
			|| (l.SparseResidency2Samples != r.SparseResidency2Samples) || (l.SparseResidency4Samples != r.SparseResidency4Samples) || (l.SparseResidency8Samples != r.SparseResidency8Samples) || (l.SparseResidency16Samples != r.SparseResidency16Samples)
			|| (l.SparseResidencyAliased != r.SparseResidencyAliased) || (l.VariableMultisampleRate != r.VariableMultisampleRate) || (l.InheritedQueries != r.InheritedQueries)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceFeatures s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceSparseProperties : IEquatable<VkPhysicalDeviceSparseProperties>
{
	public VkBool32 ResidencyStandard2DBlockShape;
	public VkBool32 ResidencyStandard2DMultisampleBlockShape;
	public VkBool32 ResidencyStandard3DBlockShape;
	public VkBool32 ResidencyAlignedMipSize;
	public VkBool32 ResidencyNonResidentStrict;

	public VkPhysicalDeviceSparseProperties(
		VkBool32 residencyStandard2DBlockShape = default,
		VkBool32 residencyStandard2DMultisampleBlockShape = default,
		VkBool32 residencyStandard3DBlockShape = default,
		VkBool32 residencyAlignedMipSize = default,
		VkBool32 residencyNonResidentStrict = default
	) {
		ResidencyStandard2DBlockShape = residencyStandard2DBlockShape;
		ResidencyStandard2DMultisampleBlockShape = residencyStandard2DMultisampleBlockShape;
		ResidencyStandard3DBlockShape = residencyStandard3DBlockShape;
		ResidencyAlignedMipSize = residencyAlignedMipSize;
		ResidencyNonResidentStrict = residencyNonResidentStrict;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceSparseProperties s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceSparseProperties>.Equals(VkPhysicalDeviceSparseProperties o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			ResidencyStandard2DBlockShape.GetHashCode() ^ ResidencyStandard2DMultisampleBlockShape.GetHashCode() ^ ResidencyStandard3DBlockShape.GetHashCode() ^ ResidencyAlignedMipSize.GetHashCode()
			^ ResidencyNonResidentStrict.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceSparseProperties l, in VkPhysicalDeviceSparseProperties r)
	{
		return
			(l.ResidencyStandard2DBlockShape == r.ResidencyStandard2DBlockShape) && (l.ResidencyStandard2DMultisampleBlockShape == r.ResidencyStandard2DMultisampleBlockShape) && (l.ResidencyStandard3DBlockShape == r.ResidencyStandard3DBlockShape) && (l.ResidencyAlignedMipSize == r.ResidencyAlignedMipSize)
			&& (l.ResidencyNonResidentStrict == r.ResidencyNonResidentStrict)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceSparseProperties l, in VkPhysicalDeviceSparseProperties r)
	{
		return
			(l.ResidencyStandard2DBlockShape != r.ResidencyStandard2DBlockShape) || (l.ResidencyStandard2DMultisampleBlockShape != r.ResidencyStandard2DMultisampleBlockShape) || (l.ResidencyStandard3DBlockShape != r.ResidencyStandard3DBlockShape) || (l.ResidencyAlignedMipSize != r.ResidencyAlignedMipSize)
			|| (l.ResidencyNonResidentStrict != r.ResidencyNonResidentStrict)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceSparseProperties s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceLimits : IEquatable<VkPhysicalDeviceLimits>
{
	public uint MaxImageDimension1D;
	public uint MaxImageDimension2D;
	public uint MaxImageDimension3D;
	public uint MaxImageDimensionCube;
	public uint MaxImageArrayLayers;
	public uint MaxTexelBufferElements;
	public uint MaxUniformBufferRange;
	public uint MaxStorageBufferRange;
	public uint MaxPushConstantsSize;
	public uint MaxMemoryAllocationCount;
	public uint MaxSamplerAllocationCount;
	public ulong BufferImageGranularity;
	public ulong SparseAddressSpaceSize;
	public uint MaxBoundDescriptorSets;
	public uint MaxPerStageDescriptorSamplers;
	public uint MaxPerStageDescriptorUniformBuffers;
	public uint MaxPerStageDescriptorStorageBuffers;
	public uint MaxPerStageDescriptorSampledImages;
	public uint MaxPerStageDescriptorStorageImages;
	public uint MaxPerStageDescriptorInputAttachments;
	public uint MaxPerStageResources;
	public uint MaxDescriptorSetSamplers;
	public uint MaxDescriptorSetUniformBuffers;
	public uint MaxDescriptorSetUniformBuffersDynamic;
	public uint MaxDescriptorSetStorageBuffers;
	public uint MaxDescriptorSetStorageBuffersDynamic;
	public uint MaxDescriptorSetSampledImages;
	public uint MaxDescriptorSetStorageImages;
	public uint MaxDescriptorSetInputAttachments;
	public uint MaxVertexInputAttributes;
	public uint MaxVertexInputBindings;
	public uint MaxVertexInputAttributeOffset;
	public uint MaxVertexInputBindingStride;
	public uint MaxVertexOutputComponents;
	public uint MaxTessellationGenerationLevel;
	public uint MaxTessellationPatchSize;
	public uint MaxTessellationControlPerVertexInputComponents;
	public uint MaxTessellationControlPerVertexOutputComponents;
	public uint MaxTessellationControlPerPatchOutputComponents;
	public uint MaxTessellationControlTotalOutputComponents;
	public uint MaxTessellationEvaluationInputComponents;
	public uint MaxTessellationEvaluationOutputComponents;
	public uint MaxGeometryShaderInvocations;
	public uint MaxGeometryInputComponents;
	public uint MaxGeometryOutputComponents;
	public uint MaxGeometryOutputVertices;
	public uint MaxGeometryTotalOutputComponents;
	public uint MaxFragmentInputComponents;
	public uint MaxFragmentOutputAttachments;
	public uint MaxFragmentDualSrcAttachments;
	public uint MaxFragmentCombinedOutputResources;
	public uint MaxComputeSharedMemorySize;
	public fixed uint MaxComputeWorkGroupCount[3];
	public uint MaxComputeWorkGroupInvocations;
	public fixed uint MaxComputeWorkGroupSize[3];
	public uint SubPixelPrecisionBits;
	public uint SubTexelPrecisionBits;
	public uint MipmapPrecisionBits;
	public uint MaxDrawIndexedIndexValue;
	public uint MaxDrawIndirectCount;
	public float MaxSamplerLodBias;
	public float MaxSamplerAnisotropy;
	public uint MaxViewports;
	public fixed uint MaxViewportDimensions[2];
	public fixed float ViewportBoundsRange[2];
	public uint ViewportSubPixelBits;
	public ulong MinMemoryMapAlignment;
	public ulong MinTexelBufferOffsetAlignment;
	public ulong MinUniformBufferOffsetAlignment;
	public ulong MinStorageBufferOffsetAlignment;
	public int MinTexelOffset;
	public uint MaxTexelOffset;
	public int MinTexelGatherOffset;
	public uint MaxTexelGatherOffset;
	public float MinInterpolationOffset;
	public float MaxInterpolationOffset;
	public uint SubPixelInterpolationOffsetBits;
	public uint MaxFramebufferWidth;
	public uint MaxFramebufferHeight;
	public uint MaxFramebufferLayers;
	public VkSampleCountFlags FramebufferColorSampleCounts;
	public VkSampleCountFlags FramebufferDepthSampleCounts;
	public VkSampleCountFlags FramebufferStencilSampleCounts;
	public VkSampleCountFlags FramebufferNoAttachmentsSampleCounts;
	public uint MaxColorAttachments;
	public VkSampleCountFlags SampledImageColorSampleCounts;
	public VkSampleCountFlags SampledImageIntegerSampleCounts;
	public VkSampleCountFlags SampledImageDepthSampleCounts;
	public VkSampleCountFlags SampledImageStencilSampleCounts;
	public VkSampleCountFlags StorageImageSampleCounts;
	public uint MaxSampleMaskWords;
	public VkBool32 TimestampComputeAndGraphics;
	public float TimestampPeriod;
	public uint MaxClipDistances;
	public uint MaxCullDistances;
	public uint MaxCombinedClipAndCullDistances;
	public uint DiscreteQueuePriorities;
	public fixed float PointSizeRange[2];
	public fixed float LineWidthRange[2];
	public float PointSizeGranularity;
	public float LineWidthGranularity;
	public VkBool32 StrictLines;
	public VkBool32 StandardSampleLocations;
	public ulong OptimalBufferCopyOffsetAlignment;
	public ulong OptimalBufferCopyRowPitchAlignment;
	public ulong NonCoherentAtomSize;

	public VkPhysicalDeviceLimits(
		uint maxImageDimension1D = default,
		uint maxImageDimension2D = default,
		uint maxImageDimension3D = default,
		uint maxImageDimensionCube = default,
		uint maxImageArrayLayers = default,
		uint maxTexelBufferElements = default,
		uint maxUniformBufferRange = default,
		uint maxStorageBufferRange = default,
		uint maxPushConstantsSize = default,
		uint maxMemoryAllocationCount = default,
		uint maxSamplerAllocationCount = default,
		ulong bufferImageGranularity = default,
		ulong sparseAddressSpaceSize = default,
		uint maxBoundDescriptorSets = default,
		uint maxPerStageDescriptorSamplers = default,
		uint maxPerStageDescriptorUniformBuffers = default,
		uint maxPerStageDescriptorStorageBuffers = default,
		uint maxPerStageDescriptorSampledImages = default,
		uint maxPerStageDescriptorStorageImages = default,
		uint maxPerStageDescriptorInputAttachments = default,
		uint maxPerStageResources = default,
		uint maxDescriptorSetSamplers = default,
		uint maxDescriptorSetUniformBuffers = default,
		uint maxDescriptorSetUniformBuffersDynamic = default,
		uint maxDescriptorSetStorageBuffers = default,
		uint maxDescriptorSetStorageBuffersDynamic = default,
		uint maxDescriptorSetSampledImages = default,
		uint maxDescriptorSetStorageImages = default,
		uint maxDescriptorSetInputAttachments = default,
		uint maxVertexInputAttributes = default,
		uint maxVertexInputBindings = default,
		uint maxVertexInputAttributeOffset = default,
		uint maxVertexInputBindingStride = default,
		uint maxVertexOutputComponents = default,
		uint maxTessellationGenerationLevel = default,
		uint maxTessellationPatchSize = default,
		uint maxTessellationControlPerVertexInputComponents = default,
		uint maxTessellationControlPerVertexOutputComponents = default,
		uint maxTessellationControlPerPatchOutputComponents = default,
		uint maxTessellationControlTotalOutputComponents = default,
		uint maxTessellationEvaluationInputComponents = default,
		uint maxTessellationEvaluationOutputComponents = default,
		uint maxGeometryShaderInvocations = default,
		uint maxGeometryInputComponents = default,
		uint maxGeometryOutputComponents = default,
		uint maxGeometryOutputVertices = default,
		uint maxGeometryTotalOutputComponents = default,
		uint maxFragmentInputComponents = default,
		uint maxFragmentOutputAttachments = default,
		uint maxFragmentDualSrcAttachments = default,
		uint maxFragmentCombinedOutputResources = default,
		uint maxComputeSharedMemorySize = default,
		uint maxComputeWorkGroupCount_0 = default,
		uint maxComputeWorkGroupCount_1 = default,
		uint maxComputeWorkGroupCount_2 = default,
		uint maxComputeWorkGroupInvocations = default,
		uint maxComputeWorkGroupSize_0 = default,
		uint maxComputeWorkGroupSize_1 = default,
		uint maxComputeWorkGroupSize_2 = default,
		uint subPixelPrecisionBits = default,
		uint subTexelPrecisionBits = default,
		uint mipmapPrecisionBits = default,
		uint maxDrawIndexedIndexValue = default,
		uint maxDrawIndirectCount = default,
		float maxSamplerLodBias = default,
		float maxSamplerAnisotropy = default,
		uint maxViewports = default,
		uint maxViewportDimensions_0 = default,
		uint maxViewportDimensions_1 = default,
		float viewportBoundsRange_0 = default,
		float viewportBoundsRange_1 = default,
		uint viewportSubPixelBits = default,
		ulong minMemoryMapAlignment = default,
		ulong minTexelBufferOffsetAlignment = default,
		ulong minUniformBufferOffsetAlignment = default,
		ulong minStorageBufferOffsetAlignment = default,
		int minTexelOffset = default,
		uint maxTexelOffset = default,
		int minTexelGatherOffset = default,
		uint maxTexelGatherOffset = default,
		float minInterpolationOffset = default,
		float maxInterpolationOffset = default,
		uint subPixelInterpolationOffsetBits = default,
		uint maxFramebufferWidth = default,
		uint maxFramebufferHeight = default,
		uint maxFramebufferLayers = default,
		VkSampleCountFlags framebufferColorSampleCounts = default,
		VkSampleCountFlags framebufferDepthSampleCounts = default,
		VkSampleCountFlags framebufferStencilSampleCounts = default,
		VkSampleCountFlags framebufferNoAttachmentsSampleCounts = default,
		uint maxColorAttachments = default,
		VkSampleCountFlags sampledImageColorSampleCounts = default,
		VkSampleCountFlags sampledImageIntegerSampleCounts = default,
		VkSampleCountFlags sampledImageDepthSampleCounts = default,
		VkSampleCountFlags sampledImageStencilSampleCounts = default,
		VkSampleCountFlags storageImageSampleCounts = default,
		uint maxSampleMaskWords = default,
		VkBool32 timestampComputeAndGraphics = default,
		float timestampPeriod = default,
		uint maxClipDistances = default,
		uint maxCullDistances = default,
		uint maxCombinedClipAndCullDistances = default,
		uint discreteQueuePriorities = default,
		float pointSizeRange_0 = default,
		float pointSizeRange_1 = default,
		float lineWidthRange_0 = default,
		float lineWidthRange_1 = default,
		float pointSizeGranularity = default,
		float lineWidthGranularity = default,
		VkBool32 strictLines = default,
		VkBool32 standardSampleLocations = default,
		ulong optimalBufferCopyOffsetAlignment = default,
		ulong optimalBufferCopyRowPitchAlignment = default,
		ulong nonCoherentAtomSize = default
	) {
		MaxImageDimension1D = maxImageDimension1D;
		MaxImageDimension2D = maxImageDimension2D;
		MaxImageDimension3D = maxImageDimension3D;
		MaxImageDimensionCube = maxImageDimensionCube;
		MaxImageArrayLayers = maxImageArrayLayers;
		MaxTexelBufferElements = maxTexelBufferElements;
		MaxUniformBufferRange = maxUniformBufferRange;
		MaxStorageBufferRange = maxStorageBufferRange;
		MaxPushConstantsSize = maxPushConstantsSize;
		MaxMemoryAllocationCount = maxMemoryAllocationCount;
		MaxSamplerAllocationCount = maxSamplerAllocationCount;
		BufferImageGranularity = bufferImageGranularity;
		SparseAddressSpaceSize = sparseAddressSpaceSize;
		MaxBoundDescriptorSets = maxBoundDescriptorSets;
		MaxPerStageDescriptorSamplers = maxPerStageDescriptorSamplers;
		MaxPerStageDescriptorUniformBuffers = maxPerStageDescriptorUniformBuffers;
		MaxPerStageDescriptorStorageBuffers = maxPerStageDescriptorStorageBuffers;
		MaxPerStageDescriptorSampledImages = maxPerStageDescriptorSampledImages;
		MaxPerStageDescriptorStorageImages = maxPerStageDescriptorStorageImages;
		MaxPerStageDescriptorInputAttachments = maxPerStageDescriptorInputAttachments;
		MaxPerStageResources = maxPerStageResources;
		MaxDescriptorSetSamplers = maxDescriptorSetSamplers;
		MaxDescriptorSetUniformBuffers = maxDescriptorSetUniformBuffers;
		MaxDescriptorSetUniformBuffersDynamic = maxDescriptorSetUniformBuffersDynamic;
		MaxDescriptorSetStorageBuffers = maxDescriptorSetStorageBuffers;
		MaxDescriptorSetStorageBuffersDynamic = maxDescriptorSetStorageBuffersDynamic;
		MaxDescriptorSetSampledImages = maxDescriptorSetSampledImages;
		MaxDescriptorSetStorageImages = maxDescriptorSetStorageImages;
		MaxDescriptorSetInputAttachments = maxDescriptorSetInputAttachments;
		MaxVertexInputAttributes = maxVertexInputAttributes;
		MaxVertexInputBindings = maxVertexInputBindings;
		MaxVertexInputAttributeOffset = maxVertexInputAttributeOffset;
		MaxVertexInputBindingStride = maxVertexInputBindingStride;
		MaxVertexOutputComponents = maxVertexOutputComponents;
		MaxTessellationGenerationLevel = maxTessellationGenerationLevel;
		MaxTessellationPatchSize = maxTessellationPatchSize;
		MaxTessellationControlPerVertexInputComponents = maxTessellationControlPerVertexInputComponents;
		MaxTessellationControlPerVertexOutputComponents = maxTessellationControlPerVertexOutputComponents;
		MaxTessellationControlPerPatchOutputComponents = maxTessellationControlPerPatchOutputComponents;
		MaxTessellationControlTotalOutputComponents = maxTessellationControlTotalOutputComponents;
		MaxTessellationEvaluationInputComponents = maxTessellationEvaluationInputComponents;
		MaxTessellationEvaluationOutputComponents = maxTessellationEvaluationOutputComponents;
		MaxGeometryShaderInvocations = maxGeometryShaderInvocations;
		MaxGeometryInputComponents = maxGeometryInputComponents;
		MaxGeometryOutputComponents = maxGeometryOutputComponents;
		MaxGeometryOutputVertices = maxGeometryOutputVertices;
		MaxGeometryTotalOutputComponents = maxGeometryTotalOutputComponents;
		MaxFragmentInputComponents = maxFragmentInputComponents;
		MaxFragmentOutputAttachments = maxFragmentOutputAttachments;
		MaxFragmentDualSrcAttachments = maxFragmentDualSrcAttachments;
		MaxFragmentCombinedOutputResources = maxFragmentCombinedOutputResources;
		MaxComputeSharedMemorySize = maxComputeSharedMemorySize;
		MaxComputeWorkGroupCount[0] = maxComputeWorkGroupCount_0;
		MaxComputeWorkGroupCount[1] = maxComputeWorkGroupCount_1;
		MaxComputeWorkGroupCount[2] = maxComputeWorkGroupCount_2;
		MaxComputeWorkGroupInvocations = maxComputeWorkGroupInvocations;
		MaxComputeWorkGroupSize[0] = maxComputeWorkGroupSize_0;
		MaxComputeWorkGroupSize[1] = maxComputeWorkGroupSize_1;
		MaxComputeWorkGroupSize[2] = maxComputeWorkGroupSize_2;
		SubPixelPrecisionBits = subPixelPrecisionBits;
		SubTexelPrecisionBits = subTexelPrecisionBits;
		MipmapPrecisionBits = mipmapPrecisionBits;
		MaxDrawIndexedIndexValue = maxDrawIndexedIndexValue;
		MaxDrawIndirectCount = maxDrawIndirectCount;
		MaxSamplerLodBias = maxSamplerLodBias;
		MaxSamplerAnisotropy = maxSamplerAnisotropy;
		MaxViewports = maxViewports;
		MaxViewportDimensions[0] = maxViewportDimensions_0;
		MaxViewportDimensions[1] = maxViewportDimensions_1;
		ViewportBoundsRange[0] = viewportBoundsRange_0;
		ViewportBoundsRange[1] = viewportBoundsRange_1;
		ViewportSubPixelBits = viewportSubPixelBits;
		MinMemoryMapAlignment = minMemoryMapAlignment;
		MinTexelBufferOffsetAlignment = minTexelBufferOffsetAlignment;
		MinUniformBufferOffsetAlignment = minUniformBufferOffsetAlignment;
		MinStorageBufferOffsetAlignment = minStorageBufferOffsetAlignment;
		MinTexelOffset = minTexelOffset;
		MaxTexelOffset = maxTexelOffset;
		MinTexelGatherOffset = minTexelGatherOffset;
		MaxTexelGatherOffset = maxTexelGatherOffset;
		MinInterpolationOffset = minInterpolationOffset;
		MaxInterpolationOffset = maxInterpolationOffset;
		SubPixelInterpolationOffsetBits = subPixelInterpolationOffsetBits;
		MaxFramebufferWidth = maxFramebufferWidth;
		MaxFramebufferHeight = maxFramebufferHeight;
		MaxFramebufferLayers = maxFramebufferLayers;
		FramebufferColorSampleCounts = framebufferColorSampleCounts;
		FramebufferDepthSampleCounts = framebufferDepthSampleCounts;
		FramebufferStencilSampleCounts = framebufferStencilSampleCounts;
		FramebufferNoAttachmentsSampleCounts = framebufferNoAttachmentsSampleCounts;
		MaxColorAttachments = maxColorAttachments;
		SampledImageColorSampleCounts = sampledImageColorSampleCounts;
		SampledImageIntegerSampleCounts = sampledImageIntegerSampleCounts;
		SampledImageDepthSampleCounts = sampledImageDepthSampleCounts;
		SampledImageStencilSampleCounts = sampledImageStencilSampleCounts;
		StorageImageSampleCounts = storageImageSampleCounts;
		MaxSampleMaskWords = maxSampleMaskWords;
		TimestampComputeAndGraphics = timestampComputeAndGraphics;
		TimestampPeriod = timestampPeriod;
		MaxClipDistances = maxClipDistances;
		MaxCullDistances = maxCullDistances;
		MaxCombinedClipAndCullDistances = maxCombinedClipAndCullDistances;
		DiscreteQueuePriorities = discreteQueuePriorities;
		PointSizeRange[0] = pointSizeRange_0;
		PointSizeRange[1] = pointSizeRange_1;
		LineWidthRange[0] = lineWidthRange_0;
		LineWidthRange[1] = lineWidthRange_1;
		PointSizeGranularity = pointSizeGranularity;
		LineWidthGranularity = lineWidthGranularity;
		StrictLines = strictLines;
		StandardSampleLocations = standardSampleLocations;
		OptimalBufferCopyOffsetAlignment = optimalBufferCopyOffsetAlignment;
		OptimalBufferCopyRowPitchAlignment = optimalBufferCopyRowPitchAlignment;
		NonCoherentAtomSize = nonCoherentAtomSize;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceLimits s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceLimits>.Equals(VkPhysicalDeviceLimits o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			MaxImageDimension1D.GetHashCode() ^ MaxImageDimension2D.GetHashCode() ^ MaxImageDimension3D.GetHashCode() ^ MaxImageDimensionCube.GetHashCode()
			^ MaxImageArrayLayers.GetHashCode() ^ MaxTexelBufferElements.GetHashCode() ^ MaxUniformBufferRange.GetHashCode() ^ MaxStorageBufferRange.GetHashCode()
			^ MaxPushConstantsSize.GetHashCode() ^ MaxMemoryAllocationCount.GetHashCode() ^ MaxSamplerAllocationCount.GetHashCode() ^ BufferImageGranularity.GetHashCode()
			^ SparseAddressSpaceSize.GetHashCode() ^ MaxBoundDescriptorSets.GetHashCode() ^ MaxPerStageDescriptorSamplers.GetHashCode() ^ MaxPerStageDescriptorUniformBuffers.GetHashCode()
			^ MaxPerStageDescriptorStorageBuffers.GetHashCode() ^ MaxPerStageDescriptorSampledImages.GetHashCode() ^ MaxPerStageDescriptorStorageImages.GetHashCode() ^ MaxPerStageDescriptorInputAttachments.GetHashCode()
			^ MaxPerStageResources.GetHashCode() ^ MaxDescriptorSetSamplers.GetHashCode() ^ MaxDescriptorSetUniformBuffers.GetHashCode() ^ MaxDescriptorSetUniformBuffersDynamic.GetHashCode()
			^ MaxDescriptorSetStorageBuffers.GetHashCode() ^ MaxDescriptorSetStorageBuffersDynamic.GetHashCode() ^ MaxDescriptorSetSampledImages.GetHashCode() ^ MaxDescriptorSetStorageImages.GetHashCode()
			^ MaxDescriptorSetInputAttachments.GetHashCode() ^ MaxVertexInputAttributes.GetHashCode() ^ MaxVertexInputBindings.GetHashCode() ^ MaxVertexInputAttributeOffset.GetHashCode()
			^ MaxVertexInputBindingStride.GetHashCode() ^ MaxVertexOutputComponents.GetHashCode() ^ MaxTessellationGenerationLevel.GetHashCode() ^ MaxTessellationPatchSize.GetHashCode()
			^ MaxTessellationControlPerVertexInputComponents.GetHashCode() ^ MaxTessellationControlPerVertexOutputComponents.GetHashCode() ^ MaxTessellationControlPerPatchOutputComponents.GetHashCode() ^ MaxTessellationControlTotalOutputComponents.GetHashCode()
			^ MaxTessellationEvaluationInputComponents.GetHashCode() ^ MaxTessellationEvaluationOutputComponents.GetHashCode() ^ MaxGeometryShaderInvocations.GetHashCode() ^ MaxGeometryInputComponents.GetHashCode()
			^ MaxGeometryOutputComponents.GetHashCode() ^ MaxGeometryOutputVertices.GetHashCode() ^ MaxGeometryTotalOutputComponents.GetHashCode() ^ MaxFragmentInputComponents.GetHashCode()
			^ MaxFragmentOutputAttachments.GetHashCode() ^ MaxFragmentDualSrcAttachments.GetHashCode() ^ MaxFragmentCombinedOutputResources.GetHashCode() ^ MaxComputeSharedMemorySize.GetHashCode()
			^ MaxComputeWorkGroupCount[0].GetHashCode() ^ MaxComputeWorkGroupCount[1].GetHashCode() ^ MaxComputeWorkGroupCount[2].GetHashCode() ^ MaxComputeWorkGroupInvocations.GetHashCode()
			^ MaxComputeWorkGroupSize[0].GetHashCode() ^ MaxComputeWorkGroupSize[1].GetHashCode() ^ MaxComputeWorkGroupSize[2].GetHashCode() ^ SubPixelPrecisionBits.GetHashCode()
			^ SubTexelPrecisionBits.GetHashCode() ^ MipmapPrecisionBits.GetHashCode() ^ MaxDrawIndexedIndexValue.GetHashCode() ^ MaxDrawIndirectCount.GetHashCode()
			^ MaxSamplerLodBias.GetHashCode() ^ MaxSamplerAnisotropy.GetHashCode() ^ MaxViewports.GetHashCode() ^ MaxViewportDimensions[0].GetHashCode()
			^ MaxViewportDimensions[1].GetHashCode() ^ ViewportBoundsRange[0].GetHashCode() ^ ViewportBoundsRange[1].GetHashCode() ^ ViewportSubPixelBits.GetHashCode()
			^ MinMemoryMapAlignment.GetHashCode() ^ MinTexelBufferOffsetAlignment.GetHashCode() ^ MinUniformBufferOffsetAlignment.GetHashCode() ^ MinStorageBufferOffsetAlignment.GetHashCode()
			^ MinTexelOffset.GetHashCode() ^ MaxTexelOffset.GetHashCode() ^ MinTexelGatherOffset.GetHashCode() ^ MaxTexelGatherOffset.GetHashCode()
			^ MinInterpolationOffset.GetHashCode() ^ MaxInterpolationOffset.GetHashCode() ^ SubPixelInterpolationOffsetBits.GetHashCode() ^ MaxFramebufferWidth.GetHashCode()
			^ MaxFramebufferHeight.GetHashCode() ^ MaxFramebufferLayers.GetHashCode() ^ FramebufferColorSampleCounts.GetHashCode() ^ FramebufferDepthSampleCounts.GetHashCode()
			^ FramebufferStencilSampleCounts.GetHashCode() ^ FramebufferNoAttachmentsSampleCounts.GetHashCode() ^ MaxColorAttachments.GetHashCode() ^ SampledImageColorSampleCounts.GetHashCode()
			^ SampledImageIntegerSampleCounts.GetHashCode() ^ SampledImageDepthSampleCounts.GetHashCode() ^ SampledImageStencilSampleCounts.GetHashCode() ^ StorageImageSampleCounts.GetHashCode()
			^ MaxSampleMaskWords.GetHashCode() ^ TimestampComputeAndGraphics.GetHashCode() ^ TimestampPeriod.GetHashCode() ^ MaxClipDistances.GetHashCode()
			^ MaxCullDistances.GetHashCode() ^ MaxCombinedClipAndCullDistances.GetHashCode() ^ DiscreteQueuePriorities.GetHashCode() ^ PointSizeRange[0].GetHashCode()
			^ PointSizeRange[1].GetHashCode() ^ LineWidthRange[0].GetHashCode() ^ LineWidthRange[1].GetHashCode() ^ PointSizeGranularity.GetHashCode()
			^ LineWidthGranularity.GetHashCode() ^ StrictLines.GetHashCode() ^ StandardSampleLocations.GetHashCode() ^ OptimalBufferCopyOffsetAlignment.GetHashCode()
			^ OptimalBufferCopyRowPitchAlignment.GetHashCode() ^ NonCoherentAtomSize.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceLimits l, in VkPhysicalDeviceLimits r)
	{
		return
			(l.MaxImageDimension1D == r.MaxImageDimension1D) && (l.MaxImageDimension2D == r.MaxImageDimension2D) && (l.MaxImageDimension3D == r.MaxImageDimension3D) && (l.MaxImageDimensionCube == r.MaxImageDimensionCube)
			&& (l.MaxImageArrayLayers == r.MaxImageArrayLayers) && (l.MaxTexelBufferElements == r.MaxTexelBufferElements) && (l.MaxUniformBufferRange == r.MaxUniformBufferRange) && (l.MaxStorageBufferRange == r.MaxStorageBufferRange)
			&& (l.MaxPushConstantsSize == r.MaxPushConstantsSize) && (l.MaxMemoryAllocationCount == r.MaxMemoryAllocationCount) && (l.MaxSamplerAllocationCount == r.MaxSamplerAllocationCount) && (l.BufferImageGranularity == r.BufferImageGranularity)
			&& (l.SparseAddressSpaceSize == r.SparseAddressSpaceSize) && (l.MaxBoundDescriptorSets == r.MaxBoundDescriptorSets) && (l.MaxPerStageDescriptorSamplers == r.MaxPerStageDescriptorSamplers) && (l.MaxPerStageDescriptorUniformBuffers == r.MaxPerStageDescriptorUniformBuffers)
			&& (l.MaxPerStageDescriptorStorageBuffers == r.MaxPerStageDescriptorStorageBuffers) && (l.MaxPerStageDescriptorSampledImages == r.MaxPerStageDescriptorSampledImages) && (l.MaxPerStageDescriptorStorageImages == r.MaxPerStageDescriptorStorageImages) && (l.MaxPerStageDescriptorInputAttachments == r.MaxPerStageDescriptorInputAttachments)
			&& (l.MaxPerStageResources == r.MaxPerStageResources) && (l.MaxDescriptorSetSamplers == r.MaxDescriptorSetSamplers) && (l.MaxDescriptorSetUniformBuffers == r.MaxDescriptorSetUniformBuffers) && (l.MaxDescriptorSetUniformBuffersDynamic == r.MaxDescriptorSetUniformBuffersDynamic)
			&& (l.MaxDescriptorSetStorageBuffers == r.MaxDescriptorSetStorageBuffers) && (l.MaxDescriptorSetStorageBuffersDynamic == r.MaxDescriptorSetStorageBuffersDynamic) && (l.MaxDescriptorSetSampledImages == r.MaxDescriptorSetSampledImages) && (l.MaxDescriptorSetStorageImages == r.MaxDescriptorSetStorageImages)
			&& (l.MaxDescriptorSetInputAttachments == r.MaxDescriptorSetInputAttachments) && (l.MaxVertexInputAttributes == r.MaxVertexInputAttributes) && (l.MaxVertexInputBindings == r.MaxVertexInputBindings) && (l.MaxVertexInputAttributeOffset == r.MaxVertexInputAttributeOffset)
			&& (l.MaxVertexInputBindingStride == r.MaxVertexInputBindingStride) && (l.MaxVertexOutputComponents == r.MaxVertexOutputComponents) && (l.MaxTessellationGenerationLevel == r.MaxTessellationGenerationLevel) && (l.MaxTessellationPatchSize == r.MaxTessellationPatchSize)
			&& (l.MaxTessellationControlPerVertexInputComponents == r.MaxTessellationControlPerVertexInputComponents) && (l.MaxTessellationControlPerVertexOutputComponents == r.MaxTessellationControlPerVertexOutputComponents) && (l.MaxTessellationControlPerPatchOutputComponents == r.MaxTessellationControlPerPatchOutputComponents) && (l.MaxTessellationControlTotalOutputComponents == r.MaxTessellationControlTotalOutputComponents)
			&& (l.MaxTessellationEvaluationInputComponents == r.MaxTessellationEvaluationInputComponents) && (l.MaxTessellationEvaluationOutputComponents == r.MaxTessellationEvaluationOutputComponents) && (l.MaxGeometryShaderInvocations == r.MaxGeometryShaderInvocations) && (l.MaxGeometryInputComponents == r.MaxGeometryInputComponents)
			&& (l.MaxGeometryOutputComponents == r.MaxGeometryOutputComponents) && (l.MaxGeometryOutputVertices == r.MaxGeometryOutputVertices) && (l.MaxGeometryTotalOutputComponents == r.MaxGeometryTotalOutputComponents) && (l.MaxFragmentInputComponents == r.MaxFragmentInputComponents)
			&& (l.MaxFragmentOutputAttachments == r.MaxFragmentOutputAttachments) && (l.MaxFragmentDualSrcAttachments == r.MaxFragmentDualSrcAttachments) && (l.MaxFragmentCombinedOutputResources == r.MaxFragmentCombinedOutputResources) && (l.MaxComputeSharedMemorySize == r.MaxComputeSharedMemorySize)
			&& (l.MaxComputeWorkGroupCount[0] == r.MaxComputeWorkGroupCount[0]) && (l.MaxComputeWorkGroupCount[1] == r.MaxComputeWorkGroupCount[1]) && (l.MaxComputeWorkGroupCount[2] == r.MaxComputeWorkGroupCount[2]) && (l.MaxComputeWorkGroupInvocations == r.MaxComputeWorkGroupInvocations)
			&& (l.MaxComputeWorkGroupSize[0] == r.MaxComputeWorkGroupSize[0]) && (l.MaxComputeWorkGroupSize[1] == r.MaxComputeWorkGroupSize[1]) && (l.MaxComputeWorkGroupSize[2] == r.MaxComputeWorkGroupSize[2]) && (l.SubPixelPrecisionBits == r.SubPixelPrecisionBits)
			&& (l.SubTexelPrecisionBits == r.SubTexelPrecisionBits) && (l.MipmapPrecisionBits == r.MipmapPrecisionBits) && (l.MaxDrawIndexedIndexValue == r.MaxDrawIndexedIndexValue) && (l.MaxDrawIndirectCount == r.MaxDrawIndirectCount)
			&& (l.MaxSamplerLodBias == r.MaxSamplerLodBias) && (l.MaxSamplerAnisotropy == r.MaxSamplerAnisotropy) && (l.MaxViewports == r.MaxViewports) && (l.MaxViewportDimensions[0] == r.MaxViewportDimensions[0])
			&& (l.MaxViewportDimensions[1] == r.MaxViewportDimensions[1]) && (l.ViewportBoundsRange[0] == r.ViewportBoundsRange[0]) && (l.ViewportBoundsRange[1] == r.ViewportBoundsRange[1]) && (l.ViewportSubPixelBits == r.ViewportSubPixelBits)
			&& (l.MinMemoryMapAlignment == r.MinMemoryMapAlignment) && (l.MinTexelBufferOffsetAlignment == r.MinTexelBufferOffsetAlignment) && (l.MinUniformBufferOffsetAlignment == r.MinUniformBufferOffsetAlignment) && (l.MinStorageBufferOffsetAlignment == r.MinStorageBufferOffsetAlignment)
			&& (l.MinTexelOffset == r.MinTexelOffset) && (l.MaxTexelOffset == r.MaxTexelOffset) && (l.MinTexelGatherOffset == r.MinTexelGatherOffset) && (l.MaxTexelGatherOffset == r.MaxTexelGatherOffset)
			&& (l.MinInterpolationOffset == r.MinInterpolationOffset) && (l.MaxInterpolationOffset == r.MaxInterpolationOffset) && (l.SubPixelInterpolationOffsetBits == r.SubPixelInterpolationOffsetBits) && (l.MaxFramebufferWidth == r.MaxFramebufferWidth)
			&& (l.MaxFramebufferHeight == r.MaxFramebufferHeight) && (l.MaxFramebufferLayers == r.MaxFramebufferLayers) && (l.FramebufferColorSampleCounts == r.FramebufferColorSampleCounts) && (l.FramebufferDepthSampleCounts == r.FramebufferDepthSampleCounts)
			&& (l.FramebufferStencilSampleCounts == r.FramebufferStencilSampleCounts) && (l.FramebufferNoAttachmentsSampleCounts == r.FramebufferNoAttachmentsSampleCounts) && (l.MaxColorAttachments == r.MaxColorAttachments) && (l.SampledImageColorSampleCounts == r.SampledImageColorSampleCounts)
			&& (l.SampledImageIntegerSampleCounts == r.SampledImageIntegerSampleCounts) && (l.SampledImageDepthSampleCounts == r.SampledImageDepthSampleCounts) && (l.SampledImageStencilSampleCounts == r.SampledImageStencilSampleCounts) && (l.StorageImageSampleCounts == r.StorageImageSampleCounts)
			&& (l.MaxSampleMaskWords == r.MaxSampleMaskWords) && (l.TimestampComputeAndGraphics == r.TimestampComputeAndGraphics) && (l.TimestampPeriod == r.TimestampPeriod) && (l.MaxClipDistances == r.MaxClipDistances)
			&& (l.MaxCullDistances == r.MaxCullDistances) && (l.MaxCombinedClipAndCullDistances == r.MaxCombinedClipAndCullDistances) && (l.DiscreteQueuePriorities == r.DiscreteQueuePriorities) && (l.PointSizeRange[0] == r.PointSizeRange[0])
			&& (l.PointSizeRange[1] == r.PointSizeRange[1]) && (l.LineWidthRange[0] == r.LineWidthRange[0]) && (l.LineWidthRange[1] == r.LineWidthRange[1]) && (l.PointSizeGranularity == r.PointSizeGranularity)
			&& (l.LineWidthGranularity == r.LineWidthGranularity) && (l.StrictLines == r.StrictLines) && (l.StandardSampleLocations == r.StandardSampleLocations) && (l.OptimalBufferCopyOffsetAlignment == r.OptimalBufferCopyOffsetAlignment)
			&& (l.OptimalBufferCopyRowPitchAlignment == r.OptimalBufferCopyRowPitchAlignment) && (l.NonCoherentAtomSize == r.NonCoherentAtomSize)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceLimits l, in VkPhysicalDeviceLimits r)
	{
		return
			(l.MaxImageDimension1D != r.MaxImageDimension1D) || (l.MaxImageDimension2D != r.MaxImageDimension2D) || (l.MaxImageDimension3D != r.MaxImageDimension3D) || (l.MaxImageDimensionCube != r.MaxImageDimensionCube)
			|| (l.MaxImageArrayLayers != r.MaxImageArrayLayers) || (l.MaxTexelBufferElements != r.MaxTexelBufferElements) || (l.MaxUniformBufferRange != r.MaxUniformBufferRange) || (l.MaxStorageBufferRange != r.MaxStorageBufferRange)
			|| (l.MaxPushConstantsSize != r.MaxPushConstantsSize) || (l.MaxMemoryAllocationCount != r.MaxMemoryAllocationCount) || (l.MaxSamplerAllocationCount != r.MaxSamplerAllocationCount) || (l.BufferImageGranularity != r.BufferImageGranularity)
			|| (l.SparseAddressSpaceSize != r.SparseAddressSpaceSize) || (l.MaxBoundDescriptorSets != r.MaxBoundDescriptorSets) || (l.MaxPerStageDescriptorSamplers != r.MaxPerStageDescriptorSamplers) || (l.MaxPerStageDescriptorUniformBuffers != r.MaxPerStageDescriptorUniformBuffers)
			|| (l.MaxPerStageDescriptorStorageBuffers != r.MaxPerStageDescriptorStorageBuffers) || (l.MaxPerStageDescriptorSampledImages != r.MaxPerStageDescriptorSampledImages) || (l.MaxPerStageDescriptorStorageImages != r.MaxPerStageDescriptorStorageImages) || (l.MaxPerStageDescriptorInputAttachments != r.MaxPerStageDescriptorInputAttachments)
			|| (l.MaxPerStageResources != r.MaxPerStageResources) || (l.MaxDescriptorSetSamplers != r.MaxDescriptorSetSamplers) || (l.MaxDescriptorSetUniformBuffers != r.MaxDescriptorSetUniformBuffers) || (l.MaxDescriptorSetUniformBuffersDynamic != r.MaxDescriptorSetUniformBuffersDynamic)
			|| (l.MaxDescriptorSetStorageBuffers != r.MaxDescriptorSetStorageBuffers) || (l.MaxDescriptorSetStorageBuffersDynamic != r.MaxDescriptorSetStorageBuffersDynamic) || (l.MaxDescriptorSetSampledImages != r.MaxDescriptorSetSampledImages) || (l.MaxDescriptorSetStorageImages != r.MaxDescriptorSetStorageImages)
			|| (l.MaxDescriptorSetInputAttachments != r.MaxDescriptorSetInputAttachments) || (l.MaxVertexInputAttributes != r.MaxVertexInputAttributes) || (l.MaxVertexInputBindings != r.MaxVertexInputBindings) || (l.MaxVertexInputAttributeOffset != r.MaxVertexInputAttributeOffset)
			|| (l.MaxVertexInputBindingStride != r.MaxVertexInputBindingStride) || (l.MaxVertexOutputComponents != r.MaxVertexOutputComponents) || (l.MaxTessellationGenerationLevel != r.MaxTessellationGenerationLevel) || (l.MaxTessellationPatchSize != r.MaxTessellationPatchSize)
			|| (l.MaxTessellationControlPerVertexInputComponents != r.MaxTessellationControlPerVertexInputComponents) || (l.MaxTessellationControlPerVertexOutputComponents != r.MaxTessellationControlPerVertexOutputComponents) || (l.MaxTessellationControlPerPatchOutputComponents != r.MaxTessellationControlPerPatchOutputComponents) || (l.MaxTessellationControlTotalOutputComponents != r.MaxTessellationControlTotalOutputComponents)
			|| (l.MaxTessellationEvaluationInputComponents != r.MaxTessellationEvaluationInputComponents) || (l.MaxTessellationEvaluationOutputComponents != r.MaxTessellationEvaluationOutputComponents) || (l.MaxGeometryShaderInvocations != r.MaxGeometryShaderInvocations) || (l.MaxGeometryInputComponents != r.MaxGeometryInputComponents)
			|| (l.MaxGeometryOutputComponents != r.MaxGeometryOutputComponents) || (l.MaxGeometryOutputVertices != r.MaxGeometryOutputVertices) || (l.MaxGeometryTotalOutputComponents != r.MaxGeometryTotalOutputComponents) || (l.MaxFragmentInputComponents != r.MaxFragmentInputComponents)
			|| (l.MaxFragmentOutputAttachments != r.MaxFragmentOutputAttachments) || (l.MaxFragmentDualSrcAttachments != r.MaxFragmentDualSrcAttachments) || (l.MaxFragmentCombinedOutputResources != r.MaxFragmentCombinedOutputResources) || (l.MaxComputeSharedMemorySize != r.MaxComputeSharedMemorySize)
			|| (l.MaxComputeWorkGroupCount[0] != r.MaxComputeWorkGroupCount[0]) || (l.MaxComputeWorkGroupCount[1] != r.MaxComputeWorkGroupCount[1]) || (l.MaxComputeWorkGroupCount[2] != r.MaxComputeWorkGroupCount[2]) || (l.MaxComputeWorkGroupInvocations != r.MaxComputeWorkGroupInvocations)
			|| (l.MaxComputeWorkGroupSize[0] != r.MaxComputeWorkGroupSize[0]) || (l.MaxComputeWorkGroupSize[1] != r.MaxComputeWorkGroupSize[1]) || (l.MaxComputeWorkGroupSize[2] != r.MaxComputeWorkGroupSize[2]) || (l.SubPixelPrecisionBits != r.SubPixelPrecisionBits)
			|| (l.SubTexelPrecisionBits != r.SubTexelPrecisionBits) || (l.MipmapPrecisionBits != r.MipmapPrecisionBits) || (l.MaxDrawIndexedIndexValue != r.MaxDrawIndexedIndexValue) || (l.MaxDrawIndirectCount != r.MaxDrawIndirectCount)
			|| (l.MaxSamplerLodBias != r.MaxSamplerLodBias) || (l.MaxSamplerAnisotropy != r.MaxSamplerAnisotropy) || (l.MaxViewports != r.MaxViewports) || (l.MaxViewportDimensions[0] != r.MaxViewportDimensions[0])
			|| (l.MaxViewportDimensions[1] != r.MaxViewportDimensions[1]) || (l.ViewportBoundsRange[0] != r.ViewportBoundsRange[0]) || (l.ViewportBoundsRange[1] != r.ViewportBoundsRange[1]) || (l.ViewportSubPixelBits != r.ViewportSubPixelBits)
			|| (l.MinMemoryMapAlignment != r.MinMemoryMapAlignment) || (l.MinTexelBufferOffsetAlignment != r.MinTexelBufferOffsetAlignment) || (l.MinUniformBufferOffsetAlignment != r.MinUniformBufferOffsetAlignment) || (l.MinStorageBufferOffsetAlignment != r.MinStorageBufferOffsetAlignment)
			|| (l.MinTexelOffset != r.MinTexelOffset) || (l.MaxTexelOffset != r.MaxTexelOffset) || (l.MinTexelGatherOffset != r.MinTexelGatherOffset) || (l.MaxTexelGatherOffset != r.MaxTexelGatherOffset)
			|| (l.MinInterpolationOffset != r.MinInterpolationOffset) || (l.MaxInterpolationOffset != r.MaxInterpolationOffset) || (l.SubPixelInterpolationOffsetBits != r.SubPixelInterpolationOffsetBits) || (l.MaxFramebufferWidth != r.MaxFramebufferWidth)
			|| (l.MaxFramebufferHeight != r.MaxFramebufferHeight) || (l.MaxFramebufferLayers != r.MaxFramebufferLayers) || (l.FramebufferColorSampleCounts != r.FramebufferColorSampleCounts) || (l.FramebufferDepthSampleCounts != r.FramebufferDepthSampleCounts)
			|| (l.FramebufferStencilSampleCounts != r.FramebufferStencilSampleCounts) || (l.FramebufferNoAttachmentsSampleCounts != r.FramebufferNoAttachmentsSampleCounts) || (l.MaxColorAttachments != r.MaxColorAttachments) || (l.SampledImageColorSampleCounts != r.SampledImageColorSampleCounts)
			|| (l.SampledImageIntegerSampleCounts != r.SampledImageIntegerSampleCounts) || (l.SampledImageDepthSampleCounts != r.SampledImageDepthSampleCounts) || (l.SampledImageStencilSampleCounts != r.SampledImageStencilSampleCounts) || (l.StorageImageSampleCounts != r.StorageImageSampleCounts)
			|| (l.MaxSampleMaskWords != r.MaxSampleMaskWords) || (l.TimestampComputeAndGraphics != r.TimestampComputeAndGraphics) || (l.TimestampPeriod != r.TimestampPeriod) || (l.MaxClipDistances != r.MaxClipDistances)
			|| (l.MaxCullDistances != r.MaxCullDistances) || (l.MaxCombinedClipAndCullDistances != r.MaxCombinedClipAndCullDistances) || (l.DiscreteQueuePriorities != r.DiscreteQueuePriorities) || (l.PointSizeRange[0] != r.PointSizeRange[0])
			|| (l.PointSizeRange[1] != r.PointSizeRange[1]) || (l.LineWidthRange[0] != r.LineWidthRange[0]) || (l.LineWidthRange[1] != r.LineWidthRange[1]) || (l.PointSizeGranularity != r.PointSizeGranularity)
			|| (l.LineWidthGranularity != r.LineWidthGranularity) || (l.StrictLines != r.StrictLines) || (l.StandardSampleLocations != r.StandardSampleLocations) || (l.OptimalBufferCopyOffsetAlignment != r.OptimalBufferCopyOffsetAlignment)
			|| (l.OptimalBufferCopyRowPitchAlignment != r.OptimalBufferCopyRowPitchAlignment) || (l.NonCoherentAtomSize != r.NonCoherentAtomSize)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceLimits s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkSemaphoreCreateInfo : IEquatable<VkSemaphoreCreateInfo>
{
	public const VkStructureType TYPE = VkStructureType.SemaphoreCreateInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkSemaphoreCreateFlags Flags;

	public VkSemaphoreCreateInfo(
		VkSemaphoreCreateFlags flags = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
	}

	public readonly override bool Equals(object? o) => (o is VkSemaphoreCreateInfo s) && (this == s);
	readonly bool IEquatable<VkSemaphoreCreateInfo>.Equals(VkSemaphoreCreateInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkSemaphoreCreateInfo l, in VkSemaphoreCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkSemaphoreCreateInfo l, in VkSemaphoreCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkSemaphoreCreateInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkQueryPoolCreateInfo : IEquatable<VkQueryPoolCreateInfo>
{
	public const VkStructureType TYPE = VkStructureType.QueryPoolCreateInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkQueryPoolCreateFlags Flags;
	public VkQueryType QueryType;
	public uint QueryCount;
	public VkQueryPipelineStatisticFlags PipelineStatistics;

	public VkQueryPoolCreateInfo(
		VkQueryPoolCreateFlags flags = default,
		VkQueryType queryType = default,
		uint queryCount = default,
		VkQueryPipelineStatisticFlags pipelineStatistics = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		QueryType = queryType;
		QueryCount = queryCount;
		PipelineStatistics = pipelineStatistics;
	}

	public readonly override bool Equals(object? o) => (o is VkQueryPoolCreateInfo s) && (this == s);
	readonly bool IEquatable<VkQueryPoolCreateInfo>.Equals(VkQueryPoolCreateInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ QueryType.GetHashCode()
			^ QueryCount.GetHashCode() ^ PipelineStatistics.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkQueryPoolCreateInfo l, in VkQueryPoolCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.QueryType == r.QueryType)
			&& (l.QueryCount == r.QueryCount) && (l.PipelineStatistics == r.PipelineStatistics)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkQueryPoolCreateInfo l, in VkQueryPoolCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.QueryType != r.QueryType)
			|| (l.QueryCount != r.QueryCount) || (l.PipelineStatistics != r.PipelineStatistics)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkQueryPoolCreateInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkFramebufferCreateInfo : IEquatable<VkFramebufferCreateInfo>
{
	public const VkStructureType TYPE = VkStructureType.FramebufferCreateInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkFramebufferCreateFlags Flags;
	public VulkanHandle<VkRenderPass> RenderPass;
	public uint AttachmentCount;
	public VulkanHandle<VkImageView>* Attachments;
	public uint Width;
	public uint Height;
	public uint Layers;

	public VkFramebufferCreateInfo(
		VkFramebufferCreateFlags flags = default,
		VulkanHandle<VkRenderPass> renderPass = default,
		uint attachmentCount = default,
		VulkanHandle<VkImageView>* attachments = default,
		uint width = default,
		uint height = default,
		uint layers = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		RenderPass = renderPass;
		AttachmentCount = attachmentCount;
		Attachments = attachments;
		Width = width;
		Height = height;
		Layers = layers;
	}

	public readonly override bool Equals(object? o) => (o is VkFramebufferCreateInfo s) && (this == s);
	readonly bool IEquatable<VkFramebufferCreateInfo>.Equals(VkFramebufferCreateInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ RenderPass.GetHashCode()
			^ AttachmentCount.GetHashCode() ^ ((ulong)Attachments).GetHashCode() ^ Width.GetHashCode() ^ Height.GetHashCode()
			^ Layers.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkFramebufferCreateInfo l, in VkFramebufferCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.RenderPass == r.RenderPass)
			&& (l.AttachmentCount == r.AttachmentCount) && (l.Attachments == r.Attachments) && (l.Width == r.Width) && (l.Height == r.Height)
			&& (l.Layers == r.Layers)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkFramebufferCreateInfo l, in VkFramebufferCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.RenderPass != r.RenderPass)
			|| (l.AttachmentCount != r.AttachmentCount) || (l.Attachments != r.Attachments) || (l.Width != r.Width) || (l.Height != r.Height)
			|| (l.Layers != r.Layers)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkFramebufferCreateInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDrawIndirectCommand : IEquatable<VkDrawIndirectCommand>
{
	public uint VertexCount;
	public uint InstanceCount;
	public uint FirstVertex;
	public uint FirstInstance;

	public VkDrawIndirectCommand(
		uint vertexCount = default,
		uint instanceCount = default,
		uint firstVertex = default,
		uint firstInstance = default
	) {
		VertexCount = vertexCount;
		InstanceCount = instanceCount;
		FirstVertex = firstVertex;
		FirstInstance = firstInstance;
	}

	public readonly override bool Equals(object? o) => (o is VkDrawIndirectCommand s) && (this == s);
	readonly bool IEquatable<VkDrawIndirectCommand>.Equals(VkDrawIndirectCommand o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			VertexCount.GetHashCode() ^ InstanceCount.GetHashCode() ^ FirstVertex.GetHashCode() ^ FirstInstance.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDrawIndirectCommand l, in VkDrawIndirectCommand r)
	{
		return
			(l.VertexCount == r.VertexCount) && (l.InstanceCount == r.InstanceCount) && (l.FirstVertex == r.FirstVertex) && (l.FirstInstance == r.FirstInstance)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDrawIndirectCommand l, in VkDrawIndirectCommand r)
	{
		return
			(l.VertexCount != r.VertexCount) || (l.InstanceCount != r.InstanceCount) || (l.FirstVertex != r.FirstVertex) || (l.FirstInstance != r.FirstInstance)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDrawIndirectCommand s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDrawIndexedIndirectCommand : IEquatable<VkDrawIndexedIndirectCommand>
{
	public uint IndexCount;
	public uint InstanceCount;
	public uint FirstIndex;
	public int VertexOffset;
	public uint FirstInstance;

	public VkDrawIndexedIndirectCommand(
		uint indexCount = default,
		uint instanceCount = default,
		uint firstIndex = default,
		int vertexOffset = default,
		uint firstInstance = default
	) {
		IndexCount = indexCount;
		InstanceCount = instanceCount;
		FirstIndex = firstIndex;
		VertexOffset = vertexOffset;
		FirstInstance = firstInstance;
	}

	public readonly override bool Equals(object? o) => (o is VkDrawIndexedIndirectCommand s) && (this == s);
	readonly bool IEquatable<VkDrawIndexedIndirectCommand>.Equals(VkDrawIndexedIndirectCommand o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			IndexCount.GetHashCode() ^ InstanceCount.GetHashCode() ^ FirstIndex.GetHashCode() ^ VertexOffset.GetHashCode()
			^ FirstInstance.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDrawIndexedIndirectCommand l, in VkDrawIndexedIndirectCommand r)
	{
		return
			(l.IndexCount == r.IndexCount) && (l.InstanceCount == r.InstanceCount) && (l.FirstIndex == r.FirstIndex) && (l.VertexOffset == r.VertexOffset)
			&& (l.FirstInstance == r.FirstInstance)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDrawIndexedIndirectCommand l, in VkDrawIndexedIndirectCommand r)
	{
		return
			(l.IndexCount != r.IndexCount) || (l.InstanceCount != r.InstanceCount) || (l.FirstIndex != r.FirstIndex) || (l.VertexOffset != r.VertexOffset)
			|| (l.FirstInstance != r.FirstInstance)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDrawIndexedIndirectCommand s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDispatchIndirectCommand : IEquatable<VkDispatchIndirectCommand>
{
	public uint X;
	public uint Y;
	public uint Z;

	public VkDispatchIndirectCommand(
		uint x = default,
		uint y = default,
		uint z = default
	) {
		X = x;
		Y = y;
		Z = z;
	}

	public readonly override bool Equals(object? o) => (o is VkDispatchIndirectCommand s) && (this == s);
	readonly bool IEquatable<VkDispatchIndirectCommand>.Equals(VkDispatchIndirectCommand o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			X.GetHashCode() ^ Y.GetHashCode() ^ Z.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDispatchIndirectCommand l, in VkDispatchIndirectCommand r)
	{
		return
			(l.X == r.X) && (l.Y == r.Y) && (l.Z == r.Z)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDispatchIndirectCommand l, in VkDispatchIndirectCommand r)
	{
		return
			(l.X != r.X) || (l.Y != r.Y) || (l.Z != r.Z)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDispatchIndirectCommand s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkSubmitInfo : IEquatable<VkSubmitInfo>
{
	public const VkStructureType TYPE = VkStructureType.SubmitInfo;

	public VkStructureType sType;
	public void* pNext;
	public uint WaitSemaphoreCount;
	public VulkanHandle<VkSemaphore>* WaitSemaphores;
	public VkPipelineStageFlags* WaitDstStageMask;
	public uint CommandBufferCount;
	public VulkanHandle<VkCommandBuffer>* CommandBuffers;
	public uint SignalSemaphoreCount;
	public VulkanHandle<VkSemaphore>* SignalSemaphores;

	public VkSubmitInfo(
		uint waitSemaphoreCount = default,
		VulkanHandle<VkSemaphore>* waitSemaphores = default,
		VkPipelineStageFlags* waitDstStageMask = default,
		uint commandBufferCount = default,
		VulkanHandle<VkCommandBuffer>* commandBuffers = default,
		uint signalSemaphoreCount = default,
		VulkanHandle<VkSemaphore>* signalSemaphores = default
	) {
		sType = TYPE;
		pNext = null;
		WaitSemaphoreCount = waitSemaphoreCount;
		WaitSemaphores = waitSemaphores;
		WaitDstStageMask = waitDstStageMask;
		CommandBufferCount = commandBufferCount;
		CommandBuffers = commandBuffers;
		SignalSemaphoreCount = signalSemaphoreCount;
		SignalSemaphores = signalSemaphores;
	}

	public readonly override bool Equals(object? o) => (o is VkSubmitInfo s) && (this == s);
	readonly bool IEquatable<VkSubmitInfo>.Equals(VkSubmitInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ WaitSemaphoreCount.GetHashCode() ^ ((ulong)WaitSemaphores).GetHashCode()
			^ ((ulong)WaitDstStageMask).GetHashCode() ^ CommandBufferCount.GetHashCode() ^ ((ulong)CommandBuffers).GetHashCode() ^ SignalSemaphoreCount.GetHashCode()
			^ ((ulong)SignalSemaphores).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkSubmitInfo l, in VkSubmitInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.WaitSemaphoreCount == r.WaitSemaphoreCount) && (l.WaitSemaphores == r.WaitSemaphores)
			&& (l.WaitDstStageMask == r.WaitDstStageMask) && (l.CommandBufferCount == r.CommandBufferCount) && (l.CommandBuffers == r.CommandBuffers) && (l.SignalSemaphoreCount == r.SignalSemaphoreCount)
			&& (l.SignalSemaphores == r.SignalSemaphores)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkSubmitInfo l, in VkSubmitInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.WaitSemaphoreCount != r.WaitSemaphoreCount) || (l.WaitSemaphores != r.WaitSemaphores)
			|| (l.WaitDstStageMask != r.WaitDstStageMask) || (l.CommandBufferCount != r.CommandBufferCount) || (l.CommandBuffers != r.CommandBuffers) || (l.SignalSemaphoreCount != r.SignalSemaphoreCount)
			|| (l.SignalSemaphores != r.SignalSemaphores)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkSubmitInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceFeatures2 : IEquatable<VkPhysicalDeviceFeatures2>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceFeatures2;

	public VkStructureType sType;
	public void* pNext;
	public VkPhysicalDeviceFeatures Features;

	public VkPhysicalDeviceFeatures2(
		VkPhysicalDeviceFeatures features = default
	) {
		sType = TYPE;
		pNext = null;
		Features = features;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceFeatures2 s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceFeatures2>.Equals(VkPhysicalDeviceFeatures2 o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Features.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceFeatures2 l, in VkPhysicalDeviceFeatures2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Features == r.Features)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceFeatures2 l, in VkPhysicalDeviceFeatures2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Features != r.Features)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceFeatures2 s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceProperties2 : IEquatable<VkPhysicalDeviceProperties2>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceProperties2;

	public VkStructureType sType;
	public void* pNext;
	public VkPhysicalDeviceProperties Properties;

	public VkPhysicalDeviceProperties2(
		VkPhysicalDeviceProperties properties = default
	) {
		sType = TYPE;
		pNext = null;
		Properties = properties;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceProperties2 s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceProperties2>.Equals(VkPhysicalDeviceProperties2 o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Properties.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceProperties2 l, in VkPhysicalDeviceProperties2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Properties == r.Properties)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceProperties2 l, in VkPhysicalDeviceProperties2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Properties != r.Properties)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceProperties2 s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkFormatProperties2 : IEquatable<VkFormatProperties2>
{
	public const VkStructureType TYPE = VkStructureType.FormatProperties2;

	public VkStructureType sType;
	public void* pNext;
	public VkFormatProperties FormatProperties;

	public VkFormatProperties2(
		VkFormatProperties formatProperties = default
	) {
		sType = TYPE;
		pNext = null;
		FormatProperties = formatProperties;
	}

	public readonly override bool Equals(object? o) => (o is VkFormatProperties2 s) && (this == s);
	readonly bool IEquatable<VkFormatProperties2>.Equals(VkFormatProperties2 o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ FormatProperties.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkFormatProperties2 l, in VkFormatProperties2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.FormatProperties == r.FormatProperties)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkFormatProperties2 l, in VkFormatProperties2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.FormatProperties != r.FormatProperties)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkFormatProperties2 s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkImageFormatProperties2 : IEquatable<VkImageFormatProperties2>
{
	public const VkStructureType TYPE = VkStructureType.ImageFormatProperties2;

	public VkStructureType sType;
	public void* pNext;
	public VkImageFormatProperties ImageFormatProperties;

	public VkImageFormatProperties2(
		VkImageFormatProperties imageFormatProperties = default
	) {
		sType = TYPE;
		pNext = null;
		ImageFormatProperties = imageFormatProperties;
	}

	public readonly override bool Equals(object? o) => (o is VkImageFormatProperties2 s) && (this == s);
	readonly bool IEquatable<VkImageFormatProperties2>.Equals(VkImageFormatProperties2 o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ImageFormatProperties.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkImageFormatProperties2 l, in VkImageFormatProperties2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ImageFormatProperties == r.ImageFormatProperties)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkImageFormatProperties2 l, in VkImageFormatProperties2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ImageFormatProperties != r.ImageFormatProperties)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkImageFormatProperties2 s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceImageFormatInfo2 : IEquatable<VkPhysicalDeviceImageFormatInfo2>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceImageFormatInfo2;

	public VkStructureType sType;
	public void* pNext;
	public VkFormat Format;
	public VkImageType Type;
	public VkImageTiling Tiling;
	public VkImageUsageFlags Usage;
	public VkImageCreateFlags Flags;

	public VkPhysicalDeviceImageFormatInfo2(
		VkFormat format = default,
		VkImageType type = default,
		VkImageTiling tiling = default,
		VkImageUsageFlags usage = default,
		VkImageCreateFlags flags = default
	) {
		sType = TYPE;
		pNext = null;
		Format = format;
		Type = type;
		Tiling = tiling;
		Usage = usage;
		Flags = flags;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceImageFormatInfo2 s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceImageFormatInfo2>.Equals(VkPhysicalDeviceImageFormatInfo2 o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Format.GetHashCode() ^ Type.GetHashCode()
			^ Tiling.GetHashCode() ^ Usage.GetHashCode() ^ Flags.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceImageFormatInfo2 l, in VkPhysicalDeviceImageFormatInfo2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Format == r.Format) && (l.Type == r.Type)
			&& (l.Tiling == r.Tiling) && (l.Usage == r.Usage) && (l.Flags == r.Flags)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceImageFormatInfo2 l, in VkPhysicalDeviceImageFormatInfo2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Format != r.Format) || (l.Type != r.Type)
			|| (l.Tiling != r.Tiling) || (l.Usage != r.Usage) || (l.Flags != r.Flags)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceImageFormatInfo2 s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkQueueFamilyProperties2 : IEquatable<VkQueueFamilyProperties2>
{
	public const VkStructureType TYPE = VkStructureType.QueueFamilyProperties2;

	public VkStructureType sType;
	public void* pNext;
	public VkQueueFamilyProperties QueueFamilyProperties;

	public VkQueueFamilyProperties2(
		VkQueueFamilyProperties queueFamilyProperties = default
	) {
		sType = TYPE;
		pNext = null;
		QueueFamilyProperties = queueFamilyProperties;
	}

	public readonly override bool Equals(object? o) => (o is VkQueueFamilyProperties2 s) && (this == s);
	readonly bool IEquatable<VkQueueFamilyProperties2>.Equals(VkQueueFamilyProperties2 o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ QueueFamilyProperties.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkQueueFamilyProperties2 l, in VkQueueFamilyProperties2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.QueueFamilyProperties == r.QueueFamilyProperties)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkQueueFamilyProperties2 l, in VkQueueFamilyProperties2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.QueueFamilyProperties != r.QueueFamilyProperties)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkQueueFamilyProperties2 s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceMemoryProperties2 : IEquatable<VkPhysicalDeviceMemoryProperties2>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceMemoryProperties2;

	public VkStructureType sType;
	public void* pNext;
	public VkPhysicalDeviceMemoryProperties MemoryProperties;

	public VkPhysicalDeviceMemoryProperties2(
		VkPhysicalDeviceMemoryProperties memoryProperties = default
	) {
		sType = TYPE;
		pNext = null;
		MemoryProperties = memoryProperties;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceMemoryProperties2 s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceMemoryProperties2>.Equals(VkPhysicalDeviceMemoryProperties2 o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MemoryProperties.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceMemoryProperties2 l, in VkPhysicalDeviceMemoryProperties2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MemoryProperties == r.MemoryProperties)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceMemoryProperties2 l, in VkPhysicalDeviceMemoryProperties2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MemoryProperties != r.MemoryProperties)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceMemoryProperties2 s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkSparseImageFormatProperties2 : IEquatable<VkSparseImageFormatProperties2>
{
	public const VkStructureType TYPE = VkStructureType.SparseImageFormatProperties2;

	public VkStructureType sType;
	public void* pNext;
	public VkSparseImageFormatProperties Properties;

	public VkSparseImageFormatProperties2(
		VkSparseImageFormatProperties properties = default
	) {
		sType = TYPE;
		pNext = null;
		Properties = properties;
	}

	public readonly override bool Equals(object? o) => (o is VkSparseImageFormatProperties2 s) && (this == s);
	readonly bool IEquatable<VkSparseImageFormatProperties2>.Equals(VkSparseImageFormatProperties2 o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Properties.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkSparseImageFormatProperties2 l, in VkSparseImageFormatProperties2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Properties == r.Properties)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkSparseImageFormatProperties2 l, in VkSparseImageFormatProperties2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Properties != r.Properties)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkSparseImageFormatProperties2 s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceSparseImageFormatInfo2 : IEquatable<VkPhysicalDeviceSparseImageFormatInfo2>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceSparseImageFormatInfo2;

	public VkStructureType sType;
	public void* pNext;
	public VkFormat Format;
	public VkImageType Type;
	public VkSampleCountFlags Samples;
	public VkImageUsageFlags Usage;
	public VkImageTiling Tiling;

	public VkPhysicalDeviceSparseImageFormatInfo2(
		VkFormat format = default,
		VkImageType type = default,
		VkSampleCountFlags samples = default,
		VkImageUsageFlags usage = default,
		VkImageTiling tiling = default
	) {
		sType = TYPE;
		pNext = null;
		Format = format;
		Type = type;
		Samples = samples;
		Usage = usage;
		Tiling = tiling;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceSparseImageFormatInfo2 s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceSparseImageFormatInfo2>.Equals(VkPhysicalDeviceSparseImageFormatInfo2 o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Format.GetHashCode() ^ Type.GetHashCode()
			^ Samples.GetHashCode() ^ Usage.GetHashCode() ^ Tiling.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceSparseImageFormatInfo2 l, in VkPhysicalDeviceSparseImageFormatInfo2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Format == r.Format) && (l.Type == r.Type)
			&& (l.Samples == r.Samples) && (l.Usage == r.Usage) && (l.Tiling == r.Tiling)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceSparseImageFormatInfo2 l, in VkPhysicalDeviceSparseImageFormatInfo2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Format != r.Format) || (l.Type != r.Type)
			|| (l.Samples != r.Samples) || (l.Usage != r.Usage) || (l.Tiling != r.Tiling)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceSparseImageFormatInfo2 s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkConformanceVersion : IEquatable<VkConformanceVersion>
{
	public byte Major;
	public byte Minor;
	public byte Subminor;
	public byte Patch;

	public VkConformanceVersion(
		byte major = default,
		byte minor = default,
		byte subminor = default,
		byte patch = default
	) {
		Major = major;
		Minor = minor;
		Subminor = subminor;
		Patch = patch;
	}

	public readonly override bool Equals(object? o) => (o is VkConformanceVersion s) && (this == s);
	readonly bool IEquatable<VkConformanceVersion>.Equals(VkConformanceVersion o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Major.GetHashCode() ^ Minor.GetHashCode() ^ Subminor.GetHashCode() ^ Patch.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkConformanceVersion l, in VkConformanceVersion r)
	{
		return
			(l.Major == r.Major) && (l.Minor == r.Minor) && (l.Subminor == r.Subminor) && (l.Patch == r.Patch)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkConformanceVersion l, in VkConformanceVersion r)
	{
		return
			(l.Major != r.Major) || (l.Minor != r.Minor) || (l.Subminor != r.Subminor) || (l.Patch != r.Patch)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkConformanceVersion s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceDriverProperties : IEquatable<VkPhysicalDeviceDriverProperties>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceDriverProperties;

	public VkStructureType sType;
	public void* pNext;
	public VkDriverId DriverID;
	public VVK.DriverName DriverName;
	public VVK.DriverInfo DriverInfo;
	public VkConformanceVersion ConformanceVersion;

	public VkPhysicalDeviceDriverProperties(
		VkDriverId driverID = default,
		VVK.DriverName driverName = default,
		VVK.DriverInfo driverInfo = default,
		VkConformanceVersion conformanceVersion = default
	) {
		sType = TYPE;
		pNext = null;
		DriverID = driverID;
		DriverName = driverName;
		DriverInfo = driverInfo;
		ConformanceVersion = conformanceVersion;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceDriverProperties s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceDriverProperties>.Equals(VkPhysicalDeviceDriverProperties o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DriverID.GetHashCode() ^ DriverName.GetHashCode()
			^ DriverInfo.GetHashCode() ^ ConformanceVersion.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceDriverProperties l, in VkPhysicalDeviceDriverProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DriverID == r.DriverID) && (l.DriverName == r.DriverName)
			&& (l.DriverInfo == r.DriverInfo) && (l.ConformanceVersion == r.ConformanceVersion)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceDriverProperties l, in VkPhysicalDeviceDriverProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DriverID != r.DriverID) || (l.DriverName != r.DriverName)
			|| (l.DriverInfo != r.DriverInfo) || (l.ConformanceVersion != r.ConformanceVersion)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceDriverProperties s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceVariablePointersFeatures : IEquatable<VkPhysicalDeviceVariablePointersFeatures>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceVariablePointersFeatures;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 VariablePointersStorageBuffer;
	public VkBool32 VariablePointers;

	public VkPhysicalDeviceVariablePointersFeatures(
		VkBool32 variablePointersStorageBuffer = default,
		VkBool32 variablePointers = default
	) {
		sType = TYPE;
		pNext = null;
		VariablePointersStorageBuffer = variablePointersStorageBuffer;
		VariablePointers = variablePointers;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceVariablePointersFeatures s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceVariablePointersFeatures>.Equals(VkPhysicalDeviceVariablePointersFeatures o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ VariablePointersStorageBuffer.GetHashCode() ^ VariablePointers.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceVariablePointersFeatures l, in VkPhysicalDeviceVariablePointersFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.VariablePointersStorageBuffer == r.VariablePointersStorageBuffer) && (l.VariablePointers == r.VariablePointers)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceVariablePointersFeatures l, in VkPhysicalDeviceVariablePointersFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.VariablePointersStorageBuffer != r.VariablePointersStorageBuffer) || (l.VariablePointers != r.VariablePointers)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceVariablePointersFeatures s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceVariablePointerFeatures : IEquatable<VkPhysicalDeviceVariablePointerFeatures>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceVariablePointersFeatures;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 VariablePointersStorageBuffer;
	public VkBool32 VariablePointers;

	public VkPhysicalDeviceVariablePointerFeatures(
		VkBool32 variablePointersStorageBuffer = default,
		VkBool32 variablePointers = default
	) {
		sType = TYPE;
		pNext = null;
		VariablePointersStorageBuffer = variablePointersStorageBuffer;
		VariablePointers = variablePointers;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceVariablePointerFeatures s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceVariablePointerFeatures>.Equals(VkPhysicalDeviceVariablePointerFeatures o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ VariablePointersStorageBuffer.GetHashCode() ^ VariablePointers.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceVariablePointerFeatures l, in VkPhysicalDeviceVariablePointerFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.VariablePointersStorageBuffer == r.VariablePointersStorageBuffer) && (l.VariablePointers == r.VariablePointers)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceVariablePointerFeatures l, in VkPhysicalDeviceVariablePointerFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.VariablePointersStorageBuffer != r.VariablePointersStorageBuffer) || (l.VariablePointers != r.VariablePointers)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceVariablePointerFeatures s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkExternalMemoryProperties : IEquatable<VkExternalMemoryProperties>
{
	public VkExternalMemoryFeatureFlags ExternalMemoryFeatures;
	public VkExternalMemoryHandleTypeFlags ExportFromImportedHandleTypes;
	public VkExternalMemoryHandleTypeFlags CompatibleHandleTypes;

	public VkExternalMemoryProperties(
		VkExternalMemoryFeatureFlags externalMemoryFeatures = default,
		VkExternalMemoryHandleTypeFlags exportFromImportedHandleTypes = default,
		VkExternalMemoryHandleTypeFlags compatibleHandleTypes = default
	) {
		ExternalMemoryFeatures = externalMemoryFeatures;
		ExportFromImportedHandleTypes = exportFromImportedHandleTypes;
		CompatibleHandleTypes = compatibleHandleTypes;
	}

	public readonly override bool Equals(object? o) => (o is VkExternalMemoryProperties s) && (this == s);
	readonly bool IEquatable<VkExternalMemoryProperties>.Equals(VkExternalMemoryProperties o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			ExternalMemoryFeatures.GetHashCode() ^ ExportFromImportedHandleTypes.GetHashCode() ^ CompatibleHandleTypes.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkExternalMemoryProperties l, in VkExternalMemoryProperties r)
	{
		return
			(l.ExternalMemoryFeatures == r.ExternalMemoryFeatures) && (l.ExportFromImportedHandleTypes == r.ExportFromImportedHandleTypes) && (l.CompatibleHandleTypes == r.CompatibleHandleTypes)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkExternalMemoryProperties l, in VkExternalMemoryProperties r)
	{
		return
			(l.ExternalMemoryFeatures != r.ExternalMemoryFeatures) || (l.ExportFromImportedHandleTypes != r.ExportFromImportedHandleTypes) || (l.CompatibleHandleTypes != r.CompatibleHandleTypes)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkExternalMemoryProperties s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceExternalImageFormatInfo : IEquatable<VkPhysicalDeviceExternalImageFormatInfo>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceExternalImageFormatInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkExternalMemoryHandleTypeFlags HandleType;

	public VkPhysicalDeviceExternalImageFormatInfo(
		VkExternalMemoryHandleTypeFlags handleType = default
	) {
		sType = TYPE;
		pNext = null;
		HandleType = handleType;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceExternalImageFormatInfo s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceExternalImageFormatInfo>.Equals(VkPhysicalDeviceExternalImageFormatInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ HandleType.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceExternalImageFormatInfo l, in VkPhysicalDeviceExternalImageFormatInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.HandleType == r.HandleType)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceExternalImageFormatInfo l, in VkPhysicalDeviceExternalImageFormatInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.HandleType != r.HandleType)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceExternalImageFormatInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkExternalImageFormatProperties : IEquatable<VkExternalImageFormatProperties>
{
	public const VkStructureType TYPE = VkStructureType.ExternalImageFormatProperties;

	public VkStructureType sType;
	public void* pNext;
	public VkExternalMemoryProperties ExternalMemoryProperties;

	public VkExternalImageFormatProperties(
		VkExternalMemoryProperties externalMemoryProperties = default
	) {
		sType = TYPE;
		pNext = null;
		ExternalMemoryProperties = externalMemoryProperties;
	}

	public readonly override bool Equals(object? o) => (o is VkExternalImageFormatProperties s) && (this == s);
	readonly bool IEquatable<VkExternalImageFormatProperties>.Equals(VkExternalImageFormatProperties o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ExternalMemoryProperties.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkExternalImageFormatProperties l, in VkExternalImageFormatProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ExternalMemoryProperties == r.ExternalMemoryProperties)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkExternalImageFormatProperties l, in VkExternalImageFormatProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ExternalMemoryProperties != r.ExternalMemoryProperties)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkExternalImageFormatProperties s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceExternalBufferInfo : IEquatable<VkPhysicalDeviceExternalBufferInfo>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceExternalBufferInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkBufferCreateFlags Flags;
	public VkBufferUsageFlags Usage;
	public VkExternalMemoryHandleTypeFlags HandleType;

	public VkPhysicalDeviceExternalBufferInfo(
		VkBufferCreateFlags flags = default,
		VkBufferUsageFlags usage = default,
		VkExternalMemoryHandleTypeFlags handleType = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		Usage = usage;
		HandleType = handleType;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceExternalBufferInfo s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceExternalBufferInfo>.Equals(VkPhysicalDeviceExternalBufferInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ Usage.GetHashCode()
			^ HandleType.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceExternalBufferInfo l, in VkPhysicalDeviceExternalBufferInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.Usage == r.Usage)
			&& (l.HandleType == r.HandleType)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceExternalBufferInfo l, in VkPhysicalDeviceExternalBufferInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.Usage != r.Usage)
			|| (l.HandleType != r.HandleType)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceExternalBufferInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkExternalBufferProperties : IEquatable<VkExternalBufferProperties>
{
	public const VkStructureType TYPE = VkStructureType.ExternalBufferProperties;

	public VkStructureType sType;
	public void* pNext;
	public VkExternalMemoryProperties ExternalMemoryProperties;

	public VkExternalBufferProperties(
		VkExternalMemoryProperties externalMemoryProperties = default
	) {
		sType = TYPE;
		pNext = null;
		ExternalMemoryProperties = externalMemoryProperties;
	}

	public readonly override bool Equals(object? o) => (o is VkExternalBufferProperties s) && (this == s);
	readonly bool IEquatable<VkExternalBufferProperties>.Equals(VkExternalBufferProperties o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ExternalMemoryProperties.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkExternalBufferProperties l, in VkExternalBufferProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ExternalMemoryProperties == r.ExternalMemoryProperties)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkExternalBufferProperties l, in VkExternalBufferProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ExternalMemoryProperties != r.ExternalMemoryProperties)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkExternalBufferProperties s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceIDProperties : IEquatable<VkPhysicalDeviceIDProperties>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceIdProperties;

	public VkStructureType sType;
	public void* pNext;
	public VVK.UUID DeviceUUID;
	public VVK.UUID DriverUUID;
	public VVK.LUID DeviceLUID;
	public uint DeviceNodeMask;
	public VkBool32 DeviceLUIDValid;

	public VkPhysicalDeviceIDProperties(
		VVK.UUID deviceUUID = default,
		VVK.UUID driverUUID = default,
		VVK.LUID deviceLUID = default,
		uint deviceNodeMask = default,
		VkBool32 deviceLUIDValid = default
	) {
		sType = TYPE;
		pNext = null;
		DeviceUUID = deviceUUID;
		DriverUUID = driverUUID;
		DeviceLUID = deviceLUID;
		DeviceNodeMask = deviceNodeMask;
		DeviceLUIDValid = deviceLUIDValid;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceIDProperties s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceIDProperties>.Equals(VkPhysicalDeviceIDProperties o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DeviceUUID.GetHashCode() ^ DriverUUID.GetHashCode()
			^ DeviceLUID.GetHashCode() ^ DeviceNodeMask.GetHashCode() ^ DeviceLUIDValid.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceIDProperties l, in VkPhysicalDeviceIDProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DeviceUUID == r.DeviceUUID) && (l.DriverUUID == r.DriverUUID)
			&& (l.DeviceLUID == r.DeviceLUID) && (l.DeviceNodeMask == r.DeviceNodeMask) && (l.DeviceLUIDValid == r.DeviceLUIDValid)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceIDProperties l, in VkPhysicalDeviceIDProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DeviceUUID != r.DeviceUUID) || (l.DriverUUID != r.DriverUUID)
			|| (l.DeviceLUID != r.DeviceLUID) || (l.DeviceNodeMask != r.DeviceNodeMask) || (l.DeviceLUIDValid != r.DeviceLUIDValid)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceIDProperties s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkExternalMemoryImageCreateInfo : IEquatable<VkExternalMemoryImageCreateInfo>
{
	public const VkStructureType TYPE = VkStructureType.ExternalMemoryImageCreateInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkExternalMemoryHandleTypeFlags HandleTypes;

	public VkExternalMemoryImageCreateInfo(
		VkExternalMemoryHandleTypeFlags handleTypes = default
	) {
		sType = TYPE;
		pNext = null;
		HandleTypes = handleTypes;
	}

	public readonly override bool Equals(object? o) => (o is VkExternalMemoryImageCreateInfo s) && (this == s);
	readonly bool IEquatable<VkExternalMemoryImageCreateInfo>.Equals(VkExternalMemoryImageCreateInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ HandleTypes.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkExternalMemoryImageCreateInfo l, in VkExternalMemoryImageCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.HandleTypes == r.HandleTypes)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkExternalMemoryImageCreateInfo l, in VkExternalMemoryImageCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.HandleTypes != r.HandleTypes)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkExternalMemoryImageCreateInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkExternalMemoryBufferCreateInfo : IEquatable<VkExternalMemoryBufferCreateInfo>
{
	public const VkStructureType TYPE = VkStructureType.ExternalMemoryBufferCreateInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkExternalMemoryHandleTypeFlags HandleTypes;

	public VkExternalMemoryBufferCreateInfo(
		VkExternalMemoryHandleTypeFlags handleTypes = default
	) {
		sType = TYPE;
		pNext = null;
		HandleTypes = handleTypes;
	}

	public readonly override bool Equals(object? o) => (o is VkExternalMemoryBufferCreateInfo s) && (this == s);
	readonly bool IEquatable<VkExternalMemoryBufferCreateInfo>.Equals(VkExternalMemoryBufferCreateInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ HandleTypes.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkExternalMemoryBufferCreateInfo l, in VkExternalMemoryBufferCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.HandleTypes == r.HandleTypes)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkExternalMemoryBufferCreateInfo l, in VkExternalMemoryBufferCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.HandleTypes != r.HandleTypes)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkExternalMemoryBufferCreateInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkExportMemoryAllocateInfo : IEquatable<VkExportMemoryAllocateInfo>
{
	public const VkStructureType TYPE = VkStructureType.ExportMemoryAllocateInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkExternalMemoryHandleTypeFlags HandleTypes;

	public VkExportMemoryAllocateInfo(
		VkExternalMemoryHandleTypeFlags handleTypes = default
	) {
		sType = TYPE;
		pNext = null;
		HandleTypes = handleTypes;
	}

	public readonly override bool Equals(object? o) => (o is VkExportMemoryAllocateInfo s) && (this == s);
	readonly bool IEquatable<VkExportMemoryAllocateInfo>.Equals(VkExportMemoryAllocateInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ HandleTypes.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkExportMemoryAllocateInfo l, in VkExportMemoryAllocateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.HandleTypes == r.HandleTypes)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkExportMemoryAllocateInfo l, in VkExportMemoryAllocateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.HandleTypes != r.HandleTypes)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkExportMemoryAllocateInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceExternalSemaphoreInfo : IEquatable<VkPhysicalDeviceExternalSemaphoreInfo>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceExternalSemaphoreInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkExternalSemaphoreHandleTypeFlags HandleType;

	public VkPhysicalDeviceExternalSemaphoreInfo(
		VkExternalSemaphoreHandleTypeFlags handleType = default
	) {
		sType = TYPE;
		pNext = null;
		HandleType = handleType;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceExternalSemaphoreInfo s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceExternalSemaphoreInfo>.Equals(VkPhysicalDeviceExternalSemaphoreInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ HandleType.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceExternalSemaphoreInfo l, in VkPhysicalDeviceExternalSemaphoreInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.HandleType == r.HandleType)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceExternalSemaphoreInfo l, in VkPhysicalDeviceExternalSemaphoreInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.HandleType != r.HandleType)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceExternalSemaphoreInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkExternalSemaphoreProperties : IEquatable<VkExternalSemaphoreProperties>
{
	public const VkStructureType TYPE = VkStructureType.ExternalSemaphoreProperties;

	public VkStructureType sType;
	public void* pNext;
	public VkExternalSemaphoreHandleTypeFlags ExportFromImportedHandleTypes;
	public VkExternalSemaphoreHandleTypeFlags CompatibleHandleTypes;
	public VkExternalSemaphoreFeatureFlags ExternalSemaphoreFeatures;

	public VkExternalSemaphoreProperties(
		VkExternalSemaphoreHandleTypeFlags exportFromImportedHandleTypes = default,
		VkExternalSemaphoreHandleTypeFlags compatibleHandleTypes = default,
		VkExternalSemaphoreFeatureFlags externalSemaphoreFeatures = default
	) {
		sType = TYPE;
		pNext = null;
		ExportFromImportedHandleTypes = exportFromImportedHandleTypes;
		CompatibleHandleTypes = compatibleHandleTypes;
		ExternalSemaphoreFeatures = externalSemaphoreFeatures;
	}

	public readonly override bool Equals(object? o) => (o is VkExternalSemaphoreProperties s) && (this == s);
	readonly bool IEquatable<VkExternalSemaphoreProperties>.Equals(VkExternalSemaphoreProperties o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ExportFromImportedHandleTypes.GetHashCode() ^ CompatibleHandleTypes.GetHashCode()
			^ ExternalSemaphoreFeatures.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkExternalSemaphoreProperties l, in VkExternalSemaphoreProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ExportFromImportedHandleTypes == r.ExportFromImportedHandleTypes) && (l.CompatibleHandleTypes == r.CompatibleHandleTypes)
			&& (l.ExternalSemaphoreFeatures == r.ExternalSemaphoreFeatures)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkExternalSemaphoreProperties l, in VkExternalSemaphoreProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ExportFromImportedHandleTypes != r.ExportFromImportedHandleTypes) || (l.CompatibleHandleTypes != r.CompatibleHandleTypes)
			|| (l.ExternalSemaphoreFeatures != r.ExternalSemaphoreFeatures)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkExternalSemaphoreProperties s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkExportSemaphoreCreateInfo : IEquatable<VkExportSemaphoreCreateInfo>
{
	public const VkStructureType TYPE = VkStructureType.ExportSemaphoreCreateInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkExternalSemaphoreHandleTypeFlags HandleTypes;

	public VkExportSemaphoreCreateInfo(
		VkExternalSemaphoreHandleTypeFlags handleTypes = default
	) {
		sType = TYPE;
		pNext = null;
		HandleTypes = handleTypes;
	}

	public readonly override bool Equals(object? o) => (o is VkExportSemaphoreCreateInfo s) && (this == s);
	readonly bool IEquatable<VkExportSemaphoreCreateInfo>.Equals(VkExportSemaphoreCreateInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ HandleTypes.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkExportSemaphoreCreateInfo l, in VkExportSemaphoreCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.HandleTypes == r.HandleTypes)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkExportSemaphoreCreateInfo l, in VkExportSemaphoreCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.HandleTypes != r.HandleTypes)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkExportSemaphoreCreateInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceExternalFenceInfo : IEquatable<VkPhysicalDeviceExternalFenceInfo>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceExternalFenceInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkExternalFenceHandleTypeFlags HandleType;

	public VkPhysicalDeviceExternalFenceInfo(
		VkExternalFenceHandleTypeFlags handleType = default
	) {
		sType = TYPE;
		pNext = null;
		HandleType = handleType;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceExternalFenceInfo s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceExternalFenceInfo>.Equals(VkPhysicalDeviceExternalFenceInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ HandleType.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceExternalFenceInfo l, in VkPhysicalDeviceExternalFenceInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.HandleType == r.HandleType)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceExternalFenceInfo l, in VkPhysicalDeviceExternalFenceInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.HandleType != r.HandleType)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceExternalFenceInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkExternalFenceProperties : IEquatable<VkExternalFenceProperties>
{
	public const VkStructureType TYPE = VkStructureType.ExternalFenceProperties;

	public VkStructureType sType;
	public void* pNext;
	public VkExternalFenceHandleTypeFlags ExportFromImportedHandleTypes;
	public VkExternalFenceHandleTypeFlags CompatibleHandleTypes;
	public VkExternalFenceFeatureFlags ExternalFenceFeatures;

	public VkExternalFenceProperties(
		VkExternalFenceHandleTypeFlags exportFromImportedHandleTypes = default,
		VkExternalFenceHandleTypeFlags compatibleHandleTypes = default,
		VkExternalFenceFeatureFlags externalFenceFeatures = default
	) {
		sType = TYPE;
		pNext = null;
		ExportFromImportedHandleTypes = exportFromImportedHandleTypes;
		CompatibleHandleTypes = compatibleHandleTypes;
		ExternalFenceFeatures = externalFenceFeatures;
	}

	public readonly override bool Equals(object? o) => (o is VkExternalFenceProperties s) && (this == s);
	readonly bool IEquatable<VkExternalFenceProperties>.Equals(VkExternalFenceProperties o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ExportFromImportedHandleTypes.GetHashCode() ^ CompatibleHandleTypes.GetHashCode()
			^ ExternalFenceFeatures.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkExternalFenceProperties l, in VkExternalFenceProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ExportFromImportedHandleTypes == r.ExportFromImportedHandleTypes) && (l.CompatibleHandleTypes == r.CompatibleHandleTypes)
			&& (l.ExternalFenceFeatures == r.ExternalFenceFeatures)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkExternalFenceProperties l, in VkExternalFenceProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ExportFromImportedHandleTypes != r.ExportFromImportedHandleTypes) || (l.CompatibleHandleTypes != r.CompatibleHandleTypes)
			|| (l.ExternalFenceFeatures != r.ExternalFenceFeatures)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkExternalFenceProperties s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkExportFenceCreateInfo : IEquatable<VkExportFenceCreateInfo>
{
	public const VkStructureType TYPE = VkStructureType.ExportFenceCreateInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkExternalFenceHandleTypeFlags HandleTypes;

	public VkExportFenceCreateInfo(
		VkExternalFenceHandleTypeFlags handleTypes = default
	) {
		sType = TYPE;
		pNext = null;
		HandleTypes = handleTypes;
	}

	public readonly override bool Equals(object? o) => (o is VkExportFenceCreateInfo s) && (this == s);
	readonly bool IEquatable<VkExportFenceCreateInfo>.Equals(VkExportFenceCreateInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ HandleTypes.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkExportFenceCreateInfo l, in VkExportFenceCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.HandleTypes == r.HandleTypes)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkExportFenceCreateInfo l, in VkExportFenceCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.HandleTypes != r.HandleTypes)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkExportFenceCreateInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceMultiviewFeatures : IEquatable<VkPhysicalDeviceMultiviewFeatures>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceMultiviewFeatures;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 Multiview;
	public VkBool32 MultiviewGeometryShader;
	public VkBool32 MultiviewTessellationShader;

	public VkPhysicalDeviceMultiviewFeatures(
		VkBool32 multiview = default,
		VkBool32 multiviewGeometryShader = default,
		VkBool32 multiviewTessellationShader = default
	) {
		sType = TYPE;
		pNext = null;
		Multiview = multiview;
		MultiviewGeometryShader = multiviewGeometryShader;
		MultiviewTessellationShader = multiviewTessellationShader;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceMultiviewFeatures s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceMultiviewFeatures>.Equals(VkPhysicalDeviceMultiviewFeatures o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Multiview.GetHashCode() ^ MultiviewGeometryShader.GetHashCode()
			^ MultiviewTessellationShader.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceMultiviewFeatures l, in VkPhysicalDeviceMultiviewFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Multiview == r.Multiview) && (l.MultiviewGeometryShader == r.MultiviewGeometryShader)
			&& (l.MultiviewTessellationShader == r.MultiviewTessellationShader)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceMultiviewFeatures l, in VkPhysicalDeviceMultiviewFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Multiview != r.Multiview) || (l.MultiviewGeometryShader != r.MultiviewGeometryShader)
			|| (l.MultiviewTessellationShader != r.MultiviewTessellationShader)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceMultiviewFeatures s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceMultiviewProperties : IEquatable<VkPhysicalDeviceMultiviewProperties>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceMultiviewProperties;

	public VkStructureType sType;
	public void* pNext;
	public uint MaxMultiviewViewCount;
	public uint MaxMultiviewInstanceIndex;

	public VkPhysicalDeviceMultiviewProperties(
		uint maxMultiviewViewCount = default,
		uint maxMultiviewInstanceIndex = default
	) {
		sType = TYPE;
		pNext = null;
		MaxMultiviewViewCount = maxMultiviewViewCount;
		MaxMultiviewInstanceIndex = maxMultiviewInstanceIndex;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceMultiviewProperties s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceMultiviewProperties>.Equals(VkPhysicalDeviceMultiviewProperties o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MaxMultiviewViewCount.GetHashCode() ^ MaxMultiviewInstanceIndex.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceMultiviewProperties l, in VkPhysicalDeviceMultiviewProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MaxMultiviewViewCount == r.MaxMultiviewViewCount) && (l.MaxMultiviewInstanceIndex == r.MaxMultiviewInstanceIndex)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceMultiviewProperties l, in VkPhysicalDeviceMultiviewProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MaxMultiviewViewCount != r.MaxMultiviewViewCount) || (l.MaxMultiviewInstanceIndex != r.MaxMultiviewInstanceIndex)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceMultiviewProperties s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkRenderPassMultiviewCreateInfo : IEquatable<VkRenderPassMultiviewCreateInfo>
{
	public const VkStructureType TYPE = VkStructureType.RenderPassMultiviewCreateInfo;

	public VkStructureType sType;
	public void* pNext;
	public uint SubpassCount;
	public uint* ViewMasks;
	public uint DependencyCount;
	public int* ViewOffsets;
	public uint CorrelationMaskCount;
	public uint* CorrelationMasks;

	public VkRenderPassMultiviewCreateInfo(
		uint subpassCount = default,
		uint* viewMasks = default,
		uint dependencyCount = default,
		int* viewOffsets = default,
		uint correlationMaskCount = default,
		uint* correlationMasks = default
	) {
		sType = TYPE;
		pNext = null;
		SubpassCount = subpassCount;
		ViewMasks = viewMasks;
		DependencyCount = dependencyCount;
		ViewOffsets = viewOffsets;
		CorrelationMaskCount = correlationMaskCount;
		CorrelationMasks = correlationMasks;
	}

	public readonly override bool Equals(object? o) => (o is VkRenderPassMultiviewCreateInfo s) && (this == s);
	readonly bool IEquatable<VkRenderPassMultiviewCreateInfo>.Equals(VkRenderPassMultiviewCreateInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SubpassCount.GetHashCode() ^ ((ulong)ViewMasks).GetHashCode()
			^ DependencyCount.GetHashCode() ^ ((ulong)ViewOffsets).GetHashCode() ^ CorrelationMaskCount.GetHashCode() ^ ((ulong)CorrelationMasks).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkRenderPassMultiviewCreateInfo l, in VkRenderPassMultiviewCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SubpassCount == r.SubpassCount) && (l.ViewMasks == r.ViewMasks)
			&& (l.DependencyCount == r.DependencyCount) && (l.ViewOffsets == r.ViewOffsets) && (l.CorrelationMaskCount == r.CorrelationMaskCount) && (l.CorrelationMasks == r.CorrelationMasks)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkRenderPassMultiviewCreateInfo l, in VkRenderPassMultiviewCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SubpassCount != r.SubpassCount) || (l.ViewMasks != r.ViewMasks)
			|| (l.DependencyCount != r.DependencyCount) || (l.ViewOffsets != r.ViewOffsets) || (l.CorrelationMaskCount != r.CorrelationMaskCount) || (l.CorrelationMasks != r.CorrelationMasks)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkRenderPassMultiviewCreateInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceGroupProperties : IEquatable<VkPhysicalDeviceGroupProperties>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceGroupProperties;

	public VkStructureType sType;
	public void* pNext;
	public uint PhysicalDeviceCount;
	public VulkanHandle<VkPhysicalDevice> PhysicalDevices_0;
	public VulkanHandle<VkPhysicalDevice> PhysicalDevices_1;
	public VulkanHandle<VkPhysicalDevice> PhysicalDevices_2;
	public VulkanHandle<VkPhysicalDevice> PhysicalDevices_3;
	public VulkanHandle<VkPhysicalDevice> PhysicalDevices_4;
	public VulkanHandle<VkPhysicalDevice> PhysicalDevices_5;
	public VulkanHandle<VkPhysicalDevice> PhysicalDevices_6;
	public VulkanHandle<VkPhysicalDevice> PhysicalDevices_7;
	public VulkanHandle<VkPhysicalDevice> PhysicalDevices_8;
	public VulkanHandle<VkPhysicalDevice> PhysicalDevices_9;
	public VulkanHandle<VkPhysicalDevice> PhysicalDevices_10;
	public VulkanHandle<VkPhysicalDevice> PhysicalDevices_11;
	public VulkanHandle<VkPhysicalDevice> PhysicalDevices_12;
	public VulkanHandle<VkPhysicalDevice> PhysicalDevices_13;
	public VulkanHandle<VkPhysicalDevice> PhysicalDevices_14;
	public VulkanHandle<VkPhysicalDevice> PhysicalDevices_15;
	public VulkanHandle<VkPhysicalDevice> PhysicalDevices_16;
	public VulkanHandle<VkPhysicalDevice> PhysicalDevices_17;
	public VulkanHandle<VkPhysicalDevice> PhysicalDevices_18;
	public VulkanHandle<VkPhysicalDevice> PhysicalDevices_19;
	public VulkanHandle<VkPhysicalDevice> PhysicalDevices_20;
	public VulkanHandle<VkPhysicalDevice> PhysicalDevices_21;
	public VulkanHandle<VkPhysicalDevice> PhysicalDevices_22;
	public VulkanHandle<VkPhysicalDevice> PhysicalDevices_23;
	public VulkanHandle<VkPhysicalDevice> PhysicalDevices_24;
	public VulkanHandle<VkPhysicalDevice> PhysicalDevices_25;
	public VulkanHandle<VkPhysicalDevice> PhysicalDevices_26;
	public VulkanHandle<VkPhysicalDevice> PhysicalDevices_27;
	public VulkanHandle<VkPhysicalDevice> PhysicalDevices_28;
	public VulkanHandle<VkPhysicalDevice> PhysicalDevices_29;
	public VulkanHandle<VkPhysicalDevice> PhysicalDevices_30;
	public VulkanHandle<VkPhysicalDevice> PhysicalDevices_31;
	public VkBool32 SubsetAllocation;

	public VkPhysicalDeviceGroupProperties(
		uint physicalDeviceCount = default,
		VulkanHandle<VkPhysicalDevice> physicalDevices_0 = default,
		VulkanHandle<VkPhysicalDevice> physicalDevices_1 = default,
		VulkanHandle<VkPhysicalDevice> physicalDevices_2 = default,
		VulkanHandle<VkPhysicalDevice> physicalDevices_3 = default,
		VulkanHandle<VkPhysicalDevice> physicalDevices_4 = default,
		VulkanHandle<VkPhysicalDevice> physicalDevices_5 = default,
		VulkanHandle<VkPhysicalDevice> physicalDevices_6 = default,
		VulkanHandle<VkPhysicalDevice> physicalDevices_7 = default,
		VulkanHandle<VkPhysicalDevice> physicalDevices_8 = default,
		VulkanHandle<VkPhysicalDevice> physicalDevices_9 = default,
		VulkanHandle<VkPhysicalDevice> physicalDevices_10 = default,
		VulkanHandle<VkPhysicalDevice> physicalDevices_11 = default,
		VulkanHandle<VkPhysicalDevice> physicalDevices_12 = default,
		VulkanHandle<VkPhysicalDevice> physicalDevices_13 = default,
		VulkanHandle<VkPhysicalDevice> physicalDevices_14 = default,
		VulkanHandle<VkPhysicalDevice> physicalDevices_15 = default,
		VulkanHandle<VkPhysicalDevice> physicalDevices_16 = default,
		VulkanHandle<VkPhysicalDevice> physicalDevices_17 = default,
		VulkanHandle<VkPhysicalDevice> physicalDevices_18 = default,
		VulkanHandle<VkPhysicalDevice> physicalDevices_19 = default,
		VulkanHandle<VkPhysicalDevice> physicalDevices_20 = default,
		VulkanHandle<VkPhysicalDevice> physicalDevices_21 = default,
		VulkanHandle<VkPhysicalDevice> physicalDevices_22 = default,
		VulkanHandle<VkPhysicalDevice> physicalDevices_23 = default,
		VulkanHandle<VkPhysicalDevice> physicalDevices_24 = default,
		VulkanHandle<VkPhysicalDevice> physicalDevices_25 = default,
		VulkanHandle<VkPhysicalDevice> physicalDevices_26 = default,
		VulkanHandle<VkPhysicalDevice> physicalDevices_27 = default,
		VulkanHandle<VkPhysicalDevice> physicalDevices_28 = default,
		VulkanHandle<VkPhysicalDevice> physicalDevices_29 = default,
		VulkanHandle<VkPhysicalDevice> physicalDevices_30 = default,
		VulkanHandle<VkPhysicalDevice> physicalDevices_31 = default,
		VkBool32 subsetAllocation = default
	) {
		sType = TYPE;
		pNext = null;
		PhysicalDeviceCount = physicalDeviceCount;
		PhysicalDevices_0 = physicalDevices_0;
		PhysicalDevices_1 = physicalDevices_1;
		PhysicalDevices_2 = physicalDevices_2;
		PhysicalDevices_3 = physicalDevices_3;
		PhysicalDevices_4 = physicalDevices_4;
		PhysicalDevices_5 = physicalDevices_5;
		PhysicalDevices_6 = physicalDevices_6;
		PhysicalDevices_7 = physicalDevices_7;
		PhysicalDevices_8 = physicalDevices_8;
		PhysicalDevices_9 = physicalDevices_9;
		PhysicalDevices_10 = physicalDevices_10;
		PhysicalDevices_11 = physicalDevices_11;
		PhysicalDevices_12 = physicalDevices_12;
		PhysicalDevices_13 = physicalDevices_13;
		PhysicalDevices_14 = physicalDevices_14;
		PhysicalDevices_15 = physicalDevices_15;
		PhysicalDevices_16 = physicalDevices_16;
		PhysicalDevices_17 = physicalDevices_17;
		PhysicalDevices_18 = physicalDevices_18;
		PhysicalDevices_19 = physicalDevices_19;
		PhysicalDevices_20 = physicalDevices_20;
		PhysicalDevices_21 = physicalDevices_21;
		PhysicalDevices_22 = physicalDevices_22;
		PhysicalDevices_23 = physicalDevices_23;
		PhysicalDevices_24 = physicalDevices_24;
		PhysicalDevices_25 = physicalDevices_25;
		PhysicalDevices_26 = physicalDevices_26;
		PhysicalDevices_27 = physicalDevices_27;
		PhysicalDevices_28 = physicalDevices_28;
		PhysicalDevices_29 = physicalDevices_29;
		PhysicalDevices_30 = physicalDevices_30;
		PhysicalDevices_31 = physicalDevices_31;
		SubsetAllocation = subsetAllocation;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceGroupProperties s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceGroupProperties>.Equals(VkPhysicalDeviceGroupProperties o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ PhysicalDeviceCount.GetHashCode() ^ PhysicalDevices_0.GetHashCode()
			^ PhysicalDevices_1.GetHashCode() ^ PhysicalDevices_2.GetHashCode() ^ PhysicalDevices_3.GetHashCode() ^ PhysicalDevices_4.GetHashCode()
			^ PhysicalDevices_5.GetHashCode() ^ PhysicalDevices_6.GetHashCode() ^ PhysicalDevices_7.GetHashCode() ^ PhysicalDevices_8.GetHashCode()
			^ PhysicalDevices_9.GetHashCode() ^ PhysicalDevices_10.GetHashCode() ^ PhysicalDevices_11.GetHashCode() ^ PhysicalDevices_12.GetHashCode()
			^ PhysicalDevices_13.GetHashCode() ^ PhysicalDevices_14.GetHashCode() ^ PhysicalDevices_15.GetHashCode() ^ PhysicalDevices_16.GetHashCode()
			^ PhysicalDevices_17.GetHashCode() ^ PhysicalDevices_18.GetHashCode() ^ PhysicalDevices_19.GetHashCode() ^ PhysicalDevices_20.GetHashCode()
			^ PhysicalDevices_21.GetHashCode() ^ PhysicalDevices_22.GetHashCode() ^ PhysicalDevices_23.GetHashCode() ^ PhysicalDevices_24.GetHashCode()
			^ PhysicalDevices_25.GetHashCode() ^ PhysicalDevices_26.GetHashCode() ^ PhysicalDevices_27.GetHashCode() ^ PhysicalDevices_28.GetHashCode()
			^ PhysicalDevices_29.GetHashCode() ^ PhysicalDevices_30.GetHashCode() ^ PhysicalDevices_31.GetHashCode() ^ SubsetAllocation.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceGroupProperties l, in VkPhysicalDeviceGroupProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.PhysicalDeviceCount == r.PhysicalDeviceCount) && (l.PhysicalDevices_0 == r.PhysicalDevices_0)
			&& (l.PhysicalDevices_1 == r.PhysicalDevices_1) && (l.PhysicalDevices_2 == r.PhysicalDevices_2) && (l.PhysicalDevices_3 == r.PhysicalDevices_3) && (l.PhysicalDevices_4 == r.PhysicalDevices_4)
			&& (l.PhysicalDevices_5 == r.PhysicalDevices_5) && (l.PhysicalDevices_6 == r.PhysicalDevices_6) && (l.PhysicalDevices_7 == r.PhysicalDevices_7) && (l.PhysicalDevices_8 == r.PhysicalDevices_8)
			&& (l.PhysicalDevices_9 == r.PhysicalDevices_9) && (l.PhysicalDevices_10 == r.PhysicalDevices_10) && (l.PhysicalDevices_11 == r.PhysicalDevices_11) && (l.PhysicalDevices_12 == r.PhysicalDevices_12)
			&& (l.PhysicalDevices_13 == r.PhysicalDevices_13) && (l.PhysicalDevices_14 == r.PhysicalDevices_14) && (l.PhysicalDevices_15 == r.PhysicalDevices_15) && (l.PhysicalDevices_16 == r.PhysicalDevices_16)
			&& (l.PhysicalDevices_17 == r.PhysicalDevices_17) && (l.PhysicalDevices_18 == r.PhysicalDevices_18) && (l.PhysicalDevices_19 == r.PhysicalDevices_19) && (l.PhysicalDevices_20 == r.PhysicalDevices_20)
			&& (l.PhysicalDevices_21 == r.PhysicalDevices_21) && (l.PhysicalDevices_22 == r.PhysicalDevices_22) && (l.PhysicalDevices_23 == r.PhysicalDevices_23) && (l.PhysicalDevices_24 == r.PhysicalDevices_24)
			&& (l.PhysicalDevices_25 == r.PhysicalDevices_25) && (l.PhysicalDevices_26 == r.PhysicalDevices_26) && (l.PhysicalDevices_27 == r.PhysicalDevices_27) && (l.PhysicalDevices_28 == r.PhysicalDevices_28)
			&& (l.PhysicalDevices_29 == r.PhysicalDevices_29) && (l.PhysicalDevices_30 == r.PhysicalDevices_30) && (l.PhysicalDevices_31 == r.PhysicalDevices_31) && (l.SubsetAllocation == r.SubsetAllocation)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceGroupProperties l, in VkPhysicalDeviceGroupProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.PhysicalDeviceCount != r.PhysicalDeviceCount) || (l.PhysicalDevices_0 != r.PhysicalDevices_0)
			|| (l.PhysicalDevices_1 != r.PhysicalDevices_1) || (l.PhysicalDevices_2 != r.PhysicalDevices_2) || (l.PhysicalDevices_3 != r.PhysicalDevices_3) || (l.PhysicalDevices_4 != r.PhysicalDevices_4)
			|| (l.PhysicalDevices_5 != r.PhysicalDevices_5) || (l.PhysicalDevices_6 != r.PhysicalDevices_6) || (l.PhysicalDevices_7 != r.PhysicalDevices_7) || (l.PhysicalDevices_8 != r.PhysicalDevices_8)
			|| (l.PhysicalDevices_9 != r.PhysicalDevices_9) || (l.PhysicalDevices_10 != r.PhysicalDevices_10) || (l.PhysicalDevices_11 != r.PhysicalDevices_11) || (l.PhysicalDevices_12 != r.PhysicalDevices_12)
			|| (l.PhysicalDevices_13 != r.PhysicalDevices_13) || (l.PhysicalDevices_14 != r.PhysicalDevices_14) || (l.PhysicalDevices_15 != r.PhysicalDevices_15) || (l.PhysicalDevices_16 != r.PhysicalDevices_16)
			|| (l.PhysicalDevices_17 != r.PhysicalDevices_17) || (l.PhysicalDevices_18 != r.PhysicalDevices_18) || (l.PhysicalDevices_19 != r.PhysicalDevices_19) || (l.PhysicalDevices_20 != r.PhysicalDevices_20)
			|| (l.PhysicalDevices_21 != r.PhysicalDevices_21) || (l.PhysicalDevices_22 != r.PhysicalDevices_22) || (l.PhysicalDevices_23 != r.PhysicalDevices_23) || (l.PhysicalDevices_24 != r.PhysicalDevices_24)
			|| (l.PhysicalDevices_25 != r.PhysicalDevices_25) || (l.PhysicalDevices_26 != r.PhysicalDevices_26) || (l.PhysicalDevices_27 != r.PhysicalDevices_27) || (l.PhysicalDevices_28 != r.PhysicalDevices_28)
			|| (l.PhysicalDevices_29 != r.PhysicalDevices_29) || (l.PhysicalDevices_30 != r.PhysicalDevices_30) || (l.PhysicalDevices_31 != r.PhysicalDevices_31) || (l.SubsetAllocation != r.SubsetAllocation)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceGroupProperties s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkMemoryAllocateFlagsInfo : IEquatable<VkMemoryAllocateFlagsInfo>
{
	public const VkStructureType TYPE = VkStructureType.MemoryAllocateFlagsInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkMemoryAllocateFlags Flags;
	public uint DeviceMask;

	public VkMemoryAllocateFlagsInfo(
		VkMemoryAllocateFlags flags = default,
		uint deviceMask = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		DeviceMask = deviceMask;
	}

	public readonly override bool Equals(object? o) => (o is VkMemoryAllocateFlagsInfo s) && (this == s);
	readonly bool IEquatable<VkMemoryAllocateFlagsInfo>.Equals(VkMemoryAllocateFlagsInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ DeviceMask.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkMemoryAllocateFlagsInfo l, in VkMemoryAllocateFlagsInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.DeviceMask == r.DeviceMask)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkMemoryAllocateFlagsInfo l, in VkMemoryAllocateFlagsInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.DeviceMask != r.DeviceMask)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkMemoryAllocateFlagsInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkBindBufferMemoryInfo : IEquatable<VkBindBufferMemoryInfo>
{
	public const VkStructureType TYPE = VkStructureType.BindBufferMemoryInfo;

	public VkStructureType sType;
	public void* pNext;
	public VulkanHandle<VkBuffer> Buffer;
	public VulkanHandle<VkDeviceMemory> Memory;
	public ulong MemoryOffset;

	public VkBindBufferMemoryInfo(
		VulkanHandle<VkBuffer> buffer = default,
		VulkanHandle<VkDeviceMemory> memory = default,
		ulong memoryOffset = default
	) {
		sType = TYPE;
		pNext = null;
		Buffer = buffer;
		Memory = memory;
		MemoryOffset = memoryOffset;
	}

	public readonly override bool Equals(object? o) => (o is VkBindBufferMemoryInfo s) && (this == s);
	readonly bool IEquatable<VkBindBufferMemoryInfo>.Equals(VkBindBufferMemoryInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Buffer.GetHashCode() ^ Memory.GetHashCode()
			^ MemoryOffset.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkBindBufferMemoryInfo l, in VkBindBufferMemoryInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Buffer == r.Buffer) && (l.Memory == r.Memory)
			&& (l.MemoryOffset == r.MemoryOffset)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkBindBufferMemoryInfo l, in VkBindBufferMemoryInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Buffer != r.Buffer) || (l.Memory != r.Memory)
			|| (l.MemoryOffset != r.MemoryOffset)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkBindBufferMemoryInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkBindBufferMemoryDeviceGroupInfo : IEquatable<VkBindBufferMemoryDeviceGroupInfo>
{
	public const VkStructureType TYPE = VkStructureType.BindBufferMemoryDeviceGroupInfo;

	public VkStructureType sType;
	public void* pNext;
	public uint DeviceIndexCount;
	public uint* DeviceIndices;

	public VkBindBufferMemoryDeviceGroupInfo(
		uint deviceIndexCount = default,
		uint* deviceIndices = default
	) {
		sType = TYPE;
		pNext = null;
		DeviceIndexCount = deviceIndexCount;
		DeviceIndices = deviceIndices;
	}

	public readonly override bool Equals(object? o) => (o is VkBindBufferMemoryDeviceGroupInfo s) && (this == s);
	readonly bool IEquatable<VkBindBufferMemoryDeviceGroupInfo>.Equals(VkBindBufferMemoryDeviceGroupInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DeviceIndexCount.GetHashCode() ^ ((ulong)DeviceIndices).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkBindBufferMemoryDeviceGroupInfo l, in VkBindBufferMemoryDeviceGroupInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DeviceIndexCount == r.DeviceIndexCount) && (l.DeviceIndices == r.DeviceIndices)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkBindBufferMemoryDeviceGroupInfo l, in VkBindBufferMemoryDeviceGroupInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DeviceIndexCount != r.DeviceIndexCount) || (l.DeviceIndices != r.DeviceIndices)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkBindBufferMemoryDeviceGroupInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkBindImageMemoryInfo : IEquatable<VkBindImageMemoryInfo>
{
	public const VkStructureType TYPE = VkStructureType.BindImageMemoryInfo;

	public VkStructureType sType;
	public void* pNext;
	public VulkanHandle<VkImage> Image;
	public VulkanHandle<VkDeviceMemory> Memory;
	public ulong MemoryOffset;

	public VkBindImageMemoryInfo(
		VulkanHandle<VkImage> image = default,
		VulkanHandle<VkDeviceMemory> memory = default,
		ulong memoryOffset = default
	) {
		sType = TYPE;
		pNext = null;
		Image = image;
		Memory = memory;
		MemoryOffset = memoryOffset;
	}

	public readonly override bool Equals(object? o) => (o is VkBindImageMemoryInfo s) && (this == s);
	readonly bool IEquatable<VkBindImageMemoryInfo>.Equals(VkBindImageMemoryInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Image.GetHashCode() ^ Memory.GetHashCode()
			^ MemoryOffset.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkBindImageMemoryInfo l, in VkBindImageMemoryInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Image == r.Image) && (l.Memory == r.Memory)
			&& (l.MemoryOffset == r.MemoryOffset)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkBindImageMemoryInfo l, in VkBindImageMemoryInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Image != r.Image) || (l.Memory != r.Memory)
			|| (l.MemoryOffset != r.MemoryOffset)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkBindImageMemoryInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkBindImageMemoryDeviceGroupInfo : IEquatable<VkBindImageMemoryDeviceGroupInfo>
{
	public const VkStructureType TYPE = VkStructureType.BindImageMemoryDeviceGroupInfo;

	public VkStructureType sType;
	public void* pNext;
	public uint DeviceIndexCount;
	public uint* DeviceIndices;
	public uint SplitInstanceBindRegionCount;
	public VkRect2D* SplitInstanceBindRegions;

	public VkBindImageMemoryDeviceGroupInfo(
		uint deviceIndexCount = default,
		uint* deviceIndices = default,
		uint splitInstanceBindRegionCount = default,
		VkRect2D* splitInstanceBindRegions = default
	) {
		sType = TYPE;
		pNext = null;
		DeviceIndexCount = deviceIndexCount;
		DeviceIndices = deviceIndices;
		SplitInstanceBindRegionCount = splitInstanceBindRegionCount;
		SplitInstanceBindRegions = splitInstanceBindRegions;
	}

	public readonly override bool Equals(object? o) => (o is VkBindImageMemoryDeviceGroupInfo s) && (this == s);
	readonly bool IEquatable<VkBindImageMemoryDeviceGroupInfo>.Equals(VkBindImageMemoryDeviceGroupInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DeviceIndexCount.GetHashCode() ^ ((ulong)DeviceIndices).GetHashCode()
			^ SplitInstanceBindRegionCount.GetHashCode() ^ ((ulong)SplitInstanceBindRegions).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkBindImageMemoryDeviceGroupInfo l, in VkBindImageMemoryDeviceGroupInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DeviceIndexCount == r.DeviceIndexCount) && (l.DeviceIndices == r.DeviceIndices)
			&& (l.SplitInstanceBindRegionCount == r.SplitInstanceBindRegionCount) && (l.SplitInstanceBindRegions == r.SplitInstanceBindRegions)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkBindImageMemoryDeviceGroupInfo l, in VkBindImageMemoryDeviceGroupInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DeviceIndexCount != r.DeviceIndexCount) || (l.DeviceIndices != r.DeviceIndices)
			|| (l.SplitInstanceBindRegionCount != r.SplitInstanceBindRegionCount) || (l.SplitInstanceBindRegions != r.SplitInstanceBindRegions)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkBindImageMemoryDeviceGroupInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDeviceGroupRenderPassBeginInfo : IEquatable<VkDeviceGroupRenderPassBeginInfo>
{
	public const VkStructureType TYPE = VkStructureType.DeviceGroupRenderPassBeginInfo;

	public VkStructureType sType;
	public void* pNext;
	public uint DeviceMask;
	public uint DeviceRenderAreaCount;
	public VkRect2D* DeviceRenderAreas;

	public VkDeviceGroupRenderPassBeginInfo(
		uint deviceMask = default,
		uint deviceRenderAreaCount = default,
		VkRect2D* deviceRenderAreas = default
	) {
		sType = TYPE;
		pNext = null;
		DeviceMask = deviceMask;
		DeviceRenderAreaCount = deviceRenderAreaCount;
		DeviceRenderAreas = deviceRenderAreas;
	}

	public readonly override bool Equals(object? o) => (o is VkDeviceGroupRenderPassBeginInfo s) && (this == s);
	readonly bool IEquatable<VkDeviceGroupRenderPassBeginInfo>.Equals(VkDeviceGroupRenderPassBeginInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DeviceMask.GetHashCode() ^ DeviceRenderAreaCount.GetHashCode()
			^ ((ulong)DeviceRenderAreas).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDeviceGroupRenderPassBeginInfo l, in VkDeviceGroupRenderPassBeginInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DeviceMask == r.DeviceMask) && (l.DeviceRenderAreaCount == r.DeviceRenderAreaCount)
			&& (l.DeviceRenderAreas == r.DeviceRenderAreas)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDeviceGroupRenderPassBeginInfo l, in VkDeviceGroupRenderPassBeginInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DeviceMask != r.DeviceMask) || (l.DeviceRenderAreaCount != r.DeviceRenderAreaCount)
			|| (l.DeviceRenderAreas != r.DeviceRenderAreas)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDeviceGroupRenderPassBeginInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDeviceGroupCommandBufferBeginInfo : IEquatable<VkDeviceGroupCommandBufferBeginInfo>
{
	public const VkStructureType TYPE = VkStructureType.DeviceGroupCommandBufferBeginInfo;

	public VkStructureType sType;
	public void* pNext;
	public uint DeviceMask;

	public VkDeviceGroupCommandBufferBeginInfo(
		uint deviceMask = default
	) {
		sType = TYPE;
		pNext = null;
		DeviceMask = deviceMask;
	}

	public readonly override bool Equals(object? o) => (o is VkDeviceGroupCommandBufferBeginInfo s) && (this == s);
	readonly bool IEquatable<VkDeviceGroupCommandBufferBeginInfo>.Equals(VkDeviceGroupCommandBufferBeginInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DeviceMask.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDeviceGroupCommandBufferBeginInfo l, in VkDeviceGroupCommandBufferBeginInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DeviceMask == r.DeviceMask)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDeviceGroupCommandBufferBeginInfo l, in VkDeviceGroupCommandBufferBeginInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DeviceMask != r.DeviceMask)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDeviceGroupCommandBufferBeginInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDeviceGroupSubmitInfo : IEquatable<VkDeviceGroupSubmitInfo>
{
	public const VkStructureType TYPE = VkStructureType.DeviceGroupSubmitInfo;

	public VkStructureType sType;
	public void* pNext;
	public uint WaitSemaphoreCount;
	public uint* WaitSemaphoreDeviceIndices;
	public uint CommandBufferCount;
	public uint* CommandBufferDeviceMasks;
	public uint SignalSemaphoreCount;
	public uint* SignalSemaphoreDeviceIndices;

	public VkDeviceGroupSubmitInfo(
		uint waitSemaphoreCount = default,
		uint* waitSemaphoreDeviceIndices = default,
		uint commandBufferCount = default,
		uint* commandBufferDeviceMasks = default,
		uint signalSemaphoreCount = default,
		uint* signalSemaphoreDeviceIndices = default
	) {
		sType = TYPE;
		pNext = null;
		WaitSemaphoreCount = waitSemaphoreCount;
		WaitSemaphoreDeviceIndices = waitSemaphoreDeviceIndices;
		CommandBufferCount = commandBufferCount;
		CommandBufferDeviceMasks = commandBufferDeviceMasks;
		SignalSemaphoreCount = signalSemaphoreCount;
		SignalSemaphoreDeviceIndices = signalSemaphoreDeviceIndices;
	}

	public readonly override bool Equals(object? o) => (o is VkDeviceGroupSubmitInfo s) && (this == s);
	readonly bool IEquatable<VkDeviceGroupSubmitInfo>.Equals(VkDeviceGroupSubmitInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ WaitSemaphoreCount.GetHashCode() ^ ((ulong)WaitSemaphoreDeviceIndices).GetHashCode()
			^ CommandBufferCount.GetHashCode() ^ ((ulong)CommandBufferDeviceMasks).GetHashCode() ^ SignalSemaphoreCount.GetHashCode() ^ ((ulong)SignalSemaphoreDeviceIndices).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDeviceGroupSubmitInfo l, in VkDeviceGroupSubmitInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.WaitSemaphoreCount == r.WaitSemaphoreCount) && (l.WaitSemaphoreDeviceIndices == r.WaitSemaphoreDeviceIndices)
			&& (l.CommandBufferCount == r.CommandBufferCount) && (l.CommandBufferDeviceMasks == r.CommandBufferDeviceMasks) && (l.SignalSemaphoreCount == r.SignalSemaphoreCount) && (l.SignalSemaphoreDeviceIndices == r.SignalSemaphoreDeviceIndices)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDeviceGroupSubmitInfo l, in VkDeviceGroupSubmitInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.WaitSemaphoreCount != r.WaitSemaphoreCount) || (l.WaitSemaphoreDeviceIndices != r.WaitSemaphoreDeviceIndices)
			|| (l.CommandBufferCount != r.CommandBufferCount) || (l.CommandBufferDeviceMasks != r.CommandBufferDeviceMasks) || (l.SignalSemaphoreCount != r.SignalSemaphoreCount) || (l.SignalSemaphoreDeviceIndices != r.SignalSemaphoreDeviceIndices)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDeviceGroupSubmitInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDeviceGroupBindSparseInfo : IEquatable<VkDeviceGroupBindSparseInfo>
{
	public const VkStructureType TYPE = VkStructureType.DeviceGroupBindSparseInfo;

	public VkStructureType sType;
	public void* pNext;
	public uint ResourceDeviceIndex;
	public uint MemoryDeviceIndex;

	public VkDeviceGroupBindSparseInfo(
		uint resourceDeviceIndex = default,
		uint memoryDeviceIndex = default
	) {
		sType = TYPE;
		pNext = null;
		ResourceDeviceIndex = resourceDeviceIndex;
		MemoryDeviceIndex = memoryDeviceIndex;
	}

	public readonly override bool Equals(object? o) => (o is VkDeviceGroupBindSparseInfo s) && (this == s);
	readonly bool IEquatable<VkDeviceGroupBindSparseInfo>.Equals(VkDeviceGroupBindSparseInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ResourceDeviceIndex.GetHashCode() ^ MemoryDeviceIndex.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDeviceGroupBindSparseInfo l, in VkDeviceGroupBindSparseInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ResourceDeviceIndex == r.ResourceDeviceIndex) && (l.MemoryDeviceIndex == r.MemoryDeviceIndex)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDeviceGroupBindSparseInfo l, in VkDeviceGroupBindSparseInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ResourceDeviceIndex != r.ResourceDeviceIndex) || (l.MemoryDeviceIndex != r.MemoryDeviceIndex)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDeviceGroupBindSparseInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDeviceGroupDeviceCreateInfo : IEquatable<VkDeviceGroupDeviceCreateInfo>
{
	public const VkStructureType TYPE = VkStructureType.DeviceGroupDeviceCreateInfo;

	public VkStructureType sType;
	public void* pNext;
	public uint PhysicalDeviceCount;
	public VulkanHandle<VkPhysicalDevice>* PhysicalDevices;

	public VkDeviceGroupDeviceCreateInfo(
		uint physicalDeviceCount = default,
		VulkanHandle<VkPhysicalDevice>* physicalDevices = default
	) {
		sType = TYPE;
		pNext = null;
		PhysicalDeviceCount = physicalDeviceCount;
		PhysicalDevices = physicalDevices;
	}

	public readonly override bool Equals(object? o) => (o is VkDeviceGroupDeviceCreateInfo s) && (this == s);
	readonly bool IEquatable<VkDeviceGroupDeviceCreateInfo>.Equals(VkDeviceGroupDeviceCreateInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ PhysicalDeviceCount.GetHashCode() ^ ((ulong)PhysicalDevices).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDeviceGroupDeviceCreateInfo l, in VkDeviceGroupDeviceCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.PhysicalDeviceCount == r.PhysicalDeviceCount) && (l.PhysicalDevices == r.PhysicalDevices)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDeviceGroupDeviceCreateInfo l, in VkDeviceGroupDeviceCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.PhysicalDeviceCount != r.PhysicalDeviceCount) || (l.PhysicalDevices != r.PhysicalDevices)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDeviceGroupDeviceCreateInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDescriptorUpdateTemplateEntry : IEquatable<VkDescriptorUpdateTemplateEntry>
{
	public uint DstBinding;
	public uint DstArrayElement;
	public uint DescriptorCount;
	public VkDescriptorType DescriptorType;
	public ulong Offset;
	public ulong Stride;

	public VkDescriptorUpdateTemplateEntry(
		uint dstBinding = default,
		uint dstArrayElement = default,
		uint descriptorCount = default,
		VkDescriptorType descriptorType = default,
		ulong offset = default,
		ulong stride = default
	) {
		DstBinding = dstBinding;
		DstArrayElement = dstArrayElement;
		DescriptorCount = descriptorCount;
		DescriptorType = descriptorType;
		Offset = offset;
		Stride = stride;
	}

	public readonly override bool Equals(object? o) => (o is VkDescriptorUpdateTemplateEntry s) && (this == s);
	readonly bool IEquatable<VkDescriptorUpdateTemplateEntry>.Equals(VkDescriptorUpdateTemplateEntry o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			DstBinding.GetHashCode() ^ DstArrayElement.GetHashCode() ^ DescriptorCount.GetHashCode() ^ DescriptorType.GetHashCode()
			^ Offset.GetHashCode() ^ Stride.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDescriptorUpdateTemplateEntry l, in VkDescriptorUpdateTemplateEntry r)
	{
		return
			(l.DstBinding == r.DstBinding) && (l.DstArrayElement == r.DstArrayElement) && (l.DescriptorCount == r.DescriptorCount) && (l.DescriptorType == r.DescriptorType)
			&& (l.Offset == r.Offset) && (l.Stride == r.Stride)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDescriptorUpdateTemplateEntry l, in VkDescriptorUpdateTemplateEntry r)
	{
		return
			(l.DstBinding != r.DstBinding) || (l.DstArrayElement != r.DstArrayElement) || (l.DescriptorCount != r.DescriptorCount) || (l.DescriptorType != r.DescriptorType)
			|| (l.Offset != r.Offset) || (l.Stride != r.Stride)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDescriptorUpdateTemplateEntry s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDescriptorUpdateTemplateCreateInfo : IEquatable<VkDescriptorUpdateTemplateCreateInfo>
{
	public const VkStructureType TYPE = VkStructureType.DescriptorUpdateTemplateCreateInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkDescriptorUpdateTemplateCreateFlags Flags;
	public uint DescriptorUpdateEntryCount;
	public VkDescriptorUpdateTemplateEntry* DescriptorUpdateEntries;
	public VkDescriptorUpdateTemplateType TemplateType;
	public VulkanHandle<VkDescriptorSetLayout> DescriptorSetLayout;
	public VkPipelineBindPoint PipelineBindPoint;
	public VulkanHandle<VkPipelineLayout> PipelineLayout;
	public uint Set;

	public VkDescriptorUpdateTemplateCreateInfo(
		VkDescriptorUpdateTemplateCreateFlags flags = default,
		uint descriptorUpdateEntryCount = default,
		VkDescriptorUpdateTemplateEntry* descriptorUpdateEntries = default,
		VkDescriptorUpdateTemplateType templateType = default,
		VulkanHandle<VkDescriptorSetLayout> descriptorSetLayout = default,
		VkPipelineBindPoint pipelineBindPoint = default,
		VulkanHandle<VkPipelineLayout> pipelineLayout = default,
		uint set = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		DescriptorUpdateEntryCount = descriptorUpdateEntryCount;
		DescriptorUpdateEntries = descriptorUpdateEntries;
		TemplateType = templateType;
		DescriptorSetLayout = descriptorSetLayout;
		PipelineBindPoint = pipelineBindPoint;
		PipelineLayout = pipelineLayout;
		Set = set;
	}

	public readonly override bool Equals(object? o) => (o is VkDescriptorUpdateTemplateCreateInfo s) && (this == s);
	readonly bool IEquatable<VkDescriptorUpdateTemplateCreateInfo>.Equals(VkDescriptorUpdateTemplateCreateInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ DescriptorUpdateEntryCount.GetHashCode()
			^ ((ulong)DescriptorUpdateEntries).GetHashCode() ^ TemplateType.GetHashCode() ^ DescriptorSetLayout.GetHashCode() ^ PipelineBindPoint.GetHashCode()
			^ PipelineLayout.GetHashCode() ^ Set.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDescriptorUpdateTemplateCreateInfo l, in VkDescriptorUpdateTemplateCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.DescriptorUpdateEntryCount == r.DescriptorUpdateEntryCount)
			&& (l.DescriptorUpdateEntries == r.DescriptorUpdateEntries) && (l.TemplateType == r.TemplateType) && (l.DescriptorSetLayout == r.DescriptorSetLayout) && (l.PipelineBindPoint == r.PipelineBindPoint)
			&& (l.PipelineLayout == r.PipelineLayout) && (l.Set == r.Set)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDescriptorUpdateTemplateCreateInfo l, in VkDescriptorUpdateTemplateCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.DescriptorUpdateEntryCount != r.DescriptorUpdateEntryCount)
			|| (l.DescriptorUpdateEntries != r.DescriptorUpdateEntries) || (l.TemplateType != r.TemplateType) || (l.DescriptorSetLayout != r.DescriptorSetLayout) || (l.PipelineBindPoint != r.PipelineBindPoint)
			|| (l.PipelineLayout != r.PipelineLayout) || (l.Set != r.Set)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDescriptorUpdateTemplateCreateInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkInputAttachmentAspectReference : IEquatable<VkInputAttachmentAspectReference>
{
	public uint Subpass;
	public uint InputAttachmentIndex;
	public VkImageAspectFlags AspectMask;

	public VkInputAttachmentAspectReference(
		uint subpass = default,
		uint inputAttachmentIndex = default,
		VkImageAspectFlags aspectMask = default
	) {
		Subpass = subpass;
		InputAttachmentIndex = inputAttachmentIndex;
		AspectMask = aspectMask;
	}

	public readonly override bool Equals(object? o) => (o is VkInputAttachmentAspectReference s) && (this == s);
	readonly bool IEquatable<VkInputAttachmentAspectReference>.Equals(VkInputAttachmentAspectReference o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Subpass.GetHashCode() ^ InputAttachmentIndex.GetHashCode() ^ AspectMask.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkInputAttachmentAspectReference l, in VkInputAttachmentAspectReference r)
	{
		return
			(l.Subpass == r.Subpass) && (l.InputAttachmentIndex == r.InputAttachmentIndex) && (l.AspectMask == r.AspectMask)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkInputAttachmentAspectReference l, in VkInputAttachmentAspectReference r)
	{
		return
			(l.Subpass != r.Subpass) || (l.InputAttachmentIndex != r.InputAttachmentIndex) || (l.AspectMask != r.AspectMask)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkInputAttachmentAspectReference s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkRenderPassInputAttachmentAspectCreateInfo : IEquatable<VkRenderPassInputAttachmentAspectCreateInfo>
{
	public const VkStructureType TYPE = VkStructureType.RenderPassInputAttachmentAspectCreateInfo;

	public VkStructureType sType;
	public void* pNext;
	public uint AspectReferenceCount;
	public VkInputAttachmentAspectReference* AspectReferences;

	public VkRenderPassInputAttachmentAspectCreateInfo(
		uint aspectReferenceCount = default,
		VkInputAttachmentAspectReference* aspectReferences = default
	) {
		sType = TYPE;
		pNext = null;
		AspectReferenceCount = aspectReferenceCount;
		AspectReferences = aspectReferences;
	}

	public readonly override bool Equals(object? o) => (o is VkRenderPassInputAttachmentAspectCreateInfo s) && (this == s);
	readonly bool IEquatable<VkRenderPassInputAttachmentAspectCreateInfo>.Equals(VkRenderPassInputAttachmentAspectCreateInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ AspectReferenceCount.GetHashCode() ^ ((ulong)AspectReferences).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkRenderPassInputAttachmentAspectCreateInfo l, in VkRenderPassInputAttachmentAspectCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.AspectReferenceCount == r.AspectReferenceCount) && (l.AspectReferences == r.AspectReferences)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkRenderPassInputAttachmentAspectCreateInfo l, in VkRenderPassInputAttachmentAspectCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.AspectReferenceCount != r.AspectReferenceCount) || (l.AspectReferences != r.AspectReferences)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkRenderPassInputAttachmentAspectCreateInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDevice16BitStorageFeatures : IEquatable<VkPhysicalDevice16BitStorageFeatures>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDevice16BitStorageFeatures;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 StorageBuffer16BitAccess;
	public VkBool32 UniformAndStorageBuffer16BitAccess;
	public VkBool32 StoragePushConstant16;
	public VkBool32 StorageInputOutput16;

	public VkPhysicalDevice16BitStorageFeatures(
		VkBool32 storageBuffer16BitAccess = default,
		VkBool32 uniformAndStorageBuffer16BitAccess = default,
		VkBool32 storagePushConstant16 = default,
		VkBool32 storageInputOutput16 = default
	) {
		sType = TYPE;
		pNext = null;
		StorageBuffer16BitAccess = storageBuffer16BitAccess;
		UniformAndStorageBuffer16BitAccess = uniformAndStorageBuffer16BitAccess;
		StoragePushConstant16 = storagePushConstant16;
		StorageInputOutput16 = storageInputOutput16;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDevice16BitStorageFeatures s) && (this == s);
	readonly bool IEquatable<VkPhysicalDevice16BitStorageFeatures>.Equals(VkPhysicalDevice16BitStorageFeatures o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ StorageBuffer16BitAccess.GetHashCode() ^ UniformAndStorageBuffer16BitAccess.GetHashCode()
			^ StoragePushConstant16.GetHashCode() ^ StorageInputOutput16.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDevice16BitStorageFeatures l, in VkPhysicalDevice16BitStorageFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.StorageBuffer16BitAccess == r.StorageBuffer16BitAccess) && (l.UniformAndStorageBuffer16BitAccess == r.UniformAndStorageBuffer16BitAccess)
			&& (l.StoragePushConstant16 == r.StoragePushConstant16) && (l.StorageInputOutput16 == r.StorageInputOutput16)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDevice16BitStorageFeatures l, in VkPhysicalDevice16BitStorageFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.StorageBuffer16BitAccess != r.StorageBuffer16BitAccess) || (l.UniformAndStorageBuffer16BitAccess != r.UniformAndStorageBuffer16BitAccess)
			|| (l.StoragePushConstant16 != r.StoragePushConstant16) || (l.StorageInputOutput16 != r.StorageInputOutput16)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDevice16BitStorageFeatures s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceSubgroupProperties : IEquatable<VkPhysicalDeviceSubgroupProperties>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceSubgroupProperties;

	public VkStructureType sType;
	public void* pNext;
	public uint SubgroupSize;
	public VkShaderStageFlags SupportedStages;
	public VkSubgroupFeatureFlags SupportedOperations;
	public VkBool32 QuadOperationsInAllStages;

	public VkPhysicalDeviceSubgroupProperties(
		uint subgroupSize = default,
		VkShaderStageFlags supportedStages = default,
		VkSubgroupFeatureFlags supportedOperations = default,
		VkBool32 quadOperationsInAllStages = default
	) {
		sType = TYPE;
		pNext = null;
		SubgroupSize = subgroupSize;
		SupportedStages = supportedStages;
		SupportedOperations = supportedOperations;
		QuadOperationsInAllStages = quadOperationsInAllStages;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceSubgroupProperties s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceSubgroupProperties>.Equals(VkPhysicalDeviceSubgroupProperties o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SubgroupSize.GetHashCode() ^ SupportedStages.GetHashCode()
			^ SupportedOperations.GetHashCode() ^ QuadOperationsInAllStages.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceSubgroupProperties l, in VkPhysicalDeviceSubgroupProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SubgroupSize == r.SubgroupSize) && (l.SupportedStages == r.SupportedStages)
			&& (l.SupportedOperations == r.SupportedOperations) && (l.QuadOperationsInAllStages == r.QuadOperationsInAllStages)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceSubgroupProperties l, in VkPhysicalDeviceSubgroupProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SubgroupSize != r.SubgroupSize) || (l.SupportedStages != r.SupportedStages)
			|| (l.SupportedOperations != r.SupportedOperations) || (l.QuadOperationsInAllStages != r.QuadOperationsInAllStages)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceSubgroupProperties s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures : IEquatable<VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceShaderSubgroupExtendedTypesFeatures;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 ShaderSubgroupExtendedTypes;

	public VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures(
		VkBool32 shaderSubgroupExtendedTypes = default
	) {
		sType = TYPE;
		pNext = null;
		ShaderSubgroupExtendedTypes = shaderSubgroupExtendedTypes;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures>.Equals(VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ShaderSubgroupExtendedTypes.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures l, in VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ShaderSubgroupExtendedTypes == r.ShaderSubgroupExtendedTypes)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures l, in VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ShaderSubgroupExtendedTypes != r.ShaderSubgroupExtendedTypes)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkBufferMemoryRequirementsInfo2 : IEquatable<VkBufferMemoryRequirementsInfo2>
{
	public const VkStructureType TYPE = VkStructureType.BufferMemoryRequirementsInfo2;

	public VkStructureType sType;
	public void* pNext;
	public VulkanHandle<VkBuffer> Buffer;

	public VkBufferMemoryRequirementsInfo2(
		VulkanHandle<VkBuffer> buffer = default
	) {
		sType = TYPE;
		pNext = null;
		Buffer = buffer;
	}

	public readonly override bool Equals(object? o) => (o is VkBufferMemoryRequirementsInfo2 s) && (this == s);
	readonly bool IEquatable<VkBufferMemoryRequirementsInfo2>.Equals(VkBufferMemoryRequirementsInfo2 o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Buffer.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkBufferMemoryRequirementsInfo2 l, in VkBufferMemoryRequirementsInfo2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Buffer == r.Buffer)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkBufferMemoryRequirementsInfo2 l, in VkBufferMemoryRequirementsInfo2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Buffer != r.Buffer)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkBufferMemoryRequirementsInfo2 s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkImageMemoryRequirementsInfo2 : IEquatable<VkImageMemoryRequirementsInfo2>
{
	public const VkStructureType TYPE = VkStructureType.ImageMemoryRequirementsInfo2;

	public VkStructureType sType;
	public void* pNext;
	public VulkanHandle<VkImage> Image;

	public VkImageMemoryRequirementsInfo2(
		VulkanHandle<VkImage> image = default
	) {
		sType = TYPE;
		pNext = null;
		Image = image;
	}

	public readonly override bool Equals(object? o) => (o is VkImageMemoryRequirementsInfo2 s) && (this == s);
	readonly bool IEquatable<VkImageMemoryRequirementsInfo2>.Equals(VkImageMemoryRequirementsInfo2 o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Image.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkImageMemoryRequirementsInfo2 l, in VkImageMemoryRequirementsInfo2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Image == r.Image)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkImageMemoryRequirementsInfo2 l, in VkImageMemoryRequirementsInfo2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Image != r.Image)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkImageMemoryRequirementsInfo2 s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkImageSparseMemoryRequirementsInfo2 : IEquatable<VkImageSparseMemoryRequirementsInfo2>
{
	public const VkStructureType TYPE = VkStructureType.ImageSparseMemoryRequirementsInfo2;

	public VkStructureType sType;
	public void* pNext;
	public VulkanHandle<VkImage> Image;

	public VkImageSparseMemoryRequirementsInfo2(
		VulkanHandle<VkImage> image = default
	) {
		sType = TYPE;
		pNext = null;
		Image = image;
	}

	public readonly override bool Equals(object? o) => (o is VkImageSparseMemoryRequirementsInfo2 s) && (this == s);
	readonly bool IEquatable<VkImageSparseMemoryRequirementsInfo2>.Equals(VkImageSparseMemoryRequirementsInfo2 o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Image.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkImageSparseMemoryRequirementsInfo2 l, in VkImageSparseMemoryRequirementsInfo2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Image == r.Image)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkImageSparseMemoryRequirementsInfo2 l, in VkImageSparseMemoryRequirementsInfo2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Image != r.Image)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkImageSparseMemoryRequirementsInfo2 s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkMemoryRequirements2 : IEquatable<VkMemoryRequirements2>
{
	public const VkStructureType TYPE = VkStructureType.MemoryRequirements2;

	public VkStructureType sType;
	public void* pNext;
	public VkMemoryRequirements MemoryRequirements;

	public VkMemoryRequirements2(
		VkMemoryRequirements memoryRequirements = default
	) {
		sType = TYPE;
		pNext = null;
		MemoryRequirements = memoryRequirements;
	}

	public readonly override bool Equals(object? o) => (o is VkMemoryRequirements2 s) && (this == s);
	readonly bool IEquatable<VkMemoryRequirements2>.Equals(VkMemoryRequirements2 o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MemoryRequirements.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkMemoryRequirements2 l, in VkMemoryRequirements2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MemoryRequirements == r.MemoryRequirements)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkMemoryRequirements2 l, in VkMemoryRequirements2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MemoryRequirements != r.MemoryRequirements)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkMemoryRequirements2 s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkSparseImageMemoryRequirements2 : IEquatable<VkSparseImageMemoryRequirements2>
{
	public const VkStructureType TYPE = VkStructureType.SparseImageMemoryRequirements2;

	public VkStructureType sType;
	public void* pNext;
	public VkSparseImageMemoryRequirements MemoryRequirements;

	public VkSparseImageMemoryRequirements2(
		VkSparseImageMemoryRequirements memoryRequirements = default
	) {
		sType = TYPE;
		pNext = null;
		MemoryRequirements = memoryRequirements;
	}

	public readonly override bool Equals(object? o) => (o is VkSparseImageMemoryRequirements2 s) && (this == s);
	readonly bool IEquatable<VkSparseImageMemoryRequirements2>.Equals(VkSparseImageMemoryRequirements2 o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MemoryRequirements.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkSparseImageMemoryRequirements2 l, in VkSparseImageMemoryRequirements2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MemoryRequirements == r.MemoryRequirements)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkSparseImageMemoryRequirements2 l, in VkSparseImageMemoryRequirements2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MemoryRequirements != r.MemoryRequirements)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkSparseImageMemoryRequirements2 s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDevicePointClippingProperties : IEquatable<VkPhysicalDevicePointClippingProperties>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDevicePointClippingProperties;

	public VkStructureType sType;
	public void* pNext;
	public VkPointClippingBehavior PointClippingBehavior;

	public VkPhysicalDevicePointClippingProperties(
		VkPointClippingBehavior pointClippingBehavior = default
	) {
		sType = TYPE;
		pNext = null;
		PointClippingBehavior = pointClippingBehavior;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDevicePointClippingProperties s) && (this == s);
	readonly bool IEquatable<VkPhysicalDevicePointClippingProperties>.Equals(VkPhysicalDevicePointClippingProperties o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ PointClippingBehavior.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDevicePointClippingProperties l, in VkPhysicalDevicePointClippingProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.PointClippingBehavior == r.PointClippingBehavior)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDevicePointClippingProperties l, in VkPhysicalDevicePointClippingProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.PointClippingBehavior != r.PointClippingBehavior)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDevicePointClippingProperties s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkMemoryDedicatedRequirements : IEquatable<VkMemoryDedicatedRequirements>
{
	public const VkStructureType TYPE = VkStructureType.MemoryDedicatedRequirements;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 PrefersDedicatedAllocation;
	public VkBool32 RequiresDedicatedAllocation;

	public VkMemoryDedicatedRequirements(
		VkBool32 prefersDedicatedAllocation = default,
		VkBool32 requiresDedicatedAllocation = default
	) {
		sType = TYPE;
		pNext = null;
		PrefersDedicatedAllocation = prefersDedicatedAllocation;
		RequiresDedicatedAllocation = requiresDedicatedAllocation;
	}

	public readonly override bool Equals(object? o) => (o is VkMemoryDedicatedRequirements s) && (this == s);
	readonly bool IEquatable<VkMemoryDedicatedRequirements>.Equals(VkMemoryDedicatedRequirements o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ PrefersDedicatedAllocation.GetHashCode() ^ RequiresDedicatedAllocation.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkMemoryDedicatedRequirements l, in VkMemoryDedicatedRequirements r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.PrefersDedicatedAllocation == r.PrefersDedicatedAllocation) && (l.RequiresDedicatedAllocation == r.RequiresDedicatedAllocation)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkMemoryDedicatedRequirements l, in VkMemoryDedicatedRequirements r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.PrefersDedicatedAllocation != r.PrefersDedicatedAllocation) || (l.RequiresDedicatedAllocation != r.RequiresDedicatedAllocation)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkMemoryDedicatedRequirements s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkMemoryDedicatedAllocateInfo : IEquatable<VkMemoryDedicatedAllocateInfo>
{
	public const VkStructureType TYPE = VkStructureType.MemoryDedicatedAllocateInfo;

	public VkStructureType sType;
	public void* pNext;
	public VulkanHandle<VkImage> Image;
	public VulkanHandle<VkBuffer> Buffer;

	public VkMemoryDedicatedAllocateInfo(
		VulkanHandle<VkImage> image = default,
		VulkanHandle<VkBuffer> buffer = default
	) {
		sType = TYPE;
		pNext = null;
		Image = image;
		Buffer = buffer;
	}

	public readonly override bool Equals(object? o) => (o is VkMemoryDedicatedAllocateInfo s) && (this == s);
	readonly bool IEquatable<VkMemoryDedicatedAllocateInfo>.Equals(VkMemoryDedicatedAllocateInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Image.GetHashCode() ^ Buffer.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkMemoryDedicatedAllocateInfo l, in VkMemoryDedicatedAllocateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Image == r.Image) && (l.Buffer == r.Buffer)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkMemoryDedicatedAllocateInfo l, in VkMemoryDedicatedAllocateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Image != r.Image) || (l.Buffer != r.Buffer)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkMemoryDedicatedAllocateInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkImageViewUsageCreateInfo : IEquatable<VkImageViewUsageCreateInfo>
{
	public const VkStructureType TYPE = VkStructureType.ImageViewUsageCreateInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkImageUsageFlags Usage;

	public VkImageViewUsageCreateInfo(
		VkImageUsageFlags usage = default
	) {
		sType = TYPE;
		pNext = null;
		Usage = usage;
	}

	public readonly override bool Equals(object? o) => (o is VkImageViewUsageCreateInfo s) && (this == s);
	readonly bool IEquatable<VkImageViewUsageCreateInfo>.Equals(VkImageViewUsageCreateInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Usage.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkImageViewUsageCreateInfo l, in VkImageViewUsageCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Usage == r.Usage)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkImageViewUsageCreateInfo l, in VkImageViewUsageCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Usage != r.Usage)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkImageViewUsageCreateInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPipelineTessellationDomainOriginStateCreateInfo : IEquatable<VkPipelineTessellationDomainOriginStateCreateInfo>
{
	public const VkStructureType TYPE = VkStructureType.PipelineTessellationDomainOriginStateCreateInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkTessellationDomainOrigin DomainOrigin;

	public VkPipelineTessellationDomainOriginStateCreateInfo(
		VkTessellationDomainOrigin domainOrigin = default
	) {
		sType = TYPE;
		pNext = null;
		DomainOrigin = domainOrigin;
	}

	public readonly override bool Equals(object? o) => (o is VkPipelineTessellationDomainOriginStateCreateInfo s) && (this == s);
	readonly bool IEquatable<VkPipelineTessellationDomainOriginStateCreateInfo>.Equals(VkPipelineTessellationDomainOriginStateCreateInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DomainOrigin.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPipelineTessellationDomainOriginStateCreateInfo l, in VkPipelineTessellationDomainOriginStateCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DomainOrigin == r.DomainOrigin)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPipelineTessellationDomainOriginStateCreateInfo l, in VkPipelineTessellationDomainOriginStateCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DomainOrigin != r.DomainOrigin)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPipelineTessellationDomainOriginStateCreateInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkSamplerYcbcrConversionInfo : IEquatable<VkSamplerYcbcrConversionInfo>
{
	public const VkStructureType TYPE = VkStructureType.SamplerYcbcrConversionInfo;

	public VkStructureType sType;
	public void* pNext;
	public VulkanHandle<VkSamplerYcbcrConversion> Conversion;

	public VkSamplerYcbcrConversionInfo(
		VulkanHandle<VkSamplerYcbcrConversion> conversion = default
	) {
		sType = TYPE;
		pNext = null;
		Conversion = conversion;
	}

	public readonly override bool Equals(object? o) => (o is VkSamplerYcbcrConversionInfo s) && (this == s);
	readonly bool IEquatable<VkSamplerYcbcrConversionInfo>.Equals(VkSamplerYcbcrConversionInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Conversion.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkSamplerYcbcrConversionInfo l, in VkSamplerYcbcrConversionInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Conversion == r.Conversion)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkSamplerYcbcrConversionInfo l, in VkSamplerYcbcrConversionInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Conversion != r.Conversion)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkSamplerYcbcrConversionInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkSamplerYcbcrConversionCreateInfo : IEquatable<VkSamplerYcbcrConversionCreateInfo>
{
	public const VkStructureType TYPE = VkStructureType.SamplerYcbcrConversionCreateInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkFormat Format;
	public VkSamplerYcbcrModelConversion YcbcrModel;
	public VkSamplerYcbcrRange YcbcrRange;
	public VkComponentMapping Components;
	public VkChromaLocation XChromaOffset;
	public VkChromaLocation YChromaOffset;
	public VkFilter ChromaFilter;
	public VkBool32 ForceExplicitReconstruction;

	public VkSamplerYcbcrConversionCreateInfo(
		VkFormat format = default,
		VkSamplerYcbcrModelConversion ycbcrModel = default,
		VkSamplerYcbcrRange ycbcrRange = default,
		VkComponentMapping components = default,
		VkChromaLocation xChromaOffset = default,
		VkChromaLocation yChromaOffset = default,
		VkFilter chromaFilter = default,
		VkBool32 forceExplicitReconstruction = default
	) {
		sType = TYPE;
		pNext = null;
		Format = format;
		YcbcrModel = ycbcrModel;
		YcbcrRange = ycbcrRange;
		Components = components;
		XChromaOffset = xChromaOffset;
		YChromaOffset = yChromaOffset;
		ChromaFilter = chromaFilter;
		ForceExplicitReconstruction = forceExplicitReconstruction;
	}

	public readonly override bool Equals(object? o) => (o is VkSamplerYcbcrConversionCreateInfo s) && (this == s);
	readonly bool IEquatable<VkSamplerYcbcrConversionCreateInfo>.Equals(VkSamplerYcbcrConversionCreateInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Format.GetHashCode() ^ YcbcrModel.GetHashCode()
			^ YcbcrRange.GetHashCode() ^ Components.GetHashCode() ^ XChromaOffset.GetHashCode() ^ YChromaOffset.GetHashCode()
			^ ChromaFilter.GetHashCode() ^ ForceExplicitReconstruction.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkSamplerYcbcrConversionCreateInfo l, in VkSamplerYcbcrConversionCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Format == r.Format) && (l.YcbcrModel == r.YcbcrModel)
			&& (l.YcbcrRange == r.YcbcrRange) && (l.Components == r.Components) && (l.XChromaOffset == r.XChromaOffset) && (l.YChromaOffset == r.YChromaOffset)
			&& (l.ChromaFilter == r.ChromaFilter) && (l.ForceExplicitReconstruction == r.ForceExplicitReconstruction)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkSamplerYcbcrConversionCreateInfo l, in VkSamplerYcbcrConversionCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Format != r.Format) || (l.YcbcrModel != r.YcbcrModel)
			|| (l.YcbcrRange != r.YcbcrRange) || (l.Components != r.Components) || (l.XChromaOffset != r.XChromaOffset) || (l.YChromaOffset != r.YChromaOffset)
			|| (l.ChromaFilter != r.ChromaFilter) || (l.ForceExplicitReconstruction != r.ForceExplicitReconstruction)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkSamplerYcbcrConversionCreateInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkBindImagePlaneMemoryInfo : IEquatable<VkBindImagePlaneMemoryInfo>
{
	public const VkStructureType TYPE = VkStructureType.BindImagePlaneMemoryInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkImageAspectFlags PlaneAspect;

	public VkBindImagePlaneMemoryInfo(
		VkImageAspectFlags planeAspect = default
	) {
		sType = TYPE;
		pNext = null;
		PlaneAspect = planeAspect;
	}

	public readonly override bool Equals(object? o) => (o is VkBindImagePlaneMemoryInfo s) && (this == s);
	readonly bool IEquatable<VkBindImagePlaneMemoryInfo>.Equals(VkBindImagePlaneMemoryInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ PlaneAspect.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkBindImagePlaneMemoryInfo l, in VkBindImagePlaneMemoryInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.PlaneAspect == r.PlaneAspect)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkBindImagePlaneMemoryInfo l, in VkBindImagePlaneMemoryInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.PlaneAspect != r.PlaneAspect)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkBindImagePlaneMemoryInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkImagePlaneMemoryRequirementsInfo : IEquatable<VkImagePlaneMemoryRequirementsInfo>
{
	public const VkStructureType TYPE = VkStructureType.ImagePlaneMemoryRequirementsInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkImageAspectFlags PlaneAspect;

	public VkImagePlaneMemoryRequirementsInfo(
		VkImageAspectFlags planeAspect = default
	) {
		sType = TYPE;
		pNext = null;
		PlaneAspect = planeAspect;
	}

	public readonly override bool Equals(object? o) => (o is VkImagePlaneMemoryRequirementsInfo s) && (this == s);
	readonly bool IEquatable<VkImagePlaneMemoryRequirementsInfo>.Equals(VkImagePlaneMemoryRequirementsInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ PlaneAspect.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkImagePlaneMemoryRequirementsInfo l, in VkImagePlaneMemoryRequirementsInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.PlaneAspect == r.PlaneAspect)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkImagePlaneMemoryRequirementsInfo l, in VkImagePlaneMemoryRequirementsInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.PlaneAspect != r.PlaneAspect)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkImagePlaneMemoryRequirementsInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceSamplerYcbcrConversionFeatures : IEquatable<VkPhysicalDeviceSamplerYcbcrConversionFeatures>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceSamplerYcbcrConversionFeatures;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 SamplerYcbcrConversion;

	public VkPhysicalDeviceSamplerYcbcrConversionFeatures(
		VkBool32 samplerYcbcrConversion = default
	) {
		sType = TYPE;
		pNext = null;
		SamplerYcbcrConversion = samplerYcbcrConversion;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceSamplerYcbcrConversionFeatures s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceSamplerYcbcrConversionFeatures>.Equals(VkPhysicalDeviceSamplerYcbcrConversionFeatures o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SamplerYcbcrConversion.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceSamplerYcbcrConversionFeatures l, in VkPhysicalDeviceSamplerYcbcrConversionFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SamplerYcbcrConversion == r.SamplerYcbcrConversion)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceSamplerYcbcrConversionFeatures l, in VkPhysicalDeviceSamplerYcbcrConversionFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SamplerYcbcrConversion != r.SamplerYcbcrConversion)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceSamplerYcbcrConversionFeatures s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkSamplerYcbcrConversionImageFormatProperties : IEquatable<VkSamplerYcbcrConversionImageFormatProperties>
{
	public const VkStructureType TYPE = VkStructureType.SamplerYcbcrConversionImageFormatProperties;

	public VkStructureType sType;
	public void* pNext;
	public uint CombinedImageSamplerDescriptorCount;

	public VkSamplerYcbcrConversionImageFormatProperties(
		uint combinedImageSamplerDescriptorCount = default
	) {
		sType = TYPE;
		pNext = null;
		CombinedImageSamplerDescriptorCount = combinedImageSamplerDescriptorCount;
	}

	public readonly override bool Equals(object? o) => (o is VkSamplerYcbcrConversionImageFormatProperties s) && (this == s);
	readonly bool IEquatable<VkSamplerYcbcrConversionImageFormatProperties>.Equals(VkSamplerYcbcrConversionImageFormatProperties o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ CombinedImageSamplerDescriptorCount.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkSamplerYcbcrConversionImageFormatProperties l, in VkSamplerYcbcrConversionImageFormatProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.CombinedImageSamplerDescriptorCount == r.CombinedImageSamplerDescriptorCount)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkSamplerYcbcrConversionImageFormatProperties l, in VkSamplerYcbcrConversionImageFormatProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.CombinedImageSamplerDescriptorCount != r.CombinedImageSamplerDescriptorCount)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkSamplerYcbcrConversionImageFormatProperties s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkProtectedSubmitInfo : IEquatable<VkProtectedSubmitInfo>
{
	public const VkStructureType TYPE = VkStructureType.ProtectedSubmitInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 ProtectedSubmit;

	public VkProtectedSubmitInfo(
		VkBool32 protectedSubmit = default
	) {
		sType = TYPE;
		pNext = null;
		ProtectedSubmit = protectedSubmit;
	}

	public readonly override bool Equals(object? o) => (o is VkProtectedSubmitInfo s) && (this == s);
	readonly bool IEquatable<VkProtectedSubmitInfo>.Equals(VkProtectedSubmitInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ProtectedSubmit.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkProtectedSubmitInfo l, in VkProtectedSubmitInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ProtectedSubmit == r.ProtectedSubmit)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkProtectedSubmitInfo l, in VkProtectedSubmitInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ProtectedSubmit != r.ProtectedSubmit)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkProtectedSubmitInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceProtectedMemoryFeatures : IEquatable<VkPhysicalDeviceProtectedMemoryFeatures>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceProtectedMemoryFeatures;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 ProtectedMemory;

	public VkPhysicalDeviceProtectedMemoryFeatures(
		VkBool32 protectedMemory = default
	) {
		sType = TYPE;
		pNext = null;
		ProtectedMemory = protectedMemory;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceProtectedMemoryFeatures s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceProtectedMemoryFeatures>.Equals(VkPhysicalDeviceProtectedMemoryFeatures o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ProtectedMemory.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceProtectedMemoryFeatures l, in VkPhysicalDeviceProtectedMemoryFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ProtectedMemory == r.ProtectedMemory)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceProtectedMemoryFeatures l, in VkPhysicalDeviceProtectedMemoryFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ProtectedMemory != r.ProtectedMemory)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceProtectedMemoryFeatures s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceProtectedMemoryProperties : IEquatable<VkPhysicalDeviceProtectedMemoryProperties>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceProtectedMemoryProperties;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 ProtectedNoFault;

	public VkPhysicalDeviceProtectedMemoryProperties(
		VkBool32 protectedNoFault = default
	) {
		sType = TYPE;
		pNext = null;
		ProtectedNoFault = protectedNoFault;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceProtectedMemoryProperties s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceProtectedMemoryProperties>.Equals(VkPhysicalDeviceProtectedMemoryProperties o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ProtectedNoFault.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceProtectedMemoryProperties l, in VkPhysicalDeviceProtectedMemoryProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ProtectedNoFault == r.ProtectedNoFault)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceProtectedMemoryProperties l, in VkPhysicalDeviceProtectedMemoryProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ProtectedNoFault != r.ProtectedNoFault)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceProtectedMemoryProperties s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDeviceQueueInfo2 : IEquatable<VkDeviceQueueInfo2>
{
	public const VkStructureType TYPE = VkStructureType.DeviceQueueInfo2;

	public VkStructureType sType;
	public void* pNext;
	public VkDeviceQueueCreateFlags Flags;
	public uint QueueFamilyIndex;
	public uint QueueIndex;

	public VkDeviceQueueInfo2(
		VkDeviceQueueCreateFlags flags = default,
		uint queueFamilyIndex = default,
		uint queueIndex = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		QueueFamilyIndex = queueFamilyIndex;
		QueueIndex = queueIndex;
	}

	public readonly override bool Equals(object? o) => (o is VkDeviceQueueInfo2 s) && (this == s);
	readonly bool IEquatable<VkDeviceQueueInfo2>.Equals(VkDeviceQueueInfo2 o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ QueueFamilyIndex.GetHashCode()
			^ QueueIndex.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDeviceQueueInfo2 l, in VkDeviceQueueInfo2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.QueueFamilyIndex == r.QueueFamilyIndex)
			&& (l.QueueIndex == r.QueueIndex)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDeviceQueueInfo2 l, in VkDeviceQueueInfo2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.QueueFamilyIndex != r.QueueFamilyIndex)
			|| (l.QueueIndex != r.QueueIndex)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDeviceQueueInfo2 s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceSamplerFilterMinmaxProperties : IEquatable<VkPhysicalDeviceSamplerFilterMinmaxProperties>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceSamplerFilterMinmaxProperties;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 FilterMinmaxSingleComponentFormats;
	public VkBool32 FilterMinmaxImageComponentMapping;

	public VkPhysicalDeviceSamplerFilterMinmaxProperties(
		VkBool32 filterMinmaxSingleComponentFormats = default,
		VkBool32 filterMinmaxImageComponentMapping = default
	) {
		sType = TYPE;
		pNext = null;
		FilterMinmaxSingleComponentFormats = filterMinmaxSingleComponentFormats;
		FilterMinmaxImageComponentMapping = filterMinmaxImageComponentMapping;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceSamplerFilterMinmaxProperties s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceSamplerFilterMinmaxProperties>.Equals(VkPhysicalDeviceSamplerFilterMinmaxProperties o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ FilterMinmaxSingleComponentFormats.GetHashCode() ^ FilterMinmaxImageComponentMapping.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceSamplerFilterMinmaxProperties l, in VkPhysicalDeviceSamplerFilterMinmaxProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.FilterMinmaxSingleComponentFormats == r.FilterMinmaxSingleComponentFormats) && (l.FilterMinmaxImageComponentMapping == r.FilterMinmaxImageComponentMapping)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceSamplerFilterMinmaxProperties l, in VkPhysicalDeviceSamplerFilterMinmaxProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.FilterMinmaxSingleComponentFormats != r.FilterMinmaxSingleComponentFormats) || (l.FilterMinmaxImageComponentMapping != r.FilterMinmaxImageComponentMapping)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceSamplerFilterMinmaxProperties s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkSamplerReductionModeCreateInfo : IEquatable<VkSamplerReductionModeCreateInfo>
{
	public const VkStructureType TYPE = VkStructureType.SamplerReductionModeCreateInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkSamplerReductionMode ReductionMode;

	public VkSamplerReductionModeCreateInfo(
		VkSamplerReductionMode reductionMode = default
	) {
		sType = TYPE;
		pNext = null;
		ReductionMode = reductionMode;
	}

	public readonly override bool Equals(object? o) => (o is VkSamplerReductionModeCreateInfo s) && (this == s);
	readonly bool IEquatable<VkSamplerReductionModeCreateInfo>.Equals(VkSamplerReductionModeCreateInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ReductionMode.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkSamplerReductionModeCreateInfo l, in VkSamplerReductionModeCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ReductionMode == r.ReductionMode)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkSamplerReductionModeCreateInfo l, in VkSamplerReductionModeCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ReductionMode != r.ReductionMode)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkSamplerReductionModeCreateInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkImageFormatListCreateInfo : IEquatable<VkImageFormatListCreateInfo>
{
	public const VkStructureType TYPE = VkStructureType.ImageFormatListCreateInfo;

	public VkStructureType sType;
	public void* pNext;
	public uint ViewFormatCount;
	public VkFormat* ViewFormats;

	public VkImageFormatListCreateInfo(
		uint viewFormatCount = default,
		VkFormat* viewFormats = default
	) {
		sType = TYPE;
		pNext = null;
		ViewFormatCount = viewFormatCount;
		ViewFormats = viewFormats;
	}

	public readonly override bool Equals(object? o) => (o is VkImageFormatListCreateInfo s) && (this == s);
	readonly bool IEquatable<VkImageFormatListCreateInfo>.Equals(VkImageFormatListCreateInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ViewFormatCount.GetHashCode() ^ ((ulong)ViewFormats).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkImageFormatListCreateInfo l, in VkImageFormatListCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ViewFormatCount == r.ViewFormatCount) && (l.ViewFormats == r.ViewFormats)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkImageFormatListCreateInfo l, in VkImageFormatListCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ViewFormatCount != r.ViewFormatCount) || (l.ViewFormats != r.ViewFormats)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkImageFormatListCreateInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceMaintenance3Properties : IEquatable<VkPhysicalDeviceMaintenance3Properties>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceMaintenance3Properties;

	public VkStructureType sType;
	public void* pNext;
	public uint MaxPerSetDescriptors;
	public ulong MaxMemoryAllocationSize;

	public VkPhysicalDeviceMaintenance3Properties(
		uint maxPerSetDescriptors = default,
		ulong maxMemoryAllocationSize = default
	) {
		sType = TYPE;
		pNext = null;
		MaxPerSetDescriptors = maxPerSetDescriptors;
		MaxMemoryAllocationSize = maxMemoryAllocationSize;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceMaintenance3Properties s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceMaintenance3Properties>.Equals(VkPhysicalDeviceMaintenance3Properties o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MaxPerSetDescriptors.GetHashCode() ^ MaxMemoryAllocationSize.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceMaintenance3Properties l, in VkPhysicalDeviceMaintenance3Properties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MaxPerSetDescriptors == r.MaxPerSetDescriptors) && (l.MaxMemoryAllocationSize == r.MaxMemoryAllocationSize)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceMaintenance3Properties l, in VkPhysicalDeviceMaintenance3Properties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MaxPerSetDescriptors != r.MaxPerSetDescriptors) || (l.MaxMemoryAllocationSize != r.MaxMemoryAllocationSize)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceMaintenance3Properties s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDescriptorSetLayoutSupport : IEquatable<VkDescriptorSetLayoutSupport>
{
	public const VkStructureType TYPE = VkStructureType.DescriptorSetLayoutSupport;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 Supported;

	public VkDescriptorSetLayoutSupport(
		VkBool32 supported = default
	) {
		sType = TYPE;
		pNext = null;
		Supported = supported;
	}

	public readonly override bool Equals(object? o) => (o is VkDescriptorSetLayoutSupport s) && (this == s);
	readonly bool IEquatable<VkDescriptorSetLayoutSupport>.Equals(VkDescriptorSetLayoutSupport o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Supported.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDescriptorSetLayoutSupport l, in VkDescriptorSetLayoutSupport r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Supported == r.Supported)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDescriptorSetLayoutSupport l, in VkDescriptorSetLayoutSupport r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Supported != r.Supported)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDescriptorSetLayoutSupport s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceShaderDrawParametersFeatures : IEquatable<VkPhysicalDeviceShaderDrawParametersFeatures>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceShaderDrawParametersFeatures;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 ShaderDrawParameters;

	public VkPhysicalDeviceShaderDrawParametersFeatures(
		VkBool32 shaderDrawParameters = default
	) {
		sType = TYPE;
		pNext = null;
		ShaderDrawParameters = shaderDrawParameters;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceShaderDrawParametersFeatures s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceShaderDrawParametersFeatures>.Equals(VkPhysicalDeviceShaderDrawParametersFeatures o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ShaderDrawParameters.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceShaderDrawParametersFeatures l, in VkPhysicalDeviceShaderDrawParametersFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ShaderDrawParameters == r.ShaderDrawParameters)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceShaderDrawParametersFeatures l, in VkPhysicalDeviceShaderDrawParametersFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ShaderDrawParameters != r.ShaderDrawParameters)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceShaderDrawParametersFeatures s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceShaderDrawParameterFeatures : IEquatable<VkPhysicalDeviceShaderDrawParameterFeatures>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceShaderDrawParametersFeatures;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 ShaderDrawParameters;

	public VkPhysicalDeviceShaderDrawParameterFeatures(
		VkBool32 shaderDrawParameters = default
	) {
		sType = TYPE;
		pNext = null;
		ShaderDrawParameters = shaderDrawParameters;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceShaderDrawParameterFeatures s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceShaderDrawParameterFeatures>.Equals(VkPhysicalDeviceShaderDrawParameterFeatures o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ShaderDrawParameters.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceShaderDrawParameterFeatures l, in VkPhysicalDeviceShaderDrawParameterFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ShaderDrawParameters == r.ShaderDrawParameters)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceShaderDrawParameterFeatures l, in VkPhysicalDeviceShaderDrawParameterFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ShaderDrawParameters != r.ShaderDrawParameters)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceShaderDrawParameterFeatures s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceShaderFloat16Int8Features : IEquatable<VkPhysicalDeviceShaderFloat16Int8Features>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceShaderFloat16Int8Features;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 ShaderFloat16;
	public VkBool32 ShaderInt8;

	public VkPhysicalDeviceShaderFloat16Int8Features(
		VkBool32 shaderFloat16 = default,
		VkBool32 shaderInt8 = default
	) {
		sType = TYPE;
		pNext = null;
		ShaderFloat16 = shaderFloat16;
		ShaderInt8 = shaderInt8;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceShaderFloat16Int8Features s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceShaderFloat16Int8Features>.Equals(VkPhysicalDeviceShaderFloat16Int8Features o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ShaderFloat16.GetHashCode() ^ ShaderInt8.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceShaderFloat16Int8Features l, in VkPhysicalDeviceShaderFloat16Int8Features r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ShaderFloat16 == r.ShaderFloat16) && (l.ShaderInt8 == r.ShaderInt8)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceShaderFloat16Int8Features l, in VkPhysicalDeviceShaderFloat16Int8Features r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ShaderFloat16 != r.ShaderFloat16) || (l.ShaderInt8 != r.ShaderInt8)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceShaderFloat16Int8Features s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceFloatControlsProperties : IEquatable<VkPhysicalDeviceFloatControlsProperties>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceFloatControlsProperties;

	public VkStructureType sType;
	public void* pNext;
	public VkShaderFloatControlsIndependence DenormBehaviorIndependence;
	public VkShaderFloatControlsIndependence RoundingModeIndependence;
	public VkBool32 ShaderSignedZeroInfNanPreserveFloat16;
	public VkBool32 ShaderSignedZeroInfNanPreserveFloat32;
	public VkBool32 ShaderSignedZeroInfNanPreserveFloat64;
	public VkBool32 ShaderDenormPreserveFloat16;
	public VkBool32 ShaderDenormPreserveFloat32;
	public VkBool32 ShaderDenormPreserveFloat64;
	public VkBool32 ShaderDenormFlushToZeroFloat16;
	public VkBool32 ShaderDenormFlushToZeroFloat32;
	public VkBool32 ShaderDenormFlushToZeroFloat64;
	public VkBool32 ShaderRoundingModeRTEFloat16;
	public VkBool32 ShaderRoundingModeRTEFloat32;
	public VkBool32 ShaderRoundingModeRTEFloat64;
	public VkBool32 ShaderRoundingModeRTZFloat16;
	public VkBool32 ShaderRoundingModeRTZFloat32;
	public VkBool32 ShaderRoundingModeRTZFloat64;

	public VkPhysicalDeviceFloatControlsProperties(
		VkShaderFloatControlsIndependence denormBehaviorIndependence = default,
		VkShaderFloatControlsIndependence roundingModeIndependence = default,
		VkBool32 shaderSignedZeroInfNanPreserveFloat16 = default,
		VkBool32 shaderSignedZeroInfNanPreserveFloat32 = default,
		VkBool32 shaderSignedZeroInfNanPreserveFloat64 = default,
		VkBool32 shaderDenormPreserveFloat16 = default,
		VkBool32 shaderDenormPreserveFloat32 = default,
		VkBool32 shaderDenormPreserveFloat64 = default,
		VkBool32 shaderDenormFlushToZeroFloat16 = default,
		VkBool32 shaderDenormFlushToZeroFloat32 = default,
		VkBool32 shaderDenormFlushToZeroFloat64 = default,
		VkBool32 shaderRoundingModeRTEFloat16 = default,
		VkBool32 shaderRoundingModeRTEFloat32 = default,
		VkBool32 shaderRoundingModeRTEFloat64 = default,
		VkBool32 shaderRoundingModeRTZFloat16 = default,
		VkBool32 shaderRoundingModeRTZFloat32 = default,
		VkBool32 shaderRoundingModeRTZFloat64 = default
	) {
		sType = TYPE;
		pNext = null;
		DenormBehaviorIndependence = denormBehaviorIndependence;
		RoundingModeIndependence = roundingModeIndependence;
		ShaderSignedZeroInfNanPreserveFloat16 = shaderSignedZeroInfNanPreserveFloat16;
		ShaderSignedZeroInfNanPreserveFloat32 = shaderSignedZeroInfNanPreserveFloat32;
		ShaderSignedZeroInfNanPreserveFloat64 = shaderSignedZeroInfNanPreserveFloat64;
		ShaderDenormPreserveFloat16 = shaderDenormPreserveFloat16;
		ShaderDenormPreserveFloat32 = shaderDenormPreserveFloat32;
		ShaderDenormPreserveFloat64 = shaderDenormPreserveFloat64;
		ShaderDenormFlushToZeroFloat16 = shaderDenormFlushToZeroFloat16;
		ShaderDenormFlushToZeroFloat32 = shaderDenormFlushToZeroFloat32;
		ShaderDenormFlushToZeroFloat64 = shaderDenormFlushToZeroFloat64;
		ShaderRoundingModeRTEFloat16 = shaderRoundingModeRTEFloat16;
		ShaderRoundingModeRTEFloat32 = shaderRoundingModeRTEFloat32;
		ShaderRoundingModeRTEFloat64 = shaderRoundingModeRTEFloat64;
		ShaderRoundingModeRTZFloat16 = shaderRoundingModeRTZFloat16;
		ShaderRoundingModeRTZFloat32 = shaderRoundingModeRTZFloat32;
		ShaderRoundingModeRTZFloat64 = shaderRoundingModeRTZFloat64;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceFloatControlsProperties s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceFloatControlsProperties>.Equals(VkPhysicalDeviceFloatControlsProperties o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DenormBehaviorIndependence.GetHashCode() ^ RoundingModeIndependence.GetHashCode()
			^ ShaderSignedZeroInfNanPreserveFloat16.GetHashCode() ^ ShaderSignedZeroInfNanPreserveFloat32.GetHashCode() ^ ShaderSignedZeroInfNanPreserveFloat64.GetHashCode() ^ ShaderDenormPreserveFloat16.GetHashCode()
			^ ShaderDenormPreserveFloat32.GetHashCode() ^ ShaderDenormPreserveFloat64.GetHashCode() ^ ShaderDenormFlushToZeroFloat16.GetHashCode() ^ ShaderDenormFlushToZeroFloat32.GetHashCode()
			^ ShaderDenormFlushToZeroFloat64.GetHashCode() ^ ShaderRoundingModeRTEFloat16.GetHashCode() ^ ShaderRoundingModeRTEFloat32.GetHashCode() ^ ShaderRoundingModeRTEFloat64.GetHashCode()
			^ ShaderRoundingModeRTZFloat16.GetHashCode() ^ ShaderRoundingModeRTZFloat32.GetHashCode() ^ ShaderRoundingModeRTZFloat64.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceFloatControlsProperties l, in VkPhysicalDeviceFloatControlsProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DenormBehaviorIndependence == r.DenormBehaviorIndependence) && (l.RoundingModeIndependence == r.RoundingModeIndependence)
			&& (l.ShaderSignedZeroInfNanPreserveFloat16 == r.ShaderSignedZeroInfNanPreserveFloat16) && (l.ShaderSignedZeroInfNanPreserveFloat32 == r.ShaderSignedZeroInfNanPreserveFloat32) && (l.ShaderSignedZeroInfNanPreserveFloat64 == r.ShaderSignedZeroInfNanPreserveFloat64) && (l.ShaderDenormPreserveFloat16 == r.ShaderDenormPreserveFloat16)
			&& (l.ShaderDenormPreserveFloat32 == r.ShaderDenormPreserveFloat32) && (l.ShaderDenormPreserveFloat64 == r.ShaderDenormPreserveFloat64) && (l.ShaderDenormFlushToZeroFloat16 == r.ShaderDenormFlushToZeroFloat16) && (l.ShaderDenormFlushToZeroFloat32 == r.ShaderDenormFlushToZeroFloat32)
			&& (l.ShaderDenormFlushToZeroFloat64 == r.ShaderDenormFlushToZeroFloat64) && (l.ShaderRoundingModeRTEFloat16 == r.ShaderRoundingModeRTEFloat16) && (l.ShaderRoundingModeRTEFloat32 == r.ShaderRoundingModeRTEFloat32) && (l.ShaderRoundingModeRTEFloat64 == r.ShaderRoundingModeRTEFloat64)
			&& (l.ShaderRoundingModeRTZFloat16 == r.ShaderRoundingModeRTZFloat16) && (l.ShaderRoundingModeRTZFloat32 == r.ShaderRoundingModeRTZFloat32) && (l.ShaderRoundingModeRTZFloat64 == r.ShaderRoundingModeRTZFloat64)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceFloatControlsProperties l, in VkPhysicalDeviceFloatControlsProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DenormBehaviorIndependence != r.DenormBehaviorIndependence) || (l.RoundingModeIndependence != r.RoundingModeIndependence)
			|| (l.ShaderSignedZeroInfNanPreserveFloat16 != r.ShaderSignedZeroInfNanPreserveFloat16) || (l.ShaderSignedZeroInfNanPreserveFloat32 != r.ShaderSignedZeroInfNanPreserveFloat32) || (l.ShaderSignedZeroInfNanPreserveFloat64 != r.ShaderSignedZeroInfNanPreserveFloat64) || (l.ShaderDenormPreserveFloat16 != r.ShaderDenormPreserveFloat16)
			|| (l.ShaderDenormPreserveFloat32 != r.ShaderDenormPreserveFloat32) || (l.ShaderDenormPreserveFloat64 != r.ShaderDenormPreserveFloat64) || (l.ShaderDenormFlushToZeroFloat16 != r.ShaderDenormFlushToZeroFloat16) || (l.ShaderDenormFlushToZeroFloat32 != r.ShaderDenormFlushToZeroFloat32)
			|| (l.ShaderDenormFlushToZeroFloat64 != r.ShaderDenormFlushToZeroFloat64) || (l.ShaderRoundingModeRTEFloat16 != r.ShaderRoundingModeRTEFloat16) || (l.ShaderRoundingModeRTEFloat32 != r.ShaderRoundingModeRTEFloat32) || (l.ShaderRoundingModeRTEFloat64 != r.ShaderRoundingModeRTEFloat64)
			|| (l.ShaderRoundingModeRTZFloat16 != r.ShaderRoundingModeRTZFloat16) || (l.ShaderRoundingModeRTZFloat32 != r.ShaderRoundingModeRTZFloat32) || (l.ShaderRoundingModeRTZFloat64 != r.ShaderRoundingModeRTZFloat64)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceFloatControlsProperties s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceHostQueryResetFeatures : IEquatable<VkPhysicalDeviceHostQueryResetFeatures>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceHostQueryResetFeatures;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 HostQueryReset;

	public VkPhysicalDeviceHostQueryResetFeatures(
		VkBool32 hostQueryReset = default
	) {
		sType = TYPE;
		pNext = null;
		HostQueryReset = hostQueryReset;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceHostQueryResetFeatures s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceHostQueryResetFeatures>.Equals(VkPhysicalDeviceHostQueryResetFeatures o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ HostQueryReset.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceHostQueryResetFeatures l, in VkPhysicalDeviceHostQueryResetFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.HostQueryReset == r.HostQueryReset)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceHostQueryResetFeatures l, in VkPhysicalDeviceHostQueryResetFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.HostQueryReset != r.HostQueryReset)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceHostQueryResetFeatures s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceDescriptorIndexingFeatures : IEquatable<VkPhysicalDeviceDescriptorIndexingFeatures>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceDescriptorIndexingFeatures;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 ShaderInputAttachmentArrayDynamicIndexing;
	public VkBool32 ShaderUniformTexelBufferArrayDynamicIndexing;
	public VkBool32 ShaderStorageTexelBufferArrayDynamicIndexing;
	public VkBool32 ShaderUniformBufferArrayNonUniformIndexing;
	public VkBool32 ShaderSampledImageArrayNonUniformIndexing;
	public VkBool32 ShaderStorageBufferArrayNonUniformIndexing;
	public VkBool32 ShaderStorageImageArrayNonUniformIndexing;
	public VkBool32 ShaderInputAttachmentArrayNonUniformIndexing;
	public VkBool32 ShaderUniformTexelBufferArrayNonUniformIndexing;
	public VkBool32 ShaderStorageTexelBufferArrayNonUniformIndexing;
	public VkBool32 DescriptorBindingUniformBufferUpdateAfterBind;
	public VkBool32 DescriptorBindingSampledImageUpdateAfterBind;
	public VkBool32 DescriptorBindingStorageImageUpdateAfterBind;
	public VkBool32 DescriptorBindingStorageBufferUpdateAfterBind;
	public VkBool32 DescriptorBindingUniformTexelBufferUpdateAfterBind;
	public VkBool32 DescriptorBindingStorageTexelBufferUpdateAfterBind;
	public VkBool32 DescriptorBindingUpdateUnusedWhilePending;
	public VkBool32 DescriptorBindingPartiallyBound;
	public VkBool32 DescriptorBindingVariableDescriptorCount;
	public VkBool32 RuntimeDescriptorArray;

	public VkPhysicalDeviceDescriptorIndexingFeatures(
		VkBool32 shaderInputAttachmentArrayDynamicIndexing = default,
		VkBool32 shaderUniformTexelBufferArrayDynamicIndexing = default,
		VkBool32 shaderStorageTexelBufferArrayDynamicIndexing = default,
		VkBool32 shaderUniformBufferArrayNonUniformIndexing = default,
		VkBool32 shaderSampledImageArrayNonUniformIndexing = default,
		VkBool32 shaderStorageBufferArrayNonUniformIndexing = default,
		VkBool32 shaderStorageImageArrayNonUniformIndexing = default,
		VkBool32 shaderInputAttachmentArrayNonUniformIndexing = default,
		VkBool32 shaderUniformTexelBufferArrayNonUniformIndexing = default,
		VkBool32 shaderStorageTexelBufferArrayNonUniformIndexing = default,
		VkBool32 descriptorBindingUniformBufferUpdateAfterBind = default,
		VkBool32 descriptorBindingSampledImageUpdateAfterBind = default,
		VkBool32 descriptorBindingStorageImageUpdateAfterBind = default,
		VkBool32 descriptorBindingStorageBufferUpdateAfterBind = default,
		VkBool32 descriptorBindingUniformTexelBufferUpdateAfterBind = default,
		VkBool32 descriptorBindingStorageTexelBufferUpdateAfterBind = default,
		VkBool32 descriptorBindingUpdateUnusedWhilePending = default,
		VkBool32 descriptorBindingPartiallyBound = default,
		VkBool32 descriptorBindingVariableDescriptorCount = default,
		VkBool32 runtimeDescriptorArray = default
	) {
		sType = TYPE;
		pNext = null;
		ShaderInputAttachmentArrayDynamicIndexing = shaderInputAttachmentArrayDynamicIndexing;
		ShaderUniformTexelBufferArrayDynamicIndexing = shaderUniformTexelBufferArrayDynamicIndexing;
		ShaderStorageTexelBufferArrayDynamicIndexing = shaderStorageTexelBufferArrayDynamicIndexing;
		ShaderUniformBufferArrayNonUniformIndexing = shaderUniformBufferArrayNonUniformIndexing;
		ShaderSampledImageArrayNonUniformIndexing = shaderSampledImageArrayNonUniformIndexing;
		ShaderStorageBufferArrayNonUniformIndexing = shaderStorageBufferArrayNonUniformIndexing;
		ShaderStorageImageArrayNonUniformIndexing = shaderStorageImageArrayNonUniformIndexing;
		ShaderInputAttachmentArrayNonUniformIndexing = shaderInputAttachmentArrayNonUniformIndexing;
		ShaderUniformTexelBufferArrayNonUniformIndexing = shaderUniformTexelBufferArrayNonUniformIndexing;
		ShaderStorageTexelBufferArrayNonUniformIndexing = shaderStorageTexelBufferArrayNonUniformIndexing;
		DescriptorBindingUniformBufferUpdateAfterBind = descriptorBindingUniformBufferUpdateAfterBind;
		DescriptorBindingSampledImageUpdateAfterBind = descriptorBindingSampledImageUpdateAfterBind;
		DescriptorBindingStorageImageUpdateAfterBind = descriptorBindingStorageImageUpdateAfterBind;
		DescriptorBindingStorageBufferUpdateAfterBind = descriptorBindingStorageBufferUpdateAfterBind;
		DescriptorBindingUniformTexelBufferUpdateAfterBind = descriptorBindingUniformTexelBufferUpdateAfterBind;
		DescriptorBindingStorageTexelBufferUpdateAfterBind = descriptorBindingStorageTexelBufferUpdateAfterBind;
		DescriptorBindingUpdateUnusedWhilePending = descriptorBindingUpdateUnusedWhilePending;
		DescriptorBindingPartiallyBound = descriptorBindingPartiallyBound;
		DescriptorBindingVariableDescriptorCount = descriptorBindingVariableDescriptorCount;
		RuntimeDescriptorArray = runtimeDescriptorArray;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceDescriptorIndexingFeatures s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceDescriptorIndexingFeatures>.Equals(VkPhysicalDeviceDescriptorIndexingFeatures o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ShaderInputAttachmentArrayDynamicIndexing.GetHashCode() ^ ShaderUniformTexelBufferArrayDynamicIndexing.GetHashCode()
			^ ShaderStorageTexelBufferArrayDynamicIndexing.GetHashCode() ^ ShaderUniformBufferArrayNonUniformIndexing.GetHashCode() ^ ShaderSampledImageArrayNonUniformIndexing.GetHashCode() ^ ShaderStorageBufferArrayNonUniformIndexing.GetHashCode()
			^ ShaderStorageImageArrayNonUniformIndexing.GetHashCode() ^ ShaderInputAttachmentArrayNonUniformIndexing.GetHashCode() ^ ShaderUniformTexelBufferArrayNonUniformIndexing.GetHashCode() ^ ShaderStorageTexelBufferArrayNonUniformIndexing.GetHashCode()
			^ DescriptorBindingUniformBufferUpdateAfterBind.GetHashCode() ^ DescriptorBindingSampledImageUpdateAfterBind.GetHashCode() ^ DescriptorBindingStorageImageUpdateAfterBind.GetHashCode() ^ DescriptorBindingStorageBufferUpdateAfterBind.GetHashCode()
			^ DescriptorBindingUniformTexelBufferUpdateAfterBind.GetHashCode() ^ DescriptorBindingStorageTexelBufferUpdateAfterBind.GetHashCode() ^ DescriptorBindingUpdateUnusedWhilePending.GetHashCode() ^ DescriptorBindingPartiallyBound.GetHashCode()
			^ DescriptorBindingVariableDescriptorCount.GetHashCode() ^ RuntimeDescriptorArray.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceDescriptorIndexingFeatures l, in VkPhysicalDeviceDescriptorIndexingFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ShaderInputAttachmentArrayDynamicIndexing == r.ShaderInputAttachmentArrayDynamicIndexing) && (l.ShaderUniformTexelBufferArrayDynamicIndexing == r.ShaderUniformTexelBufferArrayDynamicIndexing)
			&& (l.ShaderStorageTexelBufferArrayDynamicIndexing == r.ShaderStorageTexelBufferArrayDynamicIndexing) && (l.ShaderUniformBufferArrayNonUniformIndexing == r.ShaderUniformBufferArrayNonUniformIndexing) && (l.ShaderSampledImageArrayNonUniformIndexing == r.ShaderSampledImageArrayNonUniformIndexing) && (l.ShaderStorageBufferArrayNonUniformIndexing == r.ShaderStorageBufferArrayNonUniformIndexing)
			&& (l.ShaderStorageImageArrayNonUniformIndexing == r.ShaderStorageImageArrayNonUniformIndexing) && (l.ShaderInputAttachmentArrayNonUniformIndexing == r.ShaderInputAttachmentArrayNonUniformIndexing) && (l.ShaderUniformTexelBufferArrayNonUniformIndexing == r.ShaderUniformTexelBufferArrayNonUniformIndexing) && (l.ShaderStorageTexelBufferArrayNonUniformIndexing == r.ShaderStorageTexelBufferArrayNonUniformIndexing)
			&& (l.DescriptorBindingUniformBufferUpdateAfterBind == r.DescriptorBindingUniformBufferUpdateAfterBind) && (l.DescriptorBindingSampledImageUpdateAfterBind == r.DescriptorBindingSampledImageUpdateAfterBind) && (l.DescriptorBindingStorageImageUpdateAfterBind == r.DescriptorBindingStorageImageUpdateAfterBind) && (l.DescriptorBindingStorageBufferUpdateAfterBind == r.DescriptorBindingStorageBufferUpdateAfterBind)
			&& (l.DescriptorBindingUniformTexelBufferUpdateAfterBind == r.DescriptorBindingUniformTexelBufferUpdateAfterBind) && (l.DescriptorBindingStorageTexelBufferUpdateAfterBind == r.DescriptorBindingStorageTexelBufferUpdateAfterBind) && (l.DescriptorBindingUpdateUnusedWhilePending == r.DescriptorBindingUpdateUnusedWhilePending) && (l.DescriptorBindingPartiallyBound == r.DescriptorBindingPartiallyBound)
			&& (l.DescriptorBindingVariableDescriptorCount == r.DescriptorBindingVariableDescriptorCount) && (l.RuntimeDescriptorArray == r.RuntimeDescriptorArray)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceDescriptorIndexingFeatures l, in VkPhysicalDeviceDescriptorIndexingFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ShaderInputAttachmentArrayDynamicIndexing != r.ShaderInputAttachmentArrayDynamicIndexing) || (l.ShaderUniformTexelBufferArrayDynamicIndexing != r.ShaderUniformTexelBufferArrayDynamicIndexing)
			|| (l.ShaderStorageTexelBufferArrayDynamicIndexing != r.ShaderStorageTexelBufferArrayDynamicIndexing) || (l.ShaderUniformBufferArrayNonUniformIndexing != r.ShaderUniformBufferArrayNonUniformIndexing) || (l.ShaderSampledImageArrayNonUniformIndexing != r.ShaderSampledImageArrayNonUniformIndexing) || (l.ShaderStorageBufferArrayNonUniformIndexing != r.ShaderStorageBufferArrayNonUniformIndexing)
			|| (l.ShaderStorageImageArrayNonUniformIndexing != r.ShaderStorageImageArrayNonUniformIndexing) || (l.ShaderInputAttachmentArrayNonUniformIndexing != r.ShaderInputAttachmentArrayNonUniformIndexing) || (l.ShaderUniformTexelBufferArrayNonUniformIndexing != r.ShaderUniformTexelBufferArrayNonUniformIndexing) || (l.ShaderStorageTexelBufferArrayNonUniformIndexing != r.ShaderStorageTexelBufferArrayNonUniformIndexing)
			|| (l.DescriptorBindingUniformBufferUpdateAfterBind != r.DescriptorBindingUniformBufferUpdateAfterBind) || (l.DescriptorBindingSampledImageUpdateAfterBind != r.DescriptorBindingSampledImageUpdateAfterBind) || (l.DescriptorBindingStorageImageUpdateAfterBind != r.DescriptorBindingStorageImageUpdateAfterBind) || (l.DescriptorBindingStorageBufferUpdateAfterBind != r.DescriptorBindingStorageBufferUpdateAfterBind)
			|| (l.DescriptorBindingUniformTexelBufferUpdateAfterBind != r.DescriptorBindingUniformTexelBufferUpdateAfterBind) || (l.DescriptorBindingStorageTexelBufferUpdateAfterBind != r.DescriptorBindingStorageTexelBufferUpdateAfterBind) || (l.DescriptorBindingUpdateUnusedWhilePending != r.DescriptorBindingUpdateUnusedWhilePending) || (l.DescriptorBindingPartiallyBound != r.DescriptorBindingPartiallyBound)
			|| (l.DescriptorBindingVariableDescriptorCount != r.DescriptorBindingVariableDescriptorCount) || (l.RuntimeDescriptorArray != r.RuntimeDescriptorArray)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceDescriptorIndexingFeatures s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceDescriptorIndexingProperties : IEquatable<VkPhysicalDeviceDescriptorIndexingProperties>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceDescriptorIndexingProperties;

	public VkStructureType sType;
	public void* pNext;
	public uint MaxUpdateAfterBindDescriptorsInAllPools;
	public VkBool32 ShaderUniformBufferArrayNonUniformIndexingNative;
	public VkBool32 ShaderSampledImageArrayNonUniformIndexingNative;
	public VkBool32 ShaderStorageBufferArrayNonUniformIndexingNative;
	public VkBool32 ShaderStorageImageArrayNonUniformIndexingNative;
	public VkBool32 ShaderInputAttachmentArrayNonUniformIndexingNative;
	public VkBool32 RobustBufferAccessUpdateAfterBind;
	public VkBool32 QuadDivergentImplicitLod;
	public uint MaxPerStageDescriptorUpdateAfterBindSamplers;
	public uint MaxPerStageDescriptorUpdateAfterBindUniformBuffers;
	public uint MaxPerStageDescriptorUpdateAfterBindStorageBuffers;
	public uint MaxPerStageDescriptorUpdateAfterBindSampledImages;
	public uint MaxPerStageDescriptorUpdateAfterBindStorageImages;
	public uint MaxPerStageDescriptorUpdateAfterBindInputAttachments;
	public uint MaxPerStageUpdateAfterBindResources;
	public uint MaxDescriptorSetUpdateAfterBindSamplers;
	public uint MaxDescriptorSetUpdateAfterBindUniformBuffers;
	public uint MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic;
	public uint MaxDescriptorSetUpdateAfterBindStorageBuffers;
	public uint MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic;
	public uint MaxDescriptorSetUpdateAfterBindSampledImages;
	public uint MaxDescriptorSetUpdateAfterBindStorageImages;
	public uint MaxDescriptorSetUpdateAfterBindInputAttachments;

	public VkPhysicalDeviceDescriptorIndexingProperties(
		uint maxUpdateAfterBindDescriptorsInAllPools = default,
		VkBool32 shaderUniformBufferArrayNonUniformIndexingNative = default,
		VkBool32 shaderSampledImageArrayNonUniformIndexingNative = default,
		VkBool32 shaderStorageBufferArrayNonUniformIndexingNative = default,
		VkBool32 shaderStorageImageArrayNonUniformIndexingNative = default,
		VkBool32 shaderInputAttachmentArrayNonUniformIndexingNative = default,
		VkBool32 robustBufferAccessUpdateAfterBind = default,
		VkBool32 quadDivergentImplicitLod = default,
		uint maxPerStageDescriptorUpdateAfterBindSamplers = default,
		uint maxPerStageDescriptorUpdateAfterBindUniformBuffers = default,
		uint maxPerStageDescriptorUpdateAfterBindStorageBuffers = default,
		uint maxPerStageDescriptorUpdateAfterBindSampledImages = default,
		uint maxPerStageDescriptorUpdateAfterBindStorageImages = default,
		uint maxPerStageDescriptorUpdateAfterBindInputAttachments = default,
		uint maxPerStageUpdateAfterBindResources = default,
		uint maxDescriptorSetUpdateAfterBindSamplers = default,
		uint maxDescriptorSetUpdateAfterBindUniformBuffers = default,
		uint maxDescriptorSetUpdateAfterBindUniformBuffersDynamic = default,
		uint maxDescriptorSetUpdateAfterBindStorageBuffers = default,
		uint maxDescriptorSetUpdateAfterBindStorageBuffersDynamic = default,
		uint maxDescriptorSetUpdateAfterBindSampledImages = default,
		uint maxDescriptorSetUpdateAfterBindStorageImages = default,
		uint maxDescriptorSetUpdateAfterBindInputAttachments = default
	) {
		sType = TYPE;
		pNext = null;
		MaxUpdateAfterBindDescriptorsInAllPools = maxUpdateAfterBindDescriptorsInAllPools;
		ShaderUniformBufferArrayNonUniformIndexingNative = shaderUniformBufferArrayNonUniformIndexingNative;
		ShaderSampledImageArrayNonUniformIndexingNative = shaderSampledImageArrayNonUniformIndexingNative;
		ShaderStorageBufferArrayNonUniformIndexingNative = shaderStorageBufferArrayNonUniformIndexingNative;
		ShaderStorageImageArrayNonUniformIndexingNative = shaderStorageImageArrayNonUniformIndexingNative;
		ShaderInputAttachmentArrayNonUniformIndexingNative = shaderInputAttachmentArrayNonUniformIndexingNative;
		RobustBufferAccessUpdateAfterBind = robustBufferAccessUpdateAfterBind;
		QuadDivergentImplicitLod = quadDivergentImplicitLod;
		MaxPerStageDescriptorUpdateAfterBindSamplers = maxPerStageDescriptorUpdateAfterBindSamplers;
		MaxPerStageDescriptorUpdateAfterBindUniformBuffers = maxPerStageDescriptorUpdateAfterBindUniformBuffers;
		MaxPerStageDescriptorUpdateAfterBindStorageBuffers = maxPerStageDescriptorUpdateAfterBindStorageBuffers;
		MaxPerStageDescriptorUpdateAfterBindSampledImages = maxPerStageDescriptorUpdateAfterBindSampledImages;
		MaxPerStageDescriptorUpdateAfterBindStorageImages = maxPerStageDescriptorUpdateAfterBindStorageImages;
		MaxPerStageDescriptorUpdateAfterBindInputAttachments = maxPerStageDescriptorUpdateAfterBindInputAttachments;
		MaxPerStageUpdateAfterBindResources = maxPerStageUpdateAfterBindResources;
		MaxDescriptorSetUpdateAfterBindSamplers = maxDescriptorSetUpdateAfterBindSamplers;
		MaxDescriptorSetUpdateAfterBindUniformBuffers = maxDescriptorSetUpdateAfterBindUniformBuffers;
		MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic = maxDescriptorSetUpdateAfterBindUniformBuffersDynamic;
		MaxDescriptorSetUpdateAfterBindStorageBuffers = maxDescriptorSetUpdateAfterBindStorageBuffers;
		MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic = maxDescriptorSetUpdateAfterBindStorageBuffersDynamic;
		MaxDescriptorSetUpdateAfterBindSampledImages = maxDescriptorSetUpdateAfterBindSampledImages;
		MaxDescriptorSetUpdateAfterBindStorageImages = maxDescriptorSetUpdateAfterBindStorageImages;
		MaxDescriptorSetUpdateAfterBindInputAttachments = maxDescriptorSetUpdateAfterBindInputAttachments;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceDescriptorIndexingProperties s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceDescriptorIndexingProperties>.Equals(VkPhysicalDeviceDescriptorIndexingProperties o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MaxUpdateAfterBindDescriptorsInAllPools.GetHashCode() ^ ShaderUniformBufferArrayNonUniformIndexingNative.GetHashCode()
			^ ShaderSampledImageArrayNonUniformIndexingNative.GetHashCode() ^ ShaderStorageBufferArrayNonUniformIndexingNative.GetHashCode() ^ ShaderStorageImageArrayNonUniformIndexingNative.GetHashCode() ^ ShaderInputAttachmentArrayNonUniformIndexingNative.GetHashCode()
			^ RobustBufferAccessUpdateAfterBind.GetHashCode() ^ QuadDivergentImplicitLod.GetHashCode() ^ MaxPerStageDescriptorUpdateAfterBindSamplers.GetHashCode() ^ MaxPerStageDescriptorUpdateAfterBindUniformBuffers.GetHashCode()
			^ MaxPerStageDescriptorUpdateAfterBindStorageBuffers.GetHashCode() ^ MaxPerStageDescriptorUpdateAfterBindSampledImages.GetHashCode() ^ MaxPerStageDescriptorUpdateAfterBindStorageImages.GetHashCode() ^ MaxPerStageDescriptorUpdateAfterBindInputAttachments.GetHashCode()
			^ MaxPerStageUpdateAfterBindResources.GetHashCode() ^ MaxDescriptorSetUpdateAfterBindSamplers.GetHashCode() ^ MaxDescriptorSetUpdateAfterBindUniformBuffers.GetHashCode() ^ MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic.GetHashCode()
			^ MaxDescriptorSetUpdateAfterBindStorageBuffers.GetHashCode() ^ MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic.GetHashCode() ^ MaxDescriptorSetUpdateAfterBindSampledImages.GetHashCode() ^ MaxDescriptorSetUpdateAfterBindStorageImages.GetHashCode()
			^ MaxDescriptorSetUpdateAfterBindInputAttachments.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceDescriptorIndexingProperties l, in VkPhysicalDeviceDescriptorIndexingProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MaxUpdateAfterBindDescriptorsInAllPools == r.MaxUpdateAfterBindDescriptorsInAllPools) && (l.ShaderUniformBufferArrayNonUniformIndexingNative == r.ShaderUniformBufferArrayNonUniformIndexingNative)
			&& (l.ShaderSampledImageArrayNonUniformIndexingNative == r.ShaderSampledImageArrayNonUniformIndexingNative) && (l.ShaderStorageBufferArrayNonUniformIndexingNative == r.ShaderStorageBufferArrayNonUniformIndexingNative) && (l.ShaderStorageImageArrayNonUniformIndexingNative == r.ShaderStorageImageArrayNonUniformIndexingNative) && (l.ShaderInputAttachmentArrayNonUniformIndexingNative == r.ShaderInputAttachmentArrayNonUniformIndexingNative)
			&& (l.RobustBufferAccessUpdateAfterBind == r.RobustBufferAccessUpdateAfterBind) && (l.QuadDivergentImplicitLod == r.QuadDivergentImplicitLod) && (l.MaxPerStageDescriptorUpdateAfterBindSamplers == r.MaxPerStageDescriptorUpdateAfterBindSamplers) && (l.MaxPerStageDescriptorUpdateAfterBindUniformBuffers == r.MaxPerStageDescriptorUpdateAfterBindUniformBuffers)
			&& (l.MaxPerStageDescriptorUpdateAfterBindStorageBuffers == r.MaxPerStageDescriptorUpdateAfterBindStorageBuffers) && (l.MaxPerStageDescriptorUpdateAfterBindSampledImages == r.MaxPerStageDescriptorUpdateAfterBindSampledImages) && (l.MaxPerStageDescriptorUpdateAfterBindStorageImages == r.MaxPerStageDescriptorUpdateAfterBindStorageImages) && (l.MaxPerStageDescriptorUpdateAfterBindInputAttachments == r.MaxPerStageDescriptorUpdateAfterBindInputAttachments)
			&& (l.MaxPerStageUpdateAfterBindResources == r.MaxPerStageUpdateAfterBindResources) && (l.MaxDescriptorSetUpdateAfterBindSamplers == r.MaxDescriptorSetUpdateAfterBindSamplers) && (l.MaxDescriptorSetUpdateAfterBindUniformBuffers == r.MaxDescriptorSetUpdateAfterBindUniformBuffers) && (l.MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic == r.MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic)
			&& (l.MaxDescriptorSetUpdateAfterBindStorageBuffers == r.MaxDescriptorSetUpdateAfterBindStorageBuffers) && (l.MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic == r.MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic) && (l.MaxDescriptorSetUpdateAfterBindSampledImages == r.MaxDescriptorSetUpdateAfterBindSampledImages) && (l.MaxDescriptorSetUpdateAfterBindStorageImages == r.MaxDescriptorSetUpdateAfterBindStorageImages)
			&& (l.MaxDescriptorSetUpdateAfterBindInputAttachments == r.MaxDescriptorSetUpdateAfterBindInputAttachments)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceDescriptorIndexingProperties l, in VkPhysicalDeviceDescriptorIndexingProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MaxUpdateAfterBindDescriptorsInAllPools != r.MaxUpdateAfterBindDescriptorsInAllPools) || (l.ShaderUniformBufferArrayNonUniformIndexingNative != r.ShaderUniformBufferArrayNonUniformIndexingNative)
			|| (l.ShaderSampledImageArrayNonUniformIndexingNative != r.ShaderSampledImageArrayNonUniformIndexingNative) || (l.ShaderStorageBufferArrayNonUniformIndexingNative != r.ShaderStorageBufferArrayNonUniformIndexingNative) || (l.ShaderStorageImageArrayNonUniformIndexingNative != r.ShaderStorageImageArrayNonUniformIndexingNative) || (l.ShaderInputAttachmentArrayNonUniformIndexingNative != r.ShaderInputAttachmentArrayNonUniformIndexingNative)
			|| (l.RobustBufferAccessUpdateAfterBind != r.RobustBufferAccessUpdateAfterBind) || (l.QuadDivergentImplicitLod != r.QuadDivergentImplicitLod) || (l.MaxPerStageDescriptorUpdateAfterBindSamplers != r.MaxPerStageDescriptorUpdateAfterBindSamplers) || (l.MaxPerStageDescriptorUpdateAfterBindUniformBuffers != r.MaxPerStageDescriptorUpdateAfterBindUniformBuffers)
			|| (l.MaxPerStageDescriptorUpdateAfterBindStorageBuffers != r.MaxPerStageDescriptorUpdateAfterBindStorageBuffers) || (l.MaxPerStageDescriptorUpdateAfterBindSampledImages != r.MaxPerStageDescriptorUpdateAfterBindSampledImages) || (l.MaxPerStageDescriptorUpdateAfterBindStorageImages != r.MaxPerStageDescriptorUpdateAfterBindStorageImages) || (l.MaxPerStageDescriptorUpdateAfterBindInputAttachments != r.MaxPerStageDescriptorUpdateAfterBindInputAttachments)
			|| (l.MaxPerStageUpdateAfterBindResources != r.MaxPerStageUpdateAfterBindResources) || (l.MaxDescriptorSetUpdateAfterBindSamplers != r.MaxDescriptorSetUpdateAfterBindSamplers) || (l.MaxDescriptorSetUpdateAfterBindUniformBuffers != r.MaxDescriptorSetUpdateAfterBindUniformBuffers) || (l.MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic != r.MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic)
			|| (l.MaxDescriptorSetUpdateAfterBindStorageBuffers != r.MaxDescriptorSetUpdateAfterBindStorageBuffers) || (l.MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic != r.MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic) || (l.MaxDescriptorSetUpdateAfterBindSampledImages != r.MaxDescriptorSetUpdateAfterBindSampledImages) || (l.MaxDescriptorSetUpdateAfterBindStorageImages != r.MaxDescriptorSetUpdateAfterBindStorageImages)
			|| (l.MaxDescriptorSetUpdateAfterBindInputAttachments != r.MaxDescriptorSetUpdateAfterBindInputAttachments)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceDescriptorIndexingProperties s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDescriptorSetLayoutBindingFlagsCreateInfo : IEquatable<VkDescriptorSetLayoutBindingFlagsCreateInfo>
{
	public const VkStructureType TYPE = VkStructureType.DescriptorSetLayoutBindingFlagsCreateInfo;

	public VkStructureType sType;
	public void* pNext;
	public uint BindingCount;
	public VkDescriptorBindingFlags* BindingFlags;

	public VkDescriptorSetLayoutBindingFlagsCreateInfo(
		uint bindingCount = default,
		VkDescriptorBindingFlags* bindingFlags = default
	) {
		sType = TYPE;
		pNext = null;
		BindingCount = bindingCount;
		BindingFlags = bindingFlags;
	}

	public readonly override bool Equals(object? o) => (o is VkDescriptorSetLayoutBindingFlagsCreateInfo s) && (this == s);
	readonly bool IEquatable<VkDescriptorSetLayoutBindingFlagsCreateInfo>.Equals(VkDescriptorSetLayoutBindingFlagsCreateInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ BindingCount.GetHashCode() ^ ((ulong)BindingFlags).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDescriptorSetLayoutBindingFlagsCreateInfo l, in VkDescriptorSetLayoutBindingFlagsCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.BindingCount == r.BindingCount) && (l.BindingFlags == r.BindingFlags)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDescriptorSetLayoutBindingFlagsCreateInfo l, in VkDescriptorSetLayoutBindingFlagsCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.BindingCount != r.BindingCount) || (l.BindingFlags != r.BindingFlags)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDescriptorSetLayoutBindingFlagsCreateInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDescriptorSetVariableDescriptorCountAllocateInfo : IEquatable<VkDescriptorSetVariableDescriptorCountAllocateInfo>
{
	public const VkStructureType TYPE = VkStructureType.DescriptorSetVariableDescriptorCountAllocateInfo;

	public VkStructureType sType;
	public void* pNext;
	public uint DescriptorSetCount;
	public uint* DescriptorCounts;

	public VkDescriptorSetVariableDescriptorCountAllocateInfo(
		uint descriptorSetCount = default,
		uint* descriptorCounts = default
	) {
		sType = TYPE;
		pNext = null;
		DescriptorSetCount = descriptorSetCount;
		DescriptorCounts = descriptorCounts;
	}

	public readonly override bool Equals(object? o) => (o is VkDescriptorSetVariableDescriptorCountAllocateInfo s) && (this == s);
	readonly bool IEquatable<VkDescriptorSetVariableDescriptorCountAllocateInfo>.Equals(VkDescriptorSetVariableDescriptorCountAllocateInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DescriptorSetCount.GetHashCode() ^ ((ulong)DescriptorCounts).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDescriptorSetVariableDescriptorCountAllocateInfo l, in VkDescriptorSetVariableDescriptorCountAllocateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DescriptorSetCount == r.DescriptorSetCount) && (l.DescriptorCounts == r.DescriptorCounts)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDescriptorSetVariableDescriptorCountAllocateInfo l, in VkDescriptorSetVariableDescriptorCountAllocateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DescriptorSetCount != r.DescriptorSetCount) || (l.DescriptorCounts != r.DescriptorCounts)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDescriptorSetVariableDescriptorCountAllocateInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDescriptorSetVariableDescriptorCountLayoutSupport : IEquatable<VkDescriptorSetVariableDescriptorCountLayoutSupport>
{
	public const VkStructureType TYPE = VkStructureType.DescriptorSetVariableDescriptorCountLayoutSupport;

	public VkStructureType sType;
	public void* pNext;
	public uint MaxVariableDescriptorCount;

	public VkDescriptorSetVariableDescriptorCountLayoutSupport(
		uint maxVariableDescriptorCount = default
	) {
		sType = TYPE;
		pNext = null;
		MaxVariableDescriptorCount = maxVariableDescriptorCount;
	}

	public readonly override bool Equals(object? o) => (o is VkDescriptorSetVariableDescriptorCountLayoutSupport s) && (this == s);
	readonly bool IEquatable<VkDescriptorSetVariableDescriptorCountLayoutSupport>.Equals(VkDescriptorSetVariableDescriptorCountLayoutSupport o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MaxVariableDescriptorCount.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDescriptorSetVariableDescriptorCountLayoutSupport l, in VkDescriptorSetVariableDescriptorCountLayoutSupport r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MaxVariableDescriptorCount == r.MaxVariableDescriptorCount)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDescriptorSetVariableDescriptorCountLayoutSupport l, in VkDescriptorSetVariableDescriptorCountLayoutSupport r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MaxVariableDescriptorCount != r.MaxVariableDescriptorCount)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDescriptorSetVariableDescriptorCountLayoutSupport s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkAttachmentDescription2 : IEquatable<VkAttachmentDescription2>
{
	public const VkStructureType TYPE = VkStructureType.AttachmentDescription2;

	public VkStructureType sType;
	public void* pNext;
	public VkAttachmentDescriptionFlags Flags;
	public VkFormat Format;
	public VkSampleCountFlags Samples;
	public VkAttachmentLoadOp LoadOp;
	public VkAttachmentStoreOp StoreOp;
	public VkAttachmentLoadOp StencilLoadOp;
	public VkAttachmentStoreOp StencilStoreOp;
	public VkImageLayout InitialLayout;
	public VkImageLayout FinalLayout;

	public VkAttachmentDescription2(
		VkAttachmentDescriptionFlags flags = default,
		VkFormat format = default,
		VkSampleCountFlags samples = default,
		VkAttachmentLoadOp loadOp = default,
		VkAttachmentStoreOp storeOp = default,
		VkAttachmentLoadOp stencilLoadOp = default,
		VkAttachmentStoreOp stencilStoreOp = default,
		VkImageLayout initialLayout = default,
		VkImageLayout finalLayout = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		Format = format;
		Samples = samples;
		LoadOp = loadOp;
		StoreOp = storeOp;
		StencilLoadOp = stencilLoadOp;
		StencilStoreOp = stencilStoreOp;
		InitialLayout = initialLayout;
		FinalLayout = finalLayout;
	}

	public readonly override bool Equals(object? o) => (o is VkAttachmentDescription2 s) && (this == s);
	readonly bool IEquatable<VkAttachmentDescription2>.Equals(VkAttachmentDescription2 o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ Format.GetHashCode()
			^ Samples.GetHashCode() ^ LoadOp.GetHashCode() ^ StoreOp.GetHashCode() ^ StencilLoadOp.GetHashCode()
			^ StencilStoreOp.GetHashCode() ^ InitialLayout.GetHashCode() ^ FinalLayout.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkAttachmentDescription2 l, in VkAttachmentDescription2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.Format == r.Format)
			&& (l.Samples == r.Samples) && (l.LoadOp == r.LoadOp) && (l.StoreOp == r.StoreOp) && (l.StencilLoadOp == r.StencilLoadOp)
			&& (l.StencilStoreOp == r.StencilStoreOp) && (l.InitialLayout == r.InitialLayout) && (l.FinalLayout == r.FinalLayout)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkAttachmentDescription2 l, in VkAttachmentDescription2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.Format != r.Format)
			|| (l.Samples != r.Samples) || (l.LoadOp != r.LoadOp) || (l.StoreOp != r.StoreOp) || (l.StencilLoadOp != r.StencilLoadOp)
			|| (l.StencilStoreOp != r.StencilStoreOp) || (l.InitialLayout != r.InitialLayout) || (l.FinalLayout != r.FinalLayout)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkAttachmentDescription2 s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkAttachmentReference2 : IEquatable<VkAttachmentReference2>
{
	public const VkStructureType TYPE = VkStructureType.AttachmentReference2;

	public VkStructureType sType;
	public void* pNext;
	public uint Attachment;
	public VkImageLayout Layout;
	public VkImageAspectFlags AspectMask;

	public VkAttachmentReference2(
		uint attachment = default,
		VkImageLayout layout = default,
		VkImageAspectFlags aspectMask = default
	) {
		sType = TYPE;
		pNext = null;
		Attachment = attachment;
		Layout = layout;
		AspectMask = aspectMask;
	}

	public readonly override bool Equals(object? o) => (o is VkAttachmentReference2 s) && (this == s);
	readonly bool IEquatable<VkAttachmentReference2>.Equals(VkAttachmentReference2 o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Attachment.GetHashCode() ^ Layout.GetHashCode()
			^ AspectMask.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkAttachmentReference2 l, in VkAttachmentReference2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Attachment == r.Attachment) && (l.Layout == r.Layout)
			&& (l.AspectMask == r.AspectMask)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkAttachmentReference2 l, in VkAttachmentReference2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Attachment != r.Attachment) || (l.Layout != r.Layout)
			|| (l.AspectMask != r.AspectMask)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkAttachmentReference2 s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkSubpassDescription2 : IEquatable<VkSubpassDescription2>
{
	public const VkStructureType TYPE = VkStructureType.SubpassDescription2;

	public VkStructureType sType;
	public void* pNext;
	public VkSubpassDescriptionFlags Flags;
	public VkPipelineBindPoint PipelineBindPoint;
	public uint ViewMask;
	public uint InputAttachmentCount;
	public VkAttachmentReference2* InputAttachments;
	public uint ColorAttachmentCount;
	public VkAttachmentReference2* ColorAttachments;
	public VkAttachmentReference2* ResolveAttachments;
	public VkAttachmentReference2* DepthStencilAttachment;
	public uint PreserveAttachmentCount;
	public uint* PreserveAttachments;

	public VkSubpassDescription2(
		VkSubpassDescriptionFlags flags = default,
		VkPipelineBindPoint pipelineBindPoint = default,
		uint viewMask = default,
		uint inputAttachmentCount = default,
		VkAttachmentReference2* inputAttachments = default,
		uint colorAttachmentCount = default,
		VkAttachmentReference2* colorAttachments = default,
		VkAttachmentReference2* resolveAttachments = default,
		VkAttachmentReference2* depthStencilAttachment = default,
		uint preserveAttachmentCount = default,
		uint* preserveAttachments = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		PipelineBindPoint = pipelineBindPoint;
		ViewMask = viewMask;
		InputAttachmentCount = inputAttachmentCount;
		InputAttachments = inputAttachments;
		ColorAttachmentCount = colorAttachmentCount;
		ColorAttachments = colorAttachments;
		ResolveAttachments = resolveAttachments;
		DepthStencilAttachment = depthStencilAttachment;
		PreserveAttachmentCount = preserveAttachmentCount;
		PreserveAttachments = preserveAttachments;
	}

	public readonly override bool Equals(object? o) => (o is VkSubpassDescription2 s) && (this == s);
	readonly bool IEquatable<VkSubpassDescription2>.Equals(VkSubpassDescription2 o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ PipelineBindPoint.GetHashCode()
			^ ViewMask.GetHashCode() ^ InputAttachmentCount.GetHashCode() ^ ((ulong)InputAttachments).GetHashCode() ^ ColorAttachmentCount.GetHashCode()
			^ ((ulong)ColorAttachments).GetHashCode() ^ ((ulong)ResolveAttachments).GetHashCode() ^ ((ulong)DepthStencilAttachment).GetHashCode() ^ PreserveAttachmentCount.GetHashCode()
			^ ((ulong)PreserveAttachments).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkSubpassDescription2 l, in VkSubpassDescription2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.PipelineBindPoint == r.PipelineBindPoint)
			&& (l.ViewMask == r.ViewMask) && (l.InputAttachmentCount == r.InputAttachmentCount) && (l.InputAttachments == r.InputAttachments) && (l.ColorAttachmentCount == r.ColorAttachmentCount)
			&& (l.ColorAttachments == r.ColorAttachments) && (l.ResolveAttachments == r.ResolveAttachments) && (l.DepthStencilAttachment == r.DepthStencilAttachment) && (l.PreserveAttachmentCount == r.PreserveAttachmentCount)
			&& (l.PreserveAttachments == r.PreserveAttachments)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkSubpassDescription2 l, in VkSubpassDescription2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.PipelineBindPoint != r.PipelineBindPoint)
			|| (l.ViewMask != r.ViewMask) || (l.InputAttachmentCount != r.InputAttachmentCount) || (l.InputAttachments != r.InputAttachments) || (l.ColorAttachmentCount != r.ColorAttachmentCount)
			|| (l.ColorAttachments != r.ColorAttachments) || (l.ResolveAttachments != r.ResolveAttachments) || (l.DepthStencilAttachment != r.DepthStencilAttachment) || (l.PreserveAttachmentCount != r.PreserveAttachmentCount)
			|| (l.PreserveAttachments != r.PreserveAttachments)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkSubpassDescription2 s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkSubpassDependency2 : IEquatable<VkSubpassDependency2>
{
	public const VkStructureType TYPE = VkStructureType.SubpassDependency2;

	public VkStructureType sType;
	public void* pNext;
	public uint SrcSubpass;
	public uint DstSubpass;
	public VkPipelineStageFlags SrcStageMask;
	public VkPipelineStageFlags DstStageMask;
	public VkAccessFlags SrcAccessMask;
	public VkAccessFlags DstAccessMask;
	public VkDependencyFlags DependencyFlags;
	public int ViewOffset;

	public VkSubpassDependency2(
		uint srcSubpass = default,
		uint dstSubpass = default,
		VkPipelineStageFlags srcStageMask = default,
		VkPipelineStageFlags dstStageMask = default,
		VkAccessFlags srcAccessMask = default,
		VkAccessFlags dstAccessMask = default,
		VkDependencyFlags dependencyFlags = default,
		int viewOffset = default
	) {
		sType = TYPE;
		pNext = null;
		SrcSubpass = srcSubpass;
		DstSubpass = dstSubpass;
		SrcStageMask = srcStageMask;
		DstStageMask = dstStageMask;
		SrcAccessMask = srcAccessMask;
		DstAccessMask = dstAccessMask;
		DependencyFlags = dependencyFlags;
		ViewOffset = viewOffset;
	}

	public readonly override bool Equals(object? o) => (o is VkSubpassDependency2 s) && (this == s);
	readonly bool IEquatable<VkSubpassDependency2>.Equals(VkSubpassDependency2 o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SrcSubpass.GetHashCode() ^ DstSubpass.GetHashCode()
			^ SrcStageMask.GetHashCode() ^ DstStageMask.GetHashCode() ^ SrcAccessMask.GetHashCode() ^ DstAccessMask.GetHashCode()
			^ DependencyFlags.GetHashCode() ^ ViewOffset.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkSubpassDependency2 l, in VkSubpassDependency2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SrcSubpass == r.SrcSubpass) && (l.DstSubpass == r.DstSubpass)
			&& (l.SrcStageMask == r.SrcStageMask) && (l.DstStageMask == r.DstStageMask) && (l.SrcAccessMask == r.SrcAccessMask) && (l.DstAccessMask == r.DstAccessMask)
			&& (l.DependencyFlags == r.DependencyFlags) && (l.ViewOffset == r.ViewOffset)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkSubpassDependency2 l, in VkSubpassDependency2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SrcSubpass != r.SrcSubpass) || (l.DstSubpass != r.DstSubpass)
			|| (l.SrcStageMask != r.SrcStageMask) || (l.DstStageMask != r.DstStageMask) || (l.SrcAccessMask != r.SrcAccessMask) || (l.DstAccessMask != r.DstAccessMask)
			|| (l.DependencyFlags != r.DependencyFlags) || (l.ViewOffset != r.ViewOffset)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkSubpassDependency2 s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkRenderPassCreateInfo2 : IEquatable<VkRenderPassCreateInfo2>
{
	public const VkStructureType TYPE = VkStructureType.RenderPassCreateInfo2;

	public VkStructureType sType;
	public void* pNext;
	public VkRenderPassCreateFlags Flags;
	public uint AttachmentCount;
	public VkAttachmentDescription2* Attachments;
	public uint SubpassCount;
	public VkSubpassDescription2* Subpasses;
	public uint DependencyCount;
	public VkSubpassDependency2* Dependencies;
	public uint CorrelatedViewMaskCount;
	public uint* CorrelatedViewMasks;

	public VkRenderPassCreateInfo2(
		VkRenderPassCreateFlags flags = default,
		uint attachmentCount = default,
		VkAttachmentDescription2* attachments = default,
		uint subpassCount = default,
		VkSubpassDescription2* subpasses = default,
		uint dependencyCount = default,
		VkSubpassDependency2* dependencies = default,
		uint correlatedViewMaskCount = default,
		uint* correlatedViewMasks = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		AttachmentCount = attachmentCount;
		Attachments = attachments;
		SubpassCount = subpassCount;
		Subpasses = subpasses;
		DependencyCount = dependencyCount;
		Dependencies = dependencies;
		CorrelatedViewMaskCount = correlatedViewMaskCount;
		CorrelatedViewMasks = correlatedViewMasks;
	}

	public readonly override bool Equals(object? o) => (o is VkRenderPassCreateInfo2 s) && (this == s);
	readonly bool IEquatable<VkRenderPassCreateInfo2>.Equals(VkRenderPassCreateInfo2 o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ AttachmentCount.GetHashCode()
			^ ((ulong)Attachments).GetHashCode() ^ SubpassCount.GetHashCode() ^ ((ulong)Subpasses).GetHashCode() ^ DependencyCount.GetHashCode()
			^ ((ulong)Dependencies).GetHashCode() ^ CorrelatedViewMaskCount.GetHashCode() ^ ((ulong)CorrelatedViewMasks).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkRenderPassCreateInfo2 l, in VkRenderPassCreateInfo2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.AttachmentCount == r.AttachmentCount)
			&& (l.Attachments == r.Attachments) && (l.SubpassCount == r.SubpassCount) && (l.Subpasses == r.Subpasses) && (l.DependencyCount == r.DependencyCount)
			&& (l.Dependencies == r.Dependencies) && (l.CorrelatedViewMaskCount == r.CorrelatedViewMaskCount) && (l.CorrelatedViewMasks == r.CorrelatedViewMasks)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkRenderPassCreateInfo2 l, in VkRenderPassCreateInfo2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.AttachmentCount != r.AttachmentCount)
			|| (l.Attachments != r.Attachments) || (l.SubpassCount != r.SubpassCount) || (l.Subpasses != r.Subpasses) || (l.DependencyCount != r.DependencyCount)
			|| (l.Dependencies != r.Dependencies) || (l.CorrelatedViewMaskCount != r.CorrelatedViewMaskCount) || (l.CorrelatedViewMasks != r.CorrelatedViewMasks)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkRenderPassCreateInfo2 s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkSubpassBeginInfo : IEquatable<VkSubpassBeginInfo>
{
	public const VkStructureType TYPE = VkStructureType.SubpassBeginInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkSubpassContents Contents;

	public VkSubpassBeginInfo(
		VkSubpassContents contents = default
	) {
		sType = TYPE;
		pNext = null;
		Contents = contents;
	}

	public readonly override bool Equals(object? o) => (o is VkSubpassBeginInfo s) && (this == s);
	readonly bool IEquatable<VkSubpassBeginInfo>.Equals(VkSubpassBeginInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Contents.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkSubpassBeginInfo l, in VkSubpassBeginInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Contents == r.Contents)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkSubpassBeginInfo l, in VkSubpassBeginInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Contents != r.Contents)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkSubpassBeginInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkSubpassEndInfo : IEquatable<VkSubpassEndInfo>
{
	public const VkStructureType TYPE = VkStructureType.SubpassEndInfo;

	public VkStructureType sType;
	public void* pNext;

	public readonly override bool Equals(object? o) => (o is VkSubpassEndInfo s) && (this == s);
	readonly bool IEquatable<VkSubpassEndInfo>.Equals(VkSubpassEndInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkSubpassEndInfo l, in VkSubpassEndInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkSubpassEndInfo l, in VkSubpassEndInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkSubpassEndInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceTimelineSemaphoreFeatures : IEquatable<VkPhysicalDeviceTimelineSemaphoreFeatures>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceTimelineSemaphoreFeatures;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 TimelineSemaphore;

	public VkPhysicalDeviceTimelineSemaphoreFeatures(
		VkBool32 timelineSemaphore = default
	) {
		sType = TYPE;
		pNext = null;
		TimelineSemaphore = timelineSemaphore;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceTimelineSemaphoreFeatures s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceTimelineSemaphoreFeatures>.Equals(VkPhysicalDeviceTimelineSemaphoreFeatures o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ TimelineSemaphore.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceTimelineSemaphoreFeatures l, in VkPhysicalDeviceTimelineSemaphoreFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.TimelineSemaphore == r.TimelineSemaphore)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceTimelineSemaphoreFeatures l, in VkPhysicalDeviceTimelineSemaphoreFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.TimelineSemaphore != r.TimelineSemaphore)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceTimelineSemaphoreFeatures s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceTimelineSemaphoreProperties : IEquatable<VkPhysicalDeviceTimelineSemaphoreProperties>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceTimelineSemaphoreProperties;

	public VkStructureType sType;
	public void* pNext;
	public ulong MaxTimelineSemaphoreValueDifference;

	public VkPhysicalDeviceTimelineSemaphoreProperties(
		ulong maxTimelineSemaphoreValueDifference = default
	) {
		sType = TYPE;
		pNext = null;
		MaxTimelineSemaphoreValueDifference = maxTimelineSemaphoreValueDifference;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceTimelineSemaphoreProperties s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceTimelineSemaphoreProperties>.Equals(VkPhysicalDeviceTimelineSemaphoreProperties o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MaxTimelineSemaphoreValueDifference.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceTimelineSemaphoreProperties l, in VkPhysicalDeviceTimelineSemaphoreProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MaxTimelineSemaphoreValueDifference == r.MaxTimelineSemaphoreValueDifference)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceTimelineSemaphoreProperties l, in VkPhysicalDeviceTimelineSemaphoreProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MaxTimelineSemaphoreValueDifference != r.MaxTimelineSemaphoreValueDifference)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceTimelineSemaphoreProperties s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkSemaphoreTypeCreateInfo : IEquatable<VkSemaphoreTypeCreateInfo>
{
	public const VkStructureType TYPE = VkStructureType.SemaphoreTypeCreateInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkSemaphoreType SemaphoreType;
	public ulong InitialValue;

	public VkSemaphoreTypeCreateInfo(
		VkSemaphoreType semaphoreType = default,
		ulong initialValue = default
	) {
		sType = TYPE;
		pNext = null;
		SemaphoreType = semaphoreType;
		InitialValue = initialValue;
	}

	public readonly override bool Equals(object? o) => (o is VkSemaphoreTypeCreateInfo s) && (this == s);
	readonly bool IEquatable<VkSemaphoreTypeCreateInfo>.Equals(VkSemaphoreTypeCreateInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SemaphoreType.GetHashCode() ^ InitialValue.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkSemaphoreTypeCreateInfo l, in VkSemaphoreTypeCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SemaphoreType == r.SemaphoreType) && (l.InitialValue == r.InitialValue)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkSemaphoreTypeCreateInfo l, in VkSemaphoreTypeCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SemaphoreType != r.SemaphoreType) || (l.InitialValue != r.InitialValue)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkSemaphoreTypeCreateInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkTimelineSemaphoreSubmitInfo : IEquatable<VkTimelineSemaphoreSubmitInfo>
{
	public const VkStructureType TYPE = VkStructureType.TimelineSemaphoreSubmitInfo;

	public VkStructureType sType;
	public void* pNext;
	public uint WaitSemaphoreValueCount;
	public ulong* WaitSemaphoreValues;
	public uint SignalSemaphoreValueCount;
	public ulong* SignalSemaphoreValues;

	public VkTimelineSemaphoreSubmitInfo(
		uint waitSemaphoreValueCount = default,
		ulong* waitSemaphoreValues = default,
		uint signalSemaphoreValueCount = default,
		ulong* signalSemaphoreValues = default
	) {
		sType = TYPE;
		pNext = null;
		WaitSemaphoreValueCount = waitSemaphoreValueCount;
		WaitSemaphoreValues = waitSemaphoreValues;
		SignalSemaphoreValueCount = signalSemaphoreValueCount;
		SignalSemaphoreValues = signalSemaphoreValues;
	}

	public readonly override bool Equals(object? o) => (o is VkTimelineSemaphoreSubmitInfo s) && (this == s);
	readonly bool IEquatable<VkTimelineSemaphoreSubmitInfo>.Equals(VkTimelineSemaphoreSubmitInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ WaitSemaphoreValueCount.GetHashCode() ^ ((ulong)WaitSemaphoreValues).GetHashCode()
			^ SignalSemaphoreValueCount.GetHashCode() ^ ((ulong)SignalSemaphoreValues).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkTimelineSemaphoreSubmitInfo l, in VkTimelineSemaphoreSubmitInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.WaitSemaphoreValueCount == r.WaitSemaphoreValueCount) && (l.WaitSemaphoreValues == r.WaitSemaphoreValues)
			&& (l.SignalSemaphoreValueCount == r.SignalSemaphoreValueCount) && (l.SignalSemaphoreValues == r.SignalSemaphoreValues)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkTimelineSemaphoreSubmitInfo l, in VkTimelineSemaphoreSubmitInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.WaitSemaphoreValueCount != r.WaitSemaphoreValueCount) || (l.WaitSemaphoreValues != r.WaitSemaphoreValues)
			|| (l.SignalSemaphoreValueCount != r.SignalSemaphoreValueCount) || (l.SignalSemaphoreValues != r.SignalSemaphoreValues)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkTimelineSemaphoreSubmitInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkSemaphoreWaitInfo : IEquatable<VkSemaphoreWaitInfo>
{
	public const VkStructureType TYPE = VkStructureType.SemaphoreWaitInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkSemaphoreWaitFlags Flags;
	public uint SemaphoreCount;
	public VulkanHandle<VkSemaphore>* Semaphores;
	public ulong* Values;

	public VkSemaphoreWaitInfo(
		VkSemaphoreWaitFlags flags = default,
		uint semaphoreCount = default,
		VulkanHandle<VkSemaphore>* semaphores = default,
		ulong* values = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		SemaphoreCount = semaphoreCount;
		Semaphores = semaphores;
		Values = values;
	}

	public readonly override bool Equals(object? o) => (o is VkSemaphoreWaitInfo s) && (this == s);
	readonly bool IEquatable<VkSemaphoreWaitInfo>.Equals(VkSemaphoreWaitInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ SemaphoreCount.GetHashCode()
			^ ((ulong)Semaphores).GetHashCode() ^ ((ulong)Values).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkSemaphoreWaitInfo l, in VkSemaphoreWaitInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.SemaphoreCount == r.SemaphoreCount)
			&& (l.Semaphores == r.Semaphores) && (l.Values == r.Values)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkSemaphoreWaitInfo l, in VkSemaphoreWaitInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.SemaphoreCount != r.SemaphoreCount)
			|| (l.Semaphores != r.Semaphores) || (l.Values != r.Values)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkSemaphoreWaitInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkSemaphoreSignalInfo : IEquatable<VkSemaphoreSignalInfo>
{
	public const VkStructureType TYPE = VkStructureType.SemaphoreSignalInfo;

	public VkStructureType sType;
	public void* pNext;
	public VulkanHandle<VkSemaphore> Semaphore;
	public ulong Value;

	public VkSemaphoreSignalInfo(
		VulkanHandle<VkSemaphore> semaphore = default,
		ulong value = default
	) {
		sType = TYPE;
		pNext = null;
		Semaphore = semaphore;
		Value = value;
	}

	public readonly override bool Equals(object? o) => (o is VkSemaphoreSignalInfo s) && (this == s);
	readonly bool IEquatable<VkSemaphoreSignalInfo>.Equals(VkSemaphoreSignalInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Semaphore.GetHashCode() ^ Value.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkSemaphoreSignalInfo l, in VkSemaphoreSignalInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Semaphore == r.Semaphore) && (l.Value == r.Value)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkSemaphoreSignalInfo l, in VkSemaphoreSignalInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Semaphore != r.Semaphore) || (l.Value != r.Value)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkSemaphoreSignalInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDevice8BitStorageFeatures : IEquatable<VkPhysicalDevice8BitStorageFeatures>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDevice8BitStorageFeatures;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 StorageBuffer8BitAccess;
	public VkBool32 UniformAndStorageBuffer8BitAccess;
	public VkBool32 StoragePushConstant8;

	public VkPhysicalDevice8BitStorageFeatures(
		VkBool32 storageBuffer8BitAccess = default,
		VkBool32 uniformAndStorageBuffer8BitAccess = default,
		VkBool32 storagePushConstant8 = default
	) {
		sType = TYPE;
		pNext = null;
		StorageBuffer8BitAccess = storageBuffer8BitAccess;
		UniformAndStorageBuffer8BitAccess = uniformAndStorageBuffer8BitAccess;
		StoragePushConstant8 = storagePushConstant8;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDevice8BitStorageFeatures s) && (this == s);
	readonly bool IEquatable<VkPhysicalDevice8BitStorageFeatures>.Equals(VkPhysicalDevice8BitStorageFeatures o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ StorageBuffer8BitAccess.GetHashCode() ^ UniformAndStorageBuffer8BitAccess.GetHashCode()
			^ StoragePushConstant8.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDevice8BitStorageFeatures l, in VkPhysicalDevice8BitStorageFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.StorageBuffer8BitAccess == r.StorageBuffer8BitAccess) && (l.UniformAndStorageBuffer8BitAccess == r.UniformAndStorageBuffer8BitAccess)
			&& (l.StoragePushConstant8 == r.StoragePushConstant8)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDevice8BitStorageFeatures l, in VkPhysicalDevice8BitStorageFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.StorageBuffer8BitAccess != r.StorageBuffer8BitAccess) || (l.UniformAndStorageBuffer8BitAccess != r.UniformAndStorageBuffer8BitAccess)
			|| (l.StoragePushConstant8 != r.StoragePushConstant8)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDevice8BitStorageFeatures s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceVulkanMemoryModelFeatures : IEquatable<VkPhysicalDeviceVulkanMemoryModelFeatures>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceVulkanMemoryModelFeatures;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 VulkanMemoryModel;
	public VkBool32 VulkanMemoryModelDeviceScope;
	public VkBool32 VulkanMemoryModelAvailabilityVisibilityChains;

	public VkPhysicalDeviceVulkanMemoryModelFeatures(
		VkBool32 vulkanMemoryModel = default,
		VkBool32 vulkanMemoryModelDeviceScope = default,
		VkBool32 vulkanMemoryModelAvailabilityVisibilityChains = default
	) {
		sType = TYPE;
		pNext = null;
		VulkanMemoryModel = vulkanMemoryModel;
		VulkanMemoryModelDeviceScope = vulkanMemoryModelDeviceScope;
		VulkanMemoryModelAvailabilityVisibilityChains = vulkanMemoryModelAvailabilityVisibilityChains;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceVulkanMemoryModelFeatures s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceVulkanMemoryModelFeatures>.Equals(VkPhysicalDeviceVulkanMemoryModelFeatures o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ VulkanMemoryModel.GetHashCode() ^ VulkanMemoryModelDeviceScope.GetHashCode()
			^ VulkanMemoryModelAvailabilityVisibilityChains.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceVulkanMemoryModelFeatures l, in VkPhysicalDeviceVulkanMemoryModelFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.VulkanMemoryModel == r.VulkanMemoryModel) && (l.VulkanMemoryModelDeviceScope == r.VulkanMemoryModelDeviceScope)
			&& (l.VulkanMemoryModelAvailabilityVisibilityChains == r.VulkanMemoryModelAvailabilityVisibilityChains)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceVulkanMemoryModelFeatures l, in VkPhysicalDeviceVulkanMemoryModelFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.VulkanMemoryModel != r.VulkanMemoryModel) || (l.VulkanMemoryModelDeviceScope != r.VulkanMemoryModelDeviceScope)
			|| (l.VulkanMemoryModelAvailabilityVisibilityChains != r.VulkanMemoryModelAvailabilityVisibilityChains)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceVulkanMemoryModelFeatures s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceShaderAtomicInt64Features : IEquatable<VkPhysicalDeviceShaderAtomicInt64Features>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceShaderAtomicInt64Features;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 ShaderBufferInt64Atomics;
	public VkBool32 ShaderSharedInt64Atomics;

	public VkPhysicalDeviceShaderAtomicInt64Features(
		VkBool32 shaderBufferInt64Atomics = default,
		VkBool32 shaderSharedInt64Atomics = default
	) {
		sType = TYPE;
		pNext = null;
		ShaderBufferInt64Atomics = shaderBufferInt64Atomics;
		ShaderSharedInt64Atomics = shaderSharedInt64Atomics;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceShaderAtomicInt64Features s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceShaderAtomicInt64Features>.Equals(VkPhysicalDeviceShaderAtomicInt64Features o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ShaderBufferInt64Atomics.GetHashCode() ^ ShaderSharedInt64Atomics.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceShaderAtomicInt64Features l, in VkPhysicalDeviceShaderAtomicInt64Features r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ShaderBufferInt64Atomics == r.ShaderBufferInt64Atomics) && (l.ShaderSharedInt64Atomics == r.ShaderSharedInt64Atomics)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceShaderAtomicInt64Features l, in VkPhysicalDeviceShaderAtomicInt64Features r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ShaderBufferInt64Atomics != r.ShaderBufferInt64Atomics) || (l.ShaderSharedInt64Atomics != r.ShaderSharedInt64Atomics)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceShaderAtomicInt64Features s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceDepthStencilResolveProperties : IEquatable<VkPhysicalDeviceDepthStencilResolveProperties>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceDepthStencilResolveProperties;

	public VkStructureType sType;
	public void* pNext;
	public VkResolveModeFlags SupportedDepthResolveModes;
	public VkResolveModeFlags SupportedStencilResolveModes;
	public VkBool32 IndependentResolveNone;
	public VkBool32 IndependentResolve;

	public VkPhysicalDeviceDepthStencilResolveProperties(
		VkResolveModeFlags supportedDepthResolveModes = default,
		VkResolveModeFlags supportedStencilResolveModes = default,
		VkBool32 independentResolveNone = default,
		VkBool32 independentResolve = default
	) {
		sType = TYPE;
		pNext = null;
		SupportedDepthResolveModes = supportedDepthResolveModes;
		SupportedStencilResolveModes = supportedStencilResolveModes;
		IndependentResolveNone = independentResolveNone;
		IndependentResolve = independentResolve;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceDepthStencilResolveProperties s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceDepthStencilResolveProperties>.Equals(VkPhysicalDeviceDepthStencilResolveProperties o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SupportedDepthResolveModes.GetHashCode() ^ SupportedStencilResolveModes.GetHashCode()
			^ IndependentResolveNone.GetHashCode() ^ IndependentResolve.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceDepthStencilResolveProperties l, in VkPhysicalDeviceDepthStencilResolveProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SupportedDepthResolveModes == r.SupportedDepthResolveModes) && (l.SupportedStencilResolveModes == r.SupportedStencilResolveModes)
			&& (l.IndependentResolveNone == r.IndependentResolveNone) && (l.IndependentResolve == r.IndependentResolve)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceDepthStencilResolveProperties l, in VkPhysicalDeviceDepthStencilResolveProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SupportedDepthResolveModes != r.SupportedDepthResolveModes) || (l.SupportedStencilResolveModes != r.SupportedStencilResolveModes)
			|| (l.IndependentResolveNone != r.IndependentResolveNone) || (l.IndependentResolve != r.IndependentResolve)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceDepthStencilResolveProperties s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkSubpassDescriptionDepthStencilResolve : IEquatable<VkSubpassDescriptionDepthStencilResolve>
{
	public const VkStructureType TYPE = VkStructureType.SubpassDescriptionDepthStencilResolve;

	public VkStructureType sType;
	public void* pNext;
	public VkResolveModeFlags DepthResolveMode;
	public VkResolveModeFlags StencilResolveMode;
	public VkAttachmentReference2* DepthStencilResolveAttachment;

	public VkSubpassDescriptionDepthStencilResolve(
		VkResolveModeFlags depthResolveMode = default,
		VkResolveModeFlags stencilResolveMode = default,
		VkAttachmentReference2* depthStencilResolveAttachment = default
	) {
		sType = TYPE;
		pNext = null;
		DepthResolveMode = depthResolveMode;
		StencilResolveMode = stencilResolveMode;
		DepthStencilResolveAttachment = depthStencilResolveAttachment;
	}

	public readonly override bool Equals(object? o) => (o is VkSubpassDescriptionDepthStencilResolve s) && (this == s);
	readonly bool IEquatable<VkSubpassDescriptionDepthStencilResolve>.Equals(VkSubpassDescriptionDepthStencilResolve o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DepthResolveMode.GetHashCode() ^ StencilResolveMode.GetHashCode()
			^ ((ulong)DepthStencilResolveAttachment).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkSubpassDescriptionDepthStencilResolve l, in VkSubpassDescriptionDepthStencilResolve r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DepthResolveMode == r.DepthResolveMode) && (l.StencilResolveMode == r.StencilResolveMode)
			&& (l.DepthStencilResolveAttachment == r.DepthStencilResolveAttachment)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkSubpassDescriptionDepthStencilResolve l, in VkSubpassDescriptionDepthStencilResolve r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DepthResolveMode != r.DepthResolveMode) || (l.StencilResolveMode != r.StencilResolveMode)
			|| (l.DepthStencilResolveAttachment != r.DepthStencilResolveAttachment)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkSubpassDescriptionDepthStencilResolve s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkImageStencilUsageCreateInfo : IEquatable<VkImageStencilUsageCreateInfo>
{
	public const VkStructureType TYPE = VkStructureType.ImageStencilUsageCreateInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkImageUsageFlags StencilUsage;

	public VkImageStencilUsageCreateInfo(
		VkImageUsageFlags stencilUsage = default
	) {
		sType = TYPE;
		pNext = null;
		StencilUsage = stencilUsage;
	}

	public readonly override bool Equals(object? o) => (o is VkImageStencilUsageCreateInfo s) && (this == s);
	readonly bool IEquatable<VkImageStencilUsageCreateInfo>.Equals(VkImageStencilUsageCreateInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ StencilUsage.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkImageStencilUsageCreateInfo l, in VkImageStencilUsageCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.StencilUsage == r.StencilUsage)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkImageStencilUsageCreateInfo l, in VkImageStencilUsageCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.StencilUsage != r.StencilUsage)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkImageStencilUsageCreateInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceScalarBlockLayoutFeatures : IEquatable<VkPhysicalDeviceScalarBlockLayoutFeatures>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceScalarBlockLayoutFeatures;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 ScalarBlockLayout;

	public VkPhysicalDeviceScalarBlockLayoutFeatures(
		VkBool32 scalarBlockLayout = default
	) {
		sType = TYPE;
		pNext = null;
		ScalarBlockLayout = scalarBlockLayout;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceScalarBlockLayoutFeatures s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceScalarBlockLayoutFeatures>.Equals(VkPhysicalDeviceScalarBlockLayoutFeatures o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ScalarBlockLayout.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceScalarBlockLayoutFeatures l, in VkPhysicalDeviceScalarBlockLayoutFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ScalarBlockLayout == r.ScalarBlockLayout)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceScalarBlockLayoutFeatures l, in VkPhysicalDeviceScalarBlockLayoutFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ScalarBlockLayout != r.ScalarBlockLayout)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceScalarBlockLayoutFeatures s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceUniformBufferStandardLayoutFeatures : IEquatable<VkPhysicalDeviceUniformBufferStandardLayoutFeatures>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceUniformBufferStandardLayoutFeatures;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 UniformBufferStandardLayout;

	public VkPhysicalDeviceUniformBufferStandardLayoutFeatures(
		VkBool32 uniformBufferStandardLayout = default
	) {
		sType = TYPE;
		pNext = null;
		UniformBufferStandardLayout = uniformBufferStandardLayout;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceUniformBufferStandardLayoutFeatures s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceUniformBufferStandardLayoutFeatures>.Equals(VkPhysicalDeviceUniformBufferStandardLayoutFeatures o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ UniformBufferStandardLayout.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceUniformBufferStandardLayoutFeatures l, in VkPhysicalDeviceUniformBufferStandardLayoutFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.UniformBufferStandardLayout == r.UniformBufferStandardLayout)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceUniformBufferStandardLayoutFeatures l, in VkPhysicalDeviceUniformBufferStandardLayoutFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.UniformBufferStandardLayout != r.UniformBufferStandardLayout)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceUniformBufferStandardLayoutFeatures s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceBufferDeviceAddressFeatures : IEquatable<VkPhysicalDeviceBufferDeviceAddressFeatures>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceBufferDeviceAddressFeatures;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 BufferDeviceAddress;
	public VkBool32 BufferDeviceAddressCaptureReplay;
	public VkBool32 BufferDeviceAddressMultiDevice;

	public VkPhysicalDeviceBufferDeviceAddressFeatures(
		VkBool32 bufferDeviceAddress = default,
		VkBool32 bufferDeviceAddressCaptureReplay = default,
		VkBool32 bufferDeviceAddressMultiDevice = default
	) {
		sType = TYPE;
		pNext = null;
		BufferDeviceAddress = bufferDeviceAddress;
		BufferDeviceAddressCaptureReplay = bufferDeviceAddressCaptureReplay;
		BufferDeviceAddressMultiDevice = bufferDeviceAddressMultiDevice;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceBufferDeviceAddressFeatures s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceBufferDeviceAddressFeatures>.Equals(VkPhysicalDeviceBufferDeviceAddressFeatures o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ BufferDeviceAddress.GetHashCode() ^ BufferDeviceAddressCaptureReplay.GetHashCode()
			^ BufferDeviceAddressMultiDevice.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceBufferDeviceAddressFeatures l, in VkPhysicalDeviceBufferDeviceAddressFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.BufferDeviceAddress == r.BufferDeviceAddress) && (l.BufferDeviceAddressCaptureReplay == r.BufferDeviceAddressCaptureReplay)
			&& (l.BufferDeviceAddressMultiDevice == r.BufferDeviceAddressMultiDevice)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceBufferDeviceAddressFeatures l, in VkPhysicalDeviceBufferDeviceAddressFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.BufferDeviceAddress != r.BufferDeviceAddress) || (l.BufferDeviceAddressCaptureReplay != r.BufferDeviceAddressCaptureReplay)
			|| (l.BufferDeviceAddressMultiDevice != r.BufferDeviceAddressMultiDevice)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceBufferDeviceAddressFeatures s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkBufferDeviceAddressInfo : IEquatable<VkBufferDeviceAddressInfo>
{
	public const VkStructureType TYPE = VkStructureType.BufferDeviceAddressInfo;

	public VkStructureType sType;
	public void* pNext;
	public VulkanHandle<VkBuffer> Buffer;

	public VkBufferDeviceAddressInfo(
		VulkanHandle<VkBuffer> buffer = default
	) {
		sType = TYPE;
		pNext = null;
		Buffer = buffer;
	}

	public readonly override bool Equals(object? o) => (o is VkBufferDeviceAddressInfo s) && (this == s);
	readonly bool IEquatable<VkBufferDeviceAddressInfo>.Equals(VkBufferDeviceAddressInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Buffer.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkBufferDeviceAddressInfo l, in VkBufferDeviceAddressInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Buffer == r.Buffer)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkBufferDeviceAddressInfo l, in VkBufferDeviceAddressInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Buffer != r.Buffer)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkBufferDeviceAddressInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkBufferOpaqueCaptureAddressCreateInfo : IEquatable<VkBufferOpaqueCaptureAddressCreateInfo>
{
	public const VkStructureType TYPE = VkStructureType.BufferOpaqueCaptureAddressCreateInfo;

	public VkStructureType sType;
	public void* pNext;
	public ulong OpaqueCaptureAddress;

	public VkBufferOpaqueCaptureAddressCreateInfo(
		ulong opaqueCaptureAddress = default
	) {
		sType = TYPE;
		pNext = null;
		OpaqueCaptureAddress = opaqueCaptureAddress;
	}

	public readonly override bool Equals(object? o) => (o is VkBufferOpaqueCaptureAddressCreateInfo s) && (this == s);
	readonly bool IEquatable<VkBufferOpaqueCaptureAddressCreateInfo>.Equals(VkBufferOpaqueCaptureAddressCreateInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ OpaqueCaptureAddress.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkBufferOpaqueCaptureAddressCreateInfo l, in VkBufferOpaqueCaptureAddressCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.OpaqueCaptureAddress == r.OpaqueCaptureAddress)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkBufferOpaqueCaptureAddressCreateInfo l, in VkBufferOpaqueCaptureAddressCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.OpaqueCaptureAddress != r.OpaqueCaptureAddress)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkBufferOpaqueCaptureAddressCreateInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceImagelessFramebufferFeatures : IEquatable<VkPhysicalDeviceImagelessFramebufferFeatures>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceImagelessFramebufferFeatures;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 ImagelessFramebuffer;

	public VkPhysicalDeviceImagelessFramebufferFeatures(
		VkBool32 imagelessFramebuffer = default
	) {
		sType = TYPE;
		pNext = null;
		ImagelessFramebuffer = imagelessFramebuffer;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceImagelessFramebufferFeatures s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceImagelessFramebufferFeatures>.Equals(VkPhysicalDeviceImagelessFramebufferFeatures o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ImagelessFramebuffer.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceImagelessFramebufferFeatures l, in VkPhysicalDeviceImagelessFramebufferFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ImagelessFramebuffer == r.ImagelessFramebuffer)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceImagelessFramebufferFeatures l, in VkPhysicalDeviceImagelessFramebufferFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ImagelessFramebuffer != r.ImagelessFramebuffer)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceImagelessFramebufferFeatures s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkFramebufferAttachmentsCreateInfo : IEquatable<VkFramebufferAttachmentsCreateInfo>
{
	public const VkStructureType TYPE = VkStructureType.FramebufferAttachmentsCreateInfo;

	public VkStructureType sType;
	public void* pNext;
	public uint AttachmentImageInfoCount;
	public VkFramebufferAttachmentImageInfo* AttachmentImageInfos;

	public VkFramebufferAttachmentsCreateInfo(
		uint attachmentImageInfoCount = default,
		VkFramebufferAttachmentImageInfo* attachmentImageInfos = default
	) {
		sType = TYPE;
		pNext = null;
		AttachmentImageInfoCount = attachmentImageInfoCount;
		AttachmentImageInfos = attachmentImageInfos;
	}

	public readonly override bool Equals(object? o) => (o is VkFramebufferAttachmentsCreateInfo s) && (this == s);
	readonly bool IEquatable<VkFramebufferAttachmentsCreateInfo>.Equals(VkFramebufferAttachmentsCreateInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ AttachmentImageInfoCount.GetHashCode() ^ ((ulong)AttachmentImageInfos).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkFramebufferAttachmentsCreateInfo l, in VkFramebufferAttachmentsCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.AttachmentImageInfoCount == r.AttachmentImageInfoCount) && (l.AttachmentImageInfos == r.AttachmentImageInfos)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkFramebufferAttachmentsCreateInfo l, in VkFramebufferAttachmentsCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.AttachmentImageInfoCount != r.AttachmentImageInfoCount) || (l.AttachmentImageInfos != r.AttachmentImageInfos)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkFramebufferAttachmentsCreateInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkFramebufferAttachmentImageInfo : IEquatable<VkFramebufferAttachmentImageInfo>
{
	public const VkStructureType TYPE = VkStructureType.FramebufferAttachmentImageInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkImageCreateFlags Flags;
	public VkImageUsageFlags Usage;
	public uint Width;
	public uint Height;
	public uint LayerCount;
	public uint ViewFormatCount;
	public VkFormat* ViewFormats;

	public VkFramebufferAttachmentImageInfo(
		VkImageCreateFlags flags = default,
		VkImageUsageFlags usage = default,
		uint width = default,
		uint height = default,
		uint layerCount = default,
		uint viewFormatCount = default,
		VkFormat* viewFormats = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		Usage = usage;
		Width = width;
		Height = height;
		LayerCount = layerCount;
		ViewFormatCount = viewFormatCount;
		ViewFormats = viewFormats;
	}

	public readonly override bool Equals(object? o) => (o is VkFramebufferAttachmentImageInfo s) && (this == s);
	readonly bool IEquatable<VkFramebufferAttachmentImageInfo>.Equals(VkFramebufferAttachmentImageInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ Usage.GetHashCode()
			^ Width.GetHashCode() ^ Height.GetHashCode() ^ LayerCount.GetHashCode() ^ ViewFormatCount.GetHashCode()
			^ ((ulong)ViewFormats).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkFramebufferAttachmentImageInfo l, in VkFramebufferAttachmentImageInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.Usage == r.Usage)
			&& (l.Width == r.Width) && (l.Height == r.Height) && (l.LayerCount == r.LayerCount) && (l.ViewFormatCount == r.ViewFormatCount)
			&& (l.ViewFormats == r.ViewFormats)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkFramebufferAttachmentImageInfo l, in VkFramebufferAttachmentImageInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.Usage != r.Usage)
			|| (l.Width != r.Width) || (l.Height != r.Height) || (l.LayerCount != r.LayerCount) || (l.ViewFormatCount != r.ViewFormatCount)
			|| (l.ViewFormats != r.ViewFormats)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkFramebufferAttachmentImageInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkRenderPassAttachmentBeginInfo : IEquatable<VkRenderPassAttachmentBeginInfo>
{
	public const VkStructureType TYPE = VkStructureType.RenderPassAttachmentBeginInfo;

	public VkStructureType sType;
	public void* pNext;
	public uint AttachmentCount;
	public VulkanHandle<VkImageView>* Attachments;

	public VkRenderPassAttachmentBeginInfo(
		uint attachmentCount = default,
		VulkanHandle<VkImageView>* attachments = default
	) {
		sType = TYPE;
		pNext = null;
		AttachmentCount = attachmentCount;
		Attachments = attachments;
	}

	public readonly override bool Equals(object? o) => (o is VkRenderPassAttachmentBeginInfo s) && (this == s);
	readonly bool IEquatable<VkRenderPassAttachmentBeginInfo>.Equals(VkRenderPassAttachmentBeginInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ AttachmentCount.GetHashCode() ^ ((ulong)Attachments).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkRenderPassAttachmentBeginInfo l, in VkRenderPassAttachmentBeginInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.AttachmentCount == r.AttachmentCount) && (l.Attachments == r.Attachments)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkRenderPassAttachmentBeginInfo l, in VkRenderPassAttachmentBeginInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.AttachmentCount != r.AttachmentCount) || (l.Attachments != r.Attachments)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkRenderPassAttachmentBeginInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures : IEquatable<VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceSeparateDepthStencilLayoutsFeatures;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 SeparateDepthStencilLayouts;

	public VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures(
		VkBool32 separateDepthStencilLayouts = default
	) {
		sType = TYPE;
		pNext = null;
		SeparateDepthStencilLayouts = separateDepthStencilLayouts;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures>.Equals(VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SeparateDepthStencilLayouts.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures l, in VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SeparateDepthStencilLayouts == r.SeparateDepthStencilLayouts)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures l, in VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SeparateDepthStencilLayouts != r.SeparateDepthStencilLayouts)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkAttachmentReferenceStencilLayout : IEquatable<VkAttachmentReferenceStencilLayout>
{
	public const VkStructureType TYPE = VkStructureType.AttachmentReferenceStencilLayout;

	public VkStructureType sType;
	public void* pNext;
	public VkImageLayout StencilLayout;

	public VkAttachmentReferenceStencilLayout(
		VkImageLayout stencilLayout = default
	) {
		sType = TYPE;
		pNext = null;
		StencilLayout = stencilLayout;
	}

	public readonly override bool Equals(object? o) => (o is VkAttachmentReferenceStencilLayout s) && (this == s);
	readonly bool IEquatable<VkAttachmentReferenceStencilLayout>.Equals(VkAttachmentReferenceStencilLayout o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ StencilLayout.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkAttachmentReferenceStencilLayout l, in VkAttachmentReferenceStencilLayout r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.StencilLayout == r.StencilLayout)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkAttachmentReferenceStencilLayout l, in VkAttachmentReferenceStencilLayout r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.StencilLayout != r.StencilLayout)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkAttachmentReferenceStencilLayout s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkAttachmentDescriptionStencilLayout : IEquatable<VkAttachmentDescriptionStencilLayout>
{
	public const VkStructureType TYPE = VkStructureType.AttachmentDescriptionStencilLayout;

	public VkStructureType sType;
	public void* pNext;
	public VkImageLayout StencilInitialLayout;
	public VkImageLayout StencilFinalLayout;

	public VkAttachmentDescriptionStencilLayout(
		VkImageLayout stencilInitialLayout = default,
		VkImageLayout stencilFinalLayout = default
	) {
		sType = TYPE;
		pNext = null;
		StencilInitialLayout = stencilInitialLayout;
		StencilFinalLayout = stencilFinalLayout;
	}

	public readonly override bool Equals(object? o) => (o is VkAttachmentDescriptionStencilLayout s) && (this == s);
	readonly bool IEquatable<VkAttachmentDescriptionStencilLayout>.Equals(VkAttachmentDescriptionStencilLayout o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ StencilInitialLayout.GetHashCode() ^ StencilFinalLayout.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkAttachmentDescriptionStencilLayout l, in VkAttachmentDescriptionStencilLayout r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.StencilInitialLayout == r.StencilInitialLayout) && (l.StencilFinalLayout == r.StencilFinalLayout)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkAttachmentDescriptionStencilLayout l, in VkAttachmentDescriptionStencilLayout r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.StencilInitialLayout != r.StencilInitialLayout) || (l.StencilFinalLayout != r.StencilFinalLayout)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkAttachmentDescriptionStencilLayout s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkMemoryOpaqueCaptureAddressAllocateInfo : IEquatable<VkMemoryOpaqueCaptureAddressAllocateInfo>
{
	public const VkStructureType TYPE = VkStructureType.MemoryOpaqueCaptureAddressAllocateInfo;

	public VkStructureType sType;
	public void* pNext;
	public ulong OpaqueCaptureAddress;

	public VkMemoryOpaqueCaptureAddressAllocateInfo(
		ulong opaqueCaptureAddress = default
	) {
		sType = TYPE;
		pNext = null;
		OpaqueCaptureAddress = opaqueCaptureAddress;
	}

	public readonly override bool Equals(object? o) => (o is VkMemoryOpaqueCaptureAddressAllocateInfo s) && (this == s);
	readonly bool IEquatable<VkMemoryOpaqueCaptureAddressAllocateInfo>.Equals(VkMemoryOpaqueCaptureAddressAllocateInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ OpaqueCaptureAddress.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkMemoryOpaqueCaptureAddressAllocateInfo l, in VkMemoryOpaqueCaptureAddressAllocateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.OpaqueCaptureAddress == r.OpaqueCaptureAddress)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkMemoryOpaqueCaptureAddressAllocateInfo l, in VkMemoryOpaqueCaptureAddressAllocateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.OpaqueCaptureAddress != r.OpaqueCaptureAddress)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkMemoryOpaqueCaptureAddressAllocateInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDeviceMemoryOpaqueCaptureAddressInfo : IEquatable<VkDeviceMemoryOpaqueCaptureAddressInfo>
{
	public const VkStructureType TYPE = VkStructureType.DeviceMemoryOpaqueCaptureAddressInfo;

	public VkStructureType sType;
	public void* pNext;
	public VulkanHandle<VkDeviceMemory> Memory;

	public VkDeviceMemoryOpaqueCaptureAddressInfo(
		VulkanHandle<VkDeviceMemory> memory = default
	) {
		sType = TYPE;
		pNext = null;
		Memory = memory;
	}

	public readonly override bool Equals(object? o) => (o is VkDeviceMemoryOpaqueCaptureAddressInfo s) && (this == s);
	readonly bool IEquatable<VkDeviceMemoryOpaqueCaptureAddressInfo>.Equals(VkDeviceMemoryOpaqueCaptureAddressInfo o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Memory.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDeviceMemoryOpaqueCaptureAddressInfo l, in VkDeviceMemoryOpaqueCaptureAddressInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Memory == r.Memory)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDeviceMemoryOpaqueCaptureAddressInfo l, in VkDeviceMemoryOpaqueCaptureAddressInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Memory != r.Memory)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDeviceMemoryOpaqueCaptureAddressInfo s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceVulkan11Features : IEquatable<VkPhysicalDeviceVulkan11Features>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceVulkan11Features;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 StorageBuffer16BitAccess;
	public VkBool32 UniformAndStorageBuffer16BitAccess;
	public VkBool32 StoragePushConstant16;
	public VkBool32 StorageInputOutput16;
	public VkBool32 Multiview;
	public VkBool32 MultiviewGeometryShader;
	public VkBool32 MultiviewTessellationShader;
	public VkBool32 VariablePointersStorageBuffer;
	public VkBool32 VariablePointers;
	public VkBool32 ProtectedMemory;
	public VkBool32 SamplerYcbcrConversion;
	public VkBool32 ShaderDrawParameters;

	public VkPhysicalDeviceVulkan11Features(
		VkBool32 storageBuffer16BitAccess = default,
		VkBool32 uniformAndStorageBuffer16BitAccess = default,
		VkBool32 storagePushConstant16 = default,
		VkBool32 storageInputOutput16 = default,
		VkBool32 multiview = default,
		VkBool32 multiviewGeometryShader = default,
		VkBool32 multiviewTessellationShader = default,
		VkBool32 variablePointersStorageBuffer = default,
		VkBool32 variablePointers = default,
		VkBool32 protectedMemory = default,
		VkBool32 samplerYcbcrConversion = default,
		VkBool32 shaderDrawParameters = default
	) {
		sType = TYPE;
		pNext = null;
		StorageBuffer16BitAccess = storageBuffer16BitAccess;
		UniformAndStorageBuffer16BitAccess = uniformAndStorageBuffer16BitAccess;
		StoragePushConstant16 = storagePushConstant16;
		StorageInputOutput16 = storageInputOutput16;
		Multiview = multiview;
		MultiviewGeometryShader = multiviewGeometryShader;
		MultiviewTessellationShader = multiviewTessellationShader;
		VariablePointersStorageBuffer = variablePointersStorageBuffer;
		VariablePointers = variablePointers;
		ProtectedMemory = protectedMemory;
		SamplerYcbcrConversion = samplerYcbcrConversion;
		ShaderDrawParameters = shaderDrawParameters;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceVulkan11Features s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceVulkan11Features>.Equals(VkPhysicalDeviceVulkan11Features o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ StorageBuffer16BitAccess.GetHashCode() ^ UniformAndStorageBuffer16BitAccess.GetHashCode()
			^ StoragePushConstant16.GetHashCode() ^ StorageInputOutput16.GetHashCode() ^ Multiview.GetHashCode() ^ MultiviewGeometryShader.GetHashCode()
			^ MultiviewTessellationShader.GetHashCode() ^ VariablePointersStorageBuffer.GetHashCode() ^ VariablePointers.GetHashCode() ^ ProtectedMemory.GetHashCode()
			^ SamplerYcbcrConversion.GetHashCode() ^ ShaderDrawParameters.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceVulkan11Features l, in VkPhysicalDeviceVulkan11Features r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.StorageBuffer16BitAccess == r.StorageBuffer16BitAccess) && (l.UniformAndStorageBuffer16BitAccess == r.UniformAndStorageBuffer16BitAccess)
			&& (l.StoragePushConstant16 == r.StoragePushConstant16) && (l.StorageInputOutput16 == r.StorageInputOutput16) && (l.Multiview == r.Multiview) && (l.MultiviewGeometryShader == r.MultiviewGeometryShader)
			&& (l.MultiviewTessellationShader == r.MultiviewTessellationShader) && (l.VariablePointersStorageBuffer == r.VariablePointersStorageBuffer) && (l.VariablePointers == r.VariablePointers) && (l.ProtectedMemory == r.ProtectedMemory)
			&& (l.SamplerYcbcrConversion == r.SamplerYcbcrConversion) && (l.ShaderDrawParameters == r.ShaderDrawParameters)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceVulkan11Features l, in VkPhysicalDeviceVulkan11Features r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.StorageBuffer16BitAccess != r.StorageBuffer16BitAccess) || (l.UniformAndStorageBuffer16BitAccess != r.UniformAndStorageBuffer16BitAccess)
			|| (l.StoragePushConstant16 != r.StoragePushConstant16) || (l.StorageInputOutput16 != r.StorageInputOutput16) || (l.Multiview != r.Multiview) || (l.MultiviewGeometryShader != r.MultiviewGeometryShader)
			|| (l.MultiviewTessellationShader != r.MultiviewTessellationShader) || (l.VariablePointersStorageBuffer != r.VariablePointersStorageBuffer) || (l.VariablePointers != r.VariablePointers) || (l.ProtectedMemory != r.ProtectedMemory)
			|| (l.SamplerYcbcrConversion != r.SamplerYcbcrConversion) || (l.ShaderDrawParameters != r.ShaderDrawParameters)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceVulkan11Features s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceVulkan11Properties : IEquatable<VkPhysicalDeviceVulkan11Properties>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceVulkan11Properties;

	public VkStructureType sType;
	public void* pNext;
	public VVK.UUID DeviceUUID;
	public VVK.UUID DriverUUID;
	public VVK.LUID DeviceLUID;
	public uint DeviceNodeMask;
	public VkBool32 DeviceLUIDValid;
	public uint SubgroupSize;
	public VkShaderStageFlags SubgroupSupportedStages;
	public VkSubgroupFeatureFlags SubgroupSupportedOperations;
	public VkBool32 SubgroupQuadOperationsInAllStages;
	public VkPointClippingBehavior PointClippingBehavior;
	public uint MaxMultiviewViewCount;
	public uint MaxMultiviewInstanceIndex;
	public VkBool32 ProtectedNoFault;
	public uint MaxPerSetDescriptors;
	public ulong MaxMemoryAllocationSize;

	public VkPhysicalDeviceVulkan11Properties(
		VVK.UUID deviceUUID = default,
		VVK.UUID driverUUID = default,
		VVK.LUID deviceLUID = default,
		uint deviceNodeMask = default,
		VkBool32 deviceLUIDValid = default,
		uint subgroupSize = default,
		VkShaderStageFlags subgroupSupportedStages = default,
		VkSubgroupFeatureFlags subgroupSupportedOperations = default,
		VkBool32 subgroupQuadOperationsInAllStages = default,
		VkPointClippingBehavior pointClippingBehavior = default,
		uint maxMultiviewViewCount = default,
		uint maxMultiviewInstanceIndex = default,
		VkBool32 protectedNoFault = default,
		uint maxPerSetDescriptors = default,
		ulong maxMemoryAllocationSize = default
	) {
		sType = TYPE;
		pNext = null;
		DeviceUUID = deviceUUID;
		DriverUUID = driverUUID;
		DeviceLUID = deviceLUID;
		DeviceNodeMask = deviceNodeMask;
		DeviceLUIDValid = deviceLUIDValid;
		SubgroupSize = subgroupSize;
		SubgroupSupportedStages = subgroupSupportedStages;
		SubgroupSupportedOperations = subgroupSupportedOperations;
		SubgroupQuadOperationsInAllStages = subgroupQuadOperationsInAllStages;
		PointClippingBehavior = pointClippingBehavior;
		MaxMultiviewViewCount = maxMultiviewViewCount;
		MaxMultiviewInstanceIndex = maxMultiviewInstanceIndex;
		ProtectedNoFault = protectedNoFault;
		MaxPerSetDescriptors = maxPerSetDescriptors;
		MaxMemoryAllocationSize = maxMemoryAllocationSize;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceVulkan11Properties s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceVulkan11Properties>.Equals(VkPhysicalDeviceVulkan11Properties o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DeviceUUID.GetHashCode() ^ DriverUUID.GetHashCode()
			^ DeviceLUID.GetHashCode() ^ DeviceNodeMask.GetHashCode() ^ DeviceLUIDValid.GetHashCode() ^ SubgroupSize.GetHashCode()
			^ SubgroupSupportedStages.GetHashCode() ^ SubgroupSupportedOperations.GetHashCode() ^ SubgroupQuadOperationsInAllStages.GetHashCode() ^ PointClippingBehavior.GetHashCode()
			^ MaxMultiviewViewCount.GetHashCode() ^ MaxMultiviewInstanceIndex.GetHashCode() ^ ProtectedNoFault.GetHashCode() ^ MaxPerSetDescriptors.GetHashCode()
			^ MaxMemoryAllocationSize.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceVulkan11Properties l, in VkPhysicalDeviceVulkan11Properties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DeviceUUID == r.DeviceUUID) && (l.DriverUUID == r.DriverUUID)
			&& (l.DeviceLUID == r.DeviceLUID) && (l.DeviceNodeMask == r.DeviceNodeMask) && (l.DeviceLUIDValid == r.DeviceLUIDValid) && (l.SubgroupSize == r.SubgroupSize)
			&& (l.SubgroupSupportedStages == r.SubgroupSupportedStages) && (l.SubgroupSupportedOperations == r.SubgroupSupportedOperations) && (l.SubgroupQuadOperationsInAllStages == r.SubgroupQuadOperationsInAllStages) && (l.PointClippingBehavior == r.PointClippingBehavior)
			&& (l.MaxMultiviewViewCount == r.MaxMultiviewViewCount) && (l.MaxMultiviewInstanceIndex == r.MaxMultiviewInstanceIndex) && (l.ProtectedNoFault == r.ProtectedNoFault) && (l.MaxPerSetDescriptors == r.MaxPerSetDescriptors)
			&& (l.MaxMemoryAllocationSize == r.MaxMemoryAllocationSize)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceVulkan11Properties l, in VkPhysicalDeviceVulkan11Properties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DeviceUUID != r.DeviceUUID) || (l.DriverUUID != r.DriverUUID)
			|| (l.DeviceLUID != r.DeviceLUID) || (l.DeviceNodeMask != r.DeviceNodeMask) || (l.DeviceLUIDValid != r.DeviceLUIDValid) || (l.SubgroupSize != r.SubgroupSize)
			|| (l.SubgroupSupportedStages != r.SubgroupSupportedStages) || (l.SubgroupSupportedOperations != r.SubgroupSupportedOperations) || (l.SubgroupQuadOperationsInAllStages != r.SubgroupQuadOperationsInAllStages) || (l.PointClippingBehavior != r.PointClippingBehavior)
			|| (l.MaxMultiviewViewCount != r.MaxMultiviewViewCount) || (l.MaxMultiviewInstanceIndex != r.MaxMultiviewInstanceIndex) || (l.ProtectedNoFault != r.ProtectedNoFault) || (l.MaxPerSetDescriptors != r.MaxPerSetDescriptors)
			|| (l.MaxMemoryAllocationSize != r.MaxMemoryAllocationSize)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceVulkan11Properties s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceVulkan12Features : IEquatable<VkPhysicalDeviceVulkan12Features>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceVulkan12Features;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 SamplerMirrorClampToEdge;
	public VkBool32 DrawIndirectCount;
	public VkBool32 StorageBuffer8BitAccess;
	public VkBool32 UniformAndStorageBuffer8BitAccess;
	public VkBool32 StoragePushConstant8;
	public VkBool32 ShaderBufferInt64Atomics;
	public VkBool32 ShaderSharedInt64Atomics;
	public VkBool32 ShaderFloat16;
	public VkBool32 ShaderInt8;
	public VkBool32 DescriptorIndexing;
	public VkBool32 ShaderInputAttachmentArrayDynamicIndexing;
	public VkBool32 ShaderUniformTexelBufferArrayDynamicIndexing;
	public VkBool32 ShaderStorageTexelBufferArrayDynamicIndexing;
	public VkBool32 ShaderUniformBufferArrayNonUniformIndexing;
	public VkBool32 ShaderSampledImageArrayNonUniformIndexing;
	public VkBool32 ShaderStorageBufferArrayNonUniformIndexing;
	public VkBool32 ShaderStorageImageArrayNonUniformIndexing;
	public VkBool32 ShaderInputAttachmentArrayNonUniformIndexing;
	public VkBool32 ShaderUniformTexelBufferArrayNonUniformIndexing;
	public VkBool32 ShaderStorageTexelBufferArrayNonUniformIndexing;
	public VkBool32 DescriptorBindingUniformBufferUpdateAfterBind;
	public VkBool32 DescriptorBindingSampledImageUpdateAfterBind;
	public VkBool32 DescriptorBindingStorageImageUpdateAfterBind;
	public VkBool32 DescriptorBindingStorageBufferUpdateAfterBind;
	public VkBool32 DescriptorBindingUniformTexelBufferUpdateAfterBind;
	public VkBool32 DescriptorBindingStorageTexelBufferUpdateAfterBind;
	public VkBool32 DescriptorBindingUpdateUnusedWhilePending;
	public VkBool32 DescriptorBindingPartiallyBound;
	public VkBool32 DescriptorBindingVariableDescriptorCount;
	public VkBool32 RuntimeDescriptorArray;
	public VkBool32 SamplerFilterMinmax;
	public VkBool32 ScalarBlockLayout;
	public VkBool32 ImagelessFramebuffer;
	public VkBool32 UniformBufferStandardLayout;
	public VkBool32 ShaderSubgroupExtendedTypes;
	public VkBool32 SeparateDepthStencilLayouts;
	public VkBool32 HostQueryReset;
	public VkBool32 TimelineSemaphore;
	public VkBool32 BufferDeviceAddress;
	public VkBool32 BufferDeviceAddressCaptureReplay;
	public VkBool32 BufferDeviceAddressMultiDevice;
	public VkBool32 VulkanMemoryModel;
	public VkBool32 VulkanMemoryModelDeviceScope;
	public VkBool32 VulkanMemoryModelAvailabilityVisibilityChains;
	public VkBool32 ShaderOutputViewportIndex;
	public VkBool32 ShaderOutputLayer;
	public VkBool32 SubgroupBroadcastDynamicId;

	public VkPhysicalDeviceVulkan12Features(
		VkBool32 samplerMirrorClampToEdge = default,
		VkBool32 drawIndirectCount = default,
		VkBool32 storageBuffer8BitAccess = default,
		VkBool32 uniformAndStorageBuffer8BitAccess = default,
		VkBool32 storagePushConstant8 = default,
		VkBool32 shaderBufferInt64Atomics = default,
		VkBool32 shaderSharedInt64Atomics = default,
		VkBool32 shaderFloat16 = default,
		VkBool32 shaderInt8 = default,
		VkBool32 descriptorIndexing = default,
		VkBool32 shaderInputAttachmentArrayDynamicIndexing = default,
		VkBool32 shaderUniformTexelBufferArrayDynamicIndexing = default,
		VkBool32 shaderStorageTexelBufferArrayDynamicIndexing = default,
		VkBool32 shaderUniformBufferArrayNonUniformIndexing = default,
		VkBool32 shaderSampledImageArrayNonUniformIndexing = default,
		VkBool32 shaderStorageBufferArrayNonUniformIndexing = default,
		VkBool32 shaderStorageImageArrayNonUniformIndexing = default,
		VkBool32 shaderInputAttachmentArrayNonUniformIndexing = default,
		VkBool32 shaderUniformTexelBufferArrayNonUniformIndexing = default,
		VkBool32 shaderStorageTexelBufferArrayNonUniformIndexing = default,
		VkBool32 descriptorBindingUniformBufferUpdateAfterBind = default,
		VkBool32 descriptorBindingSampledImageUpdateAfterBind = default,
		VkBool32 descriptorBindingStorageImageUpdateAfterBind = default,
		VkBool32 descriptorBindingStorageBufferUpdateAfterBind = default,
		VkBool32 descriptorBindingUniformTexelBufferUpdateAfterBind = default,
		VkBool32 descriptorBindingStorageTexelBufferUpdateAfterBind = default,
		VkBool32 descriptorBindingUpdateUnusedWhilePending = default,
		VkBool32 descriptorBindingPartiallyBound = default,
		VkBool32 descriptorBindingVariableDescriptorCount = default,
		VkBool32 runtimeDescriptorArray = default,
		VkBool32 samplerFilterMinmax = default,
		VkBool32 scalarBlockLayout = default,
		VkBool32 imagelessFramebuffer = default,
		VkBool32 uniformBufferStandardLayout = default,
		VkBool32 shaderSubgroupExtendedTypes = default,
		VkBool32 separateDepthStencilLayouts = default,
		VkBool32 hostQueryReset = default,
		VkBool32 timelineSemaphore = default,
		VkBool32 bufferDeviceAddress = default,
		VkBool32 bufferDeviceAddressCaptureReplay = default,
		VkBool32 bufferDeviceAddressMultiDevice = default,
		VkBool32 vulkanMemoryModel = default,
		VkBool32 vulkanMemoryModelDeviceScope = default,
		VkBool32 vulkanMemoryModelAvailabilityVisibilityChains = default,
		VkBool32 shaderOutputViewportIndex = default,
		VkBool32 shaderOutputLayer = default,
		VkBool32 subgroupBroadcastDynamicId = default
	) {
		sType = TYPE;
		pNext = null;
		SamplerMirrorClampToEdge = samplerMirrorClampToEdge;
		DrawIndirectCount = drawIndirectCount;
		StorageBuffer8BitAccess = storageBuffer8BitAccess;
		UniformAndStorageBuffer8BitAccess = uniformAndStorageBuffer8BitAccess;
		StoragePushConstant8 = storagePushConstant8;
		ShaderBufferInt64Atomics = shaderBufferInt64Atomics;
		ShaderSharedInt64Atomics = shaderSharedInt64Atomics;
		ShaderFloat16 = shaderFloat16;
		ShaderInt8 = shaderInt8;
		DescriptorIndexing = descriptorIndexing;
		ShaderInputAttachmentArrayDynamicIndexing = shaderInputAttachmentArrayDynamicIndexing;
		ShaderUniformTexelBufferArrayDynamicIndexing = shaderUniformTexelBufferArrayDynamicIndexing;
		ShaderStorageTexelBufferArrayDynamicIndexing = shaderStorageTexelBufferArrayDynamicIndexing;
		ShaderUniformBufferArrayNonUniformIndexing = shaderUniformBufferArrayNonUniformIndexing;
		ShaderSampledImageArrayNonUniformIndexing = shaderSampledImageArrayNonUniformIndexing;
		ShaderStorageBufferArrayNonUniformIndexing = shaderStorageBufferArrayNonUniformIndexing;
		ShaderStorageImageArrayNonUniformIndexing = shaderStorageImageArrayNonUniformIndexing;
		ShaderInputAttachmentArrayNonUniformIndexing = shaderInputAttachmentArrayNonUniformIndexing;
		ShaderUniformTexelBufferArrayNonUniformIndexing = shaderUniformTexelBufferArrayNonUniformIndexing;
		ShaderStorageTexelBufferArrayNonUniformIndexing = shaderStorageTexelBufferArrayNonUniformIndexing;
		DescriptorBindingUniformBufferUpdateAfterBind = descriptorBindingUniformBufferUpdateAfterBind;
		DescriptorBindingSampledImageUpdateAfterBind = descriptorBindingSampledImageUpdateAfterBind;
		DescriptorBindingStorageImageUpdateAfterBind = descriptorBindingStorageImageUpdateAfterBind;
		DescriptorBindingStorageBufferUpdateAfterBind = descriptorBindingStorageBufferUpdateAfterBind;
		DescriptorBindingUniformTexelBufferUpdateAfterBind = descriptorBindingUniformTexelBufferUpdateAfterBind;
		DescriptorBindingStorageTexelBufferUpdateAfterBind = descriptorBindingStorageTexelBufferUpdateAfterBind;
		DescriptorBindingUpdateUnusedWhilePending = descriptorBindingUpdateUnusedWhilePending;
		DescriptorBindingPartiallyBound = descriptorBindingPartiallyBound;
		DescriptorBindingVariableDescriptorCount = descriptorBindingVariableDescriptorCount;
		RuntimeDescriptorArray = runtimeDescriptorArray;
		SamplerFilterMinmax = samplerFilterMinmax;
		ScalarBlockLayout = scalarBlockLayout;
		ImagelessFramebuffer = imagelessFramebuffer;
		UniformBufferStandardLayout = uniformBufferStandardLayout;
		ShaderSubgroupExtendedTypes = shaderSubgroupExtendedTypes;
		SeparateDepthStencilLayouts = separateDepthStencilLayouts;
		HostQueryReset = hostQueryReset;
		TimelineSemaphore = timelineSemaphore;
		BufferDeviceAddress = bufferDeviceAddress;
		BufferDeviceAddressCaptureReplay = bufferDeviceAddressCaptureReplay;
		BufferDeviceAddressMultiDevice = bufferDeviceAddressMultiDevice;
		VulkanMemoryModel = vulkanMemoryModel;
		VulkanMemoryModelDeviceScope = vulkanMemoryModelDeviceScope;
		VulkanMemoryModelAvailabilityVisibilityChains = vulkanMemoryModelAvailabilityVisibilityChains;
		ShaderOutputViewportIndex = shaderOutputViewportIndex;
		ShaderOutputLayer = shaderOutputLayer;
		SubgroupBroadcastDynamicId = subgroupBroadcastDynamicId;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceVulkan12Features s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceVulkan12Features>.Equals(VkPhysicalDeviceVulkan12Features o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SamplerMirrorClampToEdge.GetHashCode() ^ DrawIndirectCount.GetHashCode()
			^ StorageBuffer8BitAccess.GetHashCode() ^ UniformAndStorageBuffer8BitAccess.GetHashCode() ^ StoragePushConstant8.GetHashCode() ^ ShaderBufferInt64Atomics.GetHashCode()
			^ ShaderSharedInt64Atomics.GetHashCode() ^ ShaderFloat16.GetHashCode() ^ ShaderInt8.GetHashCode() ^ DescriptorIndexing.GetHashCode()
			^ ShaderInputAttachmentArrayDynamicIndexing.GetHashCode() ^ ShaderUniformTexelBufferArrayDynamicIndexing.GetHashCode() ^ ShaderStorageTexelBufferArrayDynamicIndexing.GetHashCode() ^ ShaderUniformBufferArrayNonUniformIndexing.GetHashCode()
			^ ShaderSampledImageArrayNonUniformIndexing.GetHashCode() ^ ShaderStorageBufferArrayNonUniformIndexing.GetHashCode() ^ ShaderStorageImageArrayNonUniformIndexing.GetHashCode() ^ ShaderInputAttachmentArrayNonUniformIndexing.GetHashCode()
			^ ShaderUniformTexelBufferArrayNonUniformIndexing.GetHashCode() ^ ShaderStorageTexelBufferArrayNonUniformIndexing.GetHashCode() ^ DescriptorBindingUniformBufferUpdateAfterBind.GetHashCode() ^ DescriptorBindingSampledImageUpdateAfterBind.GetHashCode()
			^ DescriptorBindingStorageImageUpdateAfterBind.GetHashCode() ^ DescriptorBindingStorageBufferUpdateAfterBind.GetHashCode() ^ DescriptorBindingUniformTexelBufferUpdateAfterBind.GetHashCode() ^ DescriptorBindingStorageTexelBufferUpdateAfterBind.GetHashCode()
			^ DescriptorBindingUpdateUnusedWhilePending.GetHashCode() ^ DescriptorBindingPartiallyBound.GetHashCode() ^ DescriptorBindingVariableDescriptorCount.GetHashCode() ^ RuntimeDescriptorArray.GetHashCode()
			^ SamplerFilterMinmax.GetHashCode() ^ ScalarBlockLayout.GetHashCode() ^ ImagelessFramebuffer.GetHashCode() ^ UniformBufferStandardLayout.GetHashCode()
			^ ShaderSubgroupExtendedTypes.GetHashCode() ^ SeparateDepthStencilLayouts.GetHashCode() ^ HostQueryReset.GetHashCode() ^ TimelineSemaphore.GetHashCode()
			^ BufferDeviceAddress.GetHashCode() ^ BufferDeviceAddressCaptureReplay.GetHashCode() ^ BufferDeviceAddressMultiDevice.GetHashCode() ^ VulkanMemoryModel.GetHashCode()
			^ VulkanMemoryModelDeviceScope.GetHashCode() ^ VulkanMemoryModelAvailabilityVisibilityChains.GetHashCode() ^ ShaderOutputViewportIndex.GetHashCode() ^ ShaderOutputLayer.GetHashCode()
			^ SubgroupBroadcastDynamicId.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceVulkan12Features l, in VkPhysicalDeviceVulkan12Features r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SamplerMirrorClampToEdge == r.SamplerMirrorClampToEdge) && (l.DrawIndirectCount == r.DrawIndirectCount)
			&& (l.StorageBuffer8BitAccess == r.StorageBuffer8BitAccess) && (l.UniformAndStorageBuffer8BitAccess == r.UniformAndStorageBuffer8BitAccess) && (l.StoragePushConstant8 == r.StoragePushConstant8) && (l.ShaderBufferInt64Atomics == r.ShaderBufferInt64Atomics)
			&& (l.ShaderSharedInt64Atomics == r.ShaderSharedInt64Atomics) && (l.ShaderFloat16 == r.ShaderFloat16) && (l.ShaderInt8 == r.ShaderInt8) && (l.DescriptorIndexing == r.DescriptorIndexing)
			&& (l.ShaderInputAttachmentArrayDynamicIndexing == r.ShaderInputAttachmentArrayDynamicIndexing) && (l.ShaderUniformTexelBufferArrayDynamicIndexing == r.ShaderUniformTexelBufferArrayDynamicIndexing) && (l.ShaderStorageTexelBufferArrayDynamicIndexing == r.ShaderStorageTexelBufferArrayDynamicIndexing) && (l.ShaderUniformBufferArrayNonUniformIndexing == r.ShaderUniformBufferArrayNonUniformIndexing)
			&& (l.ShaderSampledImageArrayNonUniformIndexing == r.ShaderSampledImageArrayNonUniformIndexing) && (l.ShaderStorageBufferArrayNonUniformIndexing == r.ShaderStorageBufferArrayNonUniformIndexing) && (l.ShaderStorageImageArrayNonUniformIndexing == r.ShaderStorageImageArrayNonUniformIndexing) && (l.ShaderInputAttachmentArrayNonUniformIndexing == r.ShaderInputAttachmentArrayNonUniformIndexing)
			&& (l.ShaderUniformTexelBufferArrayNonUniformIndexing == r.ShaderUniformTexelBufferArrayNonUniformIndexing) && (l.ShaderStorageTexelBufferArrayNonUniformIndexing == r.ShaderStorageTexelBufferArrayNonUniformIndexing) && (l.DescriptorBindingUniformBufferUpdateAfterBind == r.DescriptorBindingUniformBufferUpdateAfterBind) && (l.DescriptorBindingSampledImageUpdateAfterBind == r.DescriptorBindingSampledImageUpdateAfterBind)
			&& (l.DescriptorBindingStorageImageUpdateAfterBind == r.DescriptorBindingStorageImageUpdateAfterBind) && (l.DescriptorBindingStorageBufferUpdateAfterBind == r.DescriptorBindingStorageBufferUpdateAfterBind) && (l.DescriptorBindingUniformTexelBufferUpdateAfterBind == r.DescriptorBindingUniformTexelBufferUpdateAfterBind) && (l.DescriptorBindingStorageTexelBufferUpdateAfterBind == r.DescriptorBindingStorageTexelBufferUpdateAfterBind)
			&& (l.DescriptorBindingUpdateUnusedWhilePending == r.DescriptorBindingUpdateUnusedWhilePending) && (l.DescriptorBindingPartiallyBound == r.DescriptorBindingPartiallyBound) && (l.DescriptorBindingVariableDescriptorCount == r.DescriptorBindingVariableDescriptorCount) && (l.RuntimeDescriptorArray == r.RuntimeDescriptorArray)
			&& (l.SamplerFilterMinmax == r.SamplerFilterMinmax) && (l.ScalarBlockLayout == r.ScalarBlockLayout) && (l.ImagelessFramebuffer == r.ImagelessFramebuffer) && (l.UniformBufferStandardLayout == r.UniformBufferStandardLayout)
			&& (l.ShaderSubgroupExtendedTypes == r.ShaderSubgroupExtendedTypes) && (l.SeparateDepthStencilLayouts == r.SeparateDepthStencilLayouts) && (l.HostQueryReset == r.HostQueryReset) && (l.TimelineSemaphore == r.TimelineSemaphore)
			&& (l.BufferDeviceAddress == r.BufferDeviceAddress) && (l.BufferDeviceAddressCaptureReplay == r.BufferDeviceAddressCaptureReplay) && (l.BufferDeviceAddressMultiDevice == r.BufferDeviceAddressMultiDevice) && (l.VulkanMemoryModel == r.VulkanMemoryModel)
			&& (l.VulkanMemoryModelDeviceScope == r.VulkanMemoryModelDeviceScope) && (l.VulkanMemoryModelAvailabilityVisibilityChains == r.VulkanMemoryModelAvailabilityVisibilityChains) && (l.ShaderOutputViewportIndex == r.ShaderOutputViewportIndex) && (l.ShaderOutputLayer == r.ShaderOutputLayer)
			&& (l.SubgroupBroadcastDynamicId == r.SubgroupBroadcastDynamicId)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceVulkan12Features l, in VkPhysicalDeviceVulkan12Features r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SamplerMirrorClampToEdge != r.SamplerMirrorClampToEdge) || (l.DrawIndirectCount != r.DrawIndirectCount)
			|| (l.StorageBuffer8BitAccess != r.StorageBuffer8BitAccess) || (l.UniformAndStorageBuffer8BitAccess != r.UniformAndStorageBuffer8BitAccess) || (l.StoragePushConstant8 != r.StoragePushConstant8) || (l.ShaderBufferInt64Atomics != r.ShaderBufferInt64Atomics)
			|| (l.ShaderSharedInt64Atomics != r.ShaderSharedInt64Atomics) || (l.ShaderFloat16 != r.ShaderFloat16) || (l.ShaderInt8 != r.ShaderInt8) || (l.DescriptorIndexing != r.DescriptorIndexing)
			|| (l.ShaderInputAttachmentArrayDynamicIndexing != r.ShaderInputAttachmentArrayDynamicIndexing) || (l.ShaderUniformTexelBufferArrayDynamicIndexing != r.ShaderUniformTexelBufferArrayDynamicIndexing) || (l.ShaderStorageTexelBufferArrayDynamicIndexing != r.ShaderStorageTexelBufferArrayDynamicIndexing) || (l.ShaderUniformBufferArrayNonUniformIndexing != r.ShaderUniformBufferArrayNonUniformIndexing)
			|| (l.ShaderSampledImageArrayNonUniformIndexing != r.ShaderSampledImageArrayNonUniformIndexing) || (l.ShaderStorageBufferArrayNonUniformIndexing != r.ShaderStorageBufferArrayNonUniformIndexing) || (l.ShaderStorageImageArrayNonUniformIndexing != r.ShaderStorageImageArrayNonUniformIndexing) || (l.ShaderInputAttachmentArrayNonUniformIndexing != r.ShaderInputAttachmentArrayNonUniformIndexing)
			|| (l.ShaderUniformTexelBufferArrayNonUniformIndexing != r.ShaderUniformTexelBufferArrayNonUniformIndexing) || (l.ShaderStorageTexelBufferArrayNonUniformIndexing != r.ShaderStorageTexelBufferArrayNonUniformIndexing) || (l.DescriptorBindingUniformBufferUpdateAfterBind != r.DescriptorBindingUniformBufferUpdateAfterBind) || (l.DescriptorBindingSampledImageUpdateAfterBind != r.DescriptorBindingSampledImageUpdateAfterBind)
			|| (l.DescriptorBindingStorageImageUpdateAfterBind != r.DescriptorBindingStorageImageUpdateAfterBind) || (l.DescriptorBindingStorageBufferUpdateAfterBind != r.DescriptorBindingStorageBufferUpdateAfterBind) || (l.DescriptorBindingUniformTexelBufferUpdateAfterBind != r.DescriptorBindingUniformTexelBufferUpdateAfterBind) || (l.DescriptorBindingStorageTexelBufferUpdateAfterBind != r.DescriptorBindingStorageTexelBufferUpdateAfterBind)
			|| (l.DescriptorBindingUpdateUnusedWhilePending != r.DescriptorBindingUpdateUnusedWhilePending) || (l.DescriptorBindingPartiallyBound != r.DescriptorBindingPartiallyBound) || (l.DescriptorBindingVariableDescriptorCount != r.DescriptorBindingVariableDescriptorCount) || (l.RuntimeDescriptorArray != r.RuntimeDescriptorArray)
			|| (l.SamplerFilterMinmax != r.SamplerFilterMinmax) || (l.ScalarBlockLayout != r.ScalarBlockLayout) || (l.ImagelessFramebuffer != r.ImagelessFramebuffer) || (l.UniformBufferStandardLayout != r.UniformBufferStandardLayout)
			|| (l.ShaderSubgroupExtendedTypes != r.ShaderSubgroupExtendedTypes) || (l.SeparateDepthStencilLayouts != r.SeparateDepthStencilLayouts) || (l.HostQueryReset != r.HostQueryReset) || (l.TimelineSemaphore != r.TimelineSemaphore)
			|| (l.BufferDeviceAddress != r.BufferDeviceAddress) || (l.BufferDeviceAddressCaptureReplay != r.BufferDeviceAddressCaptureReplay) || (l.BufferDeviceAddressMultiDevice != r.BufferDeviceAddressMultiDevice) || (l.VulkanMemoryModel != r.VulkanMemoryModel)
			|| (l.VulkanMemoryModelDeviceScope != r.VulkanMemoryModelDeviceScope) || (l.VulkanMemoryModelAvailabilityVisibilityChains != r.VulkanMemoryModelAvailabilityVisibilityChains) || (l.ShaderOutputViewportIndex != r.ShaderOutputViewportIndex) || (l.ShaderOutputLayer != r.ShaderOutputLayer)
			|| (l.SubgroupBroadcastDynamicId != r.SubgroupBroadcastDynamicId)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceVulkan12Features s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceVulkan12Properties : IEquatable<VkPhysicalDeviceVulkan12Properties>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceVulkan12Properties;

	public VkStructureType sType;
	public void* pNext;
	public VkDriverId DriverID;
	public VVK.DriverName DriverName;
	public VVK.DriverInfo DriverInfo;
	public VkConformanceVersion ConformanceVersion;
	public VkShaderFloatControlsIndependence DenormBehaviorIndependence;
	public VkShaderFloatControlsIndependence RoundingModeIndependence;
	public VkBool32 ShaderSignedZeroInfNanPreserveFloat16;
	public VkBool32 ShaderSignedZeroInfNanPreserveFloat32;
	public VkBool32 ShaderSignedZeroInfNanPreserveFloat64;
	public VkBool32 ShaderDenormPreserveFloat16;
	public VkBool32 ShaderDenormPreserveFloat32;
	public VkBool32 ShaderDenormPreserveFloat64;
	public VkBool32 ShaderDenormFlushToZeroFloat16;
	public VkBool32 ShaderDenormFlushToZeroFloat32;
	public VkBool32 ShaderDenormFlushToZeroFloat64;
	public VkBool32 ShaderRoundingModeRTEFloat16;
	public VkBool32 ShaderRoundingModeRTEFloat32;
	public VkBool32 ShaderRoundingModeRTEFloat64;
	public VkBool32 ShaderRoundingModeRTZFloat16;
	public VkBool32 ShaderRoundingModeRTZFloat32;
	public VkBool32 ShaderRoundingModeRTZFloat64;
	public uint MaxUpdateAfterBindDescriptorsInAllPools;
	public VkBool32 ShaderUniformBufferArrayNonUniformIndexingNative;
	public VkBool32 ShaderSampledImageArrayNonUniformIndexingNative;
	public VkBool32 ShaderStorageBufferArrayNonUniformIndexingNative;
	public VkBool32 ShaderStorageImageArrayNonUniformIndexingNative;
	public VkBool32 ShaderInputAttachmentArrayNonUniformIndexingNative;
	public VkBool32 RobustBufferAccessUpdateAfterBind;
	public VkBool32 QuadDivergentImplicitLod;
	public uint MaxPerStageDescriptorUpdateAfterBindSamplers;
	public uint MaxPerStageDescriptorUpdateAfterBindUniformBuffers;
	public uint MaxPerStageDescriptorUpdateAfterBindStorageBuffers;
	public uint MaxPerStageDescriptorUpdateAfterBindSampledImages;
	public uint MaxPerStageDescriptorUpdateAfterBindStorageImages;
	public uint MaxPerStageDescriptorUpdateAfterBindInputAttachments;
	public uint MaxPerStageUpdateAfterBindResources;
	public uint MaxDescriptorSetUpdateAfterBindSamplers;
	public uint MaxDescriptorSetUpdateAfterBindUniformBuffers;
	public uint MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic;
	public uint MaxDescriptorSetUpdateAfterBindStorageBuffers;
	public uint MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic;
	public uint MaxDescriptorSetUpdateAfterBindSampledImages;
	public uint MaxDescriptorSetUpdateAfterBindStorageImages;
	public uint MaxDescriptorSetUpdateAfterBindInputAttachments;
	public VkResolveModeFlags SupportedDepthResolveModes;
	public VkResolveModeFlags SupportedStencilResolveModes;
	public VkBool32 IndependentResolveNone;
	public VkBool32 IndependentResolve;
	public VkBool32 FilterMinmaxSingleComponentFormats;
	public VkBool32 FilterMinmaxImageComponentMapping;
	public ulong MaxTimelineSemaphoreValueDifference;
	public VkSampleCountFlags FramebufferIntegerColorSampleCounts;

	public VkPhysicalDeviceVulkan12Properties(
		VkDriverId driverID = default,
		VVK.DriverName driverName = default,
		VVK.DriverInfo driverInfo = default,
		VkConformanceVersion conformanceVersion = default,
		VkShaderFloatControlsIndependence denormBehaviorIndependence = default,
		VkShaderFloatControlsIndependence roundingModeIndependence = default,
		VkBool32 shaderSignedZeroInfNanPreserveFloat16 = default,
		VkBool32 shaderSignedZeroInfNanPreserveFloat32 = default,
		VkBool32 shaderSignedZeroInfNanPreserveFloat64 = default,
		VkBool32 shaderDenormPreserveFloat16 = default,
		VkBool32 shaderDenormPreserveFloat32 = default,
		VkBool32 shaderDenormPreserveFloat64 = default,
		VkBool32 shaderDenormFlushToZeroFloat16 = default,
		VkBool32 shaderDenormFlushToZeroFloat32 = default,
		VkBool32 shaderDenormFlushToZeroFloat64 = default,
		VkBool32 shaderRoundingModeRTEFloat16 = default,
		VkBool32 shaderRoundingModeRTEFloat32 = default,
		VkBool32 shaderRoundingModeRTEFloat64 = default,
		VkBool32 shaderRoundingModeRTZFloat16 = default,
		VkBool32 shaderRoundingModeRTZFloat32 = default,
		VkBool32 shaderRoundingModeRTZFloat64 = default,
		uint maxUpdateAfterBindDescriptorsInAllPools = default,
		VkBool32 shaderUniformBufferArrayNonUniformIndexingNative = default,
		VkBool32 shaderSampledImageArrayNonUniformIndexingNative = default,
		VkBool32 shaderStorageBufferArrayNonUniformIndexingNative = default,
		VkBool32 shaderStorageImageArrayNonUniformIndexingNative = default,
		VkBool32 shaderInputAttachmentArrayNonUniformIndexingNative = default,
		VkBool32 robustBufferAccessUpdateAfterBind = default,
		VkBool32 quadDivergentImplicitLod = default,
		uint maxPerStageDescriptorUpdateAfterBindSamplers = default,
		uint maxPerStageDescriptorUpdateAfterBindUniformBuffers = default,
		uint maxPerStageDescriptorUpdateAfterBindStorageBuffers = default,
		uint maxPerStageDescriptorUpdateAfterBindSampledImages = default,
		uint maxPerStageDescriptorUpdateAfterBindStorageImages = default,
		uint maxPerStageDescriptorUpdateAfterBindInputAttachments = default,
		uint maxPerStageUpdateAfterBindResources = default,
		uint maxDescriptorSetUpdateAfterBindSamplers = default,
		uint maxDescriptorSetUpdateAfterBindUniformBuffers = default,
		uint maxDescriptorSetUpdateAfterBindUniformBuffersDynamic = default,
		uint maxDescriptorSetUpdateAfterBindStorageBuffers = default,
		uint maxDescriptorSetUpdateAfterBindStorageBuffersDynamic = default,
		uint maxDescriptorSetUpdateAfterBindSampledImages = default,
		uint maxDescriptorSetUpdateAfterBindStorageImages = default,
		uint maxDescriptorSetUpdateAfterBindInputAttachments = default,
		VkResolveModeFlags supportedDepthResolveModes = default,
		VkResolveModeFlags supportedStencilResolveModes = default,
		VkBool32 independentResolveNone = default,
		VkBool32 independentResolve = default,
		VkBool32 filterMinmaxSingleComponentFormats = default,
		VkBool32 filterMinmaxImageComponentMapping = default,
		ulong maxTimelineSemaphoreValueDifference = default,
		VkSampleCountFlags framebufferIntegerColorSampleCounts = default
	) {
		sType = TYPE;
		pNext = null;
		DriverID = driverID;
		DriverName = driverName;
		DriverInfo = driverInfo;
		ConformanceVersion = conformanceVersion;
		DenormBehaviorIndependence = denormBehaviorIndependence;
		RoundingModeIndependence = roundingModeIndependence;
		ShaderSignedZeroInfNanPreserveFloat16 = shaderSignedZeroInfNanPreserveFloat16;
		ShaderSignedZeroInfNanPreserveFloat32 = shaderSignedZeroInfNanPreserveFloat32;
		ShaderSignedZeroInfNanPreserveFloat64 = shaderSignedZeroInfNanPreserveFloat64;
		ShaderDenormPreserveFloat16 = shaderDenormPreserveFloat16;
		ShaderDenormPreserveFloat32 = shaderDenormPreserveFloat32;
		ShaderDenormPreserveFloat64 = shaderDenormPreserveFloat64;
		ShaderDenormFlushToZeroFloat16 = shaderDenormFlushToZeroFloat16;
		ShaderDenormFlushToZeroFloat32 = shaderDenormFlushToZeroFloat32;
		ShaderDenormFlushToZeroFloat64 = shaderDenormFlushToZeroFloat64;
		ShaderRoundingModeRTEFloat16 = shaderRoundingModeRTEFloat16;
		ShaderRoundingModeRTEFloat32 = shaderRoundingModeRTEFloat32;
		ShaderRoundingModeRTEFloat64 = shaderRoundingModeRTEFloat64;
		ShaderRoundingModeRTZFloat16 = shaderRoundingModeRTZFloat16;
		ShaderRoundingModeRTZFloat32 = shaderRoundingModeRTZFloat32;
		ShaderRoundingModeRTZFloat64 = shaderRoundingModeRTZFloat64;
		MaxUpdateAfterBindDescriptorsInAllPools = maxUpdateAfterBindDescriptorsInAllPools;
		ShaderUniformBufferArrayNonUniformIndexingNative = shaderUniformBufferArrayNonUniformIndexingNative;
		ShaderSampledImageArrayNonUniformIndexingNative = shaderSampledImageArrayNonUniformIndexingNative;
		ShaderStorageBufferArrayNonUniformIndexingNative = shaderStorageBufferArrayNonUniformIndexingNative;
		ShaderStorageImageArrayNonUniformIndexingNative = shaderStorageImageArrayNonUniformIndexingNative;
		ShaderInputAttachmentArrayNonUniformIndexingNative = shaderInputAttachmentArrayNonUniformIndexingNative;
		RobustBufferAccessUpdateAfterBind = robustBufferAccessUpdateAfterBind;
		QuadDivergentImplicitLod = quadDivergentImplicitLod;
		MaxPerStageDescriptorUpdateAfterBindSamplers = maxPerStageDescriptorUpdateAfterBindSamplers;
		MaxPerStageDescriptorUpdateAfterBindUniformBuffers = maxPerStageDescriptorUpdateAfterBindUniformBuffers;
		MaxPerStageDescriptorUpdateAfterBindStorageBuffers = maxPerStageDescriptorUpdateAfterBindStorageBuffers;
		MaxPerStageDescriptorUpdateAfterBindSampledImages = maxPerStageDescriptorUpdateAfterBindSampledImages;
		MaxPerStageDescriptorUpdateAfterBindStorageImages = maxPerStageDescriptorUpdateAfterBindStorageImages;
		MaxPerStageDescriptorUpdateAfterBindInputAttachments = maxPerStageDescriptorUpdateAfterBindInputAttachments;
		MaxPerStageUpdateAfterBindResources = maxPerStageUpdateAfterBindResources;
		MaxDescriptorSetUpdateAfterBindSamplers = maxDescriptorSetUpdateAfterBindSamplers;
		MaxDescriptorSetUpdateAfterBindUniformBuffers = maxDescriptorSetUpdateAfterBindUniformBuffers;
		MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic = maxDescriptorSetUpdateAfterBindUniformBuffersDynamic;
		MaxDescriptorSetUpdateAfterBindStorageBuffers = maxDescriptorSetUpdateAfterBindStorageBuffers;
		MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic = maxDescriptorSetUpdateAfterBindStorageBuffersDynamic;
		MaxDescriptorSetUpdateAfterBindSampledImages = maxDescriptorSetUpdateAfterBindSampledImages;
		MaxDescriptorSetUpdateAfterBindStorageImages = maxDescriptorSetUpdateAfterBindStorageImages;
		MaxDescriptorSetUpdateAfterBindInputAttachments = maxDescriptorSetUpdateAfterBindInputAttachments;
		SupportedDepthResolveModes = supportedDepthResolveModes;
		SupportedStencilResolveModes = supportedStencilResolveModes;
		IndependentResolveNone = independentResolveNone;
		IndependentResolve = independentResolve;
		FilterMinmaxSingleComponentFormats = filterMinmaxSingleComponentFormats;
		FilterMinmaxImageComponentMapping = filterMinmaxImageComponentMapping;
		MaxTimelineSemaphoreValueDifference = maxTimelineSemaphoreValueDifference;
		FramebufferIntegerColorSampleCounts = framebufferIntegerColorSampleCounts;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceVulkan12Properties s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceVulkan12Properties>.Equals(VkPhysicalDeviceVulkan12Properties o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DriverID.GetHashCode() ^ DriverName.GetHashCode()
			^ DriverInfo.GetHashCode() ^ ConformanceVersion.GetHashCode() ^ DenormBehaviorIndependence.GetHashCode() ^ RoundingModeIndependence.GetHashCode()
			^ ShaderSignedZeroInfNanPreserveFloat16.GetHashCode() ^ ShaderSignedZeroInfNanPreserveFloat32.GetHashCode() ^ ShaderSignedZeroInfNanPreserveFloat64.GetHashCode() ^ ShaderDenormPreserveFloat16.GetHashCode()
			^ ShaderDenormPreserveFloat32.GetHashCode() ^ ShaderDenormPreserveFloat64.GetHashCode() ^ ShaderDenormFlushToZeroFloat16.GetHashCode() ^ ShaderDenormFlushToZeroFloat32.GetHashCode()
			^ ShaderDenormFlushToZeroFloat64.GetHashCode() ^ ShaderRoundingModeRTEFloat16.GetHashCode() ^ ShaderRoundingModeRTEFloat32.GetHashCode() ^ ShaderRoundingModeRTEFloat64.GetHashCode()
			^ ShaderRoundingModeRTZFloat16.GetHashCode() ^ ShaderRoundingModeRTZFloat32.GetHashCode() ^ ShaderRoundingModeRTZFloat64.GetHashCode() ^ MaxUpdateAfterBindDescriptorsInAllPools.GetHashCode()
			^ ShaderUniformBufferArrayNonUniformIndexingNative.GetHashCode() ^ ShaderSampledImageArrayNonUniformIndexingNative.GetHashCode() ^ ShaderStorageBufferArrayNonUniformIndexingNative.GetHashCode() ^ ShaderStorageImageArrayNonUniformIndexingNative.GetHashCode()
			^ ShaderInputAttachmentArrayNonUniformIndexingNative.GetHashCode() ^ RobustBufferAccessUpdateAfterBind.GetHashCode() ^ QuadDivergentImplicitLod.GetHashCode() ^ MaxPerStageDescriptorUpdateAfterBindSamplers.GetHashCode()
			^ MaxPerStageDescriptorUpdateAfterBindUniformBuffers.GetHashCode() ^ MaxPerStageDescriptorUpdateAfterBindStorageBuffers.GetHashCode() ^ MaxPerStageDescriptorUpdateAfterBindSampledImages.GetHashCode() ^ MaxPerStageDescriptorUpdateAfterBindStorageImages.GetHashCode()
			^ MaxPerStageDescriptorUpdateAfterBindInputAttachments.GetHashCode() ^ MaxPerStageUpdateAfterBindResources.GetHashCode() ^ MaxDescriptorSetUpdateAfterBindSamplers.GetHashCode() ^ MaxDescriptorSetUpdateAfterBindUniformBuffers.GetHashCode()
			^ MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic.GetHashCode() ^ MaxDescriptorSetUpdateAfterBindStorageBuffers.GetHashCode() ^ MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic.GetHashCode() ^ MaxDescriptorSetUpdateAfterBindSampledImages.GetHashCode()
			^ MaxDescriptorSetUpdateAfterBindStorageImages.GetHashCode() ^ MaxDescriptorSetUpdateAfterBindInputAttachments.GetHashCode() ^ SupportedDepthResolveModes.GetHashCode() ^ SupportedStencilResolveModes.GetHashCode()
			^ IndependentResolveNone.GetHashCode() ^ IndependentResolve.GetHashCode() ^ FilterMinmaxSingleComponentFormats.GetHashCode() ^ FilterMinmaxImageComponentMapping.GetHashCode()
			^ MaxTimelineSemaphoreValueDifference.GetHashCode() ^ FramebufferIntegerColorSampleCounts.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceVulkan12Properties l, in VkPhysicalDeviceVulkan12Properties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DriverID == r.DriverID) && (l.DriverName == r.DriverName)
			&& (l.DriverInfo == r.DriverInfo) && (l.ConformanceVersion == r.ConformanceVersion) && (l.DenormBehaviorIndependence == r.DenormBehaviorIndependence) && (l.RoundingModeIndependence == r.RoundingModeIndependence)
			&& (l.ShaderSignedZeroInfNanPreserveFloat16 == r.ShaderSignedZeroInfNanPreserveFloat16) && (l.ShaderSignedZeroInfNanPreserveFloat32 == r.ShaderSignedZeroInfNanPreserveFloat32) && (l.ShaderSignedZeroInfNanPreserveFloat64 == r.ShaderSignedZeroInfNanPreserveFloat64) && (l.ShaderDenormPreserveFloat16 == r.ShaderDenormPreserveFloat16)
			&& (l.ShaderDenormPreserveFloat32 == r.ShaderDenormPreserveFloat32) && (l.ShaderDenormPreserveFloat64 == r.ShaderDenormPreserveFloat64) && (l.ShaderDenormFlushToZeroFloat16 == r.ShaderDenormFlushToZeroFloat16) && (l.ShaderDenormFlushToZeroFloat32 == r.ShaderDenormFlushToZeroFloat32)
			&& (l.ShaderDenormFlushToZeroFloat64 == r.ShaderDenormFlushToZeroFloat64) && (l.ShaderRoundingModeRTEFloat16 == r.ShaderRoundingModeRTEFloat16) && (l.ShaderRoundingModeRTEFloat32 == r.ShaderRoundingModeRTEFloat32) && (l.ShaderRoundingModeRTEFloat64 == r.ShaderRoundingModeRTEFloat64)
			&& (l.ShaderRoundingModeRTZFloat16 == r.ShaderRoundingModeRTZFloat16) && (l.ShaderRoundingModeRTZFloat32 == r.ShaderRoundingModeRTZFloat32) && (l.ShaderRoundingModeRTZFloat64 == r.ShaderRoundingModeRTZFloat64) && (l.MaxUpdateAfterBindDescriptorsInAllPools == r.MaxUpdateAfterBindDescriptorsInAllPools)
			&& (l.ShaderUniformBufferArrayNonUniformIndexingNative == r.ShaderUniformBufferArrayNonUniformIndexingNative) && (l.ShaderSampledImageArrayNonUniformIndexingNative == r.ShaderSampledImageArrayNonUniformIndexingNative) && (l.ShaderStorageBufferArrayNonUniformIndexingNative == r.ShaderStorageBufferArrayNonUniformIndexingNative) && (l.ShaderStorageImageArrayNonUniformIndexingNative == r.ShaderStorageImageArrayNonUniformIndexingNative)
			&& (l.ShaderInputAttachmentArrayNonUniformIndexingNative == r.ShaderInputAttachmentArrayNonUniformIndexingNative) && (l.RobustBufferAccessUpdateAfterBind == r.RobustBufferAccessUpdateAfterBind) && (l.QuadDivergentImplicitLod == r.QuadDivergentImplicitLod) && (l.MaxPerStageDescriptorUpdateAfterBindSamplers == r.MaxPerStageDescriptorUpdateAfterBindSamplers)
			&& (l.MaxPerStageDescriptorUpdateAfterBindUniformBuffers == r.MaxPerStageDescriptorUpdateAfterBindUniformBuffers) && (l.MaxPerStageDescriptorUpdateAfterBindStorageBuffers == r.MaxPerStageDescriptorUpdateAfterBindStorageBuffers) && (l.MaxPerStageDescriptorUpdateAfterBindSampledImages == r.MaxPerStageDescriptorUpdateAfterBindSampledImages) && (l.MaxPerStageDescriptorUpdateAfterBindStorageImages == r.MaxPerStageDescriptorUpdateAfterBindStorageImages)
			&& (l.MaxPerStageDescriptorUpdateAfterBindInputAttachments == r.MaxPerStageDescriptorUpdateAfterBindInputAttachments) && (l.MaxPerStageUpdateAfterBindResources == r.MaxPerStageUpdateAfterBindResources) && (l.MaxDescriptorSetUpdateAfterBindSamplers == r.MaxDescriptorSetUpdateAfterBindSamplers) && (l.MaxDescriptorSetUpdateAfterBindUniformBuffers == r.MaxDescriptorSetUpdateAfterBindUniformBuffers)
			&& (l.MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic == r.MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic) && (l.MaxDescriptorSetUpdateAfterBindStorageBuffers == r.MaxDescriptorSetUpdateAfterBindStorageBuffers) && (l.MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic == r.MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic) && (l.MaxDescriptorSetUpdateAfterBindSampledImages == r.MaxDescriptorSetUpdateAfterBindSampledImages)
			&& (l.MaxDescriptorSetUpdateAfterBindStorageImages == r.MaxDescriptorSetUpdateAfterBindStorageImages) && (l.MaxDescriptorSetUpdateAfterBindInputAttachments == r.MaxDescriptorSetUpdateAfterBindInputAttachments) && (l.SupportedDepthResolveModes == r.SupportedDepthResolveModes) && (l.SupportedStencilResolveModes == r.SupportedStencilResolveModes)
			&& (l.IndependentResolveNone == r.IndependentResolveNone) && (l.IndependentResolve == r.IndependentResolve) && (l.FilterMinmaxSingleComponentFormats == r.FilterMinmaxSingleComponentFormats) && (l.FilterMinmaxImageComponentMapping == r.FilterMinmaxImageComponentMapping)
			&& (l.MaxTimelineSemaphoreValueDifference == r.MaxTimelineSemaphoreValueDifference) && (l.FramebufferIntegerColorSampleCounts == r.FramebufferIntegerColorSampleCounts)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceVulkan12Properties l, in VkPhysicalDeviceVulkan12Properties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DriverID != r.DriverID) || (l.DriverName != r.DriverName)
			|| (l.DriverInfo != r.DriverInfo) || (l.ConformanceVersion != r.ConformanceVersion) || (l.DenormBehaviorIndependence != r.DenormBehaviorIndependence) || (l.RoundingModeIndependence != r.RoundingModeIndependence)
			|| (l.ShaderSignedZeroInfNanPreserveFloat16 != r.ShaderSignedZeroInfNanPreserveFloat16) || (l.ShaderSignedZeroInfNanPreserveFloat32 != r.ShaderSignedZeroInfNanPreserveFloat32) || (l.ShaderSignedZeroInfNanPreserveFloat64 != r.ShaderSignedZeroInfNanPreserveFloat64) || (l.ShaderDenormPreserveFloat16 != r.ShaderDenormPreserveFloat16)
			|| (l.ShaderDenormPreserveFloat32 != r.ShaderDenormPreserveFloat32) || (l.ShaderDenormPreserveFloat64 != r.ShaderDenormPreserveFloat64) || (l.ShaderDenormFlushToZeroFloat16 != r.ShaderDenormFlushToZeroFloat16) || (l.ShaderDenormFlushToZeroFloat32 != r.ShaderDenormFlushToZeroFloat32)
			|| (l.ShaderDenormFlushToZeroFloat64 != r.ShaderDenormFlushToZeroFloat64) || (l.ShaderRoundingModeRTEFloat16 != r.ShaderRoundingModeRTEFloat16) || (l.ShaderRoundingModeRTEFloat32 != r.ShaderRoundingModeRTEFloat32) || (l.ShaderRoundingModeRTEFloat64 != r.ShaderRoundingModeRTEFloat64)
			|| (l.ShaderRoundingModeRTZFloat16 != r.ShaderRoundingModeRTZFloat16) || (l.ShaderRoundingModeRTZFloat32 != r.ShaderRoundingModeRTZFloat32) || (l.ShaderRoundingModeRTZFloat64 != r.ShaderRoundingModeRTZFloat64) || (l.MaxUpdateAfterBindDescriptorsInAllPools != r.MaxUpdateAfterBindDescriptorsInAllPools)
			|| (l.ShaderUniformBufferArrayNonUniformIndexingNative != r.ShaderUniformBufferArrayNonUniformIndexingNative) || (l.ShaderSampledImageArrayNonUniformIndexingNative != r.ShaderSampledImageArrayNonUniformIndexingNative) || (l.ShaderStorageBufferArrayNonUniformIndexingNative != r.ShaderStorageBufferArrayNonUniformIndexingNative) || (l.ShaderStorageImageArrayNonUniformIndexingNative != r.ShaderStorageImageArrayNonUniformIndexingNative)
			|| (l.ShaderInputAttachmentArrayNonUniformIndexingNative != r.ShaderInputAttachmentArrayNonUniformIndexingNative) || (l.RobustBufferAccessUpdateAfterBind != r.RobustBufferAccessUpdateAfterBind) || (l.QuadDivergentImplicitLod != r.QuadDivergentImplicitLod) || (l.MaxPerStageDescriptorUpdateAfterBindSamplers != r.MaxPerStageDescriptorUpdateAfterBindSamplers)
			|| (l.MaxPerStageDescriptorUpdateAfterBindUniformBuffers != r.MaxPerStageDescriptorUpdateAfterBindUniformBuffers) || (l.MaxPerStageDescriptorUpdateAfterBindStorageBuffers != r.MaxPerStageDescriptorUpdateAfterBindStorageBuffers) || (l.MaxPerStageDescriptorUpdateAfterBindSampledImages != r.MaxPerStageDescriptorUpdateAfterBindSampledImages) || (l.MaxPerStageDescriptorUpdateAfterBindStorageImages != r.MaxPerStageDescriptorUpdateAfterBindStorageImages)
			|| (l.MaxPerStageDescriptorUpdateAfterBindInputAttachments != r.MaxPerStageDescriptorUpdateAfterBindInputAttachments) || (l.MaxPerStageUpdateAfterBindResources != r.MaxPerStageUpdateAfterBindResources) || (l.MaxDescriptorSetUpdateAfterBindSamplers != r.MaxDescriptorSetUpdateAfterBindSamplers) || (l.MaxDescriptorSetUpdateAfterBindUniformBuffers != r.MaxDescriptorSetUpdateAfterBindUniformBuffers)
			|| (l.MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic != r.MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic) || (l.MaxDescriptorSetUpdateAfterBindStorageBuffers != r.MaxDescriptorSetUpdateAfterBindStorageBuffers) || (l.MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic != r.MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic) || (l.MaxDescriptorSetUpdateAfterBindSampledImages != r.MaxDescriptorSetUpdateAfterBindSampledImages)
			|| (l.MaxDescriptorSetUpdateAfterBindStorageImages != r.MaxDescriptorSetUpdateAfterBindStorageImages) || (l.MaxDescriptorSetUpdateAfterBindInputAttachments != r.MaxDescriptorSetUpdateAfterBindInputAttachments) || (l.SupportedDepthResolveModes != r.SupportedDepthResolveModes) || (l.SupportedStencilResolveModes != r.SupportedStencilResolveModes)
			|| (l.IndependentResolveNone != r.IndependentResolveNone) || (l.IndependentResolve != r.IndependentResolve) || (l.FilterMinmaxSingleComponentFormats != r.FilterMinmaxSingleComponentFormats) || (l.FilterMinmaxImageComponentMapping != r.FilterMinmaxImageComponentMapping)
			|| (l.MaxTimelineSemaphoreValueDifference != r.MaxTimelineSemaphoreValueDifference) || (l.FramebufferIntegerColorSampleCounts != r.FramebufferIntegerColorSampleCounts)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceVulkan12Properties s) => s = new() { sType = TYPE };
}


} // namespace Vulkan

