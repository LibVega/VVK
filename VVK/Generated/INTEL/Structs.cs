/*
 * MIT License - Copyright(c) 2020 Sean Moss
 * This file is subject to the terms and conditions of the MIT License, the text of which can be found in the 'LICENSE'
 * file at the root of this repository, or online at <https://opensource.org/licenses/MIT>.
 */

/// This file was generated by VVKGen. Edits to this file will be lost on next generation.

using System;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;

namespace Vulkan
{

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL : IEquatable<VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceShaderIntegerFunctions2FeaturesIntel;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 ShaderIntegerFunctions2;

	public VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL(
		VkBool32 shaderIntegerFunctions2 = default
	) {
		sType = TYPE;
		pNext = null;
		ShaderIntegerFunctions2 = shaderIntegerFunctions2;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL>.Equals(VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ShaderIntegerFunctions2.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL l, in VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ShaderIntegerFunctions2 == r.ShaderIntegerFunctions2)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL l, in VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ShaderIntegerFunctions2 != r.ShaderIntegerFunctions2)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Explicit)]
public unsafe partial struct VkPerformanceValueDataINTEL : IEquatable<VkPerformanceValueDataINTEL>
{
	[FieldOffset(0)]
	public uint Value32;
	[FieldOffset(0)]
	public ulong Value64;
	[FieldOffset(0)]
	public float ValueFloat;
	[FieldOffset(0)]
	public VkBool32 ValueBool;
	[FieldOffset(0)]
	public byte* ValueString;

	public readonly override bool Equals(object? o) => (o is VkPerformanceValueDataINTEL s) && (this == s);
	readonly bool IEquatable<VkPerformanceValueDataINTEL>.Equals(VkPerformanceValueDataINTEL o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Value32.GetHashCode() ^ Value64.GetHashCode() ^ ValueFloat.GetHashCode() ^ ValueBool.GetHashCode()
			^ ((ulong)ValueString).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPerformanceValueDataINTEL l, in VkPerformanceValueDataINTEL r)
	{
		return
			(l.Value32 == r.Value32) && (l.Value64 == r.Value64) && (l.ValueFloat == r.ValueFloat) && (l.ValueBool == r.ValueBool)
			&& (l.ValueString == r.ValueString)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPerformanceValueDataINTEL l, in VkPerformanceValueDataINTEL r)
	{
		return
			(l.Value32 != r.Value32) || (l.Value64 != r.Value64) || (l.ValueFloat != r.ValueFloat) || (l.ValueBool != r.ValueBool)
			|| (l.ValueString != r.ValueString)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPerformanceValueDataINTEL s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPerformanceValueINTEL : IEquatable<VkPerformanceValueINTEL>
{
	public VkPerformanceValueTypeINTEL Type;
	public VkPerformanceValueDataINTEL Data;

	public VkPerformanceValueINTEL(
		VkPerformanceValueTypeINTEL type = default,
		VkPerformanceValueDataINTEL data = default
	) {
		Type = type;
		Data = data;
	}

	public readonly override bool Equals(object? o) => (o is VkPerformanceValueINTEL s) && (this == s);
	readonly bool IEquatable<VkPerformanceValueINTEL>.Equals(VkPerformanceValueINTEL o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Type.GetHashCode() ^ Data.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPerformanceValueINTEL l, in VkPerformanceValueINTEL r)
	{
		return
			(l.Type == r.Type) && (l.Data == r.Data)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPerformanceValueINTEL l, in VkPerformanceValueINTEL r)
	{
		return
			(l.Type != r.Type) || (l.Data != r.Data)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPerformanceValueINTEL s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkInitializePerformanceApiInfoINTEL : IEquatable<VkInitializePerformanceApiInfoINTEL>
{
	public const VkStructureType TYPE = VkStructureType.InitializePerformanceApiInfoIntel;

	public VkStructureType sType;
	public void* pNext;
	public void* UserData;

	public VkInitializePerformanceApiInfoINTEL(
		void* userData = default
	) {
		sType = TYPE;
		pNext = null;
		UserData = userData;
	}

	public readonly override bool Equals(object? o) => (o is VkInitializePerformanceApiInfoINTEL s) && (this == s);
	readonly bool IEquatable<VkInitializePerformanceApiInfoINTEL>.Equals(VkInitializePerformanceApiInfoINTEL o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ((ulong)UserData).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkInitializePerformanceApiInfoINTEL l, in VkInitializePerformanceApiInfoINTEL r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.UserData == r.UserData)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkInitializePerformanceApiInfoINTEL l, in VkInitializePerformanceApiInfoINTEL r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.UserData != r.UserData)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkInitializePerformanceApiInfoINTEL s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkQueryPoolPerformanceQueryCreateInfoINTEL : IEquatable<VkQueryPoolPerformanceQueryCreateInfoINTEL>
{
	public const VkStructureType TYPE = VkStructureType.QueryPoolPerformanceQueryCreateInfoIntel;

	public VkStructureType sType;
	public void* pNext;
	public VkQueryPoolSamplingModeINTEL PerformanceCountersSampling;

	public VkQueryPoolPerformanceQueryCreateInfoINTEL(
		VkQueryPoolSamplingModeINTEL performanceCountersSampling = default
	) {
		sType = TYPE;
		pNext = null;
		PerformanceCountersSampling = performanceCountersSampling;
	}

	public readonly override bool Equals(object? o) => (o is VkQueryPoolPerformanceQueryCreateInfoINTEL s) && (this == s);
	readonly bool IEquatable<VkQueryPoolPerformanceQueryCreateInfoINTEL>.Equals(VkQueryPoolPerformanceQueryCreateInfoINTEL o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ PerformanceCountersSampling.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkQueryPoolPerformanceQueryCreateInfoINTEL l, in VkQueryPoolPerformanceQueryCreateInfoINTEL r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.PerformanceCountersSampling == r.PerformanceCountersSampling)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkQueryPoolPerformanceQueryCreateInfoINTEL l, in VkQueryPoolPerformanceQueryCreateInfoINTEL r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.PerformanceCountersSampling != r.PerformanceCountersSampling)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkQueryPoolPerformanceQueryCreateInfoINTEL s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkQueryPoolCreateInfoINTEL : IEquatable<VkQueryPoolCreateInfoINTEL>
{
	public const VkStructureType TYPE = VkStructureType.QueryPoolPerformanceQueryCreateInfoIntel;

	public VkStructureType sType;
	public void* pNext;
	public VkQueryPoolSamplingModeINTEL PerformanceCountersSampling;

	public VkQueryPoolCreateInfoINTEL(
		VkQueryPoolSamplingModeINTEL performanceCountersSampling = default
	) {
		sType = TYPE;
		pNext = null;
		PerformanceCountersSampling = performanceCountersSampling;
	}

	public readonly override bool Equals(object? o) => (o is VkQueryPoolCreateInfoINTEL s) && (this == s);
	readonly bool IEquatable<VkQueryPoolCreateInfoINTEL>.Equals(VkQueryPoolCreateInfoINTEL o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ PerformanceCountersSampling.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkQueryPoolCreateInfoINTEL l, in VkQueryPoolCreateInfoINTEL r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.PerformanceCountersSampling == r.PerformanceCountersSampling)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkQueryPoolCreateInfoINTEL l, in VkQueryPoolCreateInfoINTEL r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.PerformanceCountersSampling != r.PerformanceCountersSampling)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkQueryPoolCreateInfoINTEL s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPerformanceMarkerInfoINTEL : IEquatable<VkPerformanceMarkerInfoINTEL>
{
	public const VkStructureType TYPE = VkStructureType.PerformanceMarkerInfoIntel;

	public VkStructureType sType;
	public void* pNext;
	public ulong Marker;

	public VkPerformanceMarkerInfoINTEL(
		ulong marker = default
	) {
		sType = TYPE;
		pNext = null;
		Marker = marker;
	}

	public readonly override bool Equals(object? o) => (o is VkPerformanceMarkerInfoINTEL s) && (this == s);
	readonly bool IEquatable<VkPerformanceMarkerInfoINTEL>.Equals(VkPerformanceMarkerInfoINTEL o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Marker.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPerformanceMarkerInfoINTEL l, in VkPerformanceMarkerInfoINTEL r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Marker == r.Marker)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPerformanceMarkerInfoINTEL l, in VkPerformanceMarkerInfoINTEL r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Marker != r.Marker)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPerformanceMarkerInfoINTEL s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPerformanceStreamMarkerInfoINTEL : IEquatable<VkPerformanceStreamMarkerInfoINTEL>
{
	public const VkStructureType TYPE = VkStructureType.PerformanceStreamMarkerInfoIntel;

	public VkStructureType sType;
	public void* pNext;
	public uint Marker;

	public VkPerformanceStreamMarkerInfoINTEL(
		uint marker = default
	) {
		sType = TYPE;
		pNext = null;
		Marker = marker;
	}

	public readonly override bool Equals(object? o) => (o is VkPerformanceStreamMarkerInfoINTEL s) && (this == s);
	readonly bool IEquatable<VkPerformanceStreamMarkerInfoINTEL>.Equals(VkPerformanceStreamMarkerInfoINTEL o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Marker.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPerformanceStreamMarkerInfoINTEL l, in VkPerformanceStreamMarkerInfoINTEL r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Marker == r.Marker)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPerformanceStreamMarkerInfoINTEL l, in VkPerformanceStreamMarkerInfoINTEL r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Marker != r.Marker)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPerformanceStreamMarkerInfoINTEL s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPerformanceOverrideInfoINTEL : IEquatable<VkPerformanceOverrideInfoINTEL>
{
	public const VkStructureType TYPE = VkStructureType.PerformanceOverrideInfoIntel;

	public VkStructureType sType;
	public void* pNext;
	public VkPerformanceOverrideTypeINTEL Type;
	public VkBool32 Enable;
	public ulong Parameter;

	public VkPerformanceOverrideInfoINTEL(
		VkPerformanceOverrideTypeINTEL type = default,
		VkBool32 enable = default,
		ulong parameter = default
	) {
		sType = TYPE;
		pNext = null;
		Type = type;
		Enable = enable;
		Parameter = parameter;
	}

	public readonly override bool Equals(object? o) => (o is VkPerformanceOverrideInfoINTEL s) && (this == s);
	readonly bool IEquatable<VkPerformanceOverrideInfoINTEL>.Equals(VkPerformanceOverrideInfoINTEL o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Type.GetHashCode() ^ Enable.GetHashCode()
			^ Parameter.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPerformanceOverrideInfoINTEL l, in VkPerformanceOverrideInfoINTEL r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Type == r.Type) && (l.Enable == r.Enable)
			&& (l.Parameter == r.Parameter)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPerformanceOverrideInfoINTEL l, in VkPerformanceOverrideInfoINTEL r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Type != r.Type) || (l.Enable != r.Enable)
			|| (l.Parameter != r.Parameter)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPerformanceOverrideInfoINTEL s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPerformanceConfigurationAcquireInfoINTEL : IEquatable<VkPerformanceConfigurationAcquireInfoINTEL>
{
	public const VkStructureType TYPE = VkStructureType.PerformanceConfigurationAcquireInfoIntel;

	public VkStructureType sType;
	public void* pNext;
	public VkPerformanceConfigurationTypeINTEL Type;

	public VkPerformanceConfigurationAcquireInfoINTEL(
		VkPerformanceConfigurationTypeINTEL type = default
	) {
		sType = TYPE;
		pNext = null;
		Type = type;
	}

	public readonly override bool Equals(object? o) => (o is VkPerformanceConfigurationAcquireInfoINTEL s) && (this == s);
	readonly bool IEquatable<VkPerformanceConfigurationAcquireInfoINTEL>.Equals(VkPerformanceConfigurationAcquireInfoINTEL o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Type.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPerformanceConfigurationAcquireInfoINTEL l, in VkPerformanceConfigurationAcquireInfoINTEL r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Type == r.Type)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPerformanceConfigurationAcquireInfoINTEL l, in VkPerformanceConfigurationAcquireInfoINTEL r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Type != r.Type)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPerformanceConfigurationAcquireInfoINTEL s) => s = new() { sType = TYPE };
}


} // namespace Vulkan

