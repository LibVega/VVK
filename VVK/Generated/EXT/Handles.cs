/*
 * MIT License - Copyright(c) 2020 Sean Moss
 * This file is subject to the terms and conditions of the MIT License, the text of which can be found in the 'LICENSE'
 * file at the root of this repository, or online at <https://opensource.org/licenses/MIT>.
 */

/// This file was generated by VVKGen. Edits to this file will be lost on next generation.

using System;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;

namespace Vulkan
{

public unsafe sealed partial class VkValidationCacheEXT : IVulkanHandle<VkValidationCacheEXT>
{
	public readonly VulkanHandle<VkValidationCacheEXT> Handle;
	public readonly VkDevice Parent;
	public readonly DeviceFunctionTable Functions;
	public bool IsValid => Handle.IsValid;

	public VkValidationCacheEXT(VulkanHandle<VkValidationCacheEXT> handle, VkDevice parent)
	{
		Handle = handle;
		Parent = parent;
		Functions = parent.Functions;
	}

	public override int GetHashCode() => Handle.GetHashCode();
	public override string? ToString() => Handle.ToString();
	public override bool Equals(object? o) => (o is VkValidationCacheEXT h) && (h.Handle == Handle);
	bool IEquatable<VkValidationCacheEXT>.Equals(VkValidationCacheEXT? other) => other?.Handle == Handle;

	public static bool operator == (VkValidationCacheEXT? l, VkValidationCacheEXT? r) => l?.Handle == r?.Handle;
	public static bool operator != (VkValidationCacheEXT? l, VkValidationCacheEXT? r) => l?.Handle != r?.Handle;

	public static implicit operator VulkanHandle<VkValidationCacheEXT> (VkValidationCacheEXT? h) => h?.Handle ?? VulkanHandle<VkValidationCacheEXT>.Null;
	public static implicit operator bool (VkValidationCacheEXT? h) => h?.IsValid ?? false;

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void DestroyValidationCacheEXT(VkAllocationCallbacks* pAllocator)
		=> Functions.vkDestroyValidationCacheEXT(Parent, Handle, pAllocator);

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public VkResult GetValidationCacheDataEXT(ulong* pDataSize, void* pData)
		=> Functions.vkGetValidationCacheDataEXT(Parent, Handle, pDataSize, pData);

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public VkResult GetValidationCacheDataEXT(ref ulong pDataSize, void* pData)
	{
		fixed (ulong* pDataSizeFIXED = &pDataSize)
		return Functions.vkGetValidationCacheDataEXT(Parent, Handle, pDataSizeFIXED, pData);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public VkResult MergeValidationCachesEXT(uint srcCacheCount, VulkanHandle<VkValidationCacheEXT>* pSrcCaches)
		=> Functions.vkMergeValidationCachesEXT(Parent, Handle, srcCacheCount, pSrcCaches);

}

public unsafe sealed partial class VkPrivateDataSlotEXT : IVulkanHandle<VkPrivateDataSlotEXT>
{
	public readonly VulkanHandle<VkPrivateDataSlotEXT> Handle;
	public readonly VkDevice Parent;
	public readonly DeviceFunctionTable Functions;
	public bool IsValid => Handle.IsValid;

	public VkPrivateDataSlotEXT(VulkanHandle<VkPrivateDataSlotEXT> handle, VkDevice parent)
	{
		Handle = handle;
		Parent = parent;
		Functions = parent.Functions;
	}

	public override int GetHashCode() => Handle.GetHashCode();
	public override string? ToString() => Handle.ToString();
	public override bool Equals(object? o) => (o is VkPrivateDataSlotEXT h) && (h.Handle == Handle);
	bool IEquatable<VkPrivateDataSlotEXT>.Equals(VkPrivateDataSlotEXT? other) => other?.Handle == Handle;

	public static bool operator == (VkPrivateDataSlotEXT? l, VkPrivateDataSlotEXT? r) => l?.Handle == r?.Handle;
	public static bool operator != (VkPrivateDataSlotEXT? l, VkPrivateDataSlotEXT? r) => l?.Handle != r?.Handle;

	public static implicit operator VulkanHandle<VkPrivateDataSlotEXT> (VkPrivateDataSlotEXT? h) => h?.Handle ?? VulkanHandle<VkPrivateDataSlotEXT>.Null;
	public static implicit operator bool (VkPrivateDataSlotEXT? h) => h?.IsValid ?? false;

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void DestroyPrivateDataSlotEXT(VkAllocationCallbacks* pAllocator)
		=> Functions.vkDestroyPrivateDataSlotEXT(Parent, Handle, pAllocator);

}

public unsafe sealed partial class VkDebugReportCallbackEXT : IVulkanHandle<VkDebugReportCallbackEXT>
{
	public readonly VulkanHandle<VkDebugReportCallbackEXT> Handle;
	public readonly VkInstance Parent;
	public readonly InstanceFunctionTable Functions;
	public bool IsValid => Handle.IsValid;

	public VkDebugReportCallbackEXT(VulkanHandle<VkDebugReportCallbackEXT> handle, VkInstance parent)
	{
		Handle = handle;
		Parent = parent;
		Functions = parent.Functions;
	}

	public override int GetHashCode() => Handle.GetHashCode();
	public override string? ToString() => Handle.ToString();
	public override bool Equals(object? o) => (o is VkDebugReportCallbackEXT h) && (h.Handle == Handle);
	bool IEquatable<VkDebugReportCallbackEXT>.Equals(VkDebugReportCallbackEXT? other) => other?.Handle == Handle;

	public static bool operator == (VkDebugReportCallbackEXT? l, VkDebugReportCallbackEXT? r) => l?.Handle == r?.Handle;
	public static bool operator != (VkDebugReportCallbackEXT? l, VkDebugReportCallbackEXT? r) => l?.Handle != r?.Handle;

	public static implicit operator VulkanHandle<VkDebugReportCallbackEXT> (VkDebugReportCallbackEXT? h) => h?.Handle ?? VulkanHandle<VkDebugReportCallbackEXT>.Null;
	public static implicit operator bool (VkDebugReportCallbackEXT? h) => h?.IsValid ?? false;

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void DestroyDebugReportCallbackEXT(VkAllocationCallbacks* pAllocator)
		=> Functions.vkDestroyDebugReportCallbackEXT(Parent, Handle, pAllocator);

}

public unsafe sealed partial class VkDebugUtilsMessengerEXT : IVulkanHandle<VkDebugUtilsMessengerEXT>
{
	public readonly VulkanHandle<VkDebugUtilsMessengerEXT> Handle;
	public readonly VkInstance Parent;
	public readonly InstanceFunctionTable Functions;
	public bool IsValid => Handle.IsValid;

	public VkDebugUtilsMessengerEXT(VulkanHandle<VkDebugUtilsMessengerEXT> handle, VkInstance parent)
	{
		Handle = handle;
		Parent = parent;
		Functions = parent.Functions;
	}

	public override int GetHashCode() => Handle.GetHashCode();
	public override string? ToString() => Handle.ToString();
	public override bool Equals(object? o) => (o is VkDebugUtilsMessengerEXT h) && (h.Handle == Handle);
	bool IEquatable<VkDebugUtilsMessengerEXT>.Equals(VkDebugUtilsMessengerEXT? other) => other?.Handle == Handle;

	public static bool operator == (VkDebugUtilsMessengerEXT? l, VkDebugUtilsMessengerEXT? r) => l?.Handle == r?.Handle;
	public static bool operator != (VkDebugUtilsMessengerEXT? l, VkDebugUtilsMessengerEXT? r) => l?.Handle != r?.Handle;

	public static implicit operator VulkanHandle<VkDebugUtilsMessengerEXT> (VkDebugUtilsMessengerEXT? h) => h?.Handle ?? VulkanHandle<VkDebugUtilsMessengerEXT>.Null;
	public static implicit operator bool (VkDebugUtilsMessengerEXT? h) => h?.IsValid ?? false;

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void DestroyDebugUtilsMessengerEXT(VkAllocationCallbacks* pAllocator)
		=> Functions.vkDestroyDebugUtilsMessengerEXT(Parent, Handle, pAllocator);

}


} // namespace Vulkan

