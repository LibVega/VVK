/*
 * MIT License - Copyright(c) 2020 Sean Moss
 * This file is subject to the terms and conditions of the MIT License, the text of which can be found in the 'LICENSE'
 * file at the root of this repository, or online at<https://opensource.org/licenses/MIT>.
 */

/// This file was generated by VVKGen. Edits to this file will be lost on next generation.

using System;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;


namespace Vk.EXT
{

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DirectFBSurfaceCreateInfo : IEquatable<DirectFBSurfaceCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DirectfbSurfaceCreateInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.EXT.DirectFBSurfaceCreateFlags Flags;
	public void* Dfb;
	public void* Surface;

	public readonly override bool Equals(object? obj) => (obj is DirectFBSurfaceCreateInfo o) && (this == o);
	readonly bool IEquatable<DirectFBSurfaceCreateInfo>.Equals(DirectFBSurfaceCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ ((ulong)Dfb).GetHashCode()
			^ ((ulong)Surface).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DirectFBSurfaceCreateInfo l, in DirectFBSurfaceCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.Dfb == r.Dfb)
			&& (l.Surface == r.Surface)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DirectFBSurfaceCreateInfo l, in DirectFBSurfaceCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.Dfb != r.Dfb)
			|| (l.Surface != r.Surface)
			;
	}


	/// <summary>Creates a new DirectFBSurfaceCreateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DirectFBSurfaceCreateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref DirectFBSurfaceCreateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DebugReportCallbackCreateInfo : IEquatable<DebugReportCallbackCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DebugReportCallbackCreateInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.EXT.DebugReportFlags Flags;
	public delegate* managed<Vk.EXT.DebugReportFlags, Vk.EXT.DebugReportObjectType, ulong, ulong, int, byte*, byte*, void*, Vk.Bool32> Callback;
	public void* UserData;

	public readonly override bool Equals(object? obj) => (obj is DebugReportCallbackCreateInfo o) && (this == o);
	readonly bool IEquatable<DebugReportCallbackCreateInfo>.Equals(DebugReportCallbackCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ ((ulong)Callback).GetHashCode()
			^ ((ulong)UserData).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DebugReportCallbackCreateInfo l, in DebugReportCallbackCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.Callback == r.Callback)
			&& (l.UserData == r.UserData)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DebugReportCallbackCreateInfo l, in DebugReportCallbackCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.Callback != r.Callback)
			|| (l.UserData != r.UserData)
			;
	}


	/// <summary>Creates a new DebugReportCallbackCreateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DebugReportCallbackCreateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref DebugReportCallbackCreateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ValidationFlags : IEquatable<ValidationFlags>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ValidationFlagsEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public uint DisabledValidationCheckCount;
	public Vk.EXT.ValidationCheck* DisabledValidationChecks;

	public readonly override bool Equals(object? obj) => (obj is ValidationFlags o) && (this == o);
	readonly bool IEquatable<ValidationFlags>.Equals(ValidationFlags obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DisabledValidationCheckCount.GetHashCode() ^ ((ulong)DisabledValidationChecks).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ValidationFlags l, in ValidationFlags r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DisabledValidationCheckCount == r.DisabledValidationCheckCount) && (l.DisabledValidationChecks == r.DisabledValidationChecks)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ValidationFlags l, in ValidationFlags r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DisabledValidationCheckCount != r.DisabledValidationCheckCount) || (l.DisabledValidationChecks != r.DisabledValidationChecks)
			;
	}


	/// <summary>Creates a new ValidationFlags value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ValidationFlags value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref ValidationFlags value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ValidationFeatures : IEquatable<ValidationFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ValidationFeaturesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public uint EnabledValidationFeatureCount;
	public Vk.EXT.ValidationFeatureEnable* EnabledValidationFeatures;
	public uint DisabledValidationFeatureCount;
	public Vk.EXT.ValidationFeatureDisable* DisabledValidationFeatures;

	public readonly override bool Equals(object? obj) => (obj is ValidationFeatures o) && (this == o);
	readonly bool IEquatable<ValidationFeatures>.Equals(ValidationFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ EnabledValidationFeatureCount.GetHashCode() ^ ((ulong)EnabledValidationFeatures).GetHashCode()
			^ DisabledValidationFeatureCount.GetHashCode() ^ ((ulong)DisabledValidationFeatures).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ValidationFeatures l, in ValidationFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.EnabledValidationFeatureCount == r.EnabledValidationFeatureCount) && (l.EnabledValidationFeatures == r.EnabledValidationFeatures)
			&& (l.DisabledValidationFeatureCount == r.DisabledValidationFeatureCount) && (l.DisabledValidationFeatures == r.DisabledValidationFeatures)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ValidationFeatures l, in ValidationFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.EnabledValidationFeatureCount != r.EnabledValidationFeatureCount) || (l.EnabledValidationFeatures != r.EnabledValidationFeatures)
			|| (l.DisabledValidationFeatureCount != r.DisabledValidationFeatureCount) || (l.DisabledValidationFeatures != r.DisabledValidationFeatures)
			;
	}


	/// <summary>Creates a new ValidationFeatures value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ValidationFeatures value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref ValidationFeatures value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DebugMarkerObjectNameInfo : IEquatable<DebugMarkerObjectNameInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DebugMarkerObjectNameInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.EXT.DebugReportObjectType ObjectType;
	public ulong Object;
	public byte* ObjectName;

	public readonly override bool Equals(object? obj) => (obj is DebugMarkerObjectNameInfo o) && (this == o);
	readonly bool IEquatable<DebugMarkerObjectNameInfo>.Equals(DebugMarkerObjectNameInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ObjectType.GetHashCode() ^ Object.GetHashCode()
			^ ((ulong)ObjectName).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DebugMarkerObjectNameInfo l, in DebugMarkerObjectNameInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ObjectType == r.ObjectType) && (l.Object == r.Object)
			&& (l.ObjectName == r.ObjectName)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DebugMarkerObjectNameInfo l, in DebugMarkerObjectNameInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ObjectType != r.ObjectType) || (l.Object != r.Object)
			|| (l.ObjectName != r.ObjectName)
			;
	}


	/// <summary>Creates a new DebugMarkerObjectNameInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DebugMarkerObjectNameInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref DebugMarkerObjectNameInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DebugMarkerObjectTagInfo : IEquatable<DebugMarkerObjectTagInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DebugMarkerObjectTagInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.EXT.DebugReportObjectType ObjectType;
	public ulong Object;
	public ulong TagName;
	public ulong TagSize;
	public void* Tag;

	public readonly override bool Equals(object? obj) => (obj is DebugMarkerObjectTagInfo o) && (this == o);
	readonly bool IEquatable<DebugMarkerObjectTagInfo>.Equals(DebugMarkerObjectTagInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ObjectType.GetHashCode() ^ Object.GetHashCode()
			^ TagName.GetHashCode() ^ TagSize.GetHashCode() ^ ((ulong)Tag).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DebugMarkerObjectTagInfo l, in DebugMarkerObjectTagInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ObjectType == r.ObjectType) && (l.Object == r.Object)
			&& (l.TagName == r.TagName) && (l.TagSize == r.TagSize) && (l.Tag == r.Tag)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DebugMarkerObjectTagInfo l, in DebugMarkerObjectTagInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ObjectType != r.ObjectType) || (l.Object != r.Object)
			|| (l.TagName != r.TagName) || (l.TagSize != r.TagSize) || (l.Tag != r.Tag)
			;
	}


	/// <summary>Creates a new DebugMarkerObjectTagInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DebugMarkerObjectTagInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref DebugMarkerObjectTagInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DebugMarkerMarkerInfo : IEquatable<DebugMarkerMarkerInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DebugMarkerMarkerInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public byte* MarkerName;
	public fixed float Color[4];

	public readonly override bool Equals(object? obj) => (obj is DebugMarkerMarkerInfo o) && (this == o);
	readonly bool IEquatable<DebugMarkerMarkerInfo>.Equals(DebugMarkerMarkerInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ((ulong)MarkerName).GetHashCode() ^ Color[0].GetHashCode()
			^ Color[1].GetHashCode() ^ Color[2].GetHashCode() ^ Color[3].GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DebugMarkerMarkerInfo l, in DebugMarkerMarkerInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MarkerName == r.MarkerName) && (l.Color[0] == r.Color[0])
			&& (l.Color[1] == r.Color[1]) && (l.Color[2] == r.Color[2]) && (l.Color[3] == r.Color[3])
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DebugMarkerMarkerInfo l, in DebugMarkerMarkerInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MarkerName != r.MarkerName) || (l.Color[0] != r.Color[0])
			|| (l.Color[1] != r.Color[1]) || (l.Color[2] != r.Color[2]) || (l.Color[3] != r.Color[3])
			;
	}


	/// <summary>Creates a new DebugMarkerMarkerInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DebugMarkerMarkerInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref DebugMarkerMarkerInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DevicePrivateDataCreateInfo : IEquatable<DevicePrivateDataCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DevicePrivateDataCreateInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public uint PrivateDataSlotRequestCount;

	public readonly override bool Equals(object? obj) => (obj is DevicePrivateDataCreateInfo o) && (this == o);
	readonly bool IEquatable<DevicePrivateDataCreateInfo>.Equals(DevicePrivateDataCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ PrivateDataSlotRequestCount.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DevicePrivateDataCreateInfo l, in DevicePrivateDataCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.PrivateDataSlotRequestCount == r.PrivateDataSlotRequestCount)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DevicePrivateDataCreateInfo l, in DevicePrivateDataCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.PrivateDataSlotRequestCount != r.PrivateDataSlotRequestCount)
			;
	}


	/// <summary>Creates a new DevicePrivateDataCreateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DevicePrivateDataCreateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref DevicePrivateDataCreateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PrivateDataSlotCreateInfo : IEquatable<PrivateDataSlotCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PrivateDataSlotCreateInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.EXT.PrivateDataSlotCreateFlags Flags;

	public readonly override bool Equals(object? obj) => (obj is PrivateDataSlotCreateInfo o) && (this == o);
	readonly bool IEquatable<PrivateDataSlotCreateInfo>.Equals(PrivateDataSlotCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PrivateDataSlotCreateInfo l, in PrivateDataSlotCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PrivateDataSlotCreateInfo l, in PrivateDataSlotCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags)
			;
	}


	/// <summary>Creates a new PrivateDataSlotCreateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PrivateDataSlotCreateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PrivateDataSlotCreateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDevicePrivateDataFeatures : IEquatable<PhysicalDevicePrivateDataFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDevicePrivateDataFeaturesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 PrivateData;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDevicePrivateDataFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDevicePrivateDataFeatures>.Equals(PhysicalDevicePrivateDataFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ PrivateData.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDevicePrivateDataFeatures l, in PhysicalDevicePrivateDataFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.PrivateData == r.PrivateData)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDevicePrivateDataFeatures l, in PhysicalDevicePrivateDataFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.PrivateData != r.PrivateData)
			;
	}


	/// <summary>Creates a new PhysicalDevicePrivateDataFeatures value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDevicePrivateDataFeatures value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDevicePrivateDataFeatures value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SurfaceCapabilities2 : IEquatable<SurfaceCapabilities2>
{
	public const Vk.StructureType TYPE = Vk.StructureType.SurfaceCapabilities2EXT;

	public Vk.StructureType sType;
	public void* pNext;
	public uint MinImageCount;
	public uint MaxImageCount;
	public Vk.Extent2D CurrentExtent;
	public Vk.Extent2D MinImageExtent;
	public Vk.Extent2D MaxImageExtent;
	public uint MaxImageArrayLayers;
	public Vk.KHR.SurfaceTransformFlags SupportedTransforms;
	public Vk.KHR.SurfaceTransformFlags CurrentTransform;
	public Vk.KHR.CompositeAlphaFlags SupportedCompositeAlpha;
	public Vk.ImageUsageFlags SupportedUsageFlags;
	public Vk.EXT.SurfaceCounterFlags SupportedSurfaceCounters;

	public readonly override bool Equals(object? obj) => (obj is SurfaceCapabilities2 o) && (this == o);
	readonly bool IEquatable<SurfaceCapabilities2>.Equals(SurfaceCapabilities2 obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MinImageCount.GetHashCode() ^ MaxImageCount.GetHashCode()
			^ CurrentExtent.GetHashCode() ^ MinImageExtent.GetHashCode() ^ MaxImageExtent.GetHashCode() ^ MaxImageArrayLayers.GetHashCode()
			^ SupportedTransforms.GetHashCode() ^ CurrentTransform.GetHashCode() ^ SupportedCompositeAlpha.GetHashCode() ^ SupportedUsageFlags.GetHashCode()
			^ SupportedSurfaceCounters.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SurfaceCapabilities2 l, in SurfaceCapabilities2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MinImageCount == r.MinImageCount) && (l.MaxImageCount == r.MaxImageCount)
			&& (l.CurrentExtent == r.CurrentExtent) && (l.MinImageExtent == r.MinImageExtent) && (l.MaxImageExtent == r.MaxImageExtent) && (l.MaxImageArrayLayers == r.MaxImageArrayLayers)
			&& (l.SupportedTransforms == r.SupportedTransforms) && (l.CurrentTransform == r.CurrentTransform) && (l.SupportedCompositeAlpha == r.SupportedCompositeAlpha) && (l.SupportedUsageFlags == r.SupportedUsageFlags)
			&& (l.SupportedSurfaceCounters == r.SupportedSurfaceCounters)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SurfaceCapabilities2 l, in SurfaceCapabilities2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MinImageCount != r.MinImageCount) || (l.MaxImageCount != r.MaxImageCount)
			|| (l.CurrentExtent != r.CurrentExtent) || (l.MinImageExtent != r.MinImageExtent) || (l.MaxImageExtent != r.MaxImageExtent) || (l.MaxImageArrayLayers != r.MaxImageArrayLayers)
			|| (l.SupportedTransforms != r.SupportedTransforms) || (l.CurrentTransform != r.CurrentTransform) || (l.SupportedCompositeAlpha != r.SupportedCompositeAlpha) || (l.SupportedUsageFlags != r.SupportedUsageFlags)
			|| (l.SupportedSurfaceCounters != r.SupportedSurfaceCounters)
			;
	}


	/// <summary>Creates a new SurfaceCapabilities2 value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SurfaceCapabilities2 value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref SurfaceCapabilities2 value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DisplayPowerInfo : IEquatable<DisplayPowerInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DisplayPowerInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.EXT.DisplayPowerState PowerState;

	public readonly override bool Equals(object? obj) => (obj is DisplayPowerInfo o) && (this == o);
	readonly bool IEquatable<DisplayPowerInfo>.Equals(DisplayPowerInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ PowerState.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DisplayPowerInfo l, in DisplayPowerInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.PowerState == r.PowerState)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DisplayPowerInfo l, in DisplayPowerInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.PowerState != r.PowerState)
			;
	}


	/// <summary>Creates a new DisplayPowerInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DisplayPowerInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref DisplayPowerInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DeviceEventInfo : IEquatable<DeviceEventInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DeviceEventInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.EXT.DeviceEventType DeviceEvent;

	public readonly override bool Equals(object? obj) => (obj is DeviceEventInfo o) && (this == o);
	readonly bool IEquatable<DeviceEventInfo>.Equals(DeviceEventInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DeviceEvent.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DeviceEventInfo l, in DeviceEventInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DeviceEvent == r.DeviceEvent)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DeviceEventInfo l, in DeviceEventInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DeviceEvent != r.DeviceEvent)
			;
	}


	/// <summary>Creates a new DeviceEventInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DeviceEventInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref DeviceEventInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DisplayEventInfo : IEquatable<DisplayEventInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DisplayEventInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.EXT.DisplayEventType DisplayEvent;

	public readonly override bool Equals(object? obj) => (obj is DisplayEventInfo o) && (this == o);
	readonly bool IEquatable<DisplayEventInfo>.Equals(DisplayEventInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DisplayEvent.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DisplayEventInfo l, in DisplayEventInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DisplayEvent == r.DisplayEvent)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DisplayEventInfo l, in DisplayEventInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DisplayEvent != r.DisplayEvent)
			;
	}


	/// <summary>Creates a new DisplayEventInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DisplayEventInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref DisplayEventInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SwapchainCounterCreateInfo : IEquatable<SwapchainCounterCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.SwapchainCounterCreateInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.EXT.SurfaceCounterFlags SurfaceCounters;

	public readonly override bool Equals(object? obj) => (obj is SwapchainCounterCreateInfo o) && (this == o);
	readonly bool IEquatable<SwapchainCounterCreateInfo>.Equals(SwapchainCounterCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SurfaceCounters.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SwapchainCounterCreateInfo l, in SwapchainCounterCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SurfaceCounters == r.SurfaceCounters)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SwapchainCounterCreateInfo l, in SwapchainCounterCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SurfaceCounters != r.SurfaceCounters)
			;
	}


	/// <summary>Creates a new SwapchainCounterCreateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SwapchainCounterCreateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref SwapchainCounterCreateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct XYColor : IEquatable<XYColor>
{
	public float X;
	public float Y;

	public readonly override bool Equals(object? obj) => (obj is XYColor o) && (this == o);
	readonly bool IEquatable<XYColor>.Equals(XYColor obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			X.GetHashCode() ^ Y.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in XYColor l, in XYColor r)
	{
		return
			(l.X == r.X) && (l.Y == r.Y)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in XYColor l, in XYColor r)
	{
		return
			(l.X != r.X) || (l.Y != r.Y)
			;
	}

}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct HdrMetadata : IEquatable<HdrMetadata>
{
	public const Vk.StructureType TYPE = Vk.StructureType.HdrMetadataEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.EXT.XYColor DisplayPrimaryRed;
	public Vk.EXT.XYColor DisplayPrimaryGreen;
	public Vk.EXT.XYColor DisplayPrimaryBlue;
	public Vk.EXT.XYColor WhitePoint;
	public float MaxLuminance;
	public float MinLuminance;
	public float MaxContentLightLevel;
	public float MaxFrameAverageLightLevel;

	public readonly override bool Equals(object? obj) => (obj is HdrMetadata o) && (this == o);
	readonly bool IEquatable<HdrMetadata>.Equals(HdrMetadata obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DisplayPrimaryRed.GetHashCode() ^ DisplayPrimaryGreen.GetHashCode()
			^ DisplayPrimaryBlue.GetHashCode() ^ WhitePoint.GetHashCode() ^ MaxLuminance.GetHashCode() ^ MinLuminance.GetHashCode()
			^ MaxContentLightLevel.GetHashCode() ^ MaxFrameAverageLightLevel.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in HdrMetadata l, in HdrMetadata r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DisplayPrimaryRed == r.DisplayPrimaryRed) && (l.DisplayPrimaryGreen == r.DisplayPrimaryGreen)
			&& (l.DisplayPrimaryBlue == r.DisplayPrimaryBlue) && (l.WhitePoint == r.WhitePoint) && (l.MaxLuminance == r.MaxLuminance) && (l.MinLuminance == r.MinLuminance)
			&& (l.MaxContentLightLevel == r.MaxContentLightLevel) && (l.MaxFrameAverageLightLevel == r.MaxFrameAverageLightLevel)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in HdrMetadata l, in HdrMetadata r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DisplayPrimaryRed != r.DisplayPrimaryRed) || (l.DisplayPrimaryGreen != r.DisplayPrimaryGreen)
			|| (l.DisplayPrimaryBlue != r.DisplayPrimaryBlue) || (l.WhitePoint != r.WhitePoint) || (l.MaxLuminance != r.MaxLuminance) || (l.MinLuminance != r.MinLuminance)
			|| (l.MaxContentLightLevel != r.MaxContentLightLevel) || (l.MaxFrameAverageLightLevel != r.MaxFrameAverageLightLevel)
			;
	}


	/// <summary>Creates a new HdrMetadata value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out HdrMetadata value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref HdrMetadata value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct MetalSurfaceCreateInfo : IEquatable<MetalSurfaceCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.MetalSurfaceCreateInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.EXT.MetalSurfaceCreateFlags Flags;
	public void* Layer;

	public readonly override bool Equals(object? obj) => (obj is MetalSurfaceCreateInfo o) && (this == o);
	readonly bool IEquatable<MetalSurfaceCreateInfo>.Equals(MetalSurfaceCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ ((ulong)Layer).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in MetalSurfaceCreateInfo l, in MetalSurfaceCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.Layer == r.Layer)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in MetalSurfaceCreateInfo l, in MetalSurfaceCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.Layer != r.Layer)
			;
	}


	/// <summary>Creates a new MetalSurfaceCreateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out MetalSurfaceCreateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref MetalSurfaceCreateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceDiscardRectangleProperties : IEquatable<PhysicalDeviceDiscardRectangleProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceDiscardRectanglePropertiesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public uint MaxDiscardRectangles;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceDiscardRectangleProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceDiscardRectangleProperties>.Equals(PhysicalDeviceDiscardRectangleProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MaxDiscardRectangles.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceDiscardRectangleProperties l, in PhysicalDeviceDiscardRectangleProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MaxDiscardRectangles == r.MaxDiscardRectangles)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceDiscardRectangleProperties l, in PhysicalDeviceDiscardRectangleProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MaxDiscardRectangles != r.MaxDiscardRectangles)
			;
	}


	/// <summary>Creates a new PhysicalDeviceDiscardRectangleProperties value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceDiscardRectangleProperties value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceDiscardRectangleProperties value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PipelineDiscardRectangleStateCreateInfo : IEquatable<PipelineDiscardRectangleStateCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PipelineDiscardRectangleStateCreateInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.EXT.PipelineDiscardRectangleStateCreateFlags Flags;
	public Vk.EXT.DiscardRectangleMode DiscardRectangleMode;
	public uint DiscardRectangleCount;
	public Vk.Rect2D* DiscardRectangles;

	public readonly override bool Equals(object? obj) => (obj is PipelineDiscardRectangleStateCreateInfo o) && (this == o);
	readonly bool IEquatable<PipelineDiscardRectangleStateCreateInfo>.Equals(PipelineDiscardRectangleStateCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ DiscardRectangleMode.GetHashCode()
			^ DiscardRectangleCount.GetHashCode() ^ ((ulong)DiscardRectangles).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PipelineDiscardRectangleStateCreateInfo l, in PipelineDiscardRectangleStateCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.DiscardRectangleMode == r.DiscardRectangleMode)
			&& (l.DiscardRectangleCount == r.DiscardRectangleCount) && (l.DiscardRectangles == r.DiscardRectangles)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PipelineDiscardRectangleStateCreateInfo l, in PipelineDiscardRectangleStateCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.DiscardRectangleMode != r.DiscardRectangleMode)
			|| (l.DiscardRectangleCount != r.DiscardRectangleCount) || (l.DiscardRectangles != r.DiscardRectangles)
			;
	}


	/// <summary>Creates a new PipelineDiscardRectangleStateCreateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PipelineDiscardRectangleStateCreateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PipelineDiscardRectangleStateCreateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ConditionalRenderingBeginInfo : IEquatable<ConditionalRenderingBeginInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ConditionalRenderingBeginInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Handle<Vk.Buffer> Buffer;
	public Vk.DeviceSize Offset;
	public Vk.EXT.ConditionalRenderingFlags Flags;

	public readonly override bool Equals(object? obj) => (obj is ConditionalRenderingBeginInfo o) && (this == o);
	readonly bool IEquatable<ConditionalRenderingBeginInfo>.Equals(ConditionalRenderingBeginInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Buffer.GetHashCode() ^ Offset.GetHashCode()
			^ Flags.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ConditionalRenderingBeginInfo l, in ConditionalRenderingBeginInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Buffer == r.Buffer) && (l.Offset == r.Offset)
			&& (l.Flags == r.Flags)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ConditionalRenderingBeginInfo l, in ConditionalRenderingBeginInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Buffer != r.Buffer) || (l.Offset != r.Offset)
			|| (l.Flags != r.Flags)
			;
	}


	/// <summary>Creates a new ConditionalRenderingBeginInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ConditionalRenderingBeginInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref ConditionalRenderingBeginInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceSamplerFilterMinmaxProperties : IEquatable<PhysicalDeviceSamplerFilterMinmaxProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceSamplerFilterMinmaxProperties;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 FilterMinmaxSingleComponentFormats;
	public Vk.Bool32 FilterMinmaxImageComponentMapping;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceSamplerFilterMinmaxProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceSamplerFilterMinmaxProperties>.Equals(PhysicalDeviceSamplerFilterMinmaxProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ FilterMinmaxSingleComponentFormats.GetHashCode() ^ FilterMinmaxImageComponentMapping.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceSamplerFilterMinmaxProperties l, in PhysicalDeviceSamplerFilterMinmaxProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.FilterMinmaxSingleComponentFormats == r.FilterMinmaxSingleComponentFormats) && (l.FilterMinmaxImageComponentMapping == r.FilterMinmaxImageComponentMapping)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceSamplerFilterMinmaxProperties l, in PhysicalDeviceSamplerFilterMinmaxProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.FilterMinmaxSingleComponentFormats != r.FilterMinmaxSingleComponentFormats) || (l.FilterMinmaxImageComponentMapping != r.FilterMinmaxImageComponentMapping)
			;
	}


	/// <summary>Creates a new PhysicalDeviceSamplerFilterMinmaxProperties value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceSamplerFilterMinmaxProperties value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceSamplerFilterMinmaxProperties value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SampleLocation : IEquatable<SampleLocation>
{
	public float X;
	public float Y;

	public readonly override bool Equals(object? obj) => (obj is SampleLocation o) && (this == o);
	readonly bool IEquatable<SampleLocation>.Equals(SampleLocation obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			X.GetHashCode() ^ Y.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SampleLocation l, in SampleLocation r)
	{
		return
			(l.X == r.X) && (l.Y == r.Y)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SampleLocation l, in SampleLocation r)
	{
		return
			(l.X != r.X) || (l.Y != r.Y)
			;
	}

}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SampleLocationsInfo : IEquatable<SampleLocationsInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.SampleLocationsInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.SampleCountFlags SampleLocationsPerPixel;
	public Vk.Extent2D SampleLocationGridSize;
	public uint SampleLocationsCount;
	public Vk.EXT.SampleLocation* SampleLocations;

	public readonly override bool Equals(object? obj) => (obj is SampleLocationsInfo o) && (this == o);
	readonly bool IEquatable<SampleLocationsInfo>.Equals(SampleLocationsInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SampleLocationsPerPixel.GetHashCode() ^ SampleLocationGridSize.GetHashCode()
			^ SampleLocationsCount.GetHashCode() ^ ((ulong)SampleLocations).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SampleLocationsInfo l, in SampleLocationsInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SampleLocationsPerPixel == r.SampleLocationsPerPixel) && (l.SampleLocationGridSize == r.SampleLocationGridSize)
			&& (l.SampleLocationsCount == r.SampleLocationsCount) && (l.SampleLocations == r.SampleLocations)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SampleLocationsInfo l, in SampleLocationsInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SampleLocationsPerPixel != r.SampleLocationsPerPixel) || (l.SampleLocationGridSize != r.SampleLocationGridSize)
			|| (l.SampleLocationsCount != r.SampleLocationsCount) || (l.SampleLocations != r.SampleLocations)
			;
	}


	/// <summary>Creates a new SampleLocationsInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SampleLocationsInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref SampleLocationsInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct AttachmentSampleLocations : IEquatable<AttachmentSampleLocations>
{
	public uint AttachmentIndex;
	public Vk.EXT.SampleLocationsInfo SampleLocationsInfo;

	public readonly override bool Equals(object? obj) => (obj is AttachmentSampleLocations o) && (this == o);
	readonly bool IEquatable<AttachmentSampleLocations>.Equals(AttachmentSampleLocations obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			AttachmentIndex.GetHashCode() ^ SampleLocationsInfo.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in AttachmentSampleLocations l, in AttachmentSampleLocations r)
	{
		return
			(l.AttachmentIndex == r.AttachmentIndex) && (l.SampleLocationsInfo == r.SampleLocationsInfo)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in AttachmentSampleLocations l, in AttachmentSampleLocations r)
	{
		return
			(l.AttachmentIndex != r.AttachmentIndex) || (l.SampleLocationsInfo != r.SampleLocationsInfo)
			;
	}

}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SubpassSampleLocations : IEquatable<SubpassSampleLocations>
{
	public uint SubpassIndex;
	public Vk.EXT.SampleLocationsInfo SampleLocationsInfo;

	public readonly override bool Equals(object? obj) => (obj is SubpassSampleLocations o) && (this == o);
	readonly bool IEquatable<SubpassSampleLocations>.Equals(SubpassSampleLocations obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			SubpassIndex.GetHashCode() ^ SampleLocationsInfo.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SubpassSampleLocations l, in SubpassSampleLocations r)
	{
		return
			(l.SubpassIndex == r.SubpassIndex) && (l.SampleLocationsInfo == r.SampleLocationsInfo)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SubpassSampleLocations l, in SubpassSampleLocations r)
	{
		return
			(l.SubpassIndex != r.SubpassIndex) || (l.SampleLocationsInfo != r.SampleLocationsInfo)
			;
	}

}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct RenderPassSampleLocationsBeginInfo : IEquatable<RenderPassSampleLocationsBeginInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.RenderPassSampleLocationsBeginInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public uint AttachmentInitialSampleLocationsCount;
	public Vk.EXT.AttachmentSampleLocations* AttachmentInitialSampleLocations;
	public uint PostSubpassSampleLocationsCount;
	public Vk.EXT.SubpassSampleLocations* PostSubpassSampleLocations;

	public readonly override bool Equals(object? obj) => (obj is RenderPassSampleLocationsBeginInfo o) && (this == o);
	readonly bool IEquatable<RenderPassSampleLocationsBeginInfo>.Equals(RenderPassSampleLocationsBeginInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ AttachmentInitialSampleLocationsCount.GetHashCode() ^ ((ulong)AttachmentInitialSampleLocations).GetHashCode()
			^ PostSubpassSampleLocationsCount.GetHashCode() ^ ((ulong)PostSubpassSampleLocations).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in RenderPassSampleLocationsBeginInfo l, in RenderPassSampleLocationsBeginInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.AttachmentInitialSampleLocationsCount == r.AttachmentInitialSampleLocationsCount) && (l.AttachmentInitialSampleLocations == r.AttachmentInitialSampleLocations)
			&& (l.PostSubpassSampleLocationsCount == r.PostSubpassSampleLocationsCount) && (l.PostSubpassSampleLocations == r.PostSubpassSampleLocations)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in RenderPassSampleLocationsBeginInfo l, in RenderPassSampleLocationsBeginInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.AttachmentInitialSampleLocationsCount != r.AttachmentInitialSampleLocationsCount) || (l.AttachmentInitialSampleLocations != r.AttachmentInitialSampleLocations)
			|| (l.PostSubpassSampleLocationsCount != r.PostSubpassSampleLocationsCount) || (l.PostSubpassSampleLocations != r.PostSubpassSampleLocations)
			;
	}


	/// <summary>Creates a new RenderPassSampleLocationsBeginInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out RenderPassSampleLocationsBeginInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref RenderPassSampleLocationsBeginInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PipelineSampleLocationsStateCreateInfo : IEquatable<PipelineSampleLocationsStateCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PipelineSampleLocationsStateCreateInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 SampleLocationsEnable;
	public Vk.EXT.SampleLocationsInfo SampleLocationsInfo;

	public readonly override bool Equals(object? obj) => (obj is PipelineSampleLocationsStateCreateInfo o) && (this == o);
	readonly bool IEquatable<PipelineSampleLocationsStateCreateInfo>.Equals(PipelineSampleLocationsStateCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SampleLocationsEnable.GetHashCode() ^ SampleLocationsInfo.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PipelineSampleLocationsStateCreateInfo l, in PipelineSampleLocationsStateCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SampleLocationsEnable == r.SampleLocationsEnable) && (l.SampleLocationsInfo == r.SampleLocationsInfo)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PipelineSampleLocationsStateCreateInfo l, in PipelineSampleLocationsStateCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SampleLocationsEnable != r.SampleLocationsEnable) || (l.SampleLocationsInfo != r.SampleLocationsInfo)
			;
	}


	/// <summary>Creates a new PipelineSampleLocationsStateCreateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PipelineSampleLocationsStateCreateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PipelineSampleLocationsStateCreateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceSampleLocationsProperties : IEquatable<PhysicalDeviceSampleLocationsProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceSampleLocationsPropertiesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.SampleCountFlags SampleLocationSampleCounts;
	public Vk.Extent2D MaxSampleLocationGridSize;
	public fixed float SampleLocationCoordinateRange[2];
	public uint SampleLocationSubPixelBits;
	public Vk.Bool32 VariableSampleLocations;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceSampleLocationsProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceSampleLocationsProperties>.Equals(PhysicalDeviceSampleLocationsProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SampleLocationSampleCounts.GetHashCode() ^ MaxSampleLocationGridSize.GetHashCode()
			^ SampleLocationCoordinateRange[0].GetHashCode() ^ SampleLocationCoordinateRange[1].GetHashCode() ^ SampleLocationSubPixelBits.GetHashCode() ^ VariableSampleLocations.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceSampleLocationsProperties l, in PhysicalDeviceSampleLocationsProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SampleLocationSampleCounts == r.SampleLocationSampleCounts) && (l.MaxSampleLocationGridSize == r.MaxSampleLocationGridSize)
			&& (l.SampleLocationCoordinateRange[0] == r.SampleLocationCoordinateRange[0]) && (l.SampleLocationCoordinateRange[1] == r.SampleLocationCoordinateRange[1]) && (l.SampleLocationSubPixelBits == r.SampleLocationSubPixelBits) && (l.VariableSampleLocations == r.VariableSampleLocations)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceSampleLocationsProperties l, in PhysicalDeviceSampleLocationsProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SampleLocationSampleCounts != r.SampleLocationSampleCounts) || (l.MaxSampleLocationGridSize != r.MaxSampleLocationGridSize)
			|| (l.SampleLocationCoordinateRange[0] != r.SampleLocationCoordinateRange[0]) || (l.SampleLocationCoordinateRange[1] != r.SampleLocationCoordinateRange[1]) || (l.SampleLocationSubPixelBits != r.SampleLocationSubPixelBits) || (l.VariableSampleLocations != r.VariableSampleLocations)
			;
	}


	/// <summary>Creates a new PhysicalDeviceSampleLocationsProperties value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceSampleLocationsProperties value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceSampleLocationsProperties value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct MultisampleProperties : IEquatable<MultisampleProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.MultisamplePropertiesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Extent2D MaxSampleLocationGridSize;

	public readonly override bool Equals(object? obj) => (obj is MultisampleProperties o) && (this == o);
	readonly bool IEquatable<MultisampleProperties>.Equals(MultisampleProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MaxSampleLocationGridSize.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in MultisampleProperties l, in MultisampleProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MaxSampleLocationGridSize == r.MaxSampleLocationGridSize)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in MultisampleProperties l, in MultisampleProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MaxSampleLocationGridSize != r.MaxSampleLocationGridSize)
			;
	}


	/// <summary>Creates a new MultisampleProperties value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out MultisampleProperties value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref MultisampleProperties value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SamplerReductionModeCreateInfo : IEquatable<SamplerReductionModeCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.SamplerReductionModeCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.SamplerReductionMode ReductionMode;

	public readonly override bool Equals(object? obj) => (obj is SamplerReductionModeCreateInfo o) && (this == o);
	readonly bool IEquatable<SamplerReductionModeCreateInfo>.Equals(SamplerReductionModeCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ReductionMode.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SamplerReductionModeCreateInfo l, in SamplerReductionModeCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ReductionMode == r.ReductionMode)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SamplerReductionModeCreateInfo l, in SamplerReductionModeCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ReductionMode != r.ReductionMode)
			;
	}


	/// <summary>Creates a new SamplerReductionModeCreateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SamplerReductionModeCreateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref SamplerReductionModeCreateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceBlendOperationAdvancedFeatures : IEquatable<PhysicalDeviceBlendOperationAdvancedFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceBlendOperationAdvancedFeaturesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 AdvancedBlendCoherentOperations;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceBlendOperationAdvancedFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceBlendOperationAdvancedFeatures>.Equals(PhysicalDeviceBlendOperationAdvancedFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ AdvancedBlendCoherentOperations.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceBlendOperationAdvancedFeatures l, in PhysicalDeviceBlendOperationAdvancedFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.AdvancedBlendCoherentOperations == r.AdvancedBlendCoherentOperations)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceBlendOperationAdvancedFeatures l, in PhysicalDeviceBlendOperationAdvancedFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.AdvancedBlendCoherentOperations != r.AdvancedBlendCoherentOperations)
			;
	}


	/// <summary>Creates a new PhysicalDeviceBlendOperationAdvancedFeatures value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceBlendOperationAdvancedFeatures value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceBlendOperationAdvancedFeatures value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceBlendOperationAdvancedProperties : IEquatable<PhysicalDeviceBlendOperationAdvancedProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceBlendOperationAdvancedPropertiesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public uint AdvancedBlendMaxColorAttachments;
	public Vk.Bool32 AdvancedBlendIndependentBlend;
	public Vk.Bool32 AdvancedBlendNonPremultipliedSrcColor;
	public Vk.Bool32 AdvancedBlendNonPremultipliedDstColor;
	public Vk.Bool32 AdvancedBlendCorrelatedOverlap;
	public Vk.Bool32 AdvancedBlendAllOperations;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceBlendOperationAdvancedProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceBlendOperationAdvancedProperties>.Equals(PhysicalDeviceBlendOperationAdvancedProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ AdvancedBlendMaxColorAttachments.GetHashCode() ^ AdvancedBlendIndependentBlend.GetHashCode()
			^ AdvancedBlendNonPremultipliedSrcColor.GetHashCode() ^ AdvancedBlendNonPremultipliedDstColor.GetHashCode() ^ AdvancedBlendCorrelatedOverlap.GetHashCode() ^ AdvancedBlendAllOperations.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceBlendOperationAdvancedProperties l, in PhysicalDeviceBlendOperationAdvancedProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.AdvancedBlendMaxColorAttachments == r.AdvancedBlendMaxColorAttachments) && (l.AdvancedBlendIndependentBlend == r.AdvancedBlendIndependentBlend)
			&& (l.AdvancedBlendNonPremultipliedSrcColor == r.AdvancedBlendNonPremultipliedSrcColor) && (l.AdvancedBlendNonPremultipliedDstColor == r.AdvancedBlendNonPremultipliedDstColor) && (l.AdvancedBlendCorrelatedOverlap == r.AdvancedBlendCorrelatedOverlap) && (l.AdvancedBlendAllOperations == r.AdvancedBlendAllOperations)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceBlendOperationAdvancedProperties l, in PhysicalDeviceBlendOperationAdvancedProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.AdvancedBlendMaxColorAttachments != r.AdvancedBlendMaxColorAttachments) || (l.AdvancedBlendIndependentBlend != r.AdvancedBlendIndependentBlend)
			|| (l.AdvancedBlendNonPremultipliedSrcColor != r.AdvancedBlendNonPremultipliedSrcColor) || (l.AdvancedBlendNonPremultipliedDstColor != r.AdvancedBlendNonPremultipliedDstColor) || (l.AdvancedBlendCorrelatedOverlap != r.AdvancedBlendCorrelatedOverlap) || (l.AdvancedBlendAllOperations != r.AdvancedBlendAllOperations)
			;
	}


	/// <summary>Creates a new PhysicalDeviceBlendOperationAdvancedProperties value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceBlendOperationAdvancedProperties value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceBlendOperationAdvancedProperties value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PipelineColorBlendAdvancedStateCreateInfo : IEquatable<PipelineColorBlendAdvancedStateCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PipelineColorBlendAdvancedStateCreateInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 SrcPremultiplied;
	public Vk.Bool32 DstPremultiplied;
	public Vk.EXT.BlendOverlap BlendOverlap;

	public readonly override bool Equals(object? obj) => (obj is PipelineColorBlendAdvancedStateCreateInfo o) && (this == o);
	readonly bool IEquatable<PipelineColorBlendAdvancedStateCreateInfo>.Equals(PipelineColorBlendAdvancedStateCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SrcPremultiplied.GetHashCode() ^ DstPremultiplied.GetHashCode()
			^ BlendOverlap.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PipelineColorBlendAdvancedStateCreateInfo l, in PipelineColorBlendAdvancedStateCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SrcPremultiplied == r.SrcPremultiplied) && (l.DstPremultiplied == r.DstPremultiplied)
			&& (l.BlendOverlap == r.BlendOverlap)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PipelineColorBlendAdvancedStateCreateInfo l, in PipelineColorBlendAdvancedStateCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SrcPremultiplied != r.SrcPremultiplied) || (l.DstPremultiplied != r.DstPremultiplied)
			|| (l.BlendOverlap != r.BlendOverlap)
			;
	}


	/// <summary>Creates a new PipelineColorBlendAdvancedStateCreateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PipelineColorBlendAdvancedStateCreateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PipelineColorBlendAdvancedStateCreateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceInlineUniformBlockFeatures : IEquatable<PhysicalDeviceInlineUniformBlockFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceInlineUniformBlockFeaturesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 InlineUniformBlock;
	public Vk.Bool32 DescriptorBindingInlineUniformBlockUpdateAfterBind;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceInlineUniformBlockFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceInlineUniformBlockFeatures>.Equals(PhysicalDeviceInlineUniformBlockFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ InlineUniformBlock.GetHashCode() ^ DescriptorBindingInlineUniformBlockUpdateAfterBind.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceInlineUniformBlockFeatures l, in PhysicalDeviceInlineUniformBlockFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.InlineUniformBlock == r.InlineUniformBlock) && (l.DescriptorBindingInlineUniformBlockUpdateAfterBind == r.DescriptorBindingInlineUniformBlockUpdateAfterBind)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceInlineUniformBlockFeatures l, in PhysicalDeviceInlineUniformBlockFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.InlineUniformBlock != r.InlineUniformBlock) || (l.DescriptorBindingInlineUniformBlockUpdateAfterBind != r.DescriptorBindingInlineUniformBlockUpdateAfterBind)
			;
	}


	/// <summary>Creates a new PhysicalDeviceInlineUniformBlockFeatures value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceInlineUniformBlockFeatures value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceInlineUniformBlockFeatures value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceInlineUniformBlockProperties : IEquatable<PhysicalDeviceInlineUniformBlockProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceInlineUniformBlockPropertiesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public uint MaxInlineUniformBlockSize;
	public uint MaxPerStageDescriptorInlineUniformBlocks;
	public uint MaxPerStageDescriptorUpdateAfterBindInlineUniformBlocks;
	public uint MaxDescriptorSetInlineUniformBlocks;
	public uint MaxDescriptorSetUpdateAfterBindInlineUniformBlocks;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceInlineUniformBlockProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceInlineUniformBlockProperties>.Equals(PhysicalDeviceInlineUniformBlockProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MaxInlineUniformBlockSize.GetHashCode() ^ MaxPerStageDescriptorInlineUniformBlocks.GetHashCode()
			^ MaxPerStageDescriptorUpdateAfterBindInlineUniformBlocks.GetHashCode() ^ MaxDescriptorSetInlineUniformBlocks.GetHashCode() ^ MaxDescriptorSetUpdateAfterBindInlineUniformBlocks.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceInlineUniformBlockProperties l, in PhysicalDeviceInlineUniformBlockProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MaxInlineUniformBlockSize == r.MaxInlineUniformBlockSize) && (l.MaxPerStageDescriptorInlineUniformBlocks == r.MaxPerStageDescriptorInlineUniformBlocks)
			&& (l.MaxPerStageDescriptorUpdateAfterBindInlineUniformBlocks == r.MaxPerStageDescriptorUpdateAfterBindInlineUniformBlocks) && (l.MaxDescriptorSetInlineUniformBlocks == r.MaxDescriptorSetInlineUniformBlocks) && (l.MaxDescriptorSetUpdateAfterBindInlineUniformBlocks == r.MaxDescriptorSetUpdateAfterBindInlineUniformBlocks)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceInlineUniformBlockProperties l, in PhysicalDeviceInlineUniformBlockProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MaxInlineUniformBlockSize != r.MaxInlineUniformBlockSize) || (l.MaxPerStageDescriptorInlineUniformBlocks != r.MaxPerStageDescriptorInlineUniformBlocks)
			|| (l.MaxPerStageDescriptorUpdateAfterBindInlineUniformBlocks != r.MaxPerStageDescriptorUpdateAfterBindInlineUniformBlocks) || (l.MaxDescriptorSetInlineUniformBlocks != r.MaxDescriptorSetInlineUniformBlocks) || (l.MaxDescriptorSetUpdateAfterBindInlineUniformBlocks != r.MaxDescriptorSetUpdateAfterBindInlineUniformBlocks)
			;
	}


	/// <summary>Creates a new PhysicalDeviceInlineUniformBlockProperties value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceInlineUniformBlockProperties value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceInlineUniformBlockProperties value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct WriteDescriptorSetInlineUniformBlock : IEquatable<WriteDescriptorSetInlineUniformBlock>
{
	public const Vk.StructureType TYPE = Vk.StructureType.WriteDescriptorSetInlineUniformBlockEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public uint DataSize;
	public void* Data;

	public readonly override bool Equals(object? obj) => (obj is WriteDescriptorSetInlineUniformBlock o) && (this == o);
	readonly bool IEquatable<WriteDescriptorSetInlineUniformBlock>.Equals(WriteDescriptorSetInlineUniformBlock obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DataSize.GetHashCode() ^ ((ulong)Data).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in WriteDescriptorSetInlineUniformBlock l, in WriteDescriptorSetInlineUniformBlock r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DataSize == r.DataSize) && (l.Data == r.Data)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in WriteDescriptorSetInlineUniformBlock l, in WriteDescriptorSetInlineUniformBlock r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DataSize != r.DataSize) || (l.Data != r.Data)
			;
	}


	/// <summary>Creates a new WriteDescriptorSetInlineUniformBlock value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out WriteDescriptorSetInlineUniformBlock value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref WriteDescriptorSetInlineUniformBlock value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DescriptorPoolInlineUniformBlockCreateInfo : IEquatable<DescriptorPoolInlineUniformBlockCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DescriptorPoolInlineUniformBlockCreateInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public uint MaxInlineUniformBlockBindings;

	public readonly override bool Equals(object? obj) => (obj is DescriptorPoolInlineUniformBlockCreateInfo o) && (this == o);
	readonly bool IEquatable<DescriptorPoolInlineUniformBlockCreateInfo>.Equals(DescriptorPoolInlineUniformBlockCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MaxInlineUniformBlockBindings.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DescriptorPoolInlineUniformBlockCreateInfo l, in DescriptorPoolInlineUniformBlockCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MaxInlineUniformBlockBindings == r.MaxInlineUniformBlockBindings)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DescriptorPoolInlineUniformBlockCreateInfo l, in DescriptorPoolInlineUniformBlockCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MaxInlineUniformBlockBindings != r.MaxInlineUniformBlockBindings)
			;
	}


	/// <summary>Creates a new DescriptorPoolInlineUniformBlockCreateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DescriptorPoolInlineUniformBlockCreateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref DescriptorPoolInlineUniformBlockCreateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ValidationCacheCreateInfo : IEquatable<ValidationCacheCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ValidationCacheCreateInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.EXT.ValidationCacheCreateFlags Flags;
	public ulong InitialDataSize;
	public void* InitialData;

	public readonly override bool Equals(object? obj) => (obj is ValidationCacheCreateInfo o) && (this == o);
	readonly bool IEquatable<ValidationCacheCreateInfo>.Equals(ValidationCacheCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ InitialDataSize.GetHashCode()
			^ ((ulong)InitialData).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ValidationCacheCreateInfo l, in ValidationCacheCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.InitialDataSize == r.InitialDataSize)
			&& (l.InitialData == r.InitialData)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ValidationCacheCreateInfo l, in ValidationCacheCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.InitialDataSize != r.InitialDataSize)
			|| (l.InitialData != r.InitialData)
			;
	}


	/// <summary>Creates a new ValidationCacheCreateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ValidationCacheCreateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref ValidationCacheCreateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ShaderModuleValidationCacheCreateInfo : IEquatable<ShaderModuleValidationCacheCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ShaderModuleValidationCacheCreateInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Handle<Vk.EXT.ValidationCache> ValidationCache;

	public readonly override bool Equals(object? obj) => (obj is ShaderModuleValidationCacheCreateInfo o) && (this == o);
	readonly bool IEquatable<ShaderModuleValidationCacheCreateInfo>.Equals(ShaderModuleValidationCacheCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ValidationCache.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ShaderModuleValidationCacheCreateInfo l, in ShaderModuleValidationCacheCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ValidationCache == r.ValidationCache)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ShaderModuleValidationCacheCreateInfo l, in ShaderModuleValidationCacheCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ValidationCache != r.ValidationCache)
			;
	}


	/// <summary>Creates a new ShaderModuleValidationCacheCreateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ShaderModuleValidationCacheCreateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref ShaderModuleValidationCacheCreateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceHostQueryResetFeatures : IEquatable<PhysicalDeviceHostQueryResetFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceHostQueryResetFeatures;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 HostQueryReset;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceHostQueryResetFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceHostQueryResetFeatures>.Equals(PhysicalDeviceHostQueryResetFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ HostQueryReset.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceHostQueryResetFeatures l, in PhysicalDeviceHostQueryResetFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.HostQueryReset == r.HostQueryReset)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceHostQueryResetFeatures l, in PhysicalDeviceHostQueryResetFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.HostQueryReset != r.HostQueryReset)
			;
	}


	/// <summary>Creates a new PhysicalDeviceHostQueryResetFeatures value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceHostQueryResetFeatures value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceHostQueryResetFeatures value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DeviceQueueGlobalPriorityCreateInfo : IEquatable<DeviceQueueGlobalPriorityCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DeviceQueueGlobalPriorityCreateInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.EXT.QueueGlobalPriority GlobalPriority;

	public readonly override bool Equals(object? obj) => (obj is DeviceQueueGlobalPriorityCreateInfo o) && (this == o);
	readonly bool IEquatable<DeviceQueueGlobalPriorityCreateInfo>.Equals(DeviceQueueGlobalPriorityCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ GlobalPriority.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DeviceQueueGlobalPriorityCreateInfo l, in DeviceQueueGlobalPriorityCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.GlobalPriority == r.GlobalPriority)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DeviceQueueGlobalPriorityCreateInfo l, in DeviceQueueGlobalPriorityCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.GlobalPriority != r.GlobalPriority)
			;
	}


	/// <summary>Creates a new DeviceQueueGlobalPriorityCreateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DeviceQueueGlobalPriorityCreateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref DeviceQueueGlobalPriorityCreateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DebugUtilsObjectNameInfo : IEquatable<DebugUtilsObjectNameInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DebugUtilsObjectNameInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.ObjectType ObjectType;
	public ulong ObjectHandle;
	public byte* ObjectName;

	public readonly override bool Equals(object? obj) => (obj is DebugUtilsObjectNameInfo o) && (this == o);
	readonly bool IEquatable<DebugUtilsObjectNameInfo>.Equals(DebugUtilsObjectNameInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ObjectType.GetHashCode() ^ ObjectHandle.GetHashCode()
			^ ((ulong)ObjectName).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DebugUtilsObjectNameInfo l, in DebugUtilsObjectNameInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ObjectType == r.ObjectType) && (l.ObjectHandle == r.ObjectHandle)
			&& (l.ObjectName == r.ObjectName)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DebugUtilsObjectNameInfo l, in DebugUtilsObjectNameInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ObjectType != r.ObjectType) || (l.ObjectHandle != r.ObjectHandle)
			|| (l.ObjectName != r.ObjectName)
			;
	}


	/// <summary>Creates a new DebugUtilsObjectNameInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DebugUtilsObjectNameInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref DebugUtilsObjectNameInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DebugUtilsObjectTagInfo : IEquatable<DebugUtilsObjectTagInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DebugUtilsObjectTagInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.ObjectType ObjectType;
	public ulong ObjectHandle;
	public ulong TagName;
	public ulong TagSize;
	public void* Tag;

	public readonly override bool Equals(object? obj) => (obj is DebugUtilsObjectTagInfo o) && (this == o);
	readonly bool IEquatable<DebugUtilsObjectTagInfo>.Equals(DebugUtilsObjectTagInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ObjectType.GetHashCode() ^ ObjectHandle.GetHashCode()
			^ TagName.GetHashCode() ^ TagSize.GetHashCode() ^ ((ulong)Tag).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DebugUtilsObjectTagInfo l, in DebugUtilsObjectTagInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ObjectType == r.ObjectType) && (l.ObjectHandle == r.ObjectHandle)
			&& (l.TagName == r.TagName) && (l.TagSize == r.TagSize) && (l.Tag == r.Tag)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DebugUtilsObjectTagInfo l, in DebugUtilsObjectTagInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ObjectType != r.ObjectType) || (l.ObjectHandle != r.ObjectHandle)
			|| (l.TagName != r.TagName) || (l.TagSize != r.TagSize) || (l.Tag != r.Tag)
			;
	}


	/// <summary>Creates a new DebugUtilsObjectTagInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DebugUtilsObjectTagInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref DebugUtilsObjectTagInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DebugUtilsLabel : IEquatable<DebugUtilsLabel>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DebugUtilsLabelEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public byte* LabelName;
	public fixed float Color[4];

	public readonly override bool Equals(object? obj) => (obj is DebugUtilsLabel o) && (this == o);
	readonly bool IEquatable<DebugUtilsLabel>.Equals(DebugUtilsLabel obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ((ulong)LabelName).GetHashCode() ^ Color[0].GetHashCode()
			^ Color[1].GetHashCode() ^ Color[2].GetHashCode() ^ Color[3].GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DebugUtilsLabel l, in DebugUtilsLabel r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.LabelName == r.LabelName) && (l.Color[0] == r.Color[0])
			&& (l.Color[1] == r.Color[1]) && (l.Color[2] == r.Color[2]) && (l.Color[3] == r.Color[3])
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DebugUtilsLabel l, in DebugUtilsLabel r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.LabelName != r.LabelName) || (l.Color[0] != r.Color[0])
			|| (l.Color[1] != r.Color[1]) || (l.Color[2] != r.Color[2]) || (l.Color[3] != r.Color[3])
			;
	}


	/// <summary>Creates a new DebugUtilsLabel value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DebugUtilsLabel value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref DebugUtilsLabel value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DebugUtilsMessengerCreateInfo : IEquatable<DebugUtilsMessengerCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DebugUtilsMessengerCreateInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.EXT.DebugUtilsMessengerCreateFlags Flags;
	public Vk.EXT.DebugUtilsMessageSeverityFlags MessageSeverity;
	public Vk.EXT.DebugUtilsMessageTypeFlags MessageType;
	public delegate* managed<Vk.EXT.DebugUtilsMessageSeverityFlags, Vk.EXT.DebugUtilsMessageTypeFlags, Vk.EXT.DebugUtilsMessengerCallbackData*, void*, Vk.Bool32> UserCallback;
	public void* UserData;

	public readonly override bool Equals(object? obj) => (obj is DebugUtilsMessengerCreateInfo o) && (this == o);
	readonly bool IEquatable<DebugUtilsMessengerCreateInfo>.Equals(DebugUtilsMessengerCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ MessageSeverity.GetHashCode()
			^ MessageType.GetHashCode() ^ ((ulong)UserCallback).GetHashCode() ^ ((ulong)UserData).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DebugUtilsMessengerCreateInfo l, in DebugUtilsMessengerCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.MessageSeverity == r.MessageSeverity)
			&& (l.MessageType == r.MessageType) && (l.UserCallback == r.UserCallback) && (l.UserData == r.UserData)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DebugUtilsMessengerCreateInfo l, in DebugUtilsMessengerCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.MessageSeverity != r.MessageSeverity)
			|| (l.MessageType != r.MessageType) || (l.UserCallback != r.UserCallback) || (l.UserData != r.UserData)
			;
	}


	/// <summary>Creates a new DebugUtilsMessengerCreateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DebugUtilsMessengerCreateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref DebugUtilsMessengerCreateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DebugUtilsMessengerCallbackData : IEquatable<DebugUtilsMessengerCallbackData>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DebugUtilsMessengerCallbackDataEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.EXT.DebugUtilsMessengerCallbackDataFlags Flags;
	public byte* MessageIdName;
	public int MessageIdNumber;
	public byte* Message;
	public uint QueueLabelCount;
	public Vk.EXT.DebugUtilsLabel* QueueLabels;
	public uint CmdBufLabelCount;
	public Vk.EXT.DebugUtilsLabel* CmdBufLabels;
	public uint ObjectCount;
	public Vk.EXT.DebugUtilsObjectNameInfo* Objects;

	public readonly override bool Equals(object? obj) => (obj is DebugUtilsMessengerCallbackData o) && (this == o);
	readonly bool IEquatable<DebugUtilsMessengerCallbackData>.Equals(DebugUtilsMessengerCallbackData obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ ((ulong)MessageIdName).GetHashCode()
			^ MessageIdNumber.GetHashCode() ^ ((ulong)Message).GetHashCode() ^ QueueLabelCount.GetHashCode() ^ ((ulong)QueueLabels).GetHashCode()
			^ CmdBufLabelCount.GetHashCode() ^ ((ulong)CmdBufLabels).GetHashCode() ^ ObjectCount.GetHashCode() ^ ((ulong)Objects).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DebugUtilsMessengerCallbackData l, in DebugUtilsMessengerCallbackData r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.MessageIdName == r.MessageIdName)
			&& (l.MessageIdNumber == r.MessageIdNumber) && (l.Message == r.Message) && (l.QueueLabelCount == r.QueueLabelCount) && (l.QueueLabels == r.QueueLabels)
			&& (l.CmdBufLabelCount == r.CmdBufLabelCount) && (l.CmdBufLabels == r.CmdBufLabels) && (l.ObjectCount == r.ObjectCount) && (l.Objects == r.Objects)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DebugUtilsMessengerCallbackData l, in DebugUtilsMessengerCallbackData r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.MessageIdName != r.MessageIdName)
			|| (l.MessageIdNumber != r.MessageIdNumber) || (l.Message != r.Message) || (l.QueueLabelCount != r.QueueLabelCount) || (l.QueueLabels != r.QueueLabels)
			|| (l.CmdBufLabelCount != r.CmdBufLabelCount) || (l.CmdBufLabels != r.CmdBufLabels) || (l.ObjectCount != r.ObjectCount) || (l.Objects != r.Objects)
			;
	}


	/// <summary>Creates a new DebugUtilsMessengerCallbackData value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DebugUtilsMessengerCallbackData value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref DebugUtilsMessengerCallbackData value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceDeviceMemoryReportFeatures : IEquatable<PhysicalDeviceDeviceMemoryReportFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceDeviceMemoryReportFeaturesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 DeviceMemoryReport;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceDeviceMemoryReportFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceDeviceMemoryReportFeatures>.Equals(PhysicalDeviceDeviceMemoryReportFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DeviceMemoryReport.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceDeviceMemoryReportFeatures l, in PhysicalDeviceDeviceMemoryReportFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DeviceMemoryReport == r.DeviceMemoryReport)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceDeviceMemoryReportFeatures l, in PhysicalDeviceDeviceMemoryReportFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DeviceMemoryReport != r.DeviceMemoryReport)
			;
	}


	/// <summary>Creates a new PhysicalDeviceDeviceMemoryReportFeatures value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceDeviceMemoryReportFeatures value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceDeviceMemoryReportFeatures value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DeviceDeviceMemoryReportCreateInfo : IEquatable<DeviceDeviceMemoryReportCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DeviceDeviceMemoryReportCreateInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.EXT.DeviceMemoryReportFlags Flags;
	public delegate* managed<Vk.EXT.DeviceMemoryReportCallbackData*, void*, void> UserCallback;
	public void* UserData;

	public readonly override bool Equals(object? obj) => (obj is DeviceDeviceMemoryReportCreateInfo o) && (this == o);
	readonly bool IEquatable<DeviceDeviceMemoryReportCreateInfo>.Equals(DeviceDeviceMemoryReportCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ ((ulong)UserCallback).GetHashCode()
			^ ((ulong)UserData).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DeviceDeviceMemoryReportCreateInfo l, in DeviceDeviceMemoryReportCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.UserCallback == r.UserCallback)
			&& (l.UserData == r.UserData)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DeviceDeviceMemoryReportCreateInfo l, in DeviceDeviceMemoryReportCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.UserCallback != r.UserCallback)
			|| (l.UserData != r.UserData)
			;
	}


	/// <summary>Creates a new DeviceDeviceMemoryReportCreateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DeviceDeviceMemoryReportCreateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref DeviceDeviceMemoryReportCreateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DeviceMemoryReportCallbackData : IEquatable<DeviceMemoryReportCallbackData>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DeviceMemoryReportCallbackDataEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.EXT.DeviceMemoryReportFlags Flags;
	public Vk.EXT.DeviceMemoryReportEventType Type;
	public ulong MemoryObjectId;
	public Vk.DeviceSize Size;
	public Vk.ObjectType ObjectType;
	public ulong ObjectHandle;
	public uint HeapIndex;

	public readonly override bool Equals(object? obj) => (obj is DeviceMemoryReportCallbackData o) && (this == o);
	readonly bool IEquatable<DeviceMemoryReportCallbackData>.Equals(DeviceMemoryReportCallbackData obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ Type.GetHashCode()
			^ MemoryObjectId.GetHashCode() ^ Size.GetHashCode() ^ ObjectType.GetHashCode() ^ ObjectHandle.GetHashCode()
			^ HeapIndex.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DeviceMemoryReportCallbackData l, in DeviceMemoryReportCallbackData r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.Type == r.Type)
			&& (l.MemoryObjectId == r.MemoryObjectId) && (l.Size == r.Size) && (l.ObjectType == r.ObjectType) && (l.ObjectHandle == r.ObjectHandle)
			&& (l.HeapIndex == r.HeapIndex)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DeviceMemoryReportCallbackData l, in DeviceMemoryReportCallbackData r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.Type != r.Type)
			|| (l.MemoryObjectId != r.MemoryObjectId) || (l.Size != r.Size) || (l.ObjectType != r.ObjectType) || (l.ObjectHandle != r.ObjectHandle)
			|| (l.HeapIndex != r.HeapIndex)
			;
	}


	/// <summary>Creates a new DeviceMemoryReportCallbackData value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DeviceMemoryReportCallbackData value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref DeviceMemoryReportCallbackData value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ImportMemoryHostPointerInfo : IEquatable<ImportMemoryHostPointerInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ImportMemoryHostPointerInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.ExternalMemoryHandleTypeFlags HandleType;
	public void* HostPointer;

	public readonly override bool Equals(object? obj) => (obj is ImportMemoryHostPointerInfo o) && (this == o);
	readonly bool IEquatable<ImportMemoryHostPointerInfo>.Equals(ImportMemoryHostPointerInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ HandleType.GetHashCode() ^ ((ulong)HostPointer).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ImportMemoryHostPointerInfo l, in ImportMemoryHostPointerInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.HandleType == r.HandleType) && (l.HostPointer == r.HostPointer)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ImportMemoryHostPointerInfo l, in ImportMemoryHostPointerInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.HandleType != r.HandleType) || (l.HostPointer != r.HostPointer)
			;
	}


	/// <summary>Creates a new ImportMemoryHostPointerInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ImportMemoryHostPointerInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref ImportMemoryHostPointerInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct MemoryHostPointerProperties : IEquatable<MemoryHostPointerProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.MemoryHostPointerPropertiesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public uint MemoryTypeBits;

	public readonly override bool Equals(object? obj) => (obj is MemoryHostPointerProperties o) && (this == o);
	readonly bool IEquatable<MemoryHostPointerProperties>.Equals(MemoryHostPointerProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MemoryTypeBits.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in MemoryHostPointerProperties l, in MemoryHostPointerProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MemoryTypeBits == r.MemoryTypeBits)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in MemoryHostPointerProperties l, in MemoryHostPointerProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MemoryTypeBits != r.MemoryTypeBits)
			;
	}


	/// <summary>Creates a new MemoryHostPointerProperties value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out MemoryHostPointerProperties value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref MemoryHostPointerProperties value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceExternalMemoryHostProperties : IEquatable<PhysicalDeviceExternalMemoryHostProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceExternalMemoryHostPropertiesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.DeviceSize MinImportedHostPointerAlignment;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceExternalMemoryHostProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceExternalMemoryHostProperties>.Equals(PhysicalDeviceExternalMemoryHostProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MinImportedHostPointerAlignment.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceExternalMemoryHostProperties l, in PhysicalDeviceExternalMemoryHostProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MinImportedHostPointerAlignment == r.MinImportedHostPointerAlignment)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceExternalMemoryHostProperties l, in PhysicalDeviceExternalMemoryHostProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MinImportedHostPointerAlignment != r.MinImportedHostPointerAlignment)
			;
	}


	/// <summary>Creates a new PhysicalDeviceExternalMemoryHostProperties value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceExternalMemoryHostProperties value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceExternalMemoryHostProperties value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceConservativeRasterizationProperties : IEquatable<PhysicalDeviceConservativeRasterizationProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceConservativeRasterizationPropertiesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public float PrimitiveOverestimationSize;
	public float MaxExtraPrimitiveOverestimationSize;
	public float ExtraPrimitiveOverestimationSizeGranularity;
	public Vk.Bool32 PrimitiveUnderestimation;
	public Vk.Bool32 ConservativePointAndLineRasterization;
	public Vk.Bool32 DegenerateTrianglesRasterized;
	public Vk.Bool32 DegenerateLinesRasterized;
	public Vk.Bool32 FullyCoveredFragmentShaderInputVariable;
	public Vk.Bool32 ConservativeRasterizationPostDepthCoverage;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceConservativeRasterizationProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceConservativeRasterizationProperties>.Equals(PhysicalDeviceConservativeRasterizationProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ PrimitiveOverestimationSize.GetHashCode() ^ MaxExtraPrimitiveOverestimationSize.GetHashCode()
			^ ExtraPrimitiveOverestimationSizeGranularity.GetHashCode() ^ PrimitiveUnderestimation.GetHashCode() ^ ConservativePointAndLineRasterization.GetHashCode() ^ DegenerateTrianglesRasterized.GetHashCode()
			^ DegenerateLinesRasterized.GetHashCode() ^ FullyCoveredFragmentShaderInputVariable.GetHashCode() ^ ConservativeRasterizationPostDepthCoverage.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceConservativeRasterizationProperties l, in PhysicalDeviceConservativeRasterizationProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.PrimitiveOverestimationSize == r.PrimitiveOverestimationSize) && (l.MaxExtraPrimitiveOverestimationSize == r.MaxExtraPrimitiveOverestimationSize)
			&& (l.ExtraPrimitiveOverestimationSizeGranularity == r.ExtraPrimitiveOverestimationSizeGranularity) && (l.PrimitiveUnderestimation == r.PrimitiveUnderestimation) && (l.ConservativePointAndLineRasterization == r.ConservativePointAndLineRasterization) && (l.DegenerateTrianglesRasterized == r.DegenerateTrianglesRasterized)
			&& (l.DegenerateLinesRasterized == r.DegenerateLinesRasterized) && (l.FullyCoveredFragmentShaderInputVariable == r.FullyCoveredFragmentShaderInputVariable) && (l.ConservativeRasterizationPostDepthCoverage == r.ConservativeRasterizationPostDepthCoverage)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceConservativeRasterizationProperties l, in PhysicalDeviceConservativeRasterizationProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.PrimitiveOverestimationSize != r.PrimitiveOverestimationSize) || (l.MaxExtraPrimitiveOverestimationSize != r.MaxExtraPrimitiveOverestimationSize)
			|| (l.ExtraPrimitiveOverestimationSizeGranularity != r.ExtraPrimitiveOverestimationSizeGranularity) || (l.PrimitiveUnderestimation != r.PrimitiveUnderestimation) || (l.ConservativePointAndLineRasterization != r.ConservativePointAndLineRasterization) || (l.DegenerateTrianglesRasterized != r.DegenerateTrianglesRasterized)
			|| (l.DegenerateLinesRasterized != r.DegenerateLinesRasterized) || (l.FullyCoveredFragmentShaderInputVariable != r.FullyCoveredFragmentShaderInputVariable) || (l.ConservativeRasterizationPostDepthCoverage != r.ConservativeRasterizationPostDepthCoverage)
			;
	}


	/// <summary>Creates a new PhysicalDeviceConservativeRasterizationProperties value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceConservativeRasterizationProperties value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceConservativeRasterizationProperties value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct CalibratedTimestampInfo : IEquatable<CalibratedTimestampInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.CalibratedTimestampInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.EXT.TimeDomain TimeDomain;

	public readonly override bool Equals(object? obj) => (obj is CalibratedTimestampInfo o) && (this == o);
	readonly bool IEquatable<CalibratedTimestampInfo>.Equals(CalibratedTimestampInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ TimeDomain.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in CalibratedTimestampInfo l, in CalibratedTimestampInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.TimeDomain == r.TimeDomain)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in CalibratedTimestampInfo l, in CalibratedTimestampInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.TimeDomain != r.TimeDomain)
			;
	}


	/// <summary>Creates a new CalibratedTimestampInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out CalibratedTimestampInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref CalibratedTimestampInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PipelineRasterizationConservativeStateCreateInfo : IEquatable<PipelineRasterizationConservativeStateCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PipelineRasterizationConservativeStateCreateInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.EXT.PipelineRasterizationConservativeStateCreateFlags Flags;
	public Vk.EXT.ConservativeRasterizationMode ConservativeRasterizationMode;
	public float ExtraPrimitiveOverestimationSize;

	public readonly override bool Equals(object? obj) => (obj is PipelineRasterizationConservativeStateCreateInfo o) && (this == o);
	readonly bool IEquatable<PipelineRasterizationConservativeStateCreateInfo>.Equals(PipelineRasterizationConservativeStateCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ ConservativeRasterizationMode.GetHashCode()
			^ ExtraPrimitiveOverestimationSize.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PipelineRasterizationConservativeStateCreateInfo l, in PipelineRasterizationConservativeStateCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.ConservativeRasterizationMode == r.ConservativeRasterizationMode)
			&& (l.ExtraPrimitiveOverestimationSize == r.ExtraPrimitiveOverestimationSize)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PipelineRasterizationConservativeStateCreateInfo l, in PipelineRasterizationConservativeStateCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.ConservativeRasterizationMode != r.ConservativeRasterizationMode)
			|| (l.ExtraPrimitiveOverestimationSize != r.ExtraPrimitiveOverestimationSize)
			;
	}


	/// <summary>Creates a new PipelineRasterizationConservativeStateCreateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PipelineRasterizationConservativeStateCreateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PipelineRasterizationConservativeStateCreateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceDescriptorIndexingFeatures : IEquatable<PhysicalDeviceDescriptorIndexingFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceDescriptorIndexingFeatures;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 ShaderInputAttachmentArrayDynamicIndexing;
	public Vk.Bool32 ShaderUniformTexelBufferArrayDynamicIndexing;
	public Vk.Bool32 ShaderStorageTexelBufferArrayDynamicIndexing;
	public Vk.Bool32 ShaderUniformBufferArrayNonUniformIndexing;
	public Vk.Bool32 ShaderSampledImageArrayNonUniformIndexing;
	public Vk.Bool32 ShaderStorageBufferArrayNonUniformIndexing;
	public Vk.Bool32 ShaderStorageImageArrayNonUniformIndexing;
	public Vk.Bool32 ShaderInputAttachmentArrayNonUniformIndexing;
	public Vk.Bool32 ShaderUniformTexelBufferArrayNonUniformIndexing;
	public Vk.Bool32 ShaderStorageTexelBufferArrayNonUniformIndexing;
	public Vk.Bool32 DescriptorBindingUniformBufferUpdateAfterBind;
	public Vk.Bool32 DescriptorBindingSampledImageUpdateAfterBind;
	public Vk.Bool32 DescriptorBindingStorageImageUpdateAfterBind;
	public Vk.Bool32 DescriptorBindingStorageBufferUpdateAfterBind;
	public Vk.Bool32 DescriptorBindingUniformTexelBufferUpdateAfterBind;
	public Vk.Bool32 DescriptorBindingStorageTexelBufferUpdateAfterBind;
	public Vk.Bool32 DescriptorBindingUpdateUnusedWhilePending;
	public Vk.Bool32 DescriptorBindingPartiallyBound;
	public Vk.Bool32 DescriptorBindingVariableDescriptorCount;
	public Vk.Bool32 RuntimeDescriptorArray;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceDescriptorIndexingFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceDescriptorIndexingFeatures>.Equals(PhysicalDeviceDescriptorIndexingFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ShaderInputAttachmentArrayDynamicIndexing.GetHashCode() ^ ShaderUniformTexelBufferArrayDynamicIndexing.GetHashCode()
			^ ShaderStorageTexelBufferArrayDynamicIndexing.GetHashCode() ^ ShaderUniformBufferArrayNonUniformIndexing.GetHashCode() ^ ShaderSampledImageArrayNonUniformIndexing.GetHashCode() ^ ShaderStorageBufferArrayNonUniformIndexing.GetHashCode()
			^ ShaderStorageImageArrayNonUniformIndexing.GetHashCode() ^ ShaderInputAttachmentArrayNonUniformIndexing.GetHashCode() ^ ShaderUniformTexelBufferArrayNonUniformIndexing.GetHashCode() ^ ShaderStorageTexelBufferArrayNonUniformIndexing.GetHashCode()
			^ DescriptorBindingUniformBufferUpdateAfterBind.GetHashCode() ^ DescriptorBindingSampledImageUpdateAfterBind.GetHashCode() ^ DescriptorBindingStorageImageUpdateAfterBind.GetHashCode() ^ DescriptorBindingStorageBufferUpdateAfterBind.GetHashCode()
			^ DescriptorBindingUniformTexelBufferUpdateAfterBind.GetHashCode() ^ DescriptorBindingStorageTexelBufferUpdateAfterBind.GetHashCode() ^ DescriptorBindingUpdateUnusedWhilePending.GetHashCode() ^ DescriptorBindingPartiallyBound.GetHashCode()
			^ DescriptorBindingVariableDescriptorCount.GetHashCode() ^ RuntimeDescriptorArray.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceDescriptorIndexingFeatures l, in PhysicalDeviceDescriptorIndexingFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ShaderInputAttachmentArrayDynamicIndexing == r.ShaderInputAttachmentArrayDynamicIndexing) && (l.ShaderUniformTexelBufferArrayDynamicIndexing == r.ShaderUniformTexelBufferArrayDynamicIndexing)
			&& (l.ShaderStorageTexelBufferArrayDynamicIndexing == r.ShaderStorageTexelBufferArrayDynamicIndexing) && (l.ShaderUniformBufferArrayNonUniformIndexing == r.ShaderUniformBufferArrayNonUniformIndexing) && (l.ShaderSampledImageArrayNonUniformIndexing == r.ShaderSampledImageArrayNonUniformIndexing) && (l.ShaderStorageBufferArrayNonUniformIndexing == r.ShaderStorageBufferArrayNonUniformIndexing)
			&& (l.ShaderStorageImageArrayNonUniformIndexing == r.ShaderStorageImageArrayNonUniformIndexing) && (l.ShaderInputAttachmentArrayNonUniformIndexing == r.ShaderInputAttachmentArrayNonUniformIndexing) && (l.ShaderUniformTexelBufferArrayNonUniformIndexing == r.ShaderUniformTexelBufferArrayNonUniformIndexing) && (l.ShaderStorageTexelBufferArrayNonUniformIndexing == r.ShaderStorageTexelBufferArrayNonUniformIndexing)
			&& (l.DescriptorBindingUniformBufferUpdateAfterBind == r.DescriptorBindingUniformBufferUpdateAfterBind) && (l.DescriptorBindingSampledImageUpdateAfterBind == r.DescriptorBindingSampledImageUpdateAfterBind) && (l.DescriptorBindingStorageImageUpdateAfterBind == r.DescriptorBindingStorageImageUpdateAfterBind) && (l.DescriptorBindingStorageBufferUpdateAfterBind == r.DescriptorBindingStorageBufferUpdateAfterBind)
			&& (l.DescriptorBindingUniformTexelBufferUpdateAfterBind == r.DescriptorBindingUniformTexelBufferUpdateAfterBind) && (l.DescriptorBindingStorageTexelBufferUpdateAfterBind == r.DescriptorBindingStorageTexelBufferUpdateAfterBind) && (l.DescriptorBindingUpdateUnusedWhilePending == r.DescriptorBindingUpdateUnusedWhilePending) && (l.DescriptorBindingPartiallyBound == r.DescriptorBindingPartiallyBound)
			&& (l.DescriptorBindingVariableDescriptorCount == r.DescriptorBindingVariableDescriptorCount) && (l.RuntimeDescriptorArray == r.RuntimeDescriptorArray)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceDescriptorIndexingFeatures l, in PhysicalDeviceDescriptorIndexingFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ShaderInputAttachmentArrayDynamicIndexing != r.ShaderInputAttachmentArrayDynamicIndexing) || (l.ShaderUniformTexelBufferArrayDynamicIndexing != r.ShaderUniformTexelBufferArrayDynamicIndexing)
			|| (l.ShaderStorageTexelBufferArrayDynamicIndexing != r.ShaderStorageTexelBufferArrayDynamicIndexing) || (l.ShaderUniformBufferArrayNonUniformIndexing != r.ShaderUniformBufferArrayNonUniformIndexing) || (l.ShaderSampledImageArrayNonUniformIndexing != r.ShaderSampledImageArrayNonUniformIndexing) || (l.ShaderStorageBufferArrayNonUniformIndexing != r.ShaderStorageBufferArrayNonUniformIndexing)
			|| (l.ShaderStorageImageArrayNonUniformIndexing != r.ShaderStorageImageArrayNonUniformIndexing) || (l.ShaderInputAttachmentArrayNonUniformIndexing != r.ShaderInputAttachmentArrayNonUniformIndexing) || (l.ShaderUniformTexelBufferArrayNonUniformIndexing != r.ShaderUniformTexelBufferArrayNonUniformIndexing) || (l.ShaderStorageTexelBufferArrayNonUniformIndexing != r.ShaderStorageTexelBufferArrayNonUniformIndexing)
			|| (l.DescriptorBindingUniformBufferUpdateAfterBind != r.DescriptorBindingUniformBufferUpdateAfterBind) || (l.DescriptorBindingSampledImageUpdateAfterBind != r.DescriptorBindingSampledImageUpdateAfterBind) || (l.DescriptorBindingStorageImageUpdateAfterBind != r.DescriptorBindingStorageImageUpdateAfterBind) || (l.DescriptorBindingStorageBufferUpdateAfterBind != r.DescriptorBindingStorageBufferUpdateAfterBind)
			|| (l.DescriptorBindingUniformTexelBufferUpdateAfterBind != r.DescriptorBindingUniformTexelBufferUpdateAfterBind) || (l.DescriptorBindingStorageTexelBufferUpdateAfterBind != r.DescriptorBindingStorageTexelBufferUpdateAfterBind) || (l.DescriptorBindingUpdateUnusedWhilePending != r.DescriptorBindingUpdateUnusedWhilePending) || (l.DescriptorBindingPartiallyBound != r.DescriptorBindingPartiallyBound)
			|| (l.DescriptorBindingVariableDescriptorCount != r.DescriptorBindingVariableDescriptorCount) || (l.RuntimeDescriptorArray != r.RuntimeDescriptorArray)
			;
	}


	/// <summary>Creates a new PhysicalDeviceDescriptorIndexingFeatures value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceDescriptorIndexingFeatures value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceDescriptorIndexingFeatures value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceDescriptorIndexingProperties : IEquatable<PhysicalDeviceDescriptorIndexingProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceDescriptorIndexingProperties;

	public Vk.StructureType sType;
	public void* pNext;
	public uint MaxUpdateAfterBindDescriptorsInAllPools;
	public Vk.Bool32 ShaderUniformBufferArrayNonUniformIndexingNative;
	public Vk.Bool32 ShaderSampledImageArrayNonUniformIndexingNative;
	public Vk.Bool32 ShaderStorageBufferArrayNonUniformIndexingNative;
	public Vk.Bool32 ShaderStorageImageArrayNonUniformIndexingNative;
	public Vk.Bool32 ShaderInputAttachmentArrayNonUniformIndexingNative;
	public Vk.Bool32 RobustBufferAccessUpdateAfterBind;
	public Vk.Bool32 QuadDivergentImplicitLod;
	public uint MaxPerStageDescriptorUpdateAfterBindSamplers;
	public uint MaxPerStageDescriptorUpdateAfterBindUniformBuffers;
	public uint MaxPerStageDescriptorUpdateAfterBindStorageBuffers;
	public uint MaxPerStageDescriptorUpdateAfterBindSampledImages;
	public uint MaxPerStageDescriptorUpdateAfterBindStorageImages;
	public uint MaxPerStageDescriptorUpdateAfterBindInputAttachments;
	public uint MaxPerStageUpdateAfterBindResources;
	public uint MaxDescriptorSetUpdateAfterBindSamplers;
	public uint MaxDescriptorSetUpdateAfterBindUniformBuffers;
	public uint MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic;
	public uint MaxDescriptorSetUpdateAfterBindStorageBuffers;
	public uint MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic;
	public uint MaxDescriptorSetUpdateAfterBindSampledImages;
	public uint MaxDescriptorSetUpdateAfterBindStorageImages;
	public uint MaxDescriptorSetUpdateAfterBindInputAttachments;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceDescriptorIndexingProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceDescriptorIndexingProperties>.Equals(PhysicalDeviceDescriptorIndexingProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MaxUpdateAfterBindDescriptorsInAllPools.GetHashCode() ^ ShaderUniformBufferArrayNonUniformIndexingNative.GetHashCode()
			^ ShaderSampledImageArrayNonUniformIndexingNative.GetHashCode() ^ ShaderStorageBufferArrayNonUniformIndexingNative.GetHashCode() ^ ShaderStorageImageArrayNonUniformIndexingNative.GetHashCode() ^ ShaderInputAttachmentArrayNonUniformIndexingNative.GetHashCode()
			^ RobustBufferAccessUpdateAfterBind.GetHashCode() ^ QuadDivergentImplicitLod.GetHashCode() ^ MaxPerStageDescriptorUpdateAfterBindSamplers.GetHashCode() ^ MaxPerStageDescriptorUpdateAfterBindUniformBuffers.GetHashCode()
			^ MaxPerStageDescriptorUpdateAfterBindStorageBuffers.GetHashCode() ^ MaxPerStageDescriptorUpdateAfterBindSampledImages.GetHashCode() ^ MaxPerStageDescriptorUpdateAfterBindStorageImages.GetHashCode() ^ MaxPerStageDescriptorUpdateAfterBindInputAttachments.GetHashCode()
			^ MaxPerStageUpdateAfterBindResources.GetHashCode() ^ MaxDescriptorSetUpdateAfterBindSamplers.GetHashCode() ^ MaxDescriptorSetUpdateAfterBindUniformBuffers.GetHashCode() ^ MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic.GetHashCode()
			^ MaxDescriptorSetUpdateAfterBindStorageBuffers.GetHashCode() ^ MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic.GetHashCode() ^ MaxDescriptorSetUpdateAfterBindSampledImages.GetHashCode() ^ MaxDescriptorSetUpdateAfterBindStorageImages.GetHashCode()
			^ MaxDescriptorSetUpdateAfterBindInputAttachments.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceDescriptorIndexingProperties l, in PhysicalDeviceDescriptorIndexingProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MaxUpdateAfterBindDescriptorsInAllPools == r.MaxUpdateAfterBindDescriptorsInAllPools) && (l.ShaderUniformBufferArrayNonUniformIndexingNative == r.ShaderUniformBufferArrayNonUniformIndexingNative)
			&& (l.ShaderSampledImageArrayNonUniformIndexingNative == r.ShaderSampledImageArrayNonUniformIndexingNative) && (l.ShaderStorageBufferArrayNonUniformIndexingNative == r.ShaderStorageBufferArrayNonUniformIndexingNative) && (l.ShaderStorageImageArrayNonUniformIndexingNative == r.ShaderStorageImageArrayNonUniformIndexingNative) && (l.ShaderInputAttachmentArrayNonUniformIndexingNative == r.ShaderInputAttachmentArrayNonUniformIndexingNative)
			&& (l.RobustBufferAccessUpdateAfterBind == r.RobustBufferAccessUpdateAfterBind) && (l.QuadDivergentImplicitLod == r.QuadDivergentImplicitLod) && (l.MaxPerStageDescriptorUpdateAfterBindSamplers == r.MaxPerStageDescriptorUpdateAfterBindSamplers) && (l.MaxPerStageDescriptorUpdateAfterBindUniformBuffers == r.MaxPerStageDescriptorUpdateAfterBindUniformBuffers)
			&& (l.MaxPerStageDescriptorUpdateAfterBindStorageBuffers == r.MaxPerStageDescriptorUpdateAfterBindStorageBuffers) && (l.MaxPerStageDescriptorUpdateAfterBindSampledImages == r.MaxPerStageDescriptorUpdateAfterBindSampledImages) && (l.MaxPerStageDescriptorUpdateAfterBindStorageImages == r.MaxPerStageDescriptorUpdateAfterBindStorageImages) && (l.MaxPerStageDescriptorUpdateAfterBindInputAttachments == r.MaxPerStageDescriptorUpdateAfterBindInputAttachments)
			&& (l.MaxPerStageUpdateAfterBindResources == r.MaxPerStageUpdateAfterBindResources) && (l.MaxDescriptorSetUpdateAfterBindSamplers == r.MaxDescriptorSetUpdateAfterBindSamplers) && (l.MaxDescriptorSetUpdateAfterBindUniformBuffers == r.MaxDescriptorSetUpdateAfterBindUniformBuffers) && (l.MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic == r.MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic)
			&& (l.MaxDescriptorSetUpdateAfterBindStorageBuffers == r.MaxDescriptorSetUpdateAfterBindStorageBuffers) && (l.MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic == r.MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic) && (l.MaxDescriptorSetUpdateAfterBindSampledImages == r.MaxDescriptorSetUpdateAfterBindSampledImages) && (l.MaxDescriptorSetUpdateAfterBindStorageImages == r.MaxDescriptorSetUpdateAfterBindStorageImages)
			&& (l.MaxDescriptorSetUpdateAfterBindInputAttachments == r.MaxDescriptorSetUpdateAfterBindInputAttachments)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceDescriptorIndexingProperties l, in PhysicalDeviceDescriptorIndexingProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MaxUpdateAfterBindDescriptorsInAllPools != r.MaxUpdateAfterBindDescriptorsInAllPools) || (l.ShaderUniformBufferArrayNonUniformIndexingNative != r.ShaderUniformBufferArrayNonUniformIndexingNative)
			|| (l.ShaderSampledImageArrayNonUniformIndexingNative != r.ShaderSampledImageArrayNonUniformIndexingNative) || (l.ShaderStorageBufferArrayNonUniformIndexingNative != r.ShaderStorageBufferArrayNonUniformIndexingNative) || (l.ShaderStorageImageArrayNonUniformIndexingNative != r.ShaderStorageImageArrayNonUniformIndexingNative) || (l.ShaderInputAttachmentArrayNonUniformIndexingNative != r.ShaderInputAttachmentArrayNonUniformIndexingNative)
			|| (l.RobustBufferAccessUpdateAfterBind != r.RobustBufferAccessUpdateAfterBind) || (l.QuadDivergentImplicitLod != r.QuadDivergentImplicitLod) || (l.MaxPerStageDescriptorUpdateAfterBindSamplers != r.MaxPerStageDescriptorUpdateAfterBindSamplers) || (l.MaxPerStageDescriptorUpdateAfterBindUniformBuffers != r.MaxPerStageDescriptorUpdateAfterBindUniformBuffers)
			|| (l.MaxPerStageDescriptorUpdateAfterBindStorageBuffers != r.MaxPerStageDescriptorUpdateAfterBindStorageBuffers) || (l.MaxPerStageDescriptorUpdateAfterBindSampledImages != r.MaxPerStageDescriptorUpdateAfterBindSampledImages) || (l.MaxPerStageDescriptorUpdateAfterBindStorageImages != r.MaxPerStageDescriptorUpdateAfterBindStorageImages) || (l.MaxPerStageDescriptorUpdateAfterBindInputAttachments != r.MaxPerStageDescriptorUpdateAfterBindInputAttachments)
			|| (l.MaxPerStageUpdateAfterBindResources != r.MaxPerStageUpdateAfterBindResources) || (l.MaxDescriptorSetUpdateAfterBindSamplers != r.MaxDescriptorSetUpdateAfterBindSamplers) || (l.MaxDescriptorSetUpdateAfterBindUniformBuffers != r.MaxDescriptorSetUpdateAfterBindUniformBuffers) || (l.MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic != r.MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic)
			|| (l.MaxDescriptorSetUpdateAfterBindStorageBuffers != r.MaxDescriptorSetUpdateAfterBindStorageBuffers) || (l.MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic != r.MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic) || (l.MaxDescriptorSetUpdateAfterBindSampledImages != r.MaxDescriptorSetUpdateAfterBindSampledImages) || (l.MaxDescriptorSetUpdateAfterBindStorageImages != r.MaxDescriptorSetUpdateAfterBindStorageImages)
			|| (l.MaxDescriptorSetUpdateAfterBindInputAttachments != r.MaxDescriptorSetUpdateAfterBindInputAttachments)
			;
	}


	/// <summary>Creates a new PhysicalDeviceDescriptorIndexingProperties value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceDescriptorIndexingProperties value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceDescriptorIndexingProperties value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DescriptorSetLayoutBindingFlagsCreateInfo : IEquatable<DescriptorSetLayoutBindingFlagsCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DescriptorSetLayoutBindingFlagsCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public uint BindingCount;
	public Vk.DescriptorBindingFlags* BindingFlags;

	public readonly override bool Equals(object? obj) => (obj is DescriptorSetLayoutBindingFlagsCreateInfo o) && (this == o);
	readonly bool IEquatable<DescriptorSetLayoutBindingFlagsCreateInfo>.Equals(DescriptorSetLayoutBindingFlagsCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ BindingCount.GetHashCode() ^ ((ulong)BindingFlags).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DescriptorSetLayoutBindingFlagsCreateInfo l, in DescriptorSetLayoutBindingFlagsCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.BindingCount == r.BindingCount) && (l.BindingFlags == r.BindingFlags)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DescriptorSetLayoutBindingFlagsCreateInfo l, in DescriptorSetLayoutBindingFlagsCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.BindingCount != r.BindingCount) || (l.BindingFlags != r.BindingFlags)
			;
	}


	/// <summary>Creates a new DescriptorSetLayoutBindingFlagsCreateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DescriptorSetLayoutBindingFlagsCreateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref DescriptorSetLayoutBindingFlagsCreateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DescriptorSetVariableDescriptorCountAllocateInfo : IEquatable<DescriptorSetVariableDescriptorCountAllocateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DescriptorSetVariableDescriptorCountAllocateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public uint DescriptorSetCount;
	public uint* DescriptorCounts;

	public readonly override bool Equals(object? obj) => (obj is DescriptorSetVariableDescriptorCountAllocateInfo o) && (this == o);
	readonly bool IEquatable<DescriptorSetVariableDescriptorCountAllocateInfo>.Equals(DescriptorSetVariableDescriptorCountAllocateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DescriptorSetCount.GetHashCode() ^ ((ulong)DescriptorCounts).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DescriptorSetVariableDescriptorCountAllocateInfo l, in DescriptorSetVariableDescriptorCountAllocateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DescriptorSetCount == r.DescriptorSetCount) && (l.DescriptorCounts == r.DescriptorCounts)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DescriptorSetVariableDescriptorCountAllocateInfo l, in DescriptorSetVariableDescriptorCountAllocateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DescriptorSetCount != r.DescriptorSetCount) || (l.DescriptorCounts != r.DescriptorCounts)
			;
	}


	/// <summary>Creates a new DescriptorSetVariableDescriptorCountAllocateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DescriptorSetVariableDescriptorCountAllocateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref DescriptorSetVariableDescriptorCountAllocateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DescriptorSetVariableDescriptorCountLayoutSupport : IEquatable<DescriptorSetVariableDescriptorCountLayoutSupport>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DescriptorSetVariableDescriptorCountLayoutSupport;

	public Vk.StructureType sType;
	public void* pNext;
	public uint MaxVariableDescriptorCount;

	public readonly override bool Equals(object? obj) => (obj is DescriptorSetVariableDescriptorCountLayoutSupport o) && (this == o);
	readonly bool IEquatable<DescriptorSetVariableDescriptorCountLayoutSupport>.Equals(DescriptorSetVariableDescriptorCountLayoutSupport obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MaxVariableDescriptorCount.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DescriptorSetVariableDescriptorCountLayoutSupport l, in DescriptorSetVariableDescriptorCountLayoutSupport r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MaxVariableDescriptorCount == r.MaxVariableDescriptorCount)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DescriptorSetVariableDescriptorCountLayoutSupport l, in DescriptorSetVariableDescriptorCountLayoutSupport r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MaxVariableDescriptorCount != r.MaxVariableDescriptorCount)
			;
	}


	/// <summary>Creates a new DescriptorSetVariableDescriptorCountLayoutSupport value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DescriptorSetVariableDescriptorCountLayoutSupport value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref DescriptorSetVariableDescriptorCountLayoutSupport value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VertexInputBindingDivisorDescription : IEquatable<VertexInputBindingDivisorDescription>
{
	public uint Binding;
	public uint Divisor;

	public readonly override bool Equals(object? obj) => (obj is VertexInputBindingDivisorDescription o) && (this == o);
	readonly bool IEquatable<VertexInputBindingDivisorDescription>.Equals(VertexInputBindingDivisorDescription obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Binding.GetHashCode() ^ Divisor.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VertexInputBindingDivisorDescription l, in VertexInputBindingDivisorDescription r)
	{
		return
			(l.Binding == r.Binding) && (l.Divisor == r.Divisor)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VertexInputBindingDivisorDescription l, in VertexInputBindingDivisorDescription r)
	{
		return
			(l.Binding != r.Binding) || (l.Divisor != r.Divisor)
			;
	}

}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PipelineVertexInputDivisorStateCreateInfo : IEquatable<PipelineVertexInputDivisorStateCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PipelineVertexInputDivisorStateCreateInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public uint VertexBindingDivisorCount;
	public Vk.EXT.VertexInputBindingDivisorDescription* VertexBindingDivisors;

	public readonly override bool Equals(object? obj) => (obj is PipelineVertexInputDivisorStateCreateInfo o) && (this == o);
	readonly bool IEquatable<PipelineVertexInputDivisorStateCreateInfo>.Equals(PipelineVertexInputDivisorStateCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ VertexBindingDivisorCount.GetHashCode() ^ ((ulong)VertexBindingDivisors).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PipelineVertexInputDivisorStateCreateInfo l, in PipelineVertexInputDivisorStateCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.VertexBindingDivisorCount == r.VertexBindingDivisorCount) && (l.VertexBindingDivisors == r.VertexBindingDivisors)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PipelineVertexInputDivisorStateCreateInfo l, in PipelineVertexInputDivisorStateCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.VertexBindingDivisorCount != r.VertexBindingDivisorCount) || (l.VertexBindingDivisors != r.VertexBindingDivisors)
			;
	}


	/// <summary>Creates a new PipelineVertexInputDivisorStateCreateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PipelineVertexInputDivisorStateCreateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PipelineVertexInputDivisorStateCreateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceVertexAttributeDivisorProperties : IEquatable<PhysicalDeviceVertexAttributeDivisorProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceVertexAttributeDivisorPropertiesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public uint MaxVertexAttribDivisor;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceVertexAttributeDivisorProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceVertexAttributeDivisorProperties>.Equals(PhysicalDeviceVertexAttributeDivisorProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MaxVertexAttribDivisor.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceVertexAttributeDivisorProperties l, in PhysicalDeviceVertexAttributeDivisorProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MaxVertexAttribDivisor == r.MaxVertexAttribDivisor)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceVertexAttributeDivisorProperties l, in PhysicalDeviceVertexAttributeDivisorProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MaxVertexAttribDivisor != r.MaxVertexAttribDivisor)
			;
	}


	/// <summary>Creates a new PhysicalDeviceVertexAttributeDivisorProperties value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceVertexAttributeDivisorProperties value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceVertexAttributeDivisorProperties value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDevicePCIBusInfoProperties : IEquatable<PhysicalDevicePCIBusInfoProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDevicePciBusInfoPropertiesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public uint PciDomain;
	public uint PciBus;
	public uint PciDevice;
	public uint PciFunction;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDevicePCIBusInfoProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDevicePCIBusInfoProperties>.Equals(PhysicalDevicePCIBusInfoProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ PciDomain.GetHashCode() ^ PciBus.GetHashCode()
			^ PciDevice.GetHashCode() ^ PciFunction.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDevicePCIBusInfoProperties l, in PhysicalDevicePCIBusInfoProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.PciDomain == r.PciDomain) && (l.PciBus == r.PciBus)
			&& (l.PciDevice == r.PciDevice) && (l.PciFunction == r.PciFunction)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDevicePCIBusInfoProperties l, in PhysicalDevicePCIBusInfoProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.PciDomain != r.PciDomain) || (l.PciBus != r.PciBus)
			|| (l.PciDevice != r.PciDevice) || (l.PciFunction != r.PciFunction)
			;
	}


	/// <summary>Creates a new PhysicalDevicePCIBusInfoProperties value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDevicePCIBusInfoProperties value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDevicePCIBusInfoProperties value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct CommandBufferInheritanceConditionalRenderingInfo : IEquatable<CommandBufferInheritanceConditionalRenderingInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.CommandBufferInheritanceConditionalRenderingInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 ConditionalRenderingEnable;

	public readonly override bool Equals(object? obj) => (obj is CommandBufferInheritanceConditionalRenderingInfo o) && (this == o);
	readonly bool IEquatable<CommandBufferInheritanceConditionalRenderingInfo>.Equals(CommandBufferInheritanceConditionalRenderingInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ConditionalRenderingEnable.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in CommandBufferInheritanceConditionalRenderingInfo l, in CommandBufferInheritanceConditionalRenderingInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ConditionalRenderingEnable == r.ConditionalRenderingEnable)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in CommandBufferInheritanceConditionalRenderingInfo l, in CommandBufferInheritanceConditionalRenderingInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ConditionalRenderingEnable != r.ConditionalRenderingEnable)
			;
	}


	/// <summary>Creates a new CommandBufferInheritanceConditionalRenderingInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out CommandBufferInheritanceConditionalRenderingInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref CommandBufferInheritanceConditionalRenderingInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceConditionalRenderingFeatures : IEquatable<PhysicalDeviceConditionalRenderingFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceConditionalRenderingFeaturesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 ConditionalRendering;
	public Vk.Bool32 InheritedConditionalRendering;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceConditionalRenderingFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceConditionalRenderingFeatures>.Equals(PhysicalDeviceConditionalRenderingFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ConditionalRendering.GetHashCode() ^ InheritedConditionalRendering.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceConditionalRenderingFeatures l, in PhysicalDeviceConditionalRenderingFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ConditionalRendering == r.ConditionalRendering) && (l.InheritedConditionalRendering == r.InheritedConditionalRendering)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceConditionalRenderingFeatures l, in PhysicalDeviceConditionalRenderingFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ConditionalRendering != r.ConditionalRendering) || (l.InheritedConditionalRendering != r.InheritedConditionalRendering)
			;
	}


	/// <summary>Creates a new PhysicalDeviceConditionalRenderingFeatures value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceConditionalRenderingFeatures value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceConditionalRenderingFeatures value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceShaderAtomicFloatFeatures : IEquatable<PhysicalDeviceShaderAtomicFloatFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceShaderAtomicFloatFeaturesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 ShaderBufferFloat32Atomics;
	public Vk.Bool32 ShaderBufferFloat32AtomicAdd;
	public Vk.Bool32 ShaderBufferFloat64Atomics;
	public Vk.Bool32 ShaderBufferFloat64AtomicAdd;
	public Vk.Bool32 ShaderSharedFloat32Atomics;
	public Vk.Bool32 ShaderSharedFloat32AtomicAdd;
	public Vk.Bool32 ShaderSharedFloat64Atomics;
	public Vk.Bool32 ShaderSharedFloat64AtomicAdd;
	public Vk.Bool32 ShaderImageFloat32Atomics;
	public Vk.Bool32 ShaderImageFloat32AtomicAdd;
	public Vk.Bool32 SparseImageFloat32Atomics;
	public Vk.Bool32 SparseImageFloat32AtomicAdd;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceShaderAtomicFloatFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceShaderAtomicFloatFeatures>.Equals(PhysicalDeviceShaderAtomicFloatFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ShaderBufferFloat32Atomics.GetHashCode() ^ ShaderBufferFloat32AtomicAdd.GetHashCode()
			^ ShaderBufferFloat64Atomics.GetHashCode() ^ ShaderBufferFloat64AtomicAdd.GetHashCode() ^ ShaderSharedFloat32Atomics.GetHashCode() ^ ShaderSharedFloat32AtomicAdd.GetHashCode()
			^ ShaderSharedFloat64Atomics.GetHashCode() ^ ShaderSharedFloat64AtomicAdd.GetHashCode() ^ ShaderImageFloat32Atomics.GetHashCode() ^ ShaderImageFloat32AtomicAdd.GetHashCode()
			^ SparseImageFloat32Atomics.GetHashCode() ^ SparseImageFloat32AtomicAdd.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceShaderAtomicFloatFeatures l, in PhysicalDeviceShaderAtomicFloatFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ShaderBufferFloat32Atomics == r.ShaderBufferFloat32Atomics) && (l.ShaderBufferFloat32AtomicAdd == r.ShaderBufferFloat32AtomicAdd)
			&& (l.ShaderBufferFloat64Atomics == r.ShaderBufferFloat64Atomics) && (l.ShaderBufferFloat64AtomicAdd == r.ShaderBufferFloat64AtomicAdd) && (l.ShaderSharedFloat32Atomics == r.ShaderSharedFloat32Atomics) && (l.ShaderSharedFloat32AtomicAdd == r.ShaderSharedFloat32AtomicAdd)
			&& (l.ShaderSharedFloat64Atomics == r.ShaderSharedFloat64Atomics) && (l.ShaderSharedFloat64AtomicAdd == r.ShaderSharedFloat64AtomicAdd) && (l.ShaderImageFloat32Atomics == r.ShaderImageFloat32Atomics) && (l.ShaderImageFloat32AtomicAdd == r.ShaderImageFloat32AtomicAdd)
			&& (l.SparseImageFloat32Atomics == r.SparseImageFloat32Atomics) && (l.SparseImageFloat32AtomicAdd == r.SparseImageFloat32AtomicAdd)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceShaderAtomicFloatFeatures l, in PhysicalDeviceShaderAtomicFloatFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ShaderBufferFloat32Atomics != r.ShaderBufferFloat32Atomics) || (l.ShaderBufferFloat32AtomicAdd != r.ShaderBufferFloat32AtomicAdd)
			|| (l.ShaderBufferFloat64Atomics != r.ShaderBufferFloat64Atomics) || (l.ShaderBufferFloat64AtomicAdd != r.ShaderBufferFloat64AtomicAdd) || (l.ShaderSharedFloat32Atomics != r.ShaderSharedFloat32Atomics) || (l.ShaderSharedFloat32AtomicAdd != r.ShaderSharedFloat32AtomicAdd)
			|| (l.ShaderSharedFloat64Atomics != r.ShaderSharedFloat64Atomics) || (l.ShaderSharedFloat64AtomicAdd != r.ShaderSharedFloat64AtomicAdd) || (l.ShaderImageFloat32Atomics != r.ShaderImageFloat32Atomics) || (l.ShaderImageFloat32AtomicAdd != r.ShaderImageFloat32AtomicAdd)
			|| (l.SparseImageFloat32Atomics != r.SparseImageFloat32Atomics) || (l.SparseImageFloat32AtomicAdd != r.SparseImageFloat32AtomicAdd)
			;
	}


	/// <summary>Creates a new PhysicalDeviceShaderAtomicFloatFeatures value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceShaderAtomicFloatFeatures value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceShaderAtomicFloatFeatures value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceVertexAttributeDivisorFeatures : IEquatable<PhysicalDeviceVertexAttributeDivisorFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceVertexAttributeDivisorFeaturesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 VertexAttributeInstanceRateDivisor;
	public Vk.Bool32 VertexAttributeInstanceRateZeroDivisor;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceVertexAttributeDivisorFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceVertexAttributeDivisorFeatures>.Equals(PhysicalDeviceVertexAttributeDivisorFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ VertexAttributeInstanceRateDivisor.GetHashCode() ^ VertexAttributeInstanceRateZeroDivisor.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceVertexAttributeDivisorFeatures l, in PhysicalDeviceVertexAttributeDivisorFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.VertexAttributeInstanceRateDivisor == r.VertexAttributeInstanceRateDivisor) && (l.VertexAttributeInstanceRateZeroDivisor == r.VertexAttributeInstanceRateZeroDivisor)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceVertexAttributeDivisorFeatures l, in PhysicalDeviceVertexAttributeDivisorFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.VertexAttributeInstanceRateDivisor != r.VertexAttributeInstanceRateDivisor) || (l.VertexAttributeInstanceRateZeroDivisor != r.VertexAttributeInstanceRateZeroDivisor)
			;
	}


	/// <summary>Creates a new PhysicalDeviceVertexAttributeDivisorFeatures value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceVertexAttributeDivisorFeatures value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceVertexAttributeDivisorFeatures value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ImageViewASTCDecodeMode : IEquatable<ImageViewASTCDecodeMode>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ImageViewAstcDecodeModeEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Format DecodeMode;

	public readonly override bool Equals(object? obj) => (obj is ImageViewASTCDecodeMode o) && (this == o);
	readonly bool IEquatable<ImageViewASTCDecodeMode>.Equals(ImageViewASTCDecodeMode obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DecodeMode.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ImageViewASTCDecodeMode l, in ImageViewASTCDecodeMode r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DecodeMode == r.DecodeMode)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ImageViewASTCDecodeMode l, in ImageViewASTCDecodeMode r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DecodeMode != r.DecodeMode)
			;
	}


	/// <summary>Creates a new ImageViewASTCDecodeMode value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ImageViewASTCDecodeMode value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref ImageViewASTCDecodeMode value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceASTCDecodeFeatures : IEquatable<PhysicalDeviceASTCDecodeFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceAstcDecodeFeaturesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 DecodeModeSharedExponent;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceASTCDecodeFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceASTCDecodeFeatures>.Equals(PhysicalDeviceASTCDecodeFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DecodeModeSharedExponent.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceASTCDecodeFeatures l, in PhysicalDeviceASTCDecodeFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DecodeModeSharedExponent == r.DecodeModeSharedExponent)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceASTCDecodeFeatures l, in PhysicalDeviceASTCDecodeFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DecodeModeSharedExponent != r.DecodeModeSharedExponent)
			;
	}


	/// <summary>Creates a new PhysicalDeviceASTCDecodeFeatures value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceASTCDecodeFeatures value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceASTCDecodeFeatures value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceTransformFeedbackFeatures : IEquatable<PhysicalDeviceTransformFeedbackFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceTransformFeedbackFeaturesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 TransformFeedback;
	public Vk.Bool32 GeometryStreams;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceTransformFeedbackFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceTransformFeedbackFeatures>.Equals(PhysicalDeviceTransformFeedbackFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ TransformFeedback.GetHashCode() ^ GeometryStreams.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceTransformFeedbackFeatures l, in PhysicalDeviceTransformFeedbackFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.TransformFeedback == r.TransformFeedback) && (l.GeometryStreams == r.GeometryStreams)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceTransformFeedbackFeatures l, in PhysicalDeviceTransformFeedbackFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.TransformFeedback != r.TransformFeedback) || (l.GeometryStreams != r.GeometryStreams)
			;
	}


	/// <summary>Creates a new PhysicalDeviceTransformFeedbackFeatures value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceTransformFeedbackFeatures value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceTransformFeedbackFeatures value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceTransformFeedbackProperties : IEquatable<PhysicalDeviceTransformFeedbackProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceTransformFeedbackPropertiesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public uint MaxTransformFeedbackStreams;
	public uint MaxTransformFeedbackBuffers;
	public Vk.DeviceSize MaxTransformFeedbackBufferSize;
	public uint MaxTransformFeedbackStreamDataSize;
	public uint MaxTransformFeedbackBufferDataSize;
	public uint MaxTransformFeedbackBufferDataStride;
	public Vk.Bool32 TransformFeedbackQueries;
	public Vk.Bool32 TransformFeedbackStreamsLinesTriangles;
	public Vk.Bool32 TransformFeedbackRasterizationStreamSelect;
	public Vk.Bool32 TransformFeedbackDraw;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceTransformFeedbackProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceTransformFeedbackProperties>.Equals(PhysicalDeviceTransformFeedbackProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MaxTransformFeedbackStreams.GetHashCode() ^ MaxTransformFeedbackBuffers.GetHashCode()
			^ MaxTransformFeedbackBufferSize.GetHashCode() ^ MaxTransformFeedbackStreamDataSize.GetHashCode() ^ MaxTransformFeedbackBufferDataSize.GetHashCode() ^ MaxTransformFeedbackBufferDataStride.GetHashCode()
			^ TransformFeedbackQueries.GetHashCode() ^ TransformFeedbackStreamsLinesTriangles.GetHashCode() ^ TransformFeedbackRasterizationStreamSelect.GetHashCode() ^ TransformFeedbackDraw.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceTransformFeedbackProperties l, in PhysicalDeviceTransformFeedbackProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MaxTransformFeedbackStreams == r.MaxTransformFeedbackStreams) && (l.MaxTransformFeedbackBuffers == r.MaxTransformFeedbackBuffers)
			&& (l.MaxTransformFeedbackBufferSize == r.MaxTransformFeedbackBufferSize) && (l.MaxTransformFeedbackStreamDataSize == r.MaxTransformFeedbackStreamDataSize) && (l.MaxTransformFeedbackBufferDataSize == r.MaxTransformFeedbackBufferDataSize) && (l.MaxTransformFeedbackBufferDataStride == r.MaxTransformFeedbackBufferDataStride)
			&& (l.TransformFeedbackQueries == r.TransformFeedbackQueries) && (l.TransformFeedbackStreamsLinesTriangles == r.TransformFeedbackStreamsLinesTriangles) && (l.TransformFeedbackRasterizationStreamSelect == r.TransformFeedbackRasterizationStreamSelect) && (l.TransformFeedbackDraw == r.TransformFeedbackDraw)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceTransformFeedbackProperties l, in PhysicalDeviceTransformFeedbackProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MaxTransformFeedbackStreams != r.MaxTransformFeedbackStreams) || (l.MaxTransformFeedbackBuffers != r.MaxTransformFeedbackBuffers)
			|| (l.MaxTransformFeedbackBufferSize != r.MaxTransformFeedbackBufferSize) || (l.MaxTransformFeedbackStreamDataSize != r.MaxTransformFeedbackStreamDataSize) || (l.MaxTransformFeedbackBufferDataSize != r.MaxTransformFeedbackBufferDataSize) || (l.MaxTransformFeedbackBufferDataStride != r.MaxTransformFeedbackBufferDataStride)
			|| (l.TransformFeedbackQueries != r.TransformFeedbackQueries) || (l.TransformFeedbackStreamsLinesTriangles != r.TransformFeedbackStreamsLinesTriangles) || (l.TransformFeedbackRasterizationStreamSelect != r.TransformFeedbackRasterizationStreamSelect) || (l.TransformFeedbackDraw != r.TransformFeedbackDraw)
			;
	}


	/// <summary>Creates a new PhysicalDeviceTransformFeedbackProperties value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceTransformFeedbackProperties value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceTransformFeedbackProperties value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PipelineRasterizationStateStreamCreateInfo : IEquatable<PipelineRasterizationStateStreamCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PipelineRasterizationStateStreamCreateInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.EXT.PipelineRasterizationStateStreamCreateFlags Flags;
	public uint RasterizationStream;

	public readonly override bool Equals(object? obj) => (obj is PipelineRasterizationStateStreamCreateInfo o) && (this == o);
	readonly bool IEquatable<PipelineRasterizationStateStreamCreateInfo>.Equals(PipelineRasterizationStateStreamCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ RasterizationStream.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PipelineRasterizationStateStreamCreateInfo l, in PipelineRasterizationStateStreamCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.RasterizationStream == r.RasterizationStream)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PipelineRasterizationStateStreamCreateInfo l, in PipelineRasterizationStateStreamCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.RasterizationStream != r.RasterizationStream)
			;
	}


	/// <summary>Creates a new PipelineRasterizationStateStreamCreateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PipelineRasterizationStateStreamCreateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PipelineRasterizationStateStreamCreateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DrmFormatModifierPropertiesList : IEquatable<DrmFormatModifierPropertiesList>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DrmFormatModifierPropertiesListEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public uint DrmFormatModifierCount;
	public Vk.EXT.DrmFormatModifierProperties* DrmFormatModifierProperties;

	public readonly override bool Equals(object? obj) => (obj is DrmFormatModifierPropertiesList o) && (this == o);
	readonly bool IEquatable<DrmFormatModifierPropertiesList>.Equals(DrmFormatModifierPropertiesList obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DrmFormatModifierCount.GetHashCode() ^ ((ulong)DrmFormatModifierProperties).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DrmFormatModifierPropertiesList l, in DrmFormatModifierPropertiesList r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DrmFormatModifierCount == r.DrmFormatModifierCount) && (l.DrmFormatModifierProperties == r.DrmFormatModifierProperties)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DrmFormatModifierPropertiesList l, in DrmFormatModifierPropertiesList r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DrmFormatModifierCount != r.DrmFormatModifierCount) || (l.DrmFormatModifierProperties != r.DrmFormatModifierProperties)
			;
	}


	/// <summary>Creates a new DrmFormatModifierPropertiesList value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DrmFormatModifierPropertiesList value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref DrmFormatModifierPropertiesList value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DrmFormatModifierProperties : IEquatable<DrmFormatModifierProperties>
{
	public ulong DrmFormatModifier;
	public uint DrmFormatModifierPlaneCount;
	public Vk.FormatFeatureFlags DrmFormatModifierTilingFeatures;

	public readonly override bool Equals(object? obj) => (obj is DrmFormatModifierProperties o) && (this == o);
	readonly bool IEquatable<DrmFormatModifierProperties>.Equals(DrmFormatModifierProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			DrmFormatModifier.GetHashCode() ^ DrmFormatModifierPlaneCount.GetHashCode() ^ DrmFormatModifierTilingFeatures.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DrmFormatModifierProperties l, in DrmFormatModifierProperties r)
	{
		return
			(l.DrmFormatModifier == r.DrmFormatModifier) && (l.DrmFormatModifierPlaneCount == r.DrmFormatModifierPlaneCount) && (l.DrmFormatModifierTilingFeatures == r.DrmFormatModifierTilingFeatures)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DrmFormatModifierProperties l, in DrmFormatModifierProperties r)
	{
		return
			(l.DrmFormatModifier != r.DrmFormatModifier) || (l.DrmFormatModifierPlaneCount != r.DrmFormatModifierPlaneCount) || (l.DrmFormatModifierTilingFeatures != r.DrmFormatModifierTilingFeatures)
			;
	}

}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceImageDrmFormatModifierInfo : IEquatable<PhysicalDeviceImageDrmFormatModifierInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceImageDrmFormatModifierInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public ulong DrmFormatModifier;
	public Vk.SharingMode SharingMode;
	public uint QueueFamilyIndexCount;
	public uint* QueueFamilyIndices;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceImageDrmFormatModifierInfo o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceImageDrmFormatModifierInfo>.Equals(PhysicalDeviceImageDrmFormatModifierInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DrmFormatModifier.GetHashCode() ^ SharingMode.GetHashCode()
			^ QueueFamilyIndexCount.GetHashCode() ^ ((ulong)QueueFamilyIndices).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceImageDrmFormatModifierInfo l, in PhysicalDeviceImageDrmFormatModifierInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DrmFormatModifier == r.DrmFormatModifier) && (l.SharingMode == r.SharingMode)
			&& (l.QueueFamilyIndexCount == r.QueueFamilyIndexCount) && (l.QueueFamilyIndices == r.QueueFamilyIndices)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceImageDrmFormatModifierInfo l, in PhysicalDeviceImageDrmFormatModifierInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DrmFormatModifier != r.DrmFormatModifier) || (l.SharingMode != r.SharingMode)
			|| (l.QueueFamilyIndexCount != r.QueueFamilyIndexCount) || (l.QueueFamilyIndices != r.QueueFamilyIndices)
			;
	}


	/// <summary>Creates a new PhysicalDeviceImageDrmFormatModifierInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceImageDrmFormatModifierInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceImageDrmFormatModifierInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ImageDrmFormatModifierListCreateInfo : IEquatable<ImageDrmFormatModifierListCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ImageDrmFormatModifierListCreateInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public uint DrmFormatModifierCount;
	public ulong* DrmFormatModifiers;

	public readonly override bool Equals(object? obj) => (obj is ImageDrmFormatModifierListCreateInfo o) && (this == o);
	readonly bool IEquatable<ImageDrmFormatModifierListCreateInfo>.Equals(ImageDrmFormatModifierListCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DrmFormatModifierCount.GetHashCode() ^ ((ulong)DrmFormatModifiers).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ImageDrmFormatModifierListCreateInfo l, in ImageDrmFormatModifierListCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DrmFormatModifierCount == r.DrmFormatModifierCount) && (l.DrmFormatModifiers == r.DrmFormatModifiers)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ImageDrmFormatModifierListCreateInfo l, in ImageDrmFormatModifierListCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DrmFormatModifierCount != r.DrmFormatModifierCount) || (l.DrmFormatModifiers != r.DrmFormatModifiers)
			;
	}


	/// <summary>Creates a new ImageDrmFormatModifierListCreateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ImageDrmFormatModifierListCreateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref ImageDrmFormatModifierListCreateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ImageDrmFormatModifierExplicitCreateInfo : IEquatable<ImageDrmFormatModifierExplicitCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ImageDrmFormatModifierExplicitCreateInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public ulong DrmFormatModifier;
	public uint DrmFormatModifierPlaneCount;
	public Vk.SubresourceLayout* PlaneLayouts;

	public readonly override bool Equals(object? obj) => (obj is ImageDrmFormatModifierExplicitCreateInfo o) && (this == o);
	readonly bool IEquatable<ImageDrmFormatModifierExplicitCreateInfo>.Equals(ImageDrmFormatModifierExplicitCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DrmFormatModifier.GetHashCode() ^ DrmFormatModifierPlaneCount.GetHashCode()
			^ ((ulong)PlaneLayouts).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ImageDrmFormatModifierExplicitCreateInfo l, in ImageDrmFormatModifierExplicitCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DrmFormatModifier == r.DrmFormatModifier) && (l.DrmFormatModifierPlaneCount == r.DrmFormatModifierPlaneCount)
			&& (l.PlaneLayouts == r.PlaneLayouts)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ImageDrmFormatModifierExplicitCreateInfo l, in ImageDrmFormatModifierExplicitCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DrmFormatModifier != r.DrmFormatModifier) || (l.DrmFormatModifierPlaneCount != r.DrmFormatModifierPlaneCount)
			|| (l.PlaneLayouts != r.PlaneLayouts)
			;
	}


	/// <summary>Creates a new ImageDrmFormatModifierExplicitCreateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ImageDrmFormatModifierExplicitCreateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref ImageDrmFormatModifierExplicitCreateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ImageDrmFormatModifierProperties : IEquatable<ImageDrmFormatModifierProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ImageDrmFormatModifierPropertiesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public ulong DrmFormatModifier;

	public readonly override bool Equals(object? obj) => (obj is ImageDrmFormatModifierProperties o) && (this == o);
	readonly bool IEquatable<ImageDrmFormatModifierProperties>.Equals(ImageDrmFormatModifierProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DrmFormatModifier.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ImageDrmFormatModifierProperties l, in ImageDrmFormatModifierProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DrmFormatModifier == r.DrmFormatModifier)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ImageDrmFormatModifierProperties l, in ImageDrmFormatModifierProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DrmFormatModifier != r.DrmFormatModifier)
			;
	}


	/// <summary>Creates a new ImageDrmFormatModifierProperties value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ImageDrmFormatModifierProperties value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref ImageDrmFormatModifierProperties value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ImageStencilUsageCreateInfo : IEquatable<ImageStencilUsageCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ImageStencilUsageCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.ImageUsageFlags StencilUsage;

	public readonly override bool Equals(object? obj) => (obj is ImageStencilUsageCreateInfo o) && (this == o);
	readonly bool IEquatable<ImageStencilUsageCreateInfo>.Equals(ImageStencilUsageCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ StencilUsage.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ImageStencilUsageCreateInfo l, in ImageStencilUsageCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.StencilUsage == r.StencilUsage)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ImageStencilUsageCreateInfo l, in ImageStencilUsageCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.StencilUsage != r.StencilUsage)
			;
	}


	/// <summary>Creates a new ImageStencilUsageCreateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ImageStencilUsageCreateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref ImageStencilUsageCreateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceFragmentDensityMapFeatures : IEquatable<PhysicalDeviceFragmentDensityMapFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceFragmentDensityMapFeaturesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 FragmentDensityMap;
	public Vk.Bool32 FragmentDensityMapDynamic;
	public Vk.Bool32 FragmentDensityMapNonSubsampledImages;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceFragmentDensityMapFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceFragmentDensityMapFeatures>.Equals(PhysicalDeviceFragmentDensityMapFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ FragmentDensityMap.GetHashCode() ^ FragmentDensityMapDynamic.GetHashCode()
			^ FragmentDensityMapNonSubsampledImages.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceFragmentDensityMapFeatures l, in PhysicalDeviceFragmentDensityMapFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.FragmentDensityMap == r.FragmentDensityMap) && (l.FragmentDensityMapDynamic == r.FragmentDensityMapDynamic)
			&& (l.FragmentDensityMapNonSubsampledImages == r.FragmentDensityMapNonSubsampledImages)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceFragmentDensityMapFeatures l, in PhysicalDeviceFragmentDensityMapFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.FragmentDensityMap != r.FragmentDensityMap) || (l.FragmentDensityMapDynamic != r.FragmentDensityMapDynamic)
			|| (l.FragmentDensityMapNonSubsampledImages != r.FragmentDensityMapNonSubsampledImages)
			;
	}


	/// <summary>Creates a new PhysicalDeviceFragmentDensityMapFeatures value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceFragmentDensityMapFeatures value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceFragmentDensityMapFeatures value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceFragmentDensityMap2Features : IEquatable<PhysicalDeviceFragmentDensityMap2Features>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceFragmentDensityMap2FeaturesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 FragmentDensityMapDeferred;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceFragmentDensityMap2Features o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceFragmentDensityMap2Features>.Equals(PhysicalDeviceFragmentDensityMap2Features obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ FragmentDensityMapDeferred.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceFragmentDensityMap2Features l, in PhysicalDeviceFragmentDensityMap2Features r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.FragmentDensityMapDeferred == r.FragmentDensityMapDeferred)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceFragmentDensityMap2Features l, in PhysicalDeviceFragmentDensityMap2Features r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.FragmentDensityMapDeferred != r.FragmentDensityMapDeferred)
			;
	}


	/// <summary>Creates a new PhysicalDeviceFragmentDensityMap2Features value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceFragmentDensityMap2Features value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceFragmentDensityMap2Features value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceFragmentDensityMapProperties : IEquatable<PhysicalDeviceFragmentDensityMapProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceFragmentDensityMapPropertiesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Extent2D MinFragmentDensityTexelSize;
	public Vk.Extent2D MaxFragmentDensityTexelSize;
	public Vk.Bool32 FragmentDensityInvocations;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceFragmentDensityMapProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceFragmentDensityMapProperties>.Equals(PhysicalDeviceFragmentDensityMapProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MinFragmentDensityTexelSize.GetHashCode() ^ MaxFragmentDensityTexelSize.GetHashCode()
			^ FragmentDensityInvocations.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceFragmentDensityMapProperties l, in PhysicalDeviceFragmentDensityMapProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MinFragmentDensityTexelSize == r.MinFragmentDensityTexelSize) && (l.MaxFragmentDensityTexelSize == r.MaxFragmentDensityTexelSize)
			&& (l.FragmentDensityInvocations == r.FragmentDensityInvocations)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceFragmentDensityMapProperties l, in PhysicalDeviceFragmentDensityMapProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MinFragmentDensityTexelSize != r.MinFragmentDensityTexelSize) || (l.MaxFragmentDensityTexelSize != r.MaxFragmentDensityTexelSize)
			|| (l.FragmentDensityInvocations != r.FragmentDensityInvocations)
			;
	}


	/// <summary>Creates a new PhysicalDeviceFragmentDensityMapProperties value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceFragmentDensityMapProperties value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceFragmentDensityMapProperties value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceFragmentDensityMap2Properties : IEquatable<PhysicalDeviceFragmentDensityMap2Properties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceFragmentDensityMap2PropertiesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 SubsampledLoads;
	public Vk.Bool32 SubsampledCoarseReconstructionEarlyAccess;
	public uint MaxSubsampledArrayLayers;
	public uint MaxDescriptorSetSubsampledSamplers;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceFragmentDensityMap2Properties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceFragmentDensityMap2Properties>.Equals(PhysicalDeviceFragmentDensityMap2Properties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SubsampledLoads.GetHashCode() ^ SubsampledCoarseReconstructionEarlyAccess.GetHashCode()
			^ MaxSubsampledArrayLayers.GetHashCode() ^ MaxDescriptorSetSubsampledSamplers.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceFragmentDensityMap2Properties l, in PhysicalDeviceFragmentDensityMap2Properties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SubsampledLoads == r.SubsampledLoads) && (l.SubsampledCoarseReconstructionEarlyAccess == r.SubsampledCoarseReconstructionEarlyAccess)
			&& (l.MaxSubsampledArrayLayers == r.MaxSubsampledArrayLayers) && (l.MaxDescriptorSetSubsampledSamplers == r.MaxDescriptorSetSubsampledSamplers)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceFragmentDensityMap2Properties l, in PhysicalDeviceFragmentDensityMap2Properties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SubsampledLoads != r.SubsampledLoads) || (l.SubsampledCoarseReconstructionEarlyAccess != r.SubsampledCoarseReconstructionEarlyAccess)
			|| (l.MaxSubsampledArrayLayers != r.MaxSubsampledArrayLayers) || (l.MaxDescriptorSetSubsampledSamplers != r.MaxDescriptorSetSubsampledSamplers)
			;
	}


	/// <summary>Creates a new PhysicalDeviceFragmentDensityMap2Properties value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceFragmentDensityMap2Properties value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceFragmentDensityMap2Properties value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct RenderPassFragmentDensityMapCreateInfo : IEquatable<RenderPassFragmentDensityMapCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.RenderPassFragmentDensityMapCreateInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.AttachmentReference FragmentDensityMapAttachment;

	public readonly override bool Equals(object? obj) => (obj is RenderPassFragmentDensityMapCreateInfo o) && (this == o);
	readonly bool IEquatable<RenderPassFragmentDensityMapCreateInfo>.Equals(RenderPassFragmentDensityMapCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ FragmentDensityMapAttachment.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in RenderPassFragmentDensityMapCreateInfo l, in RenderPassFragmentDensityMapCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.FragmentDensityMapAttachment == r.FragmentDensityMapAttachment)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in RenderPassFragmentDensityMapCreateInfo l, in RenderPassFragmentDensityMapCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.FragmentDensityMapAttachment != r.FragmentDensityMapAttachment)
			;
	}


	/// <summary>Creates a new RenderPassFragmentDensityMapCreateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out RenderPassFragmentDensityMapCreateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref RenderPassFragmentDensityMapCreateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceScalarBlockLayoutFeatures : IEquatable<PhysicalDeviceScalarBlockLayoutFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceScalarBlockLayoutFeatures;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 ScalarBlockLayout;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceScalarBlockLayoutFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceScalarBlockLayoutFeatures>.Equals(PhysicalDeviceScalarBlockLayoutFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ScalarBlockLayout.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceScalarBlockLayoutFeatures l, in PhysicalDeviceScalarBlockLayoutFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ScalarBlockLayout == r.ScalarBlockLayout)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceScalarBlockLayoutFeatures l, in PhysicalDeviceScalarBlockLayoutFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ScalarBlockLayout != r.ScalarBlockLayout)
			;
	}


	/// <summary>Creates a new PhysicalDeviceScalarBlockLayoutFeatures value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceScalarBlockLayoutFeatures value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceScalarBlockLayoutFeatures value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceDepthClipEnableFeatures : IEquatable<PhysicalDeviceDepthClipEnableFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceDepthClipEnableFeaturesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 DepthClipEnable;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceDepthClipEnableFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceDepthClipEnableFeatures>.Equals(PhysicalDeviceDepthClipEnableFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DepthClipEnable.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceDepthClipEnableFeatures l, in PhysicalDeviceDepthClipEnableFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DepthClipEnable == r.DepthClipEnable)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceDepthClipEnableFeatures l, in PhysicalDeviceDepthClipEnableFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DepthClipEnable != r.DepthClipEnable)
			;
	}


	/// <summary>Creates a new PhysicalDeviceDepthClipEnableFeatures value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceDepthClipEnableFeatures value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceDepthClipEnableFeatures value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PipelineRasterizationDepthClipStateCreateInfo : IEquatable<PipelineRasterizationDepthClipStateCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PipelineRasterizationDepthClipStateCreateInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.EXT.PipelineRasterizationDepthClipStateCreateFlags Flags;
	public Vk.Bool32 DepthClipEnable;

	public readonly override bool Equals(object? obj) => (obj is PipelineRasterizationDepthClipStateCreateInfo o) && (this == o);
	readonly bool IEquatable<PipelineRasterizationDepthClipStateCreateInfo>.Equals(PipelineRasterizationDepthClipStateCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ DepthClipEnable.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PipelineRasterizationDepthClipStateCreateInfo l, in PipelineRasterizationDepthClipStateCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.DepthClipEnable == r.DepthClipEnable)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PipelineRasterizationDepthClipStateCreateInfo l, in PipelineRasterizationDepthClipStateCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.DepthClipEnable != r.DepthClipEnable)
			;
	}


	/// <summary>Creates a new PipelineRasterizationDepthClipStateCreateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PipelineRasterizationDepthClipStateCreateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PipelineRasterizationDepthClipStateCreateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceMemoryBudgetProperties : IEquatable<PhysicalDeviceMemoryBudgetProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceMemoryBudgetPropertiesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.DeviceSize HeapBudget_0;
	public Vk.DeviceSize HeapBudget_1;
	public Vk.DeviceSize HeapBudget_2;
	public Vk.DeviceSize HeapBudget_3;
	public Vk.DeviceSize HeapBudget_4;
	public Vk.DeviceSize HeapBudget_5;
	public Vk.DeviceSize HeapBudget_6;
	public Vk.DeviceSize HeapBudget_7;
	public Vk.DeviceSize HeapBudget_8;
	public Vk.DeviceSize HeapBudget_9;
	public Vk.DeviceSize HeapBudget_10;
	public Vk.DeviceSize HeapBudget_11;
	public Vk.DeviceSize HeapBudget_12;
	public Vk.DeviceSize HeapBudget_13;
	public Vk.DeviceSize HeapBudget_14;
	public Vk.DeviceSize HeapBudget_15;
	public Vk.DeviceSize HeapUsage_0;
	public Vk.DeviceSize HeapUsage_1;
	public Vk.DeviceSize HeapUsage_2;
	public Vk.DeviceSize HeapUsage_3;
	public Vk.DeviceSize HeapUsage_4;
	public Vk.DeviceSize HeapUsage_5;
	public Vk.DeviceSize HeapUsage_6;
	public Vk.DeviceSize HeapUsage_7;
	public Vk.DeviceSize HeapUsage_8;
	public Vk.DeviceSize HeapUsage_9;
	public Vk.DeviceSize HeapUsage_10;
	public Vk.DeviceSize HeapUsage_11;
	public Vk.DeviceSize HeapUsage_12;
	public Vk.DeviceSize HeapUsage_13;
	public Vk.DeviceSize HeapUsage_14;
	public Vk.DeviceSize HeapUsage_15;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceMemoryBudgetProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceMemoryBudgetProperties>.Equals(PhysicalDeviceMemoryBudgetProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ HeapBudget_0.GetHashCode() ^ HeapBudget_1.GetHashCode()
			^ HeapBudget_2.GetHashCode() ^ HeapBudget_3.GetHashCode() ^ HeapBudget_4.GetHashCode() ^ HeapBudget_5.GetHashCode()
			^ HeapBudget_6.GetHashCode() ^ HeapBudget_7.GetHashCode() ^ HeapBudget_8.GetHashCode() ^ HeapBudget_9.GetHashCode()
			^ HeapBudget_10.GetHashCode() ^ HeapBudget_11.GetHashCode() ^ HeapBudget_12.GetHashCode() ^ HeapBudget_13.GetHashCode()
			^ HeapBudget_14.GetHashCode() ^ HeapBudget_15.GetHashCode() ^ HeapUsage_0.GetHashCode() ^ HeapUsage_1.GetHashCode()
			^ HeapUsage_2.GetHashCode() ^ HeapUsage_3.GetHashCode() ^ HeapUsage_4.GetHashCode() ^ HeapUsage_5.GetHashCode()
			^ HeapUsage_6.GetHashCode() ^ HeapUsage_7.GetHashCode() ^ HeapUsage_8.GetHashCode() ^ HeapUsage_9.GetHashCode()
			^ HeapUsage_10.GetHashCode() ^ HeapUsage_11.GetHashCode() ^ HeapUsage_12.GetHashCode() ^ HeapUsage_13.GetHashCode()
			^ HeapUsage_14.GetHashCode() ^ HeapUsage_15.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceMemoryBudgetProperties l, in PhysicalDeviceMemoryBudgetProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.HeapBudget_0 == r.HeapBudget_0) && (l.HeapBudget_1 == r.HeapBudget_1)
			&& (l.HeapBudget_2 == r.HeapBudget_2) && (l.HeapBudget_3 == r.HeapBudget_3) && (l.HeapBudget_4 == r.HeapBudget_4) && (l.HeapBudget_5 == r.HeapBudget_5)
			&& (l.HeapBudget_6 == r.HeapBudget_6) && (l.HeapBudget_7 == r.HeapBudget_7) && (l.HeapBudget_8 == r.HeapBudget_8) && (l.HeapBudget_9 == r.HeapBudget_9)
			&& (l.HeapBudget_10 == r.HeapBudget_10) && (l.HeapBudget_11 == r.HeapBudget_11) && (l.HeapBudget_12 == r.HeapBudget_12) && (l.HeapBudget_13 == r.HeapBudget_13)
			&& (l.HeapBudget_14 == r.HeapBudget_14) && (l.HeapBudget_15 == r.HeapBudget_15) && (l.HeapUsage_0 == r.HeapUsage_0) && (l.HeapUsage_1 == r.HeapUsage_1)
			&& (l.HeapUsage_2 == r.HeapUsage_2) && (l.HeapUsage_3 == r.HeapUsage_3) && (l.HeapUsage_4 == r.HeapUsage_4) && (l.HeapUsage_5 == r.HeapUsage_5)
			&& (l.HeapUsage_6 == r.HeapUsage_6) && (l.HeapUsage_7 == r.HeapUsage_7) && (l.HeapUsage_8 == r.HeapUsage_8) && (l.HeapUsage_9 == r.HeapUsage_9)
			&& (l.HeapUsage_10 == r.HeapUsage_10) && (l.HeapUsage_11 == r.HeapUsage_11) && (l.HeapUsage_12 == r.HeapUsage_12) && (l.HeapUsage_13 == r.HeapUsage_13)
			&& (l.HeapUsage_14 == r.HeapUsage_14) && (l.HeapUsage_15 == r.HeapUsage_15)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceMemoryBudgetProperties l, in PhysicalDeviceMemoryBudgetProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.HeapBudget_0 != r.HeapBudget_0) || (l.HeapBudget_1 != r.HeapBudget_1)
			|| (l.HeapBudget_2 != r.HeapBudget_2) || (l.HeapBudget_3 != r.HeapBudget_3) || (l.HeapBudget_4 != r.HeapBudget_4) || (l.HeapBudget_5 != r.HeapBudget_5)
			|| (l.HeapBudget_6 != r.HeapBudget_6) || (l.HeapBudget_7 != r.HeapBudget_7) || (l.HeapBudget_8 != r.HeapBudget_8) || (l.HeapBudget_9 != r.HeapBudget_9)
			|| (l.HeapBudget_10 != r.HeapBudget_10) || (l.HeapBudget_11 != r.HeapBudget_11) || (l.HeapBudget_12 != r.HeapBudget_12) || (l.HeapBudget_13 != r.HeapBudget_13)
			|| (l.HeapBudget_14 != r.HeapBudget_14) || (l.HeapBudget_15 != r.HeapBudget_15) || (l.HeapUsage_0 != r.HeapUsage_0) || (l.HeapUsage_1 != r.HeapUsage_1)
			|| (l.HeapUsage_2 != r.HeapUsage_2) || (l.HeapUsage_3 != r.HeapUsage_3) || (l.HeapUsage_4 != r.HeapUsage_4) || (l.HeapUsage_5 != r.HeapUsage_5)
			|| (l.HeapUsage_6 != r.HeapUsage_6) || (l.HeapUsage_7 != r.HeapUsage_7) || (l.HeapUsage_8 != r.HeapUsage_8) || (l.HeapUsage_9 != r.HeapUsage_9)
			|| (l.HeapUsage_10 != r.HeapUsage_10) || (l.HeapUsage_11 != r.HeapUsage_11) || (l.HeapUsage_12 != r.HeapUsage_12) || (l.HeapUsage_13 != r.HeapUsage_13)
			|| (l.HeapUsage_14 != r.HeapUsage_14) || (l.HeapUsage_15 != r.HeapUsage_15)
			;
	}


	/// <summary>Creates a new PhysicalDeviceMemoryBudgetProperties value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceMemoryBudgetProperties value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceMemoryBudgetProperties value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceMemoryPriorityFeatures : IEquatable<PhysicalDeviceMemoryPriorityFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceMemoryPriorityFeaturesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 MemoryPriority;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceMemoryPriorityFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceMemoryPriorityFeatures>.Equals(PhysicalDeviceMemoryPriorityFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MemoryPriority.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceMemoryPriorityFeatures l, in PhysicalDeviceMemoryPriorityFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MemoryPriority == r.MemoryPriority)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceMemoryPriorityFeatures l, in PhysicalDeviceMemoryPriorityFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MemoryPriority != r.MemoryPriority)
			;
	}


	/// <summary>Creates a new PhysicalDeviceMemoryPriorityFeatures value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceMemoryPriorityFeatures value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceMemoryPriorityFeatures value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct MemoryPriorityAllocateInfo : IEquatable<MemoryPriorityAllocateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.MemoryPriorityAllocateInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public float Priority;

	public readonly override bool Equals(object? obj) => (obj is MemoryPriorityAllocateInfo o) && (this == o);
	readonly bool IEquatable<MemoryPriorityAllocateInfo>.Equals(MemoryPriorityAllocateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Priority.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in MemoryPriorityAllocateInfo l, in MemoryPriorityAllocateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Priority == r.Priority)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in MemoryPriorityAllocateInfo l, in MemoryPriorityAllocateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Priority != r.Priority)
			;
	}


	/// <summary>Creates a new MemoryPriorityAllocateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out MemoryPriorityAllocateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref MemoryPriorityAllocateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceBufferDeviceAddressFeatures : IEquatable<PhysicalDeviceBufferDeviceAddressFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceBufferDeviceAddressFeaturesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 BufferDeviceAddress;
	public Vk.Bool32 BufferDeviceAddressCaptureReplay;
	public Vk.Bool32 BufferDeviceAddressMultiDevice;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceBufferDeviceAddressFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceBufferDeviceAddressFeatures>.Equals(PhysicalDeviceBufferDeviceAddressFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ BufferDeviceAddress.GetHashCode() ^ BufferDeviceAddressCaptureReplay.GetHashCode()
			^ BufferDeviceAddressMultiDevice.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceBufferDeviceAddressFeatures l, in PhysicalDeviceBufferDeviceAddressFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.BufferDeviceAddress == r.BufferDeviceAddress) && (l.BufferDeviceAddressCaptureReplay == r.BufferDeviceAddressCaptureReplay)
			&& (l.BufferDeviceAddressMultiDevice == r.BufferDeviceAddressMultiDevice)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceBufferDeviceAddressFeatures l, in PhysicalDeviceBufferDeviceAddressFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.BufferDeviceAddress != r.BufferDeviceAddress) || (l.BufferDeviceAddressCaptureReplay != r.BufferDeviceAddressCaptureReplay)
			|| (l.BufferDeviceAddressMultiDevice != r.BufferDeviceAddressMultiDevice)
			;
	}


	/// <summary>Creates a new PhysicalDeviceBufferDeviceAddressFeatures value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceBufferDeviceAddressFeatures value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceBufferDeviceAddressFeatures value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceBufferAddressFeatures : IEquatable<PhysicalDeviceBufferAddressFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceBufferDeviceAddressFeaturesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 BufferDeviceAddress;
	public Vk.Bool32 BufferDeviceAddressCaptureReplay;
	public Vk.Bool32 BufferDeviceAddressMultiDevice;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceBufferAddressFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceBufferAddressFeatures>.Equals(PhysicalDeviceBufferAddressFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ BufferDeviceAddress.GetHashCode() ^ BufferDeviceAddressCaptureReplay.GetHashCode()
			^ BufferDeviceAddressMultiDevice.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceBufferAddressFeatures l, in PhysicalDeviceBufferAddressFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.BufferDeviceAddress == r.BufferDeviceAddress) && (l.BufferDeviceAddressCaptureReplay == r.BufferDeviceAddressCaptureReplay)
			&& (l.BufferDeviceAddressMultiDevice == r.BufferDeviceAddressMultiDevice)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceBufferAddressFeatures l, in PhysicalDeviceBufferAddressFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.BufferDeviceAddress != r.BufferDeviceAddress) || (l.BufferDeviceAddressCaptureReplay != r.BufferDeviceAddressCaptureReplay)
			|| (l.BufferDeviceAddressMultiDevice != r.BufferDeviceAddressMultiDevice)
			;
	}


	/// <summary>Creates a new PhysicalDeviceBufferAddressFeatures value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceBufferAddressFeatures value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceBufferAddressFeatures value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct BufferDeviceAddressInfo : IEquatable<BufferDeviceAddressInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.BufferDeviceAddressInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Handle<Vk.Buffer> Buffer;

	public readonly override bool Equals(object? obj) => (obj is BufferDeviceAddressInfo o) && (this == o);
	readonly bool IEquatable<BufferDeviceAddressInfo>.Equals(BufferDeviceAddressInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Buffer.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in BufferDeviceAddressInfo l, in BufferDeviceAddressInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Buffer == r.Buffer)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in BufferDeviceAddressInfo l, in BufferDeviceAddressInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Buffer != r.Buffer)
			;
	}


	/// <summary>Creates a new BufferDeviceAddressInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out BufferDeviceAddressInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref BufferDeviceAddressInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct BufferDeviceAddressCreateInfo : IEquatable<BufferDeviceAddressCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.BufferDeviceAddressCreateInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public ulong DeviceAddress;

	public readonly override bool Equals(object? obj) => (obj is BufferDeviceAddressCreateInfo o) && (this == o);
	readonly bool IEquatable<BufferDeviceAddressCreateInfo>.Equals(BufferDeviceAddressCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DeviceAddress.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in BufferDeviceAddressCreateInfo l, in BufferDeviceAddressCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DeviceAddress == r.DeviceAddress)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in BufferDeviceAddressCreateInfo l, in BufferDeviceAddressCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DeviceAddress != r.DeviceAddress)
			;
	}


	/// <summary>Creates a new BufferDeviceAddressCreateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out BufferDeviceAddressCreateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref BufferDeviceAddressCreateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceImageViewImageFormatInfo : IEquatable<PhysicalDeviceImageViewImageFormatInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceImageViewImageFormatInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.ImageViewType ImageViewType;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceImageViewImageFormatInfo o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceImageViewImageFormatInfo>.Equals(PhysicalDeviceImageViewImageFormatInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ImageViewType.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceImageViewImageFormatInfo l, in PhysicalDeviceImageViewImageFormatInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ImageViewType == r.ImageViewType)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceImageViewImageFormatInfo l, in PhysicalDeviceImageViewImageFormatInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ImageViewType != r.ImageViewType)
			;
	}


	/// <summary>Creates a new PhysicalDeviceImageViewImageFormatInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceImageViewImageFormatInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceImageViewImageFormatInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct FilterCubicImageViewImageFormatProperties : IEquatable<FilterCubicImageViewImageFormatProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.FilterCubicImageViewImageFormatPropertiesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 FilterCubic;
	public Vk.Bool32 FilterCubicMinmax;

	public readonly override bool Equals(object? obj) => (obj is FilterCubicImageViewImageFormatProperties o) && (this == o);
	readonly bool IEquatable<FilterCubicImageViewImageFormatProperties>.Equals(FilterCubicImageViewImageFormatProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ FilterCubic.GetHashCode() ^ FilterCubicMinmax.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in FilterCubicImageViewImageFormatProperties l, in FilterCubicImageViewImageFormatProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.FilterCubic == r.FilterCubic) && (l.FilterCubicMinmax == r.FilterCubicMinmax)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in FilterCubicImageViewImageFormatProperties l, in FilterCubicImageViewImageFormatProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.FilterCubic != r.FilterCubic) || (l.FilterCubicMinmax != r.FilterCubicMinmax)
			;
	}


	/// <summary>Creates a new FilterCubicImageViewImageFormatProperties value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out FilterCubicImageViewImageFormatProperties value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref FilterCubicImageViewImageFormatProperties value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceTextureCompressionASTCHDRFeatures : IEquatable<PhysicalDeviceTextureCompressionASTCHDRFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceTextureCompressionAstcHdrFeaturesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 TextureCompressionASTC_HDR;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceTextureCompressionASTCHDRFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceTextureCompressionASTCHDRFeatures>.Equals(PhysicalDeviceTextureCompressionASTCHDRFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ TextureCompressionASTC_HDR.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceTextureCompressionASTCHDRFeatures l, in PhysicalDeviceTextureCompressionASTCHDRFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.TextureCompressionASTC_HDR == r.TextureCompressionASTC_HDR)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceTextureCompressionASTCHDRFeatures l, in PhysicalDeviceTextureCompressionASTCHDRFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.TextureCompressionASTC_HDR != r.TextureCompressionASTC_HDR)
			;
	}


	/// <summary>Creates a new PhysicalDeviceTextureCompressionASTCHDRFeatures value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceTextureCompressionASTCHDRFeatures value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceTextureCompressionASTCHDRFeatures value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceYcbcrImageArraysFeatures : IEquatable<PhysicalDeviceYcbcrImageArraysFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceYcbcrImageArraysFeaturesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 YcbcrImageArrays;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceYcbcrImageArraysFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceYcbcrImageArraysFeatures>.Equals(PhysicalDeviceYcbcrImageArraysFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ YcbcrImageArrays.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceYcbcrImageArraysFeatures l, in PhysicalDeviceYcbcrImageArraysFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.YcbcrImageArrays == r.YcbcrImageArrays)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceYcbcrImageArraysFeatures l, in PhysicalDeviceYcbcrImageArraysFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.YcbcrImageArrays != r.YcbcrImageArrays)
			;
	}


	/// <summary>Creates a new PhysicalDeviceYcbcrImageArraysFeatures value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceYcbcrImageArraysFeatures value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceYcbcrImageArraysFeatures value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PipelineCreationFeedback : IEquatable<PipelineCreationFeedback>
{
	public Vk.EXT.PipelineCreationFeedbackFlags Flags;
	public ulong Duration;

	public readonly override bool Equals(object? obj) => (obj is PipelineCreationFeedback o) && (this == o);
	readonly bool IEquatable<PipelineCreationFeedback>.Equals(PipelineCreationFeedback obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Flags.GetHashCode() ^ Duration.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PipelineCreationFeedback l, in PipelineCreationFeedback r)
	{
		return
			(l.Flags == r.Flags) && (l.Duration == r.Duration)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PipelineCreationFeedback l, in PipelineCreationFeedback r)
	{
		return
			(l.Flags != r.Flags) || (l.Duration != r.Duration)
			;
	}

}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PipelineCreationFeedbackCreateInfo : IEquatable<PipelineCreationFeedbackCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PipelineCreationFeedbackCreateInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.EXT.PipelineCreationFeedback* PipelineCreationFeedback;
	public uint PipelineStageCreationFeedbackCount;
	public Vk.EXT.PipelineCreationFeedback** PipelineStageCreationFeedbacks;

	public readonly override bool Equals(object? obj) => (obj is PipelineCreationFeedbackCreateInfo o) && (this == o);
	readonly bool IEquatable<PipelineCreationFeedbackCreateInfo>.Equals(PipelineCreationFeedbackCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ((ulong)PipelineCreationFeedback).GetHashCode() ^ PipelineStageCreationFeedbackCount.GetHashCode()
			^ ((ulong)PipelineStageCreationFeedbacks).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PipelineCreationFeedbackCreateInfo l, in PipelineCreationFeedbackCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.PipelineCreationFeedback == r.PipelineCreationFeedback) && (l.PipelineStageCreationFeedbackCount == r.PipelineStageCreationFeedbackCount)
			&& (l.PipelineStageCreationFeedbacks == r.PipelineStageCreationFeedbacks)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PipelineCreationFeedbackCreateInfo l, in PipelineCreationFeedbackCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.PipelineCreationFeedback != r.PipelineCreationFeedback) || (l.PipelineStageCreationFeedbackCount != r.PipelineStageCreationFeedbackCount)
			|| (l.PipelineStageCreationFeedbacks != r.PipelineStageCreationFeedbacks)
			;
	}


	/// <summary>Creates a new PipelineCreationFeedbackCreateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PipelineCreationFeedbackCreateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PipelineCreationFeedbackCreateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SurfaceFullScreenExclusiveInfo : IEquatable<SurfaceFullScreenExclusiveInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.SurfaceFullScreenExclusiveInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.EXT.FullScreenExclusive FullScreenExclusive;

	public readonly override bool Equals(object? obj) => (obj is SurfaceFullScreenExclusiveInfo o) && (this == o);
	readonly bool IEquatable<SurfaceFullScreenExclusiveInfo>.Equals(SurfaceFullScreenExclusiveInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ FullScreenExclusive.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SurfaceFullScreenExclusiveInfo l, in SurfaceFullScreenExclusiveInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.FullScreenExclusive == r.FullScreenExclusive)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SurfaceFullScreenExclusiveInfo l, in SurfaceFullScreenExclusiveInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.FullScreenExclusive != r.FullScreenExclusive)
			;
	}


	/// <summary>Creates a new SurfaceFullScreenExclusiveInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SurfaceFullScreenExclusiveInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref SurfaceFullScreenExclusiveInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SurfaceFullScreenExclusiveWin32Info : IEquatable<SurfaceFullScreenExclusiveWin32Info>
{
	public const Vk.StructureType TYPE = Vk.StructureType.SurfaceFullScreenExclusiveWin32InfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public void* Hmonitor;

	public readonly override bool Equals(object? obj) => (obj is SurfaceFullScreenExclusiveWin32Info o) && (this == o);
	readonly bool IEquatable<SurfaceFullScreenExclusiveWin32Info>.Equals(SurfaceFullScreenExclusiveWin32Info obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ((ulong)Hmonitor).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SurfaceFullScreenExclusiveWin32Info l, in SurfaceFullScreenExclusiveWin32Info r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Hmonitor == r.Hmonitor)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SurfaceFullScreenExclusiveWin32Info l, in SurfaceFullScreenExclusiveWin32Info r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Hmonitor != r.Hmonitor)
			;
	}


	/// <summary>Creates a new SurfaceFullScreenExclusiveWin32Info value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SurfaceFullScreenExclusiveWin32Info value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref SurfaceFullScreenExclusiveWin32Info value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SurfaceCapabilitiesFullScreenExclusive : IEquatable<SurfaceCapabilitiesFullScreenExclusive>
{
	public const Vk.StructureType TYPE = Vk.StructureType.SurfaceCapabilitiesFullScreenExclusiveEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 FullScreenExclusiveSupported;

	public readonly override bool Equals(object? obj) => (obj is SurfaceCapabilitiesFullScreenExclusive o) && (this == o);
	readonly bool IEquatable<SurfaceCapabilitiesFullScreenExclusive>.Equals(SurfaceCapabilitiesFullScreenExclusive obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ FullScreenExclusiveSupported.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SurfaceCapabilitiesFullScreenExclusive l, in SurfaceCapabilitiesFullScreenExclusive r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.FullScreenExclusiveSupported == r.FullScreenExclusiveSupported)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SurfaceCapabilitiesFullScreenExclusive l, in SurfaceCapabilitiesFullScreenExclusive r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.FullScreenExclusiveSupported != r.FullScreenExclusiveSupported)
			;
	}


	/// <summary>Creates a new SurfaceCapabilitiesFullScreenExclusive value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SurfaceCapabilitiesFullScreenExclusive value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref SurfaceCapabilitiesFullScreenExclusive value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct HeadlessSurfaceCreateInfo : IEquatable<HeadlessSurfaceCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.HeadlessSurfaceCreateInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.EXT.HeadlessSurfaceCreateFlags Flags;

	public readonly override bool Equals(object? obj) => (obj is HeadlessSurfaceCreateInfo o) && (this == o);
	readonly bool IEquatable<HeadlessSurfaceCreateInfo>.Equals(HeadlessSurfaceCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in HeadlessSurfaceCreateInfo l, in HeadlessSurfaceCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in HeadlessSurfaceCreateInfo l, in HeadlessSurfaceCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags)
			;
	}


	/// <summary>Creates a new HeadlessSurfaceCreateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out HeadlessSurfaceCreateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref HeadlessSurfaceCreateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceIndexTypeUint8Features : IEquatable<PhysicalDeviceIndexTypeUint8Features>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceIndexTypeUint8FeaturesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 IndexTypeUint8;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceIndexTypeUint8Features o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceIndexTypeUint8Features>.Equals(PhysicalDeviceIndexTypeUint8Features obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ IndexTypeUint8.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceIndexTypeUint8Features l, in PhysicalDeviceIndexTypeUint8Features r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.IndexTypeUint8 == r.IndexTypeUint8)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceIndexTypeUint8Features l, in PhysicalDeviceIndexTypeUint8Features r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.IndexTypeUint8 != r.IndexTypeUint8)
			;
	}


	/// <summary>Creates a new PhysicalDeviceIndexTypeUint8Features value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceIndexTypeUint8Features value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceIndexTypeUint8Features value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceFragmentShaderInterlockFeatures : IEquatable<PhysicalDeviceFragmentShaderInterlockFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceFragmentShaderInterlockFeaturesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 FragmentShaderSampleInterlock;
	public Vk.Bool32 FragmentShaderPixelInterlock;
	public Vk.Bool32 FragmentShaderShadingRateInterlock;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceFragmentShaderInterlockFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceFragmentShaderInterlockFeatures>.Equals(PhysicalDeviceFragmentShaderInterlockFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ FragmentShaderSampleInterlock.GetHashCode() ^ FragmentShaderPixelInterlock.GetHashCode()
			^ FragmentShaderShadingRateInterlock.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceFragmentShaderInterlockFeatures l, in PhysicalDeviceFragmentShaderInterlockFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.FragmentShaderSampleInterlock == r.FragmentShaderSampleInterlock) && (l.FragmentShaderPixelInterlock == r.FragmentShaderPixelInterlock)
			&& (l.FragmentShaderShadingRateInterlock == r.FragmentShaderShadingRateInterlock)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceFragmentShaderInterlockFeatures l, in PhysicalDeviceFragmentShaderInterlockFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.FragmentShaderSampleInterlock != r.FragmentShaderSampleInterlock) || (l.FragmentShaderPixelInterlock != r.FragmentShaderPixelInterlock)
			|| (l.FragmentShaderShadingRateInterlock != r.FragmentShaderShadingRateInterlock)
			;
	}


	/// <summary>Creates a new PhysicalDeviceFragmentShaderInterlockFeatures value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceFragmentShaderInterlockFeatures value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceFragmentShaderInterlockFeatures value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceShaderDemoteToHelperInvocationFeatures : IEquatable<PhysicalDeviceShaderDemoteToHelperInvocationFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 ShaderDemoteToHelperInvocation;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceShaderDemoteToHelperInvocationFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceShaderDemoteToHelperInvocationFeatures>.Equals(PhysicalDeviceShaderDemoteToHelperInvocationFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ShaderDemoteToHelperInvocation.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceShaderDemoteToHelperInvocationFeatures l, in PhysicalDeviceShaderDemoteToHelperInvocationFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ShaderDemoteToHelperInvocation == r.ShaderDemoteToHelperInvocation)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceShaderDemoteToHelperInvocationFeatures l, in PhysicalDeviceShaderDemoteToHelperInvocationFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ShaderDemoteToHelperInvocation != r.ShaderDemoteToHelperInvocation)
			;
	}


	/// <summary>Creates a new PhysicalDeviceShaderDemoteToHelperInvocationFeatures value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceShaderDemoteToHelperInvocationFeatures value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceShaderDemoteToHelperInvocationFeatures value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceTexelBufferAlignmentFeatures : IEquatable<PhysicalDeviceTexelBufferAlignmentFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceTexelBufferAlignmentFeaturesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 TexelBufferAlignment;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceTexelBufferAlignmentFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceTexelBufferAlignmentFeatures>.Equals(PhysicalDeviceTexelBufferAlignmentFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ TexelBufferAlignment.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceTexelBufferAlignmentFeatures l, in PhysicalDeviceTexelBufferAlignmentFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.TexelBufferAlignment == r.TexelBufferAlignment)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceTexelBufferAlignmentFeatures l, in PhysicalDeviceTexelBufferAlignmentFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.TexelBufferAlignment != r.TexelBufferAlignment)
			;
	}


	/// <summary>Creates a new PhysicalDeviceTexelBufferAlignmentFeatures value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceTexelBufferAlignmentFeatures value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceTexelBufferAlignmentFeatures value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceTexelBufferAlignmentProperties : IEquatable<PhysicalDeviceTexelBufferAlignmentProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceTexelBufferAlignmentPropertiesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.DeviceSize StorageTexelBufferOffsetAlignmentBytes;
	public Vk.Bool32 StorageTexelBufferOffsetSingleTexelAlignment;
	public Vk.DeviceSize UniformTexelBufferOffsetAlignmentBytes;
	public Vk.Bool32 UniformTexelBufferOffsetSingleTexelAlignment;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceTexelBufferAlignmentProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceTexelBufferAlignmentProperties>.Equals(PhysicalDeviceTexelBufferAlignmentProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ StorageTexelBufferOffsetAlignmentBytes.GetHashCode() ^ StorageTexelBufferOffsetSingleTexelAlignment.GetHashCode()
			^ UniformTexelBufferOffsetAlignmentBytes.GetHashCode() ^ UniformTexelBufferOffsetSingleTexelAlignment.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceTexelBufferAlignmentProperties l, in PhysicalDeviceTexelBufferAlignmentProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.StorageTexelBufferOffsetAlignmentBytes == r.StorageTexelBufferOffsetAlignmentBytes) && (l.StorageTexelBufferOffsetSingleTexelAlignment == r.StorageTexelBufferOffsetSingleTexelAlignment)
			&& (l.UniformTexelBufferOffsetAlignmentBytes == r.UniformTexelBufferOffsetAlignmentBytes) && (l.UniformTexelBufferOffsetSingleTexelAlignment == r.UniformTexelBufferOffsetSingleTexelAlignment)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceTexelBufferAlignmentProperties l, in PhysicalDeviceTexelBufferAlignmentProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.StorageTexelBufferOffsetAlignmentBytes != r.StorageTexelBufferOffsetAlignmentBytes) || (l.StorageTexelBufferOffsetSingleTexelAlignment != r.StorageTexelBufferOffsetSingleTexelAlignment)
			|| (l.UniformTexelBufferOffsetAlignmentBytes != r.UniformTexelBufferOffsetAlignmentBytes) || (l.UniformTexelBufferOffsetSingleTexelAlignment != r.UniformTexelBufferOffsetSingleTexelAlignment)
			;
	}


	/// <summary>Creates a new PhysicalDeviceTexelBufferAlignmentProperties value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceTexelBufferAlignmentProperties value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceTexelBufferAlignmentProperties value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceSubgroupSizeControlFeatures : IEquatable<PhysicalDeviceSubgroupSizeControlFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceSubgroupSizeControlFeaturesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 SubgroupSizeControl;
	public Vk.Bool32 ComputeFullSubgroups;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceSubgroupSizeControlFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceSubgroupSizeControlFeatures>.Equals(PhysicalDeviceSubgroupSizeControlFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SubgroupSizeControl.GetHashCode() ^ ComputeFullSubgroups.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceSubgroupSizeControlFeatures l, in PhysicalDeviceSubgroupSizeControlFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SubgroupSizeControl == r.SubgroupSizeControl) && (l.ComputeFullSubgroups == r.ComputeFullSubgroups)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceSubgroupSizeControlFeatures l, in PhysicalDeviceSubgroupSizeControlFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SubgroupSizeControl != r.SubgroupSizeControl) || (l.ComputeFullSubgroups != r.ComputeFullSubgroups)
			;
	}


	/// <summary>Creates a new PhysicalDeviceSubgroupSizeControlFeatures value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceSubgroupSizeControlFeatures value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceSubgroupSizeControlFeatures value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceSubgroupSizeControlProperties : IEquatable<PhysicalDeviceSubgroupSizeControlProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceSubgroupSizeControlPropertiesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public uint MinSubgroupSize;
	public uint MaxSubgroupSize;
	public uint MaxComputeWorkgroupSubgroups;
	public Vk.ShaderStageFlags RequiredSubgroupSizeStages;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceSubgroupSizeControlProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceSubgroupSizeControlProperties>.Equals(PhysicalDeviceSubgroupSizeControlProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MinSubgroupSize.GetHashCode() ^ MaxSubgroupSize.GetHashCode()
			^ MaxComputeWorkgroupSubgroups.GetHashCode() ^ RequiredSubgroupSizeStages.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceSubgroupSizeControlProperties l, in PhysicalDeviceSubgroupSizeControlProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MinSubgroupSize == r.MinSubgroupSize) && (l.MaxSubgroupSize == r.MaxSubgroupSize)
			&& (l.MaxComputeWorkgroupSubgroups == r.MaxComputeWorkgroupSubgroups) && (l.RequiredSubgroupSizeStages == r.RequiredSubgroupSizeStages)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceSubgroupSizeControlProperties l, in PhysicalDeviceSubgroupSizeControlProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MinSubgroupSize != r.MinSubgroupSize) || (l.MaxSubgroupSize != r.MaxSubgroupSize)
			|| (l.MaxComputeWorkgroupSubgroups != r.MaxComputeWorkgroupSubgroups) || (l.RequiredSubgroupSizeStages != r.RequiredSubgroupSizeStages)
			;
	}


	/// <summary>Creates a new PhysicalDeviceSubgroupSizeControlProperties value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceSubgroupSizeControlProperties value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceSubgroupSizeControlProperties value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PipelineShaderStageRequiredSubgroupSizeCreateInfo : IEquatable<PipelineShaderStageRequiredSubgroupSizeCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PipelineShaderStageRequiredSubgroupSizeCreateInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public uint RequiredSubgroupSize;

	public readonly override bool Equals(object? obj) => (obj is PipelineShaderStageRequiredSubgroupSizeCreateInfo o) && (this == o);
	readonly bool IEquatable<PipelineShaderStageRequiredSubgroupSizeCreateInfo>.Equals(PipelineShaderStageRequiredSubgroupSizeCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ RequiredSubgroupSize.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PipelineShaderStageRequiredSubgroupSizeCreateInfo l, in PipelineShaderStageRequiredSubgroupSizeCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.RequiredSubgroupSize == r.RequiredSubgroupSize)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PipelineShaderStageRequiredSubgroupSizeCreateInfo l, in PipelineShaderStageRequiredSubgroupSizeCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.RequiredSubgroupSize != r.RequiredSubgroupSize)
			;
	}


	/// <summary>Creates a new PipelineShaderStageRequiredSubgroupSizeCreateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PipelineShaderStageRequiredSubgroupSizeCreateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PipelineShaderStageRequiredSubgroupSizeCreateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceLineRasterizationFeatures : IEquatable<PhysicalDeviceLineRasterizationFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceLineRasterizationFeaturesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 RectangularLines;
	public Vk.Bool32 BresenhamLines;
	public Vk.Bool32 SmoothLines;
	public Vk.Bool32 StippledRectangularLines;
	public Vk.Bool32 StippledBresenhamLines;
	public Vk.Bool32 StippledSmoothLines;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceLineRasterizationFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceLineRasterizationFeatures>.Equals(PhysicalDeviceLineRasterizationFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ RectangularLines.GetHashCode() ^ BresenhamLines.GetHashCode()
			^ SmoothLines.GetHashCode() ^ StippledRectangularLines.GetHashCode() ^ StippledBresenhamLines.GetHashCode() ^ StippledSmoothLines.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceLineRasterizationFeatures l, in PhysicalDeviceLineRasterizationFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.RectangularLines == r.RectangularLines) && (l.BresenhamLines == r.BresenhamLines)
			&& (l.SmoothLines == r.SmoothLines) && (l.StippledRectangularLines == r.StippledRectangularLines) && (l.StippledBresenhamLines == r.StippledBresenhamLines) && (l.StippledSmoothLines == r.StippledSmoothLines)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceLineRasterizationFeatures l, in PhysicalDeviceLineRasterizationFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.RectangularLines != r.RectangularLines) || (l.BresenhamLines != r.BresenhamLines)
			|| (l.SmoothLines != r.SmoothLines) || (l.StippledRectangularLines != r.StippledRectangularLines) || (l.StippledBresenhamLines != r.StippledBresenhamLines) || (l.StippledSmoothLines != r.StippledSmoothLines)
			;
	}


	/// <summary>Creates a new PhysicalDeviceLineRasterizationFeatures value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceLineRasterizationFeatures value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceLineRasterizationFeatures value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceLineRasterizationProperties : IEquatable<PhysicalDeviceLineRasterizationProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceLineRasterizationPropertiesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public uint LineSubPixelPrecisionBits;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceLineRasterizationProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceLineRasterizationProperties>.Equals(PhysicalDeviceLineRasterizationProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ LineSubPixelPrecisionBits.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceLineRasterizationProperties l, in PhysicalDeviceLineRasterizationProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.LineSubPixelPrecisionBits == r.LineSubPixelPrecisionBits)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceLineRasterizationProperties l, in PhysicalDeviceLineRasterizationProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.LineSubPixelPrecisionBits != r.LineSubPixelPrecisionBits)
			;
	}


	/// <summary>Creates a new PhysicalDeviceLineRasterizationProperties value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceLineRasterizationProperties value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceLineRasterizationProperties value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PipelineRasterizationLineStateCreateInfo : IEquatable<PipelineRasterizationLineStateCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PipelineRasterizationLineStateCreateInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.EXT.LineRasterizationMode LineRasterizationMode;
	public Vk.Bool32 StippledLineEnable;
	public uint LineStippleFactor;
	public ushort LineStipplePattern;

	public readonly override bool Equals(object? obj) => (obj is PipelineRasterizationLineStateCreateInfo o) && (this == o);
	readonly bool IEquatable<PipelineRasterizationLineStateCreateInfo>.Equals(PipelineRasterizationLineStateCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ LineRasterizationMode.GetHashCode() ^ StippledLineEnable.GetHashCode()
			^ LineStippleFactor.GetHashCode() ^ LineStipplePattern.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PipelineRasterizationLineStateCreateInfo l, in PipelineRasterizationLineStateCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.LineRasterizationMode == r.LineRasterizationMode) && (l.StippledLineEnable == r.StippledLineEnable)
			&& (l.LineStippleFactor == r.LineStippleFactor) && (l.LineStipplePattern == r.LineStipplePattern)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PipelineRasterizationLineStateCreateInfo l, in PipelineRasterizationLineStateCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.LineRasterizationMode != r.LineRasterizationMode) || (l.StippledLineEnable != r.StippledLineEnable)
			|| (l.LineStippleFactor != r.LineStippleFactor) || (l.LineStipplePattern != r.LineStipplePattern)
			;
	}


	/// <summary>Creates a new PipelineRasterizationLineStateCreateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PipelineRasterizationLineStateCreateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PipelineRasterizationLineStateCreateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDevicePipelineCreationCacheControlFeatures : IEquatable<PhysicalDevicePipelineCreationCacheControlFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDevicePipelineCreationCacheControlFeaturesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 PipelineCreationCacheControl;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDevicePipelineCreationCacheControlFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDevicePipelineCreationCacheControlFeatures>.Equals(PhysicalDevicePipelineCreationCacheControlFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ PipelineCreationCacheControl.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDevicePipelineCreationCacheControlFeatures l, in PhysicalDevicePipelineCreationCacheControlFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.PipelineCreationCacheControl == r.PipelineCreationCacheControl)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDevicePipelineCreationCacheControlFeatures l, in PhysicalDevicePipelineCreationCacheControlFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.PipelineCreationCacheControl != r.PipelineCreationCacheControl)
			;
	}


	/// <summary>Creates a new PhysicalDevicePipelineCreationCacheControlFeatures value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDevicePipelineCreationCacheControlFeatures value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDevicePipelineCreationCacheControlFeatures value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceToolProperties : IEquatable<PhysicalDeviceToolProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceToolPropertiesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.FixedString Name;
	public Vk.FixedString Version;
	public Vk.EXT.ToolPurposeFlags Purposes;
	public Vk.FixedString Description;
	public Vk.FixedString Layer;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceToolProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceToolProperties>.Equals(PhysicalDeviceToolProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Name.GetHashCode() ^ Version.GetHashCode()
			^ Purposes.GetHashCode() ^ Description.GetHashCode() ^ Layer.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceToolProperties l, in PhysicalDeviceToolProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Name == r.Name) && (l.Version == r.Version)
			&& (l.Purposes == r.Purposes) && (l.Description == r.Description) && (l.Layer == r.Layer)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceToolProperties l, in PhysicalDeviceToolProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Name != r.Name) || (l.Version != r.Version)
			|| (l.Purposes != r.Purposes) || (l.Description != r.Description) || (l.Layer != r.Layer)
			;
	}


	/// <summary>Creates a new PhysicalDeviceToolProperties value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceToolProperties value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceToolProperties value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SamplerCustomBorderColorCreateInfo : IEquatable<SamplerCustomBorderColorCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.SamplerCustomBorderColorCreateInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.ClearColorValue CustomBorderColor;
	public Vk.Format Format;

	public readonly override bool Equals(object? obj) => (obj is SamplerCustomBorderColorCreateInfo o) && (this == o);
	readonly bool IEquatable<SamplerCustomBorderColorCreateInfo>.Equals(SamplerCustomBorderColorCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ CustomBorderColor.GetHashCode() ^ Format.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SamplerCustomBorderColorCreateInfo l, in SamplerCustomBorderColorCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.CustomBorderColor == r.CustomBorderColor) && (l.Format == r.Format)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SamplerCustomBorderColorCreateInfo l, in SamplerCustomBorderColorCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.CustomBorderColor != r.CustomBorderColor) || (l.Format != r.Format)
			;
	}


	/// <summary>Creates a new SamplerCustomBorderColorCreateInfo value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SamplerCustomBorderColorCreateInfo value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref SamplerCustomBorderColorCreateInfo value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceCustomBorderColorProperties : IEquatable<PhysicalDeviceCustomBorderColorProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceCustomBorderColorPropertiesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public uint MaxCustomBorderColorSamplers;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceCustomBorderColorProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceCustomBorderColorProperties>.Equals(PhysicalDeviceCustomBorderColorProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MaxCustomBorderColorSamplers.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceCustomBorderColorProperties l, in PhysicalDeviceCustomBorderColorProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MaxCustomBorderColorSamplers == r.MaxCustomBorderColorSamplers)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceCustomBorderColorProperties l, in PhysicalDeviceCustomBorderColorProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MaxCustomBorderColorSamplers != r.MaxCustomBorderColorSamplers)
			;
	}


	/// <summary>Creates a new PhysicalDeviceCustomBorderColorProperties value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceCustomBorderColorProperties value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceCustomBorderColorProperties value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceCustomBorderColorFeatures : IEquatable<PhysicalDeviceCustomBorderColorFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceCustomBorderColorFeaturesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 CustomBorderColors;
	public Vk.Bool32 CustomBorderColorWithoutFormat;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceCustomBorderColorFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceCustomBorderColorFeatures>.Equals(PhysicalDeviceCustomBorderColorFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ CustomBorderColors.GetHashCode() ^ CustomBorderColorWithoutFormat.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceCustomBorderColorFeatures l, in PhysicalDeviceCustomBorderColorFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.CustomBorderColors == r.CustomBorderColors) && (l.CustomBorderColorWithoutFormat == r.CustomBorderColorWithoutFormat)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceCustomBorderColorFeatures l, in PhysicalDeviceCustomBorderColorFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.CustomBorderColors != r.CustomBorderColors) || (l.CustomBorderColorWithoutFormat != r.CustomBorderColorWithoutFormat)
			;
	}


	/// <summary>Creates a new PhysicalDeviceCustomBorderColorFeatures value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceCustomBorderColorFeatures value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceCustomBorderColorFeatures value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceExtendedDynamicStateFeatures : IEquatable<PhysicalDeviceExtendedDynamicStateFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceExtendedDynamicStateFeaturesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 ExtendedDynamicState;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceExtendedDynamicStateFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceExtendedDynamicStateFeatures>.Equals(PhysicalDeviceExtendedDynamicStateFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ExtendedDynamicState.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceExtendedDynamicStateFeatures l, in PhysicalDeviceExtendedDynamicStateFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ExtendedDynamicState == r.ExtendedDynamicState)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceExtendedDynamicStateFeatures l, in PhysicalDeviceExtendedDynamicStateFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ExtendedDynamicState != r.ExtendedDynamicState)
			;
	}


	/// <summary>Creates a new PhysicalDeviceExtendedDynamicStateFeatures value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceExtendedDynamicStateFeatures value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceExtendedDynamicStateFeatures value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceRobustness2Features : IEquatable<PhysicalDeviceRobustness2Features>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceRobustness2FeaturesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 RobustBufferAccess2;
	public Vk.Bool32 RobustImageAccess2;
	public Vk.Bool32 NullDescriptor;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceRobustness2Features o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceRobustness2Features>.Equals(PhysicalDeviceRobustness2Features obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ RobustBufferAccess2.GetHashCode() ^ RobustImageAccess2.GetHashCode()
			^ NullDescriptor.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceRobustness2Features l, in PhysicalDeviceRobustness2Features r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.RobustBufferAccess2 == r.RobustBufferAccess2) && (l.RobustImageAccess2 == r.RobustImageAccess2)
			&& (l.NullDescriptor == r.NullDescriptor)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceRobustness2Features l, in PhysicalDeviceRobustness2Features r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.RobustBufferAccess2 != r.RobustBufferAccess2) || (l.RobustImageAccess2 != r.RobustImageAccess2)
			|| (l.NullDescriptor != r.NullDescriptor)
			;
	}


	/// <summary>Creates a new PhysicalDeviceRobustness2Features value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceRobustness2Features value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceRobustness2Features value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceRobustness2Properties : IEquatable<PhysicalDeviceRobustness2Properties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceRobustness2PropertiesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.DeviceSize RobustStorageBufferAccessSizeAlignment;
	public Vk.DeviceSize RobustUniformBufferAccessSizeAlignment;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceRobustness2Properties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceRobustness2Properties>.Equals(PhysicalDeviceRobustness2Properties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ RobustStorageBufferAccessSizeAlignment.GetHashCode() ^ RobustUniformBufferAccessSizeAlignment.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceRobustness2Properties l, in PhysicalDeviceRobustness2Properties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.RobustStorageBufferAccessSizeAlignment == r.RobustStorageBufferAccessSizeAlignment) && (l.RobustUniformBufferAccessSizeAlignment == r.RobustUniformBufferAccessSizeAlignment)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceRobustness2Properties l, in PhysicalDeviceRobustness2Properties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.RobustStorageBufferAccessSizeAlignment != r.RobustStorageBufferAccessSizeAlignment) || (l.RobustUniformBufferAccessSizeAlignment != r.RobustUniformBufferAccessSizeAlignment)
			;
	}


	/// <summary>Creates a new PhysicalDeviceRobustness2Properties value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceRobustness2Properties value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceRobustness2Properties value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceImageRobustnessFeatures : IEquatable<PhysicalDeviceImageRobustnessFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceImageRobustnessFeaturesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 RobustImageAccess;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceImageRobustnessFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceImageRobustnessFeatures>.Equals(PhysicalDeviceImageRobustnessFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ RobustImageAccess.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceImageRobustnessFeatures l, in PhysicalDeviceImageRobustnessFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.RobustImageAccess == r.RobustImageAccess)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceImageRobustnessFeatures l, in PhysicalDeviceImageRobustnessFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.RobustImageAccess != r.RobustImageAccess)
			;
	}


	/// <summary>Creates a new PhysicalDeviceImageRobustnessFeatures value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceImageRobustnessFeatures value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceImageRobustnessFeatures value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDevice4444FormatsFeatures : IEquatable<PhysicalDevice4444FormatsFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDevice4444FormatsFeaturesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 FormatA4R4G4B4;
	public Vk.Bool32 FormatA4B4G4R4;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDevice4444FormatsFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDevice4444FormatsFeatures>.Equals(PhysicalDevice4444FormatsFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ FormatA4R4G4B4.GetHashCode() ^ FormatA4B4G4R4.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDevice4444FormatsFeatures l, in PhysicalDevice4444FormatsFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.FormatA4R4G4B4 == r.FormatA4R4G4B4) && (l.FormatA4B4G4R4 == r.FormatA4B4G4R4)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDevice4444FormatsFeatures l, in PhysicalDevice4444FormatsFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.FormatA4R4G4B4 != r.FormatA4R4G4B4) || (l.FormatA4B4G4R4 != r.FormatA4B4G4R4)
			;
	}


	/// <summary>Creates a new PhysicalDevice4444FormatsFeatures value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDevice4444FormatsFeatures value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDevice4444FormatsFeatures value) { value.sType = TYPE; value.pNext = null; }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceShaderImageAtomicInt64Features : IEquatable<PhysicalDeviceShaderImageAtomicInt64Features>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceShaderImageAtomicInt64FeaturesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 ShaderImageInt64Atomics;
	public Vk.Bool32 SparseImageInt64Atomics;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceShaderImageAtomicInt64Features o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceShaderImageAtomicInt64Features>.Equals(PhysicalDeviceShaderImageAtomicInt64Features obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ShaderImageInt64Atomics.GetHashCode() ^ SparseImageInt64Atomics.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceShaderImageAtomicInt64Features l, in PhysicalDeviceShaderImageAtomicInt64Features r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ShaderImageInt64Atomics == r.ShaderImageInt64Atomics) && (l.SparseImageInt64Atomics == r.SparseImageInt64Atomics)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceShaderImageAtomicInt64Features l, in PhysicalDeviceShaderImageAtomicInt64Features r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ShaderImageInt64Atomics != r.ShaderImageInt64Atomics) || (l.SparseImageInt64Atomics != r.SparseImageInt64Atomics)
			;
	}


	/// <summary>Creates a new PhysicalDeviceShaderImageAtomicInt64Features value with the correct type field.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceShaderImageAtomicInt64Features value) => value = new() { sType = TYPE };
	/// <summary>Initializes the sType and pNext fields to the correct default values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Init(ref PhysicalDeviceShaderImageAtomicInt64Features value) { value.sType = TYPE; value.pNext = null; }
}

} // namespace Vk.EXT
