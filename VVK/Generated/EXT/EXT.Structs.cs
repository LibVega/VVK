/*
 * MIT License - Copyright(c) 2020 Sean Moss
 * This file is subject to the terms and conditions of the MIT License, the text of which can be found in the 'LICENSE'
 * file at the root of this repository, or online at<https://opensource.org/licenses/MIT>.
 */

/// This file was generated by VVKGen. Edits to this file will be lost on next generation.

using System;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;


namespace Vk.EXT
{

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DirectFBSurfaceCreateInfo : IEquatable<DirectFBSurfaceCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DirectfbSurfaceCreateInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.EXT.DirectFBSurfaceCreateFlags Flags;
	public void* Dfb;
	public void* Surface;
	public DirectFBSurfaceCreateInfo(
		in Vk.EXT.DirectFBSurfaceCreateFlags flags = default,
		void* dfb = default,
		void* surface = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		Dfb = dfb;
		Surface = surface;
	}


	public readonly override bool Equals(object? obj) => (obj is DirectFBSurfaceCreateInfo o) && (this == o);
	readonly bool IEquatable<DirectFBSurfaceCreateInfo>.Equals(DirectFBSurfaceCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ ((ulong)Dfb).GetHashCode()
			^ ((ulong)Surface).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DirectFBSurfaceCreateInfo l, in DirectFBSurfaceCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.Dfb == r.Dfb)
			&& (l.Surface == r.Surface)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DirectFBSurfaceCreateInfo l, in DirectFBSurfaceCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.Dfb != r.Dfb)
			|| (l.Surface != r.Surface)
			;
	}


	/// <summary>Creates a new DirectFBSurfaceCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DirectFBSurfaceCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DebugReportCallbackCreateInfo : IEquatable<DebugReportCallbackCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DebugReportCallbackCreateInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.EXT.DebugReportFlags Flags;
	public delegate* managed<Vk.EXT.DebugReportFlags, Vk.EXT.DebugReportObjectType, ulong, ulong, int, byte*, byte*, void*, Vk.Bool32> Callback;
	public void* UserData;
	public DebugReportCallbackCreateInfo(
		in Vk.EXT.DebugReportFlags flags = default,
		delegate* managed<Vk.EXT.DebugReportFlags, Vk.EXT.DebugReportObjectType, ulong, ulong, int, byte*, byte*, void*, Vk.Bool32> callback = default,
		void* userData = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		Callback = callback;
		UserData = userData;
	}


	public readonly override bool Equals(object? obj) => (obj is DebugReportCallbackCreateInfo o) && (this == o);
	readonly bool IEquatable<DebugReportCallbackCreateInfo>.Equals(DebugReportCallbackCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ ((ulong)Callback).GetHashCode()
			^ ((ulong)UserData).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DebugReportCallbackCreateInfo l, in DebugReportCallbackCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.Callback == r.Callback)
			&& (l.UserData == r.UserData)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DebugReportCallbackCreateInfo l, in DebugReportCallbackCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.Callback != r.Callback)
			|| (l.UserData != r.UserData)
			;
	}


	/// <summary>Creates a new DebugReportCallbackCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DebugReportCallbackCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ValidationFlags : IEquatable<ValidationFlags>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ValidationFlagsEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public uint DisabledValidationCheckCount;
	public Vk.EXT.ValidationCheck* DisabledValidationChecks;
	public ValidationFlags(
		uint disabledValidationCheckCount = default,
		in Vk.EXT.ValidationCheck* disabledValidationChecks = default
	) {
		sType = TYPE;
		pNext = null;
		DisabledValidationCheckCount = disabledValidationCheckCount;
		DisabledValidationChecks = disabledValidationChecks;
	}


	public readonly override bool Equals(object? obj) => (obj is ValidationFlags o) && (this == o);
	readonly bool IEquatable<ValidationFlags>.Equals(ValidationFlags obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DisabledValidationCheckCount.GetHashCode() ^ ((ulong)DisabledValidationChecks).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ValidationFlags l, in ValidationFlags r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DisabledValidationCheckCount == r.DisabledValidationCheckCount) && (l.DisabledValidationChecks == r.DisabledValidationChecks)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ValidationFlags l, in ValidationFlags r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DisabledValidationCheckCount != r.DisabledValidationCheckCount) || (l.DisabledValidationChecks != r.DisabledValidationChecks)
			;
	}


	/// <summary>Creates a new ValidationFlags value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ValidationFlags value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ValidationFeatures : IEquatable<ValidationFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ValidationFeaturesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public uint EnabledValidationFeatureCount;
	public Vk.EXT.ValidationFeatureEnable* EnabledValidationFeatures;
	public uint DisabledValidationFeatureCount;
	public Vk.EXT.ValidationFeatureDisable* DisabledValidationFeatures;
	public ValidationFeatures(
		uint enabledValidationFeatureCount = default,
		in Vk.EXT.ValidationFeatureEnable* enabledValidationFeatures = default,
		uint disabledValidationFeatureCount = default,
		in Vk.EXT.ValidationFeatureDisable* disabledValidationFeatures = default
	) {
		sType = TYPE;
		pNext = null;
		EnabledValidationFeatureCount = enabledValidationFeatureCount;
		EnabledValidationFeatures = enabledValidationFeatures;
		DisabledValidationFeatureCount = disabledValidationFeatureCount;
		DisabledValidationFeatures = disabledValidationFeatures;
	}


	public readonly override bool Equals(object? obj) => (obj is ValidationFeatures o) && (this == o);
	readonly bool IEquatable<ValidationFeatures>.Equals(ValidationFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ EnabledValidationFeatureCount.GetHashCode() ^ ((ulong)EnabledValidationFeatures).GetHashCode()
			^ DisabledValidationFeatureCount.GetHashCode() ^ ((ulong)DisabledValidationFeatures).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ValidationFeatures l, in ValidationFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.EnabledValidationFeatureCount == r.EnabledValidationFeatureCount) && (l.EnabledValidationFeatures == r.EnabledValidationFeatures)
			&& (l.DisabledValidationFeatureCount == r.DisabledValidationFeatureCount) && (l.DisabledValidationFeatures == r.DisabledValidationFeatures)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ValidationFeatures l, in ValidationFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.EnabledValidationFeatureCount != r.EnabledValidationFeatureCount) || (l.EnabledValidationFeatures != r.EnabledValidationFeatures)
			|| (l.DisabledValidationFeatureCount != r.DisabledValidationFeatureCount) || (l.DisabledValidationFeatures != r.DisabledValidationFeatures)
			;
	}


	/// <summary>Creates a new ValidationFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ValidationFeatures value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DebugMarkerObjectNameInfo : IEquatable<DebugMarkerObjectNameInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DebugMarkerObjectNameInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.EXT.DebugReportObjectType ObjectType;
	public ulong Object;
	public byte* ObjectName;
	public DebugMarkerObjectNameInfo(
		in Vk.EXT.DebugReportObjectType objectType = default,
		ulong @object = default,
		byte* objectName = default
	) {
		sType = TYPE;
		pNext = null;
		ObjectType = objectType;
		Object = @object;
		ObjectName = objectName;
	}


	public readonly override bool Equals(object? obj) => (obj is DebugMarkerObjectNameInfo o) && (this == o);
	readonly bool IEquatable<DebugMarkerObjectNameInfo>.Equals(DebugMarkerObjectNameInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ObjectType.GetHashCode() ^ Object.GetHashCode()
			^ ((ulong)ObjectName).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DebugMarkerObjectNameInfo l, in DebugMarkerObjectNameInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ObjectType == r.ObjectType) && (l.Object == r.Object)
			&& (l.ObjectName == r.ObjectName)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DebugMarkerObjectNameInfo l, in DebugMarkerObjectNameInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ObjectType != r.ObjectType) || (l.Object != r.Object)
			|| (l.ObjectName != r.ObjectName)
			;
	}


	/// <summary>Creates a new DebugMarkerObjectNameInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DebugMarkerObjectNameInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DebugMarkerObjectTagInfo : IEquatable<DebugMarkerObjectTagInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DebugMarkerObjectTagInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.EXT.DebugReportObjectType ObjectType;
	public ulong Object;
	public ulong TagName;
	public ulong TagSize;
	public void* Tag;
	public DebugMarkerObjectTagInfo(
		in Vk.EXT.DebugReportObjectType objectType = default,
		ulong @object = default,
		ulong tagName = default,
		ulong tagSize = default,
		void* tag = default
	) {
		sType = TYPE;
		pNext = null;
		ObjectType = objectType;
		Object = @object;
		TagName = tagName;
		TagSize = tagSize;
		Tag = tag;
	}


	public readonly override bool Equals(object? obj) => (obj is DebugMarkerObjectTagInfo o) && (this == o);
	readonly bool IEquatable<DebugMarkerObjectTagInfo>.Equals(DebugMarkerObjectTagInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ObjectType.GetHashCode() ^ Object.GetHashCode()
			^ TagName.GetHashCode() ^ TagSize.GetHashCode() ^ ((ulong)Tag).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DebugMarkerObjectTagInfo l, in DebugMarkerObjectTagInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ObjectType == r.ObjectType) && (l.Object == r.Object)
			&& (l.TagName == r.TagName) && (l.TagSize == r.TagSize) && (l.Tag == r.Tag)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DebugMarkerObjectTagInfo l, in DebugMarkerObjectTagInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ObjectType != r.ObjectType) || (l.Object != r.Object)
			|| (l.TagName != r.TagName) || (l.TagSize != r.TagSize) || (l.Tag != r.Tag)
			;
	}


	/// <summary>Creates a new DebugMarkerObjectTagInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DebugMarkerObjectTagInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DebugMarkerMarkerInfo : IEquatable<DebugMarkerMarkerInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DebugMarkerMarkerInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public byte* MarkerName;
	public fixed float Color[4];
	public DebugMarkerMarkerInfo(
		byte* markerName = default,
		float color0 = default,
		float color1 = default,
		float color2 = default,
		float color3 = default
	) {
		sType = TYPE;
		pNext = null;
		MarkerName = markerName;
		Color[0] = color0;
		Color[1] = color1;
		Color[2] = color2;
		Color[3] = color3;
	}


	public readonly override bool Equals(object? obj) => (obj is DebugMarkerMarkerInfo o) && (this == o);
	readonly bool IEquatable<DebugMarkerMarkerInfo>.Equals(DebugMarkerMarkerInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ((ulong)MarkerName).GetHashCode() ^ Color[0].GetHashCode()
			^ Color[1].GetHashCode() ^ Color[2].GetHashCode() ^ Color[3].GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DebugMarkerMarkerInfo l, in DebugMarkerMarkerInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MarkerName == r.MarkerName) && (l.Color[0] == r.Color[0])
			&& (l.Color[1] == r.Color[1]) && (l.Color[2] == r.Color[2]) && (l.Color[3] == r.Color[3])
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DebugMarkerMarkerInfo l, in DebugMarkerMarkerInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MarkerName != r.MarkerName) || (l.Color[0] != r.Color[0])
			|| (l.Color[1] != r.Color[1]) || (l.Color[2] != r.Color[2]) || (l.Color[3] != r.Color[3])
			;
	}


	/// <summary>Creates a new DebugMarkerMarkerInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DebugMarkerMarkerInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DevicePrivateDataCreateInfo : IEquatable<DevicePrivateDataCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DevicePrivateDataCreateInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public uint PrivateDataSlotRequestCount;
	public DevicePrivateDataCreateInfo(
		uint privateDataSlotRequestCount = default
	) {
		sType = TYPE;
		pNext = null;
		PrivateDataSlotRequestCount = privateDataSlotRequestCount;
	}


	public readonly override bool Equals(object? obj) => (obj is DevicePrivateDataCreateInfo o) && (this == o);
	readonly bool IEquatable<DevicePrivateDataCreateInfo>.Equals(DevicePrivateDataCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ PrivateDataSlotRequestCount.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DevicePrivateDataCreateInfo l, in DevicePrivateDataCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.PrivateDataSlotRequestCount == r.PrivateDataSlotRequestCount)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DevicePrivateDataCreateInfo l, in DevicePrivateDataCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.PrivateDataSlotRequestCount != r.PrivateDataSlotRequestCount)
			;
	}


	/// <summary>Creates a new DevicePrivateDataCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DevicePrivateDataCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PrivateDataSlotCreateInfo : IEquatable<PrivateDataSlotCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PrivateDataSlotCreateInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.EXT.PrivateDataSlotCreateFlags Flags;
	public PrivateDataSlotCreateInfo(
		in Vk.EXT.PrivateDataSlotCreateFlags flags = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
	}


	public readonly override bool Equals(object? obj) => (obj is PrivateDataSlotCreateInfo o) && (this == o);
	readonly bool IEquatable<PrivateDataSlotCreateInfo>.Equals(PrivateDataSlotCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PrivateDataSlotCreateInfo l, in PrivateDataSlotCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PrivateDataSlotCreateInfo l, in PrivateDataSlotCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags)
			;
	}


	/// <summary>Creates a new PrivateDataSlotCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PrivateDataSlotCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDevicePrivateDataFeatures : IEquatable<PhysicalDevicePrivateDataFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDevicePrivateDataFeaturesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 PrivateData;
	public PhysicalDevicePrivateDataFeatures(
		in Vk.Bool32 privateData = default
	) {
		sType = TYPE;
		pNext = null;
		PrivateData = privateData;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDevicePrivateDataFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDevicePrivateDataFeatures>.Equals(PhysicalDevicePrivateDataFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ PrivateData.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDevicePrivateDataFeatures l, in PhysicalDevicePrivateDataFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.PrivateData == r.PrivateData)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDevicePrivateDataFeatures l, in PhysicalDevicePrivateDataFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.PrivateData != r.PrivateData)
			;
	}


	/// <summary>Creates a new PhysicalDevicePrivateDataFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDevicePrivateDataFeatures value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SurfaceCapabilities2 : IEquatable<SurfaceCapabilities2>
{
	public const Vk.StructureType TYPE = Vk.StructureType.SurfaceCapabilities2EXT;

	public Vk.StructureType sType;
	public void* pNext;
	public uint MinImageCount;
	public uint MaxImageCount;
	public Vk.Extent2D CurrentExtent;
	public Vk.Extent2D MinImageExtent;
	public Vk.Extent2D MaxImageExtent;
	public uint MaxImageArrayLayers;
	public Vk.KHR.SurfaceTransformFlags SupportedTransforms;
	public Vk.KHR.SurfaceTransformFlags CurrentTransform;
	public Vk.KHR.CompositeAlphaFlags SupportedCompositeAlpha;
	public Vk.ImageUsageFlags SupportedUsageFlags;
	public Vk.EXT.SurfaceCounterFlags SupportedSurfaceCounters;
	public SurfaceCapabilities2(
		uint minImageCount = default,
		uint maxImageCount = default,
		in Vk.Extent2D currentExtent = default,
		in Vk.Extent2D minImageExtent = default,
		in Vk.Extent2D maxImageExtent = default,
		uint maxImageArrayLayers = default,
		in Vk.KHR.SurfaceTransformFlags supportedTransforms = default,
		in Vk.KHR.SurfaceTransformFlags currentTransform = default,
		in Vk.KHR.CompositeAlphaFlags supportedCompositeAlpha = default,
		in Vk.ImageUsageFlags supportedUsageFlags = default,
		in Vk.EXT.SurfaceCounterFlags supportedSurfaceCounters = default
	) {
		sType = TYPE;
		pNext = null;
		MinImageCount = minImageCount;
		MaxImageCount = maxImageCount;
		CurrentExtent = currentExtent;
		MinImageExtent = minImageExtent;
		MaxImageExtent = maxImageExtent;
		MaxImageArrayLayers = maxImageArrayLayers;
		SupportedTransforms = supportedTransforms;
		CurrentTransform = currentTransform;
		SupportedCompositeAlpha = supportedCompositeAlpha;
		SupportedUsageFlags = supportedUsageFlags;
		SupportedSurfaceCounters = supportedSurfaceCounters;
	}


	public readonly override bool Equals(object? obj) => (obj is SurfaceCapabilities2 o) && (this == o);
	readonly bool IEquatable<SurfaceCapabilities2>.Equals(SurfaceCapabilities2 obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MinImageCount.GetHashCode() ^ MaxImageCount.GetHashCode()
			^ CurrentExtent.GetHashCode() ^ MinImageExtent.GetHashCode() ^ MaxImageExtent.GetHashCode() ^ MaxImageArrayLayers.GetHashCode()
			^ SupportedTransforms.GetHashCode() ^ CurrentTransform.GetHashCode() ^ SupportedCompositeAlpha.GetHashCode() ^ SupportedUsageFlags.GetHashCode()
			^ SupportedSurfaceCounters.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SurfaceCapabilities2 l, in SurfaceCapabilities2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MinImageCount == r.MinImageCount) && (l.MaxImageCount == r.MaxImageCount)
			&& (l.CurrentExtent == r.CurrentExtent) && (l.MinImageExtent == r.MinImageExtent) && (l.MaxImageExtent == r.MaxImageExtent) && (l.MaxImageArrayLayers == r.MaxImageArrayLayers)
			&& (l.SupportedTransforms == r.SupportedTransforms) && (l.CurrentTransform == r.CurrentTransform) && (l.SupportedCompositeAlpha == r.SupportedCompositeAlpha) && (l.SupportedUsageFlags == r.SupportedUsageFlags)
			&& (l.SupportedSurfaceCounters == r.SupportedSurfaceCounters)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SurfaceCapabilities2 l, in SurfaceCapabilities2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MinImageCount != r.MinImageCount) || (l.MaxImageCount != r.MaxImageCount)
			|| (l.CurrentExtent != r.CurrentExtent) || (l.MinImageExtent != r.MinImageExtent) || (l.MaxImageExtent != r.MaxImageExtent) || (l.MaxImageArrayLayers != r.MaxImageArrayLayers)
			|| (l.SupportedTransforms != r.SupportedTransforms) || (l.CurrentTransform != r.CurrentTransform) || (l.SupportedCompositeAlpha != r.SupportedCompositeAlpha) || (l.SupportedUsageFlags != r.SupportedUsageFlags)
			|| (l.SupportedSurfaceCounters != r.SupportedSurfaceCounters)
			;
	}


	/// <summary>Creates a new SurfaceCapabilities2 value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SurfaceCapabilities2 value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DisplayPowerInfo : IEquatable<DisplayPowerInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DisplayPowerInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.EXT.DisplayPowerState PowerState;
	public DisplayPowerInfo(
		in Vk.EXT.DisplayPowerState powerState = default
	) {
		sType = TYPE;
		pNext = null;
		PowerState = powerState;
	}


	public readonly override bool Equals(object? obj) => (obj is DisplayPowerInfo o) && (this == o);
	readonly bool IEquatable<DisplayPowerInfo>.Equals(DisplayPowerInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ PowerState.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DisplayPowerInfo l, in DisplayPowerInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.PowerState == r.PowerState)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DisplayPowerInfo l, in DisplayPowerInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.PowerState != r.PowerState)
			;
	}


	/// <summary>Creates a new DisplayPowerInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DisplayPowerInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DeviceEventInfo : IEquatable<DeviceEventInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DeviceEventInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.EXT.DeviceEventType DeviceEvent;
	public DeviceEventInfo(
		in Vk.EXT.DeviceEventType deviceEvent = default
	) {
		sType = TYPE;
		pNext = null;
		DeviceEvent = deviceEvent;
	}


	public readonly override bool Equals(object? obj) => (obj is DeviceEventInfo o) && (this == o);
	readonly bool IEquatable<DeviceEventInfo>.Equals(DeviceEventInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DeviceEvent.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DeviceEventInfo l, in DeviceEventInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DeviceEvent == r.DeviceEvent)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DeviceEventInfo l, in DeviceEventInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DeviceEvent != r.DeviceEvent)
			;
	}


	/// <summary>Creates a new DeviceEventInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DeviceEventInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DisplayEventInfo : IEquatable<DisplayEventInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DisplayEventInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.EXT.DisplayEventType DisplayEvent;
	public DisplayEventInfo(
		in Vk.EXT.DisplayEventType displayEvent = default
	) {
		sType = TYPE;
		pNext = null;
		DisplayEvent = displayEvent;
	}


	public readonly override bool Equals(object? obj) => (obj is DisplayEventInfo o) && (this == o);
	readonly bool IEquatable<DisplayEventInfo>.Equals(DisplayEventInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DisplayEvent.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DisplayEventInfo l, in DisplayEventInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DisplayEvent == r.DisplayEvent)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DisplayEventInfo l, in DisplayEventInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DisplayEvent != r.DisplayEvent)
			;
	}


	/// <summary>Creates a new DisplayEventInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DisplayEventInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SwapchainCounterCreateInfo : IEquatable<SwapchainCounterCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.SwapchainCounterCreateInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.EXT.SurfaceCounterFlags SurfaceCounters;
	public SwapchainCounterCreateInfo(
		in Vk.EXT.SurfaceCounterFlags surfaceCounters = default
	) {
		sType = TYPE;
		pNext = null;
		SurfaceCounters = surfaceCounters;
	}


	public readonly override bool Equals(object? obj) => (obj is SwapchainCounterCreateInfo o) && (this == o);
	readonly bool IEquatable<SwapchainCounterCreateInfo>.Equals(SwapchainCounterCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SurfaceCounters.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SwapchainCounterCreateInfo l, in SwapchainCounterCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SurfaceCounters == r.SurfaceCounters)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SwapchainCounterCreateInfo l, in SwapchainCounterCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SurfaceCounters != r.SurfaceCounters)
			;
	}


	/// <summary>Creates a new SwapchainCounterCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SwapchainCounterCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct XYColor : IEquatable<XYColor>
{
	public float X;
	public float Y;
	public XYColor(
		float x = default,
		float y = default
	) {
		X = x;
		Y = y;
	}


	public readonly override bool Equals(object? obj) => (obj is XYColor o) && (this == o);
	readonly bool IEquatable<XYColor>.Equals(XYColor obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			X.GetHashCode() ^ Y.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in XYColor l, in XYColor r)
	{
		return
			(l.X == r.X) && (l.Y == r.Y)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in XYColor l, in XYColor r)
	{
		return
			(l.X != r.X) || (l.Y != r.Y)
			;
	}


	/// <summary>Creates a new XYColor value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out XYColor value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct HdrMetadata : IEquatable<HdrMetadata>
{
	public const Vk.StructureType TYPE = Vk.StructureType.HdrMetadataEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.EXT.XYColor DisplayPrimaryRed;
	public Vk.EXT.XYColor DisplayPrimaryGreen;
	public Vk.EXT.XYColor DisplayPrimaryBlue;
	public Vk.EXT.XYColor WhitePoint;
	public float MaxLuminance;
	public float MinLuminance;
	public float MaxContentLightLevel;
	public float MaxFrameAverageLightLevel;
	public HdrMetadata(
		in Vk.EXT.XYColor displayPrimaryRed = default,
		in Vk.EXT.XYColor displayPrimaryGreen = default,
		in Vk.EXT.XYColor displayPrimaryBlue = default,
		in Vk.EXT.XYColor whitePoint = default,
		float maxLuminance = default,
		float minLuminance = default,
		float maxContentLightLevel = default,
		float maxFrameAverageLightLevel = default
	) {
		sType = TYPE;
		pNext = null;
		DisplayPrimaryRed = displayPrimaryRed;
		DisplayPrimaryGreen = displayPrimaryGreen;
		DisplayPrimaryBlue = displayPrimaryBlue;
		WhitePoint = whitePoint;
		MaxLuminance = maxLuminance;
		MinLuminance = minLuminance;
		MaxContentLightLevel = maxContentLightLevel;
		MaxFrameAverageLightLevel = maxFrameAverageLightLevel;
	}


	public readonly override bool Equals(object? obj) => (obj is HdrMetadata o) && (this == o);
	readonly bool IEquatable<HdrMetadata>.Equals(HdrMetadata obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DisplayPrimaryRed.GetHashCode() ^ DisplayPrimaryGreen.GetHashCode()
			^ DisplayPrimaryBlue.GetHashCode() ^ WhitePoint.GetHashCode() ^ MaxLuminance.GetHashCode() ^ MinLuminance.GetHashCode()
			^ MaxContentLightLevel.GetHashCode() ^ MaxFrameAverageLightLevel.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in HdrMetadata l, in HdrMetadata r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DisplayPrimaryRed == r.DisplayPrimaryRed) && (l.DisplayPrimaryGreen == r.DisplayPrimaryGreen)
			&& (l.DisplayPrimaryBlue == r.DisplayPrimaryBlue) && (l.WhitePoint == r.WhitePoint) && (l.MaxLuminance == r.MaxLuminance) && (l.MinLuminance == r.MinLuminance)
			&& (l.MaxContentLightLevel == r.MaxContentLightLevel) && (l.MaxFrameAverageLightLevel == r.MaxFrameAverageLightLevel)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in HdrMetadata l, in HdrMetadata r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DisplayPrimaryRed != r.DisplayPrimaryRed) || (l.DisplayPrimaryGreen != r.DisplayPrimaryGreen)
			|| (l.DisplayPrimaryBlue != r.DisplayPrimaryBlue) || (l.WhitePoint != r.WhitePoint) || (l.MaxLuminance != r.MaxLuminance) || (l.MinLuminance != r.MinLuminance)
			|| (l.MaxContentLightLevel != r.MaxContentLightLevel) || (l.MaxFrameAverageLightLevel != r.MaxFrameAverageLightLevel)
			;
	}


	/// <summary>Creates a new HdrMetadata value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out HdrMetadata value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct MetalSurfaceCreateInfo : IEquatable<MetalSurfaceCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.MetalSurfaceCreateInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.EXT.MetalSurfaceCreateFlags Flags;
	public void* Layer;
	public MetalSurfaceCreateInfo(
		in Vk.EXT.MetalSurfaceCreateFlags flags = default,
		void* layer = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		Layer = layer;
	}


	public readonly override bool Equals(object? obj) => (obj is MetalSurfaceCreateInfo o) && (this == o);
	readonly bool IEquatable<MetalSurfaceCreateInfo>.Equals(MetalSurfaceCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ ((ulong)Layer).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in MetalSurfaceCreateInfo l, in MetalSurfaceCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.Layer == r.Layer)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in MetalSurfaceCreateInfo l, in MetalSurfaceCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.Layer != r.Layer)
			;
	}


	/// <summary>Creates a new MetalSurfaceCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out MetalSurfaceCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceDiscardRectangleProperties : IEquatable<PhysicalDeviceDiscardRectangleProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceDiscardRectanglePropertiesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public uint MaxDiscardRectangles;
	public PhysicalDeviceDiscardRectangleProperties(
		uint maxDiscardRectangles = default
	) {
		sType = TYPE;
		pNext = null;
		MaxDiscardRectangles = maxDiscardRectangles;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceDiscardRectangleProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceDiscardRectangleProperties>.Equals(PhysicalDeviceDiscardRectangleProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MaxDiscardRectangles.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceDiscardRectangleProperties l, in PhysicalDeviceDiscardRectangleProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MaxDiscardRectangles == r.MaxDiscardRectangles)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceDiscardRectangleProperties l, in PhysicalDeviceDiscardRectangleProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MaxDiscardRectangles != r.MaxDiscardRectangles)
			;
	}


	/// <summary>Creates a new PhysicalDeviceDiscardRectangleProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceDiscardRectangleProperties value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PipelineDiscardRectangleStateCreateInfo : IEquatable<PipelineDiscardRectangleStateCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PipelineDiscardRectangleStateCreateInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.EXT.PipelineDiscardRectangleStateCreateFlags Flags;
	public Vk.EXT.DiscardRectangleMode DiscardRectangleMode;
	public uint DiscardRectangleCount;
	public Vk.Rect2D* DiscardRectangles;
	public PipelineDiscardRectangleStateCreateInfo(
		in Vk.EXT.PipelineDiscardRectangleStateCreateFlags flags = default,
		in Vk.EXT.DiscardRectangleMode discardRectangleMode = default,
		uint discardRectangleCount = default,
		in Vk.Rect2D* discardRectangles = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		DiscardRectangleMode = discardRectangleMode;
		DiscardRectangleCount = discardRectangleCount;
		DiscardRectangles = discardRectangles;
	}


	public readonly override bool Equals(object? obj) => (obj is PipelineDiscardRectangleStateCreateInfo o) && (this == o);
	readonly bool IEquatable<PipelineDiscardRectangleStateCreateInfo>.Equals(PipelineDiscardRectangleStateCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ DiscardRectangleMode.GetHashCode()
			^ DiscardRectangleCount.GetHashCode() ^ ((ulong)DiscardRectangles).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PipelineDiscardRectangleStateCreateInfo l, in PipelineDiscardRectangleStateCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.DiscardRectangleMode == r.DiscardRectangleMode)
			&& (l.DiscardRectangleCount == r.DiscardRectangleCount) && (l.DiscardRectangles == r.DiscardRectangles)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PipelineDiscardRectangleStateCreateInfo l, in PipelineDiscardRectangleStateCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.DiscardRectangleMode != r.DiscardRectangleMode)
			|| (l.DiscardRectangleCount != r.DiscardRectangleCount) || (l.DiscardRectangles != r.DiscardRectangles)
			;
	}


	/// <summary>Creates a new PipelineDiscardRectangleStateCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PipelineDiscardRectangleStateCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ConditionalRenderingBeginInfo : IEquatable<ConditionalRenderingBeginInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ConditionalRenderingBeginInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Handle<Vk.Buffer> Buffer;
	public Vk.DeviceSize Offset;
	public Vk.EXT.ConditionalRenderingFlags Flags;
	public ConditionalRenderingBeginInfo(
		in Vk.Handle<Vk.Buffer> buffer = default,
		in Vk.DeviceSize offset = default,
		in Vk.EXT.ConditionalRenderingFlags flags = default
	) {
		sType = TYPE;
		pNext = null;
		Buffer = buffer;
		Offset = offset;
		Flags = flags;
	}


	public readonly override bool Equals(object? obj) => (obj is ConditionalRenderingBeginInfo o) && (this == o);
	readonly bool IEquatable<ConditionalRenderingBeginInfo>.Equals(ConditionalRenderingBeginInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Buffer.GetHashCode() ^ Offset.GetHashCode()
			^ Flags.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ConditionalRenderingBeginInfo l, in ConditionalRenderingBeginInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Buffer == r.Buffer) && (l.Offset == r.Offset)
			&& (l.Flags == r.Flags)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ConditionalRenderingBeginInfo l, in ConditionalRenderingBeginInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Buffer != r.Buffer) || (l.Offset != r.Offset)
			|| (l.Flags != r.Flags)
			;
	}


	/// <summary>Creates a new ConditionalRenderingBeginInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ConditionalRenderingBeginInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceSamplerFilterMinmaxProperties : IEquatable<PhysicalDeviceSamplerFilterMinmaxProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceSamplerFilterMinmaxProperties;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 FilterMinmaxSingleComponentFormats;
	public Vk.Bool32 FilterMinmaxImageComponentMapping;
	public PhysicalDeviceSamplerFilterMinmaxProperties(
		in Vk.Bool32 filterMinmaxSingleComponentFormats = default,
		in Vk.Bool32 filterMinmaxImageComponentMapping = default
	) {
		sType = TYPE;
		pNext = null;
		FilterMinmaxSingleComponentFormats = filterMinmaxSingleComponentFormats;
		FilterMinmaxImageComponentMapping = filterMinmaxImageComponentMapping;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceSamplerFilterMinmaxProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceSamplerFilterMinmaxProperties>.Equals(PhysicalDeviceSamplerFilterMinmaxProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ FilterMinmaxSingleComponentFormats.GetHashCode() ^ FilterMinmaxImageComponentMapping.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceSamplerFilterMinmaxProperties l, in PhysicalDeviceSamplerFilterMinmaxProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.FilterMinmaxSingleComponentFormats == r.FilterMinmaxSingleComponentFormats) && (l.FilterMinmaxImageComponentMapping == r.FilterMinmaxImageComponentMapping)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceSamplerFilterMinmaxProperties l, in PhysicalDeviceSamplerFilterMinmaxProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.FilterMinmaxSingleComponentFormats != r.FilterMinmaxSingleComponentFormats) || (l.FilterMinmaxImageComponentMapping != r.FilterMinmaxImageComponentMapping)
			;
	}


	/// <summary>Creates a new PhysicalDeviceSamplerFilterMinmaxProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceSamplerFilterMinmaxProperties value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SampleLocation : IEquatable<SampleLocation>
{
	public float X;
	public float Y;
	public SampleLocation(
		float x = default,
		float y = default
	) {
		X = x;
		Y = y;
	}


	public readonly override bool Equals(object? obj) => (obj is SampleLocation o) && (this == o);
	readonly bool IEquatable<SampleLocation>.Equals(SampleLocation obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			X.GetHashCode() ^ Y.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SampleLocation l, in SampleLocation r)
	{
		return
			(l.X == r.X) && (l.Y == r.Y)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SampleLocation l, in SampleLocation r)
	{
		return
			(l.X != r.X) || (l.Y != r.Y)
			;
	}


	/// <summary>Creates a new SampleLocation value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SampleLocation value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SampleLocationsInfo : IEquatable<SampleLocationsInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.SampleLocationsInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.SampleCountFlags SampleLocationsPerPixel;
	public Vk.Extent2D SampleLocationGridSize;
	public uint SampleLocationsCount;
	public Vk.EXT.SampleLocation* SampleLocations;
	public SampleLocationsInfo(
		in Vk.SampleCountFlags sampleLocationsPerPixel = default,
		in Vk.Extent2D sampleLocationGridSize = default,
		uint sampleLocationsCount = default,
		in Vk.EXT.SampleLocation* sampleLocations = default
	) {
		sType = TYPE;
		pNext = null;
		SampleLocationsPerPixel = sampleLocationsPerPixel;
		SampleLocationGridSize = sampleLocationGridSize;
		SampleLocationsCount = sampleLocationsCount;
		SampleLocations = sampleLocations;
	}


	public readonly override bool Equals(object? obj) => (obj is SampleLocationsInfo o) && (this == o);
	readonly bool IEquatable<SampleLocationsInfo>.Equals(SampleLocationsInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SampleLocationsPerPixel.GetHashCode() ^ SampleLocationGridSize.GetHashCode()
			^ SampleLocationsCount.GetHashCode() ^ ((ulong)SampleLocations).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SampleLocationsInfo l, in SampleLocationsInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SampleLocationsPerPixel == r.SampleLocationsPerPixel) && (l.SampleLocationGridSize == r.SampleLocationGridSize)
			&& (l.SampleLocationsCount == r.SampleLocationsCount) && (l.SampleLocations == r.SampleLocations)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SampleLocationsInfo l, in SampleLocationsInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SampleLocationsPerPixel != r.SampleLocationsPerPixel) || (l.SampleLocationGridSize != r.SampleLocationGridSize)
			|| (l.SampleLocationsCount != r.SampleLocationsCount) || (l.SampleLocations != r.SampleLocations)
			;
	}


	/// <summary>Creates a new SampleLocationsInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SampleLocationsInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct AttachmentSampleLocations : IEquatable<AttachmentSampleLocations>
{
	public uint AttachmentIndex;
	public Vk.EXT.SampleLocationsInfo SampleLocationsInfo;
	public AttachmentSampleLocations(
		uint attachmentIndex = default,
		in Vk.EXT.SampleLocationsInfo sampleLocationsInfo = default
	) {
		AttachmentIndex = attachmentIndex;
		SampleLocationsInfo = sampleLocationsInfo;
	}


	public readonly override bool Equals(object? obj) => (obj is AttachmentSampleLocations o) && (this == o);
	readonly bool IEquatable<AttachmentSampleLocations>.Equals(AttachmentSampleLocations obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			AttachmentIndex.GetHashCode() ^ SampleLocationsInfo.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in AttachmentSampleLocations l, in AttachmentSampleLocations r)
	{
		return
			(l.AttachmentIndex == r.AttachmentIndex) && (l.SampleLocationsInfo == r.SampleLocationsInfo)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in AttachmentSampleLocations l, in AttachmentSampleLocations r)
	{
		return
			(l.AttachmentIndex != r.AttachmentIndex) || (l.SampleLocationsInfo != r.SampleLocationsInfo)
			;
	}


	/// <summary>Creates a new AttachmentSampleLocations value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out AttachmentSampleLocations value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SubpassSampleLocations : IEquatable<SubpassSampleLocations>
{
	public uint SubpassIndex;
	public Vk.EXT.SampleLocationsInfo SampleLocationsInfo;
	public SubpassSampleLocations(
		uint subpassIndex = default,
		in Vk.EXT.SampleLocationsInfo sampleLocationsInfo = default
	) {
		SubpassIndex = subpassIndex;
		SampleLocationsInfo = sampleLocationsInfo;
	}


	public readonly override bool Equals(object? obj) => (obj is SubpassSampleLocations o) && (this == o);
	readonly bool IEquatable<SubpassSampleLocations>.Equals(SubpassSampleLocations obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			SubpassIndex.GetHashCode() ^ SampleLocationsInfo.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SubpassSampleLocations l, in SubpassSampleLocations r)
	{
		return
			(l.SubpassIndex == r.SubpassIndex) && (l.SampleLocationsInfo == r.SampleLocationsInfo)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SubpassSampleLocations l, in SubpassSampleLocations r)
	{
		return
			(l.SubpassIndex != r.SubpassIndex) || (l.SampleLocationsInfo != r.SampleLocationsInfo)
			;
	}


	/// <summary>Creates a new SubpassSampleLocations value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SubpassSampleLocations value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct RenderPassSampleLocationsBeginInfo : IEquatable<RenderPassSampleLocationsBeginInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.RenderPassSampleLocationsBeginInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public uint AttachmentInitialSampleLocationsCount;
	public Vk.EXT.AttachmentSampleLocations* AttachmentInitialSampleLocations;
	public uint PostSubpassSampleLocationsCount;
	public Vk.EXT.SubpassSampleLocations* PostSubpassSampleLocations;
	public RenderPassSampleLocationsBeginInfo(
		uint attachmentInitialSampleLocationsCount = default,
		in Vk.EXT.AttachmentSampleLocations* attachmentInitialSampleLocations = default,
		uint postSubpassSampleLocationsCount = default,
		in Vk.EXT.SubpassSampleLocations* postSubpassSampleLocations = default
	) {
		sType = TYPE;
		pNext = null;
		AttachmentInitialSampleLocationsCount = attachmentInitialSampleLocationsCount;
		AttachmentInitialSampleLocations = attachmentInitialSampleLocations;
		PostSubpassSampleLocationsCount = postSubpassSampleLocationsCount;
		PostSubpassSampleLocations = postSubpassSampleLocations;
	}


	public readonly override bool Equals(object? obj) => (obj is RenderPassSampleLocationsBeginInfo o) && (this == o);
	readonly bool IEquatable<RenderPassSampleLocationsBeginInfo>.Equals(RenderPassSampleLocationsBeginInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ AttachmentInitialSampleLocationsCount.GetHashCode() ^ ((ulong)AttachmentInitialSampleLocations).GetHashCode()
			^ PostSubpassSampleLocationsCount.GetHashCode() ^ ((ulong)PostSubpassSampleLocations).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in RenderPassSampleLocationsBeginInfo l, in RenderPassSampleLocationsBeginInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.AttachmentInitialSampleLocationsCount == r.AttachmentInitialSampleLocationsCount) && (l.AttachmentInitialSampleLocations == r.AttachmentInitialSampleLocations)
			&& (l.PostSubpassSampleLocationsCount == r.PostSubpassSampleLocationsCount) && (l.PostSubpassSampleLocations == r.PostSubpassSampleLocations)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in RenderPassSampleLocationsBeginInfo l, in RenderPassSampleLocationsBeginInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.AttachmentInitialSampleLocationsCount != r.AttachmentInitialSampleLocationsCount) || (l.AttachmentInitialSampleLocations != r.AttachmentInitialSampleLocations)
			|| (l.PostSubpassSampleLocationsCount != r.PostSubpassSampleLocationsCount) || (l.PostSubpassSampleLocations != r.PostSubpassSampleLocations)
			;
	}


	/// <summary>Creates a new RenderPassSampleLocationsBeginInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out RenderPassSampleLocationsBeginInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PipelineSampleLocationsStateCreateInfo : IEquatable<PipelineSampleLocationsStateCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PipelineSampleLocationsStateCreateInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 SampleLocationsEnable;
	public Vk.EXT.SampleLocationsInfo SampleLocationsInfo;
	public PipelineSampleLocationsStateCreateInfo(
		in Vk.Bool32 sampleLocationsEnable = default,
		in Vk.EXT.SampleLocationsInfo sampleLocationsInfo = default
	) {
		sType = TYPE;
		pNext = null;
		SampleLocationsEnable = sampleLocationsEnable;
		SampleLocationsInfo = sampleLocationsInfo;
	}


	public readonly override bool Equals(object? obj) => (obj is PipelineSampleLocationsStateCreateInfo o) && (this == o);
	readonly bool IEquatable<PipelineSampleLocationsStateCreateInfo>.Equals(PipelineSampleLocationsStateCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SampleLocationsEnable.GetHashCode() ^ SampleLocationsInfo.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PipelineSampleLocationsStateCreateInfo l, in PipelineSampleLocationsStateCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SampleLocationsEnable == r.SampleLocationsEnable) && (l.SampleLocationsInfo == r.SampleLocationsInfo)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PipelineSampleLocationsStateCreateInfo l, in PipelineSampleLocationsStateCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SampleLocationsEnable != r.SampleLocationsEnable) || (l.SampleLocationsInfo != r.SampleLocationsInfo)
			;
	}


	/// <summary>Creates a new PipelineSampleLocationsStateCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PipelineSampleLocationsStateCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceSampleLocationsProperties : IEquatable<PhysicalDeviceSampleLocationsProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceSampleLocationsPropertiesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.SampleCountFlags SampleLocationSampleCounts;
	public Vk.Extent2D MaxSampleLocationGridSize;
	public fixed float SampleLocationCoordinateRange[2];
	public uint SampleLocationSubPixelBits;
	public Vk.Bool32 VariableSampleLocations;
	public PhysicalDeviceSampleLocationsProperties(
		in Vk.SampleCountFlags sampleLocationSampleCounts = default,
		in Vk.Extent2D maxSampleLocationGridSize = default,
		float sampleLocationCoordinateRange0 = default,
		float sampleLocationCoordinateRange1 = default,
		uint sampleLocationSubPixelBits = default,
		in Vk.Bool32 variableSampleLocations = default
	) {
		sType = TYPE;
		pNext = null;
		SampleLocationSampleCounts = sampleLocationSampleCounts;
		MaxSampleLocationGridSize = maxSampleLocationGridSize;
		SampleLocationCoordinateRange[0] = sampleLocationCoordinateRange0;
		SampleLocationCoordinateRange[1] = sampleLocationCoordinateRange1;
		SampleLocationSubPixelBits = sampleLocationSubPixelBits;
		VariableSampleLocations = variableSampleLocations;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceSampleLocationsProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceSampleLocationsProperties>.Equals(PhysicalDeviceSampleLocationsProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SampleLocationSampleCounts.GetHashCode() ^ MaxSampleLocationGridSize.GetHashCode()
			^ SampleLocationCoordinateRange[0].GetHashCode() ^ SampleLocationCoordinateRange[1].GetHashCode() ^ SampleLocationSubPixelBits.GetHashCode() ^ VariableSampleLocations.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceSampleLocationsProperties l, in PhysicalDeviceSampleLocationsProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SampleLocationSampleCounts == r.SampleLocationSampleCounts) && (l.MaxSampleLocationGridSize == r.MaxSampleLocationGridSize)
			&& (l.SampleLocationCoordinateRange[0] == r.SampleLocationCoordinateRange[0]) && (l.SampleLocationCoordinateRange[1] == r.SampleLocationCoordinateRange[1]) && (l.SampleLocationSubPixelBits == r.SampleLocationSubPixelBits) && (l.VariableSampleLocations == r.VariableSampleLocations)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceSampleLocationsProperties l, in PhysicalDeviceSampleLocationsProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SampleLocationSampleCounts != r.SampleLocationSampleCounts) || (l.MaxSampleLocationGridSize != r.MaxSampleLocationGridSize)
			|| (l.SampleLocationCoordinateRange[0] != r.SampleLocationCoordinateRange[0]) || (l.SampleLocationCoordinateRange[1] != r.SampleLocationCoordinateRange[1]) || (l.SampleLocationSubPixelBits != r.SampleLocationSubPixelBits) || (l.VariableSampleLocations != r.VariableSampleLocations)
			;
	}


	/// <summary>Creates a new PhysicalDeviceSampleLocationsProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceSampleLocationsProperties value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct MultisampleProperties : IEquatable<MultisampleProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.MultisamplePropertiesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Extent2D MaxSampleLocationGridSize;
	public MultisampleProperties(
		in Vk.Extent2D maxSampleLocationGridSize = default
	) {
		sType = TYPE;
		pNext = null;
		MaxSampleLocationGridSize = maxSampleLocationGridSize;
	}


	public readonly override bool Equals(object? obj) => (obj is MultisampleProperties o) && (this == o);
	readonly bool IEquatable<MultisampleProperties>.Equals(MultisampleProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MaxSampleLocationGridSize.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in MultisampleProperties l, in MultisampleProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MaxSampleLocationGridSize == r.MaxSampleLocationGridSize)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in MultisampleProperties l, in MultisampleProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MaxSampleLocationGridSize != r.MaxSampleLocationGridSize)
			;
	}


	/// <summary>Creates a new MultisampleProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out MultisampleProperties value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SamplerReductionModeCreateInfo : IEquatable<SamplerReductionModeCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.SamplerReductionModeCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.SamplerReductionMode ReductionMode;
	public SamplerReductionModeCreateInfo(
		in Vk.SamplerReductionMode reductionMode = default
	) {
		sType = TYPE;
		pNext = null;
		ReductionMode = reductionMode;
	}


	public readonly override bool Equals(object? obj) => (obj is SamplerReductionModeCreateInfo o) && (this == o);
	readonly bool IEquatable<SamplerReductionModeCreateInfo>.Equals(SamplerReductionModeCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ReductionMode.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SamplerReductionModeCreateInfo l, in SamplerReductionModeCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ReductionMode == r.ReductionMode)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SamplerReductionModeCreateInfo l, in SamplerReductionModeCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ReductionMode != r.ReductionMode)
			;
	}


	/// <summary>Creates a new SamplerReductionModeCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SamplerReductionModeCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceBlendOperationAdvancedFeatures : IEquatable<PhysicalDeviceBlendOperationAdvancedFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceBlendOperationAdvancedFeaturesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 AdvancedBlendCoherentOperations;
	public PhysicalDeviceBlendOperationAdvancedFeatures(
		in Vk.Bool32 advancedBlendCoherentOperations = default
	) {
		sType = TYPE;
		pNext = null;
		AdvancedBlendCoherentOperations = advancedBlendCoherentOperations;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceBlendOperationAdvancedFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceBlendOperationAdvancedFeatures>.Equals(PhysicalDeviceBlendOperationAdvancedFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ AdvancedBlendCoherentOperations.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceBlendOperationAdvancedFeatures l, in PhysicalDeviceBlendOperationAdvancedFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.AdvancedBlendCoherentOperations == r.AdvancedBlendCoherentOperations)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceBlendOperationAdvancedFeatures l, in PhysicalDeviceBlendOperationAdvancedFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.AdvancedBlendCoherentOperations != r.AdvancedBlendCoherentOperations)
			;
	}


	/// <summary>Creates a new PhysicalDeviceBlendOperationAdvancedFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceBlendOperationAdvancedFeatures value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceBlendOperationAdvancedProperties : IEquatable<PhysicalDeviceBlendOperationAdvancedProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceBlendOperationAdvancedPropertiesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public uint AdvancedBlendMaxColorAttachments;
	public Vk.Bool32 AdvancedBlendIndependentBlend;
	public Vk.Bool32 AdvancedBlendNonPremultipliedSrcColor;
	public Vk.Bool32 AdvancedBlendNonPremultipliedDstColor;
	public Vk.Bool32 AdvancedBlendCorrelatedOverlap;
	public Vk.Bool32 AdvancedBlendAllOperations;
	public PhysicalDeviceBlendOperationAdvancedProperties(
		uint advancedBlendMaxColorAttachments = default,
		in Vk.Bool32 advancedBlendIndependentBlend = default,
		in Vk.Bool32 advancedBlendNonPremultipliedSrcColor = default,
		in Vk.Bool32 advancedBlendNonPremultipliedDstColor = default,
		in Vk.Bool32 advancedBlendCorrelatedOverlap = default,
		in Vk.Bool32 advancedBlendAllOperations = default
	) {
		sType = TYPE;
		pNext = null;
		AdvancedBlendMaxColorAttachments = advancedBlendMaxColorAttachments;
		AdvancedBlendIndependentBlend = advancedBlendIndependentBlend;
		AdvancedBlendNonPremultipliedSrcColor = advancedBlendNonPremultipliedSrcColor;
		AdvancedBlendNonPremultipliedDstColor = advancedBlendNonPremultipliedDstColor;
		AdvancedBlendCorrelatedOverlap = advancedBlendCorrelatedOverlap;
		AdvancedBlendAllOperations = advancedBlendAllOperations;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceBlendOperationAdvancedProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceBlendOperationAdvancedProperties>.Equals(PhysicalDeviceBlendOperationAdvancedProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ AdvancedBlendMaxColorAttachments.GetHashCode() ^ AdvancedBlendIndependentBlend.GetHashCode()
			^ AdvancedBlendNonPremultipliedSrcColor.GetHashCode() ^ AdvancedBlendNonPremultipliedDstColor.GetHashCode() ^ AdvancedBlendCorrelatedOverlap.GetHashCode() ^ AdvancedBlendAllOperations.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceBlendOperationAdvancedProperties l, in PhysicalDeviceBlendOperationAdvancedProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.AdvancedBlendMaxColorAttachments == r.AdvancedBlendMaxColorAttachments) && (l.AdvancedBlendIndependentBlend == r.AdvancedBlendIndependentBlend)
			&& (l.AdvancedBlendNonPremultipliedSrcColor == r.AdvancedBlendNonPremultipliedSrcColor) && (l.AdvancedBlendNonPremultipliedDstColor == r.AdvancedBlendNonPremultipliedDstColor) && (l.AdvancedBlendCorrelatedOverlap == r.AdvancedBlendCorrelatedOverlap) && (l.AdvancedBlendAllOperations == r.AdvancedBlendAllOperations)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceBlendOperationAdvancedProperties l, in PhysicalDeviceBlendOperationAdvancedProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.AdvancedBlendMaxColorAttachments != r.AdvancedBlendMaxColorAttachments) || (l.AdvancedBlendIndependentBlend != r.AdvancedBlendIndependentBlend)
			|| (l.AdvancedBlendNonPremultipliedSrcColor != r.AdvancedBlendNonPremultipliedSrcColor) || (l.AdvancedBlendNonPremultipliedDstColor != r.AdvancedBlendNonPremultipliedDstColor) || (l.AdvancedBlendCorrelatedOverlap != r.AdvancedBlendCorrelatedOverlap) || (l.AdvancedBlendAllOperations != r.AdvancedBlendAllOperations)
			;
	}


	/// <summary>Creates a new PhysicalDeviceBlendOperationAdvancedProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceBlendOperationAdvancedProperties value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PipelineColorBlendAdvancedStateCreateInfo : IEquatable<PipelineColorBlendAdvancedStateCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PipelineColorBlendAdvancedStateCreateInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 SrcPremultiplied;
	public Vk.Bool32 DstPremultiplied;
	public Vk.EXT.BlendOverlap BlendOverlap;
	public PipelineColorBlendAdvancedStateCreateInfo(
		in Vk.Bool32 srcPremultiplied = default,
		in Vk.Bool32 dstPremultiplied = default,
		in Vk.EXT.BlendOverlap blendOverlap = default
	) {
		sType = TYPE;
		pNext = null;
		SrcPremultiplied = srcPremultiplied;
		DstPremultiplied = dstPremultiplied;
		BlendOverlap = blendOverlap;
	}


	public readonly override bool Equals(object? obj) => (obj is PipelineColorBlendAdvancedStateCreateInfo o) && (this == o);
	readonly bool IEquatable<PipelineColorBlendAdvancedStateCreateInfo>.Equals(PipelineColorBlendAdvancedStateCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SrcPremultiplied.GetHashCode() ^ DstPremultiplied.GetHashCode()
			^ BlendOverlap.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PipelineColorBlendAdvancedStateCreateInfo l, in PipelineColorBlendAdvancedStateCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SrcPremultiplied == r.SrcPremultiplied) && (l.DstPremultiplied == r.DstPremultiplied)
			&& (l.BlendOverlap == r.BlendOverlap)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PipelineColorBlendAdvancedStateCreateInfo l, in PipelineColorBlendAdvancedStateCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SrcPremultiplied != r.SrcPremultiplied) || (l.DstPremultiplied != r.DstPremultiplied)
			|| (l.BlendOverlap != r.BlendOverlap)
			;
	}


	/// <summary>Creates a new PipelineColorBlendAdvancedStateCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PipelineColorBlendAdvancedStateCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceInlineUniformBlockFeatures : IEquatable<PhysicalDeviceInlineUniformBlockFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceInlineUniformBlockFeaturesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 InlineUniformBlock;
	public Vk.Bool32 DescriptorBindingInlineUniformBlockUpdateAfterBind;
	public PhysicalDeviceInlineUniformBlockFeatures(
		in Vk.Bool32 inlineUniformBlock = default,
		in Vk.Bool32 descriptorBindingInlineUniformBlockUpdateAfterBind = default
	) {
		sType = TYPE;
		pNext = null;
		InlineUniformBlock = inlineUniformBlock;
		DescriptorBindingInlineUniformBlockUpdateAfterBind = descriptorBindingInlineUniformBlockUpdateAfterBind;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceInlineUniformBlockFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceInlineUniformBlockFeatures>.Equals(PhysicalDeviceInlineUniformBlockFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ InlineUniformBlock.GetHashCode() ^ DescriptorBindingInlineUniformBlockUpdateAfterBind.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceInlineUniformBlockFeatures l, in PhysicalDeviceInlineUniformBlockFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.InlineUniformBlock == r.InlineUniformBlock) && (l.DescriptorBindingInlineUniformBlockUpdateAfterBind == r.DescriptorBindingInlineUniformBlockUpdateAfterBind)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceInlineUniformBlockFeatures l, in PhysicalDeviceInlineUniformBlockFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.InlineUniformBlock != r.InlineUniformBlock) || (l.DescriptorBindingInlineUniformBlockUpdateAfterBind != r.DescriptorBindingInlineUniformBlockUpdateAfterBind)
			;
	}


	/// <summary>Creates a new PhysicalDeviceInlineUniformBlockFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceInlineUniformBlockFeatures value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceInlineUniformBlockProperties : IEquatable<PhysicalDeviceInlineUniformBlockProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceInlineUniformBlockPropertiesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public uint MaxInlineUniformBlockSize;
	public uint MaxPerStageDescriptorInlineUniformBlocks;
	public uint MaxPerStageDescriptorUpdateAfterBindInlineUniformBlocks;
	public uint MaxDescriptorSetInlineUniformBlocks;
	public uint MaxDescriptorSetUpdateAfterBindInlineUniformBlocks;
	public PhysicalDeviceInlineUniformBlockProperties(
		uint maxInlineUniformBlockSize = default,
		uint maxPerStageDescriptorInlineUniformBlocks = default,
		uint maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks = default,
		uint maxDescriptorSetInlineUniformBlocks = default,
		uint maxDescriptorSetUpdateAfterBindInlineUniformBlocks = default
	) {
		sType = TYPE;
		pNext = null;
		MaxInlineUniformBlockSize = maxInlineUniformBlockSize;
		MaxPerStageDescriptorInlineUniformBlocks = maxPerStageDescriptorInlineUniformBlocks;
		MaxPerStageDescriptorUpdateAfterBindInlineUniformBlocks = maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks;
		MaxDescriptorSetInlineUniformBlocks = maxDescriptorSetInlineUniformBlocks;
		MaxDescriptorSetUpdateAfterBindInlineUniformBlocks = maxDescriptorSetUpdateAfterBindInlineUniformBlocks;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceInlineUniformBlockProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceInlineUniformBlockProperties>.Equals(PhysicalDeviceInlineUniformBlockProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MaxInlineUniformBlockSize.GetHashCode() ^ MaxPerStageDescriptorInlineUniformBlocks.GetHashCode()
			^ MaxPerStageDescriptorUpdateAfterBindInlineUniformBlocks.GetHashCode() ^ MaxDescriptorSetInlineUniformBlocks.GetHashCode() ^ MaxDescriptorSetUpdateAfterBindInlineUniformBlocks.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceInlineUniformBlockProperties l, in PhysicalDeviceInlineUniformBlockProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MaxInlineUniformBlockSize == r.MaxInlineUniformBlockSize) && (l.MaxPerStageDescriptorInlineUniformBlocks == r.MaxPerStageDescriptorInlineUniformBlocks)
			&& (l.MaxPerStageDescriptorUpdateAfterBindInlineUniformBlocks == r.MaxPerStageDescriptorUpdateAfterBindInlineUniformBlocks) && (l.MaxDescriptorSetInlineUniformBlocks == r.MaxDescriptorSetInlineUniformBlocks) && (l.MaxDescriptorSetUpdateAfterBindInlineUniformBlocks == r.MaxDescriptorSetUpdateAfterBindInlineUniformBlocks)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceInlineUniformBlockProperties l, in PhysicalDeviceInlineUniformBlockProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MaxInlineUniformBlockSize != r.MaxInlineUniformBlockSize) || (l.MaxPerStageDescriptorInlineUniformBlocks != r.MaxPerStageDescriptorInlineUniformBlocks)
			|| (l.MaxPerStageDescriptorUpdateAfterBindInlineUniformBlocks != r.MaxPerStageDescriptorUpdateAfterBindInlineUniformBlocks) || (l.MaxDescriptorSetInlineUniformBlocks != r.MaxDescriptorSetInlineUniformBlocks) || (l.MaxDescriptorSetUpdateAfterBindInlineUniformBlocks != r.MaxDescriptorSetUpdateAfterBindInlineUniformBlocks)
			;
	}


	/// <summary>Creates a new PhysicalDeviceInlineUniformBlockProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceInlineUniformBlockProperties value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct WriteDescriptorSetInlineUniformBlock : IEquatable<WriteDescriptorSetInlineUniformBlock>
{
	public const Vk.StructureType TYPE = Vk.StructureType.WriteDescriptorSetInlineUniformBlockEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public uint DataSize;
	public void* Data;
	public WriteDescriptorSetInlineUniformBlock(
		uint dataSize = default,
		void* data = default
	) {
		sType = TYPE;
		pNext = null;
		DataSize = dataSize;
		Data = data;
	}


	public readonly override bool Equals(object? obj) => (obj is WriteDescriptorSetInlineUniformBlock o) && (this == o);
	readonly bool IEquatable<WriteDescriptorSetInlineUniformBlock>.Equals(WriteDescriptorSetInlineUniformBlock obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DataSize.GetHashCode() ^ ((ulong)Data).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in WriteDescriptorSetInlineUniformBlock l, in WriteDescriptorSetInlineUniformBlock r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DataSize == r.DataSize) && (l.Data == r.Data)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in WriteDescriptorSetInlineUniformBlock l, in WriteDescriptorSetInlineUniformBlock r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DataSize != r.DataSize) || (l.Data != r.Data)
			;
	}


	/// <summary>Creates a new WriteDescriptorSetInlineUniformBlock value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out WriteDescriptorSetInlineUniformBlock value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DescriptorPoolInlineUniformBlockCreateInfo : IEquatable<DescriptorPoolInlineUniformBlockCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DescriptorPoolInlineUniformBlockCreateInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public uint MaxInlineUniformBlockBindings;
	public DescriptorPoolInlineUniformBlockCreateInfo(
		uint maxInlineUniformBlockBindings = default
	) {
		sType = TYPE;
		pNext = null;
		MaxInlineUniformBlockBindings = maxInlineUniformBlockBindings;
	}


	public readonly override bool Equals(object? obj) => (obj is DescriptorPoolInlineUniformBlockCreateInfo o) && (this == o);
	readonly bool IEquatable<DescriptorPoolInlineUniformBlockCreateInfo>.Equals(DescriptorPoolInlineUniformBlockCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MaxInlineUniformBlockBindings.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DescriptorPoolInlineUniformBlockCreateInfo l, in DescriptorPoolInlineUniformBlockCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MaxInlineUniformBlockBindings == r.MaxInlineUniformBlockBindings)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DescriptorPoolInlineUniformBlockCreateInfo l, in DescriptorPoolInlineUniformBlockCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MaxInlineUniformBlockBindings != r.MaxInlineUniformBlockBindings)
			;
	}


	/// <summary>Creates a new DescriptorPoolInlineUniformBlockCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DescriptorPoolInlineUniformBlockCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ValidationCacheCreateInfo : IEquatable<ValidationCacheCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ValidationCacheCreateInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.EXT.ValidationCacheCreateFlags Flags;
	public ulong InitialDataSize;
	public void* InitialData;
	public ValidationCacheCreateInfo(
		in Vk.EXT.ValidationCacheCreateFlags flags = default,
		ulong initialDataSize = default,
		void* initialData = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		InitialDataSize = initialDataSize;
		InitialData = initialData;
	}


	public readonly override bool Equals(object? obj) => (obj is ValidationCacheCreateInfo o) && (this == o);
	readonly bool IEquatable<ValidationCacheCreateInfo>.Equals(ValidationCacheCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ InitialDataSize.GetHashCode()
			^ ((ulong)InitialData).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ValidationCacheCreateInfo l, in ValidationCacheCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.InitialDataSize == r.InitialDataSize)
			&& (l.InitialData == r.InitialData)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ValidationCacheCreateInfo l, in ValidationCacheCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.InitialDataSize != r.InitialDataSize)
			|| (l.InitialData != r.InitialData)
			;
	}


	/// <summary>Creates a new ValidationCacheCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ValidationCacheCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ShaderModuleValidationCacheCreateInfo : IEquatable<ShaderModuleValidationCacheCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ShaderModuleValidationCacheCreateInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Handle<Vk.EXT.ValidationCache> ValidationCache;
	public ShaderModuleValidationCacheCreateInfo(
		in Vk.Handle<Vk.EXT.ValidationCache> validationCache = default
	) {
		sType = TYPE;
		pNext = null;
		ValidationCache = validationCache;
	}


	public readonly override bool Equals(object? obj) => (obj is ShaderModuleValidationCacheCreateInfo o) && (this == o);
	readonly bool IEquatable<ShaderModuleValidationCacheCreateInfo>.Equals(ShaderModuleValidationCacheCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ValidationCache.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ShaderModuleValidationCacheCreateInfo l, in ShaderModuleValidationCacheCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ValidationCache == r.ValidationCache)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ShaderModuleValidationCacheCreateInfo l, in ShaderModuleValidationCacheCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ValidationCache != r.ValidationCache)
			;
	}


	/// <summary>Creates a new ShaderModuleValidationCacheCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ShaderModuleValidationCacheCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceHostQueryResetFeatures : IEquatable<PhysicalDeviceHostQueryResetFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceHostQueryResetFeatures;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 HostQueryReset;
	public PhysicalDeviceHostQueryResetFeatures(
		in Vk.Bool32 hostQueryReset = default
	) {
		sType = TYPE;
		pNext = null;
		HostQueryReset = hostQueryReset;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceHostQueryResetFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceHostQueryResetFeatures>.Equals(PhysicalDeviceHostQueryResetFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ HostQueryReset.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceHostQueryResetFeatures l, in PhysicalDeviceHostQueryResetFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.HostQueryReset == r.HostQueryReset)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceHostQueryResetFeatures l, in PhysicalDeviceHostQueryResetFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.HostQueryReset != r.HostQueryReset)
			;
	}


	/// <summary>Creates a new PhysicalDeviceHostQueryResetFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceHostQueryResetFeatures value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DeviceQueueGlobalPriorityCreateInfo : IEquatable<DeviceQueueGlobalPriorityCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DeviceQueueGlobalPriorityCreateInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.EXT.QueueGlobalPriority GlobalPriority;
	public DeviceQueueGlobalPriorityCreateInfo(
		in Vk.EXT.QueueGlobalPriority globalPriority = default
	) {
		sType = TYPE;
		pNext = null;
		GlobalPriority = globalPriority;
	}


	public readonly override bool Equals(object? obj) => (obj is DeviceQueueGlobalPriorityCreateInfo o) && (this == o);
	readonly bool IEquatable<DeviceQueueGlobalPriorityCreateInfo>.Equals(DeviceQueueGlobalPriorityCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ GlobalPriority.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DeviceQueueGlobalPriorityCreateInfo l, in DeviceQueueGlobalPriorityCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.GlobalPriority == r.GlobalPriority)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DeviceQueueGlobalPriorityCreateInfo l, in DeviceQueueGlobalPriorityCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.GlobalPriority != r.GlobalPriority)
			;
	}


	/// <summary>Creates a new DeviceQueueGlobalPriorityCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DeviceQueueGlobalPriorityCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DebugUtilsObjectNameInfo : IEquatable<DebugUtilsObjectNameInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DebugUtilsObjectNameInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.ObjectType ObjectType;
	public ulong ObjectHandle;
	public byte* ObjectName;
	public DebugUtilsObjectNameInfo(
		in Vk.ObjectType objectType = default,
		ulong objectHandle = default,
		byte* objectName = default
	) {
		sType = TYPE;
		pNext = null;
		ObjectType = objectType;
		ObjectHandle = objectHandle;
		ObjectName = objectName;
	}


	public readonly override bool Equals(object? obj) => (obj is DebugUtilsObjectNameInfo o) && (this == o);
	readonly bool IEquatable<DebugUtilsObjectNameInfo>.Equals(DebugUtilsObjectNameInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ObjectType.GetHashCode() ^ ObjectHandle.GetHashCode()
			^ ((ulong)ObjectName).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DebugUtilsObjectNameInfo l, in DebugUtilsObjectNameInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ObjectType == r.ObjectType) && (l.ObjectHandle == r.ObjectHandle)
			&& (l.ObjectName == r.ObjectName)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DebugUtilsObjectNameInfo l, in DebugUtilsObjectNameInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ObjectType != r.ObjectType) || (l.ObjectHandle != r.ObjectHandle)
			|| (l.ObjectName != r.ObjectName)
			;
	}


	/// <summary>Creates a new DebugUtilsObjectNameInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DebugUtilsObjectNameInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DebugUtilsObjectTagInfo : IEquatable<DebugUtilsObjectTagInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DebugUtilsObjectTagInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.ObjectType ObjectType;
	public ulong ObjectHandle;
	public ulong TagName;
	public ulong TagSize;
	public void* Tag;
	public DebugUtilsObjectTagInfo(
		in Vk.ObjectType objectType = default,
		ulong objectHandle = default,
		ulong tagName = default,
		ulong tagSize = default,
		void* tag = default
	) {
		sType = TYPE;
		pNext = null;
		ObjectType = objectType;
		ObjectHandle = objectHandle;
		TagName = tagName;
		TagSize = tagSize;
		Tag = tag;
	}


	public readonly override bool Equals(object? obj) => (obj is DebugUtilsObjectTagInfo o) && (this == o);
	readonly bool IEquatable<DebugUtilsObjectTagInfo>.Equals(DebugUtilsObjectTagInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ObjectType.GetHashCode() ^ ObjectHandle.GetHashCode()
			^ TagName.GetHashCode() ^ TagSize.GetHashCode() ^ ((ulong)Tag).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DebugUtilsObjectTagInfo l, in DebugUtilsObjectTagInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ObjectType == r.ObjectType) && (l.ObjectHandle == r.ObjectHandle)
			&& (l.TagName == r.TagName) && (l.TagSize == r.TagSize) && (l.Tag == r.Tag)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DebugUtilsObjectTagInfo l, in DebugUtilsObjectTagInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ObjectType != r.ObjectType) || (l.ObjectHandle != r.ObjectHandle)
			|| (l.TagName != r.TagName) || (l.TagSize != r.TagSize) || (l.Tag != r.Tag)
			;
	}


	/// <summary>Creates a new DebugUtilsObjectTagInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DebugUtilsObjectTagInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DebugUtilsLabel : IEquatable<DebugUtilsLabel>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DebugUtilsLabelEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public byte* LabelName;
	public fixed float Color[4];
	public DebugUtilsLabel(
		byte* labelName = default,
		float color0 = default,
		float color1 = default,
		float color2 = default,
		float color3 = default
	) {
		sType = TYPE;
		pNext = null;
		LabelName = labelName;
		Color[0] = color0;
		Color[1] = color1;
		Color[2] = color2;
		Color[3] = color3;
	}


	public readonly override bool Equals(object? obj) => (obj is DebugUtilsLabel o) && (this == o);
	readonly bool IEquatable<DebugUtilsLabel>.Equals(DebugUtilsLabel obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ((ulong)LabelName).GetHashCode() ^ Color[0].GetHashCode()
			^ Color[1].GetHashCode() ^ Color[2].GetHashCode() ^ Color[3].GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DebugUtilsLabel l, in DebugUtilsLabel r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.LabelName == r.LabelName) && (l.Color[0] == r.Color[0])
			&& (l.Color[1] == r.Color[1]) && (l.Color[2] == r.Color[2]) && (l.Color[3] == r.Color[3])
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DebugUtilsLabel l, in DebugUtilsLabel r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.LabelName != r.LabelName) || (l.Color[0] != r.Color[0])
			|| (l.Color[1] != r.Color[1]) || (l.Color[2] != r.Color[2]) || (l.Color[3] != r.Color[3])
			;
	}


	/// <summary>Creates a new DebugUtilsLabel value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DebugUtilsLabel value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DebugUtilsMessengerCreateInfo : IEquatable<DebugUtilsMessengerCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DebugUtilsMessengerCreateInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.EXT.DebugUtilsMessengerCreateFlags Flags;
	public Vk.EXT.DebugUtilsMessageSeverityFlags MessageSeverity;
	public Vk.EXT.DebugUtilsMessageTypeFlags MessageType;
	public delegate* managed<Vk.EXT.DebugUtilsMessageSeverityFlags, Vk.EXT.DebugUtilsMessageTypeFlags, Vk.EXT.DebugUtilsMessengerCallbackData*, void*, Vk.Bool32> UserCallback;
	public void* UserData;
	public DebugUtilsMessengerCreateInfo(
		in Vk.EXT.DebugUtilsMessengerCreateFlags flags = default,
		in Vk.EXT.DebugUtilsMessageSeverityFlags messageSeverity = default,
		in Vk.EXT.DebugUtilsMessageTypeFlags messageType = default,
		delegate* managed<Vk.EXT.DebugUtilsMessageSeverityFlags, Vk.EXT.DebugUtilsMessageTypeFlags, Vk.EXT.DebugUtilsMessengerCallbackData*, void*, Vk.Bool32> userCallback = default,
		void* userData = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		MessageSeverity = messageSeverity;
		MessageType = messageType;
		UserCallback = userCallback;
		UserData = userData;
	}


	public readonly override bool Equals(object? obj) => (obj is DebugUtilsMessengerCreateInfo o) && (this == o);
	readonly bool IEquatable<DebugUtilsMessengerCreateInfo>.Equals(DebugUtilsMessengerCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ MessageSeverity.GetHashCode()
			^ MessageType.GetHashCode() ^ ((ulong)UserCallback).GetHashCode() ^ ((ulong)UserData).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DebugUtilsMessengerCreateInfo l, in DebugUtilsMessengerCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.MessageSeverity == r.MessageSeverity)
			&& (l.MessageType == r.MessageType) && (l.UserCallback == r.UserCallback) && (l.UserData == r.UserData)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DebugUtilsMessengerCreateInfo l, in DebugUtilsMessengerCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.MessageSeverity != r.MessageSeverity)
			|| (l.MessageType != r.MessageType) || (l.UserCallback != r.UserCallback) || (l.UserData != r.UserData)
			;
	}


	/// <summary>Creates a new DebugUtilsMessengerCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DebugUtilsMessengerCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DebugUtilsMessengerCallbackData : IEquatable<DebugUtilsMessengerCallbackData>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DebugUtilsMessengerCallbackDataEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.EXT.DebugUtilsMessengerCallbackDataFlags Flags;
	public byte* MessageIdName;
	public int MessageIdNumber;
	public byte* Message;
	public uint QueueLabelCount;
	public Vk.EXT.DebugUtilsLabel* QueueLabels;
	public uint CmdBufLabelCount;
	public Vk.EXT.DebugUtilsLabel* CmdBufLabels;
	public uint ObjectCount;
	public Vk.EXT.DebugUtilsObjectNameInfo* Objects;
	public DebugUtilsMessengerCallbackData(
		in Vk.EXT.DebugUtilsMessengerCallbackDataFlags flags = default,
		byte* messageIdName = default,
		int messageIdNumber = default,
		byte* message = default,
		uint queueLabelCount = default,
		in Vk.EXT.DebugUtilsLabel* queueLabels = default,
		uint cmdBufLabelCount = default,
		in Vk.EXT.DebugUtilsLabel* cmdBufLabels = default,
		uint objectCount = default,
		in Vk.EXT.DebugUtilsObjectNameInfo* objects = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		MessageIdName = messageIdName;
		MessageIdNumber = messageIdNumber;
		Message = message;
		QueueLabelCount = queueLabelCount;
		QueueLabels = queueLabels;
		CmdBufLabelCount = cmdBufLabelCount;
		CmdBufLabels = cmdBufLabels;
		ObjectCount = objectCount;
		Objects = objects;
	}


	public readonly override bool Equals(object? obj) => (obj is DebugUtilsMessengerCallbackData o) && (this == o);
	readonly bool IEquatable<DebugUtilsMessengerCallbackData>.Equals(DebugUtilsMessengerCallbackData obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ ((ulong)MessageIdName).GetHashCode()
			^ MessageIdNumber.GetHashCode() ^ ((ulong)Message).GetHashCode() ^ QueueLabelCount.GetHashCode() ^ ((ulong)QueueLabels).GetHashCode()
			^ CmdBufLabelCount.GetHashCode() ^ ((ulong)CmdBufLabels).GetHashCode() ^ ObjectCount.GetHashCode() ^ ((ulong)Objects).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DebugUtilsMessengerCallbackData l, in DebugUtilsMessengerCallbackData r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.MessageIdName == r.MessageIdName)
			&& (l.MessageIdNumber == r.MessageIdNumber) && (l.Message == r.Message) && (l.QueueLabelCount == r.QueueLabelCount) && (l.QueueLabels == r.QueueLabels)
			&& (l.CmdBufLabelCount == r.CmdBufLabelCount) && (l.CmdBufLabels == r.CmdBufLabels) && (l.ObjectCount == r.ObjectCount) && (l.Objects == r.Objects)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DebugUtilsMessengerCallbackData l, in DebugUtilsMessengerCallbackData r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.MessageIdName != r.MessageIdName)
			|| (l.MessageIdNumber != r.MessageIdNumber) || (l.Message != r.Message) || (l.QueueLabelCount != r.QueueLabelCount) || (l.QueueLabels != r.QueueLabels)
			|| (l.CmdBufLabelCount != r.CmdBufLabelCount) || (l.CmdBufLabels != r.CmdBufLabels) || (l.ObjectCount != r.ObjectCount) || (l.Objects != r.Objects)
			;
	}


	/// <summary>Creates a new DebugUtilsMessengerCallbackData value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DebugUtilsMessengerCallbackData value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceDeviceMemoryReportFeatures : IEquatable<PhysicalDeviceDeviceMemoryReportFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceDeviceMemoryReportFeaturesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 DeviceMemoryReport;
	public PhysicalDeviceDeviceMemoryReportFeatures(
		in Vk.Bool32 deviceMemoryReport = default
	) {
		sType = TYPE;
		pNext = null;
		DeviceMemoryReport = deviceMemoryReport;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceDeviceMemoryReportFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceDeviceMemoryReportFeatures>.Equals(PhysicalDeviceDeviceMemoryReportFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DeviceMemoryReport.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceDeviceMemoryReportFeatures l, in PhysicalDeviceDeviceMemoryReportFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DeviceMemoryReport == r.DeviceMemoryReport)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceDeviceMemoryReportFeatures l, in PhysicalDeviceDeviceMemoryReportFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DeviceMemoryReport != r.DeviceMemoryReport)
			;
	}


	/// <summary>Creates a new PhysicalDeviceDeviceMemoryReportFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceDeviceMemoryReportFeatures value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DeviceDeviceMemoryReportCreateInfo : IEquatable<DeviceDeviceMemoryReportCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DeviceDeviceMemoryReportCreateInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.EXT.DeviceMemoryReportFlags Flags;
	public delegate* managed<Vk.EXT.DeviceMemoryReportCallbackData*, void*, void> UserCallback;
	public void* UserData;
	public DeviceDeviceMemoryReportCreateInfo(
		in Vk.EXT.DeviceMemoryReportFlags flags = default,
		delegate* managed<Vk.EXT.DeviceMemoryReportCallbackData*, void*, void> userCallback = default,
		void* userData = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		UserCallback = userCallback;
		UserData = userData;
	}


	public readonly override bool Equals(object? obj) => (obj is DeviceDeviceMemoryReportCreateInfo o) && (this == o);
	readonly bool IEquatable<DeviceDeviceMemoryReportCreateInfo>.Equals(DeviceDeviceMemoryReportCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ ((ulong)UserCallback).GetHashCode()
			^ ((ulong)UserData).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DeviceDeviceMemoryReportCreateInfo l, in DeviceDeviceMemoryReportCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.UserCallback == r.UserCallback)
			&& (l.UserData == r.UserData)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DeviceDeviceMemoryReportCreateInfo l, in DeviceDeviceMemoryReportCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.UserCallback != r.UserCallback)
			|| (l.UserData != r.UserData)
			;
	}


	/// <summary>Creates a new DeviceDeviceMemoryReportCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DeviceDeviceMemoryReportCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DeviceMemoryReportCallbackData : IEquatable<DeviceMemoryReportCallbackData>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DeviceMemoryReportCallbackDataEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.EXT.DeviceMemoryReportFlags Flags;
	public Vk.EXT.DeviceMemoryReportEventType Type;
	public ulong MemoryObjectId;
	public Vk.DeviceSize Size;
	public Vk.ObjectType ObjectType;
	public ulong ObjectHandle;
	public uint HeapIndex;
	public DeviceMemoryReportCallbackData(
		in Vk.EXT.DeviceMemoryReportFlags flags = default,
		in Vk.EXT.DeviceMemoryReportEventType type = default,
		ulong memoryObjectId = default,
		in Vk.DeviceSize size = default,
		in Vk.ObjectType objectType = default,
		ulong objectHandle = default,
		uint heapIndex = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		Type = type;
		MemoryObjectId = memoryObjectId;
		Size = size;
		ObjectType = objectType;
		ObjectHandle = objectHandle;
		HeapIndex = heapIndex;
	}


	public readonly override bool Equals(object? obj) => (obj is DeviceMemoryReportCallbackData o) && (this == o);
	readonly bool IEquatable<DeviceMemoryReportCallbackData>.Equals(DeviceMemoryReportCallbackData obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ Type.GetHashCode()
			^ MemoryObjectId.GetHashCode() ^ Size.GetHashCode() ^ ObjectType.GetHashCode() ^ ObjectHandle.GetHashCode()
			^ HeapIndex.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DeviceMemoryReportCallbackData l, in DeviceMemoryReportCallbackData r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.Type == r.Type)
			&& (l.MemoryObjectId == r.MemoryObjectId) && (l.Size == r.Size) && (l.ObjectType == r.ObjectType) && (l.ObjectHandle == r.ObjectHandle)
			&& (l.HeapIndex == r.HeapIndex)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DeviceMemoryReportCallbackData l, in DeviceMemoryReportCallbackData r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.Type != r.Type)
			|| (l.MemoryObjectId != r.MemoryObjectId) || (l.Size != r.Size) || (l.ObjectType != r.ObjectType) || (l.ObjectHandle != r.ObjectHandle)
			|| (l.HeapIndex != r.HeapIndex)
			;
	}


	/// <summary>Creates a new DeviceMemoryReportCallbackData value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DeviceMemoryReportCallbackData value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ImportMemoryHostPointerInfo : IEquatable<ImportMemoryHostPointerInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ImportMemoryHostPointerInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.ExternalMemoryHandleTypeFlags HandleType;
	public void* HostPointer;
	public ImportMemoryHostPointerInfo(
		in Vk.ExternalMemoryHandleTypeFlags handleType = default,
		void* hostPointer = default
	) {
		sType = TYPE;
		pNext = null;
		HandleType = handleType;
		HostPointer = hostPointer;
	}


	public readonly override bool Equals(object? obj) => (obj is ImportMemoryHostPointerInfo o) && (this == o);
	readonly bool IEquatable<ImportMemoryHostPointerInfo>.Equals(ImportMemoryHostPointerInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ HandleType.GetHashCode() ^ ((ulong)HostPointer).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ImportMemoryHostPointerInfo l, in ImportMemoryHostPointerInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.HandleType == r.HandleType) && (l.HostPointer == r.HostPointer)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ImportMemoryHostPointerInfo l, in ImportMemoryHostPointerInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.HandleType != r.HandleType) || (l.HostPointer != r.HostPointer)
			;
	}


	/// <summary>Creates a new ImportMemoryHostPointerInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ImportMemoryHostPointerInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct MemoryHostPointerProperties : IEquatable<MemoryHostPointerProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.MemoryHostPointerPropertiesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public uint MemoryTypeBits;
	public MemoryHostPointerProperties(
		uint memoryTypeBits = default
	) {
		sType = TYPE;
		pNext = null;
		MemoryTypeBits = memoryTypeBits;
	}


	public readonly override bool Equals(object? obj) => (obj is MemoryHostPointerProperties o) && (this == o);
	readonly bool IEquatable<MemoryHostPointerProperties>.Equals(MemoryHostPointerProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MemoryTypeBits.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in MemoryHostPointerProperties l, in MemoryHostPointerProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MemoryTypeBits == r.MemoryTypeBits)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in MemoryHostPointerProperties l, in MemoryHostPointerProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MemoryTypeBits != r.MemoryTypeBits)
			;
	}


	/// <summary>Creates a new MemoryHostPointerProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out MemoryHostPointerProperties value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceExternalMemoryHostProperties : IEquatable<PhysicalDeviceExternalMemoryHostProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceExternalMemoryHostPropertiesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.DeviceSize MinImportedHostPointerAlignment;
	public PhysicalDeviceExternalMemoryHostProperties(
		in Vk.DeviceSize minImportedHostPointerAlignment = default
	) {
		sType = TYPE;
		pNext = null;
		MinImportedHostPointerAlignment = minImportedHostPointerAlignment;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceExternalMemoryHostProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceExternalMemoryHostProperties>.Equals(PhysicalDeviceExternalMemoryHostProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MinImportedHostPointerAlignment.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceExternalMemoryHostProperties l, in PhysicalDeviceExternalMemoryHostProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MinImportedHostPointerAlignment == r.MinImportedHostPointerAlignment)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceExternalMemoryHostProperties l, in PhysicalDeviceExternalMemoryHostProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MinImportedHostPointerAlignment != r.MinImportedHostPointerAlignment)
			;
	}


	/// <summary>Creates a new PhysicalDeviceExternalMemoryHostProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceExternalMemoryHostProperties value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceConservativeRasterizationProperties : IEquatable<PhysicalDeviceConservativeRasterizationProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceConservativeRasterizationPropertiesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public float PrimitiveOverestimationSize;
	public float MaxExtraPrimitiveOverestimationSize;
	public float ExtraPrimitiveOverestimationSizeGranularity;
	public Vk.Bool32 PrimitiveUnderestimation;
	public Vk.Bool32 ConservativePointAndLineRasterization;
	public Vk.Bool32 DegenerateTrianglesRasterized;
	public Vk.Bool32 DegenerateLinesRasterized;
	public Vk.Bool32 FullyCoveredFragmentShaderInputVariable;
	public Vk.Bool32 ConservativeRasterizationPostDepthCoverage;
	public PhysicalDeviceConservativeRasterizationProperties(
		float primitiveOverestimationSize = default,
		float maxExtraPrimitiveOverestimationSize = default,
		float extraPrimitiveOverestimationSizeGranularity = default,
		in Vk.Bool32 primitiveUnderestimation = default,
		in Vk.Bool32 conservativePointAndLineRasterization = default,
		in Vk.Bool32 degenerateTrianglesRasterized = default,
		in Vk.Bool32 degenerateLinesRasterized = default,
		in Vk.Bool32 fullyCoveredFragmentShaderInputVariable = default,
		in Vk.Bool32 conservativeRasterizationPostDepthCoverage = default
	) {
		sType = TYPE;
		pNext = null;
		PrimitiveOverestimationSize = primitiveOverestimationSize;
		MaxExtraPrimitiveOverestimationSize = maxExtraPrimitiveOverestimationSize;
		ExtraPrimitiveOverestimationSizeGranularity = extraPrimitiveOverestimationSizeGranularity;
		PrimitiveUnderestimation = primitiveUnderestimation;
		ConservativePointAndLineRasterization = conservativePointAndLineRasterization;
		DegenerateTrianglesRasterized = degenerateTrianglesRasterized;
		DegenerateLinesRasterized = degenerateLinesRasterized;
		FullyCoveredFragmentShaderInputVariable = fullyCoveredFragmentShaderInputVariable;
		ConservativeRasterizationPostDepthCoverage = conservativeRasterizationPostDepthCoverage;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceConservativeRasterizationProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceConservativeRasterizationProperties>.Equals(PhysicalDeviceConservativeRasterizationProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ PrimitiveOverestimationSize.GetHashCode() ^ MaxExtraPrimitiveOverestimationSize.GetHashCode()
			^ ExtraPrimitiveOverestimationSizeGranularity.GetHashCode() ^ PrimitiveUnderestimation.GetHashCode() ^ ConservativePointAndLineRasterization.GetHashCode() ^ DegenerateTrianglesRasterized.GetHashCode()
			^ DegenerateLinesRasterized.GetHashCode() ^ FullyCoveredFragmentShaderInputVariable.GetHashCode() ^ ConservativeRasterizationPostDepthCoverage.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceConservativeRasterizationProperties l, in PhysicalDeviceConservativeRasterizationProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.PrimitiveOverestimationSize == r.PrimitiveOverestimationSize) && (l.MaxExtraPrimitiveOverestimationSize == r.MaxExtraPrimitiveOverestimationSize)
			&& (l.ExtraPrimitiveOverestimationSizeGranularity == r.ExtraPrimitiveOverestimationSizeGranularity) && (l.PrimitiveUnderestimation == r.PrimitiveUnderestimation) && (l.ConservativePointAndLineRasterization == r.ConservativePointAndLineRasterization) && (l.DegenerateTrianglesRasterized == r.DegenerateTrianglesRasterized)
			&& (l.DegenerateLinesRasterized == r.DegenerateLinesRasterized) && (l.FullyCoveredFragmentShaderInputVariable == r.FullyCoveredFragmentShaderInputVariable) && (l.ConservativeRasterizationPostDepthCoverage == r.ConservativeRasterizationPostDepthCoverage)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceConservativeRasterizationProperties l, in PhysicalDeviceConservativeRasterizationProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.PrimitiveOverestimationSize != r.PrimitiveOverestimationSize) || (l.MaxExtraPrimitiveOverestimationSize != r.MaxExtraPrimitiveOverestimationSize)
			|| (l.ExtraPrimitiveOverestimationSizeGranularity != r.ExtraPrimitiveOverestimationSizeGranularity) || (l.PrimitiveUnderestimation != r.PrimitiveUnderestimation) || (l.ConservativePointAndLineRasterization != r.ConservativePointAndLineRasterization) || (l.DegenerateTrianglesRasterized != r.DegenerateTrianglesRasterized)
			|| (l.DegenerateLinesRasterized != r.DegenerateLinesRasterized) || (l.FullyCoveredFragmentShaderInputVariable != r.FullyCoveredFragmentShaderInputVariable) || (l.ConservativeRasterizationPostDepthCoverage != r.ConservativeRasterizationPostDepthCoverage)
			;
	}


	/// <summary>Creates a new PhysicalDeviceConservativeRasterizationProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceConservativeRasterizationProperties value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct CalibratedTimestampInfo : IEquatable<CalibratedTimestampInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.CalibratedTimestampInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.EXT.TimeDomain TimeDomain;
	public CalibratedTimestampInfo(
		in Vk.EXT.TimeDomain timeDomain = default
	) {
		sType = TYPE;
		pNext = null;
		TimeDomain = timeDomain;
	}


	public readonly override bool Equals(object? obj) => (obj is CalibratedTimestampInfo o) && (this == o);
	readonly bool IEquatable<CalibratedTimestampInfo>.Equals(CalibratedTimestampInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ TimeDomain.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in CalibratedTimestampInfo l, in CalibratedTimestampInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.TimeDomain == r.TimeDomain)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in CalibratedTimestampInfo l, in CalibratedTimestampInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.TimeDomain != r.TimeDomain)
			;
	}


	/// <summary>Creates a new CalibratedTimestampInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out CalibratedTimestampInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PipelineRasterizationConservativeStateCreateInfo : IEquatable<PipelineRasterizationConservativeStateCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PipelineRasterizationConservativeStateCreateInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.EXT.PipelineRasterizationConservativeStateCreateFlags Flags;
	public Vk.EXT.ConservativeRasterizationMode ConservativeRasterizationMode;
	public float ExtraPrimitiveOverestimationSize;
	public PipelineRasterizationConservativeStateCreateInfo(
		in Vk.EXT.PipelineRasterizationConservativeStateCreateFlags flags = default,
		in Vk.EXT.ConservativeRasterizationMode conservativeRasterizationMode = default,
		float extraPrimitiveOverestimationSize = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		ConservativeRasterizationMode = conservativeRasterizationMode;
		ExtraPrimitiveOverestimationSize = extraPrimitiveOverestimationSize;
	}


	public readonly override bool Equals(object? obj) => (obj is PipelineRasterizationConservativeStateCreateInfo o) && (this == o);
	readonly bool IEquatable<PipelineRasterizationConservativeStateCreateInfo>.Equals(PipelineRasterizationConservativeStateCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ ConservativeRasterizationMode.GetHashCode()
			^ ExtraPrimitiveOverestimationSize.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PipelineRasterizationConservativeStateCreateInfo l, in PipelineRasterizationConservativeStateCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.ConservativeRasterizationMode == r.ConservativeRasterizationMode)
			&& (l.ExtraPrimitiveOverestimationSize == r.ExtraPrimitiveOverestimationSize)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PipelineRasterizationConservativeStateCreateInfo l, in PipelineRasterizationConservativeStateCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.ConservativeRasterizationMode != r.ConservativeRasterizationMode)
			|| (l.ExtraPrimitiveOverestimationSize != r.ExtraPrimitiveOverestimationSize)
			;
	}


	/// <summary>Creates a new PipelineRasterizationConservativeStateCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PipelineRasterizationConservativeStateCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceDescriptorIndexingFeatures : IEquatable<PhysicalDeviceDescriptorIndexingFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceDescriptorIndexingFeatures;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 ShaderInputAttachmentArrayDynamicIndexing;
	public Vk.Bool32 ShaderUniformTexelBufferArrayDynamicIndexing;
	public Vk.Bool32 ShaderStorageTexelBufferArrayDynamicIndexing;
	public Vk.Bool32 ShaderUniformBufferArrayNonUniformIndexing;
	public Vk.Bool32 ShaderSampledImageArrayNonUniformIndexing;
	public Vk.Bool32 ShaderStorageBufferArrayNonUniformIndexing;
	public Vk.Bool32 ShaderStorageImageArrayNonUniformIndexing;
	public Vk.Bool32 ShaderInputAttachmentArrayNonUniformIndexing;
	public Vk.Bool32 ShaderUniformTexelBufferArrayNonUniformIndexing;
	public Vk.Bool32 ShaderStorageTexelBufferArrayNonUniformIndexing;
	public Vk.Bool32 DescriptorBindingUniformBufferUpdateAfterBind;
	public Vk.Bool32 DescriptorBindingSampledImageUpdateAfterBind;
	public Vk.Bool32 DescriptorBindingStorageImageUpdateAfterBind;
	public Vk.Bool32 DescriptorBindingStorageBufferUpdateAfterBind;
	public Vk.Bool32 DescriptorBindingUniformTexelBufferUpdateAfterBind;
	public Vk.Bool32 DescriptorBindingStorageTexelBufferUpdateAfterBind;
	public Vk.Bool32 DescriptorBindingUpdateUnusedWhilePending;
	public Vk.Bool32 DescriptorBindingPartiallyBound;
	public Vk.Bool32 DescriptorBindingVariableDescriptorCount;
	public Vk.Bool32 RuntimeDescriptorArray;
	public PhysicalDeviceDescriptorIndexingFeatures(
		in Vk.Bool32 shaderInputAttachmentArrayDynamicIndexing = default,
		in Vk.Bool32 shaderUniformTexelBufferArrayDynamicIndexing = default,
		in Vk.Bool32 shaderStorageTexelBufferArrayDynamicIndexing = default,
		in Vk.Bool32 shaderUniformBufferArrayNonUniformIndexing = default,
		in Vk.Bool32 shaderSampledImageArrayNonUniformIndexing = default,
		in Vk.Bool32 shaderStorageBufferArrayNonUniformIndexing = default,
		in Vk.Bool32 shaderStorageImageArrayNonUniformIndexing = default,
		in Vk.Bool32 shaderInputAttachmentArrayNonUniformIndexing = default,
		in Vk.Bool32 shaderUniformTexelBufferArrayNonUniformIndexing = default,
		in Vk.Bool32 shaderStorageTexelBufferArrayNonUniformIndexing = default,
		in Vk.Bool32 descriptorBindingUniformBufferUpdateAfterBind = default,
		in Vk.Bool32 descriptorBindingSampledImageUpdateAfterBind = default,
		in Vk.Bool32 descriptorBindingStorageImageUpdateAfterBind = default,
		in Vk.Bool32 descriptorBindingStorageBufferUpdateAfterBind = default,
		in Vk.Bool32 descriptorBindingUniformTexelBufferUpdateAfterBind = default,
		in Vk.Bool32 descriptorBindingStorageTexelBufferUpdateAfterBind = default,
		in Vk.Bool32 descriptorBindingUpdateUnusedWhilePending = default,
		in Vk.Bool32 descriptorBindingPartiallyBound = default,
		in Vk.Bool32 descriptorBindingVariableDescriptorCount = default,
		in Vk.Bool32 runtimeDescriptorArray = default
	) {
		sType = TYPE;
		pNext = null;
		ShaderInputAttachmentArrayDynamicIndexing = shaderInputAttachmentArrayDynamicIndexing;
		ShaderUniformTexelBufferArrayDynamicIndexing = shaderUniformTexelBufferArrayDynamicIndexing;
		ShaderStorageTexelBufferArrayDynamicIndexing = shaderStorageTexelBufferArrayDynamicIndexing;
		ShaderUniformBufferArrayNonUniformIndexing = shaderUniformBufferArrayNonUniformIndexing;
		ShaderSampledImageArrayNonUniformIndexing = shaderSampledImageArrayNonUniformIndexing;
		ShaderStorageBufferArrayNonUniformIndexing = shaderStorageBufferArrayNonUniformIndexing;
		ShaderStorageImageArrayNonUniformIndexing = shaderStorageImageArrayNonUniformIndexing;
		ShaderInputAttachmentArrayNonUniformIndexing = shaderInputAttachmentArrayNonUniformIndexing;
		ShaderUniformTexelBufferArrayNonUniformIndexing = shaderUniformTexelBufferArrayNonUniformIndexing;
		ShaderStorageTexelBufferArrayNonUniformIndexing = shaderStorageTexelBufferArrayNonUniformIndexing;
		DescriptorBindingUniformBufferUpdateAfterBind = descriptorBindingUniformBufferUpdateAfterBind;
		DescriptorBindingSampledImageUpdateAfterBind = descriptorBindingSampledImageUpdateAfterBind;
		DescriptorBindingStorageImageUpdateAfterBind = descriptorBindingStorageImageUpdateAfterBind;
		DescriptorBindingStorageBufferUpdateAfterBind = descriptorBindingStorageBufferUpdateAfterBind;
		DescriptorBindingUniformTexelBufferUpdateAfterBind = descriptorBindingUniformTexelBufferUpdateAfterBind;
		DescriptorBindingStorageTexelBufferUpdateAfterBind = descriptorBindingStorageTexelBufferUpdateAfterBind;
		DescriptorBindingUpdateUnusedWhilePending = descriptorBindingUpdateUnusedWhilePending;
		DescriptorBindingPartiallyBound = descriptorBindingPartiallyBound;
		DescriptorBindingVariableDescriptorCount = descriptorBindingVariableDescriptorCount;
		RuntimeDescriptorArray = runtimeDescriptorArray;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceDescriptorIndexingFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceDescriptorIndexingFeatures>.Equals(PhysicalDeviceDescriptorIndexingFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ShaderInputAttachmentArrayDynamicIndexing.GetHashCode() ^ ShaderUniformTexelBufferArrayDynamicIndexing.GetHashCode()
			^ ShaderStorageTexelBufferArrayDynamicIndexing.GetHashCode() ^ ShaderUniformBufferArrayNonUniformIndexing.GetHashCode() ^ ShaderSampledImageArrayNonUniformIndexing.GetHashCode() ^ ShaderStorageBufferArrayNonUniformIndexing.GetHashCode()
			^ ShaderStorageImageArrayNonUniformIndexing.GetHashCode() ^ ShaderInputAttachmentArrayNonUniformIndexing.GetHashCode() ^ ShaderUniformTexelBufferArrayNonUniformIndexing.GetHashCode() ^ ShaderStorageTexelBufferArrayNonUniformIndexing.GetHashCode()
			^ DescriptorBindingUniformBufferUpdateAfterBind.GetHashCode() ^ DescriptorBindingSampledImageUpdateAfterBind.GetHashCode() ^ DescriptorBindingStorageImageUpdateAfterBind.GetHashCode() ^ DescriptorBindingStorageBufferUpdateAfterBind.GetHashCode()
			^ DescriptorBindingUniformTexelBufferUpdateAfterBind.GetHashCode() ^ DescriptorBindingStorageTexelBufferUpdateAfterBind.GetHashCode() ^ DescriptorBindingUpdateUnusedWhilePending.GetHashCode() ^ DescriptorBindingPartiallyBound.GetHashCode()
			^ DescriptorBindingVariableDescriptorCount.GetHashCode() ^ RuntimeDescriptorArray.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceDescriptorIndexingFeatures l, in PhysicalDeviceDescriptorIndexingFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ShaderInputAttachmentArrayDynamicIndexing == r.ShaderInputAttachmentArrayDynamicIndexing) && (l.ShaderUniformTexelBufferArrayDynamicIndexing == r.ShaderUniformTexelBufferArrayDynamicIndexing)
			&& (l.ShaderStorageTexelBufferArrayDynamicIndexing == r.ShaderStorageTexelBufferArrayDynamicIndexing) && (l.ShaderUniformBufferArrayNonUniformIndexing == r.ShaderUniformBufferArrayNonUniformIndexing) && (l.ShaderSampledImageArrayNonUniformIndexing == r.ShaderSampledImageArrayNonUniformIndexing) && (l.ShaderStorageBufferArrayNonUniformIndexing == r.ShaderStorageBufferArrayNonUniformIndexing)
			&& (l.ShaderStorageImageArrayNonUniformIndexing == r.ShaderStorageImageArrayNonUniformIndexing) && (l.ShaderInputAttachmentArrayNonUniformIndexing == r.ShaderInputAttachmentArrayNonUniformIndexing) && (l.ShaderUniformTexelBufferArrayNonUniformIndexing == r.ShaderUniformTexelBufferArrayNonUniformIndexing) && (l.ShaderStorageTexelBufferArrayNonUniformIndexing == r.ShaderStorageTexelBufferArrayNonUniformIndexing)
			&& (l.DescriptorBindingUniformBufferUpdateAfterBind == r.DescriptorBindingUniformBufferUpdateAfterBind) && (l.DescriptorBindingSampledImageUpdateAfterBind == r.DescriptorBindingSampledImageUpdateAfterBind) && (l.DescriptorBindingStorageImageUpdateAfterBind == r.DescriptorBindingStorageImageUpdateAfterBind) && (l.DescriptorBindingStorageBufferUpdateAfterBind == r.DescriptorBindingStorageBufferUpdateAfterBind)
			&& (l.DescriptorBindingUniformTexelBufferUpdateAfterBind == r.DescriptorBindingUniformTexelBufferUpdateAfterBind) && (l.DescriptorBindingStorageTexelBufferUpdateAfterBind == r.DescriptorBindingStorageTexelBufferUpdateAfterBind) && (l.DescriptorBindingUpdateUnusedWhilePending == r.DescriptorBindingUpdateUnusedWhilePending) && (l.DescriptorBindingPartiallyBound == r.DescriptorBindingPartiallyBound)
			&& (l.DescriptorBindingVariableDescriptorCount == r.DescriptorBindingVariableDescriptorCount) && (l.RuntimeDescriptorArray == r.RuntimeDescriptorArray)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceDescriptorIndexingFeatures l, in PhysicalDeviceDescriptorIndexingFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ShaderInputAttachmentArrayDynamicIndexing != r.ShaderInputAttachmentArrayDynamicIndexing) || (l.ShaderUniformTexelBufferArrayDynamicIndexing != r.ShaderUniformTexelBufferArrayDynamicIndexing)
			|| (l.ShaderStorageTexelBufferArrayDynamicIndexing != r.ShaderStorageTexelBufferArrayDynamicIndexing) || (l.ShaderUniformBufferArrayNonUniformIndexing != r.ShaderUniformBufferArrayNonUniformIndexing) || (l.ShaderSampledImageArrayNonUniformIndexing != r.ShaderSampledImageArrayNonUniformIndexing) || (l.ShaderStorageBufferArrayNonUniformIndexing != r.ShaderStorageBufferArrayNonUniformIndexing)
			|| (l.ShaderStorageImageArrayNonUniformIndexing != r.ShaderStorageImageArrayNonUniformIndexing) || (l.ShaderInputAttachmentArrayNonUniformIndexing != r.ShaderInputAttachmentArrayNonUniformIndexing) || (l.ShaderUniformTexelBufferArrayNonUniformIndexing != r.ShaderUniformTexelBufferArrayNonUniformIndexing) || (l.ShaderStorageTexelBufferArrayNonUniformIndexing != r.ShaderStorageTexelBufferArrayNonUniformIndexing)
			|| (l.DescriptorBindingUniformBufferUpdateAfterBind != r.DescriptorBindingUniformBufferUpdateAfterBind) || (l.DescriptorBindingSampledImageUpdateAfterBind != r.DescriptorBindingSampledImageUpdateAfterBind) || (l.DescriptorBindingStorageImageUpdateAfterBind != r.DescriptorBindingStorageImageUpdateAfterBind) || (l.DescriptorBindingStorageBufferUpdateAfterBind != r.DescriptorBindingStorageBufferUpdateAfterBind)
			|| (l.DescriptorBindingUniformTexelBufferUpdateAfterBind != r.DescriptorBindingUniformTexelBufferUpdateAfterBind) || (l.DescriptorBindingStorageTexelBufferUpdateAfterBind != r.DescriptorBindingStorageTexelBufferUpdateAfterBind) || (l.DescriptorBindingUpdateUnusedWhilePending != r.DescriptorBindingUpdateUnusedWhilePending) || (l.DescriptorBindingPartiallyBound != r.DescriptorBindingPartiallyBound)
			|| (l.DescriptorBindingVariableDescriptorCount != r.DescriptorBindingVariableDescriptorCount) || (l.RuntimeDescriptorArray != r.RuntimeDescriptorArray)
			;
	}


	/// <summary>Creates a new PhysicalDeviceDescriptorIndexingFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceDescriptorIndexingFeatures value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceDescriptorIndexingProperties : IEquatable<PhysicalDeviceDescriptorIndexingProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceDescriptorIndexingProperties;

	public Vk.StructureType sType;
	public void* pNext;
	public uint MaxUpdateAfterBindDescriptorsInAllPools;
	public Vk.Bool32 ShaderUniformBufferArrayNonUniformIndexingNative;
	public Vk.Bool32 ShaderSampledImageArrayNonUniformIndexingNative;
	public Vk.Bool32 ShaderStorageBufferArrayNonUniformIndexingNative;
	public Vk.Bool32 ShaderStorageImageArrayNonUniformIndexingNative;
	public Vk.Bool32 ShaderInputAttachmentArrayNonUniformIndexingNative;
	public Vk.Bool32 RobustBufferAccessUpdateAfterBind;
	public Vk.Bool32 QuadDivergentImplicitLod;
	public uint MaxPerStageDescriptorUpdateAfterBindSamplers;
	public uint MaxPerStageDescriptorUpdateAfterBindUniformBuffers;
	public uint MaxPerStageDescriptorUpdateAfterBindStorageBuffers;
	public uint MaxPerStageDescriptorUpdateAfterBindSampledImages;
	public uint MaxPerStageDescriptorUpdateAfterBindStorageImages;
	public uint MaxPerStageDescriptorUpdateAfterBindInputAttachments;
	public uint MaxPerStageUpdateAfterBindResources;
	public uint MaxDescriptorSetUpdateAfterBindSamplers;
	public uint MaxDescriptorSetUpdateAfterBindUniformBuffers;
	public uint MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic;
	public uint MaxDescriptorSetUpdateAfterBindStorageBuffers;
	public uint MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic;
	public uint MaxDescriptorSetUpdateAfterBindSampledImages;
	public uint MaxDescriptorSetUpdateAfterBindStorageImages;
	public uint MaxDescriptorSetUpdateAfterBindInputAttachments;
	public PhysicalDeviceDescriptorIndexingProperties(
		uint maxUpdateAfterBindDescriptorsInAllPools = default,
		in Vk.Bool32 shaderUniformBufferArrayNonUniformIndexingNative = default,
		in Vk.Bool32 shaderSampledImageArrayNonUniformIndexingNative = default,
		in Vk.Bool32 shaderStorageBufferArrayNonUniformIndexingNative = default,
		in Vk.Bool32 shaderStorageImageArrayNonUniformIndexingNative = default,
		in Vk.Bool32 shaderInputAttachmentArrayNonUniformIndexingNative = default,
		in Vk.Bool32 robustBufferAccessUpdateAfterBind = default,
		in Vk.Bool32 quadDivergentImplicitLod = default,
		uint maxPerStageDescriptorUpdateAfterBindSamplers = default,
		uint maxPerStageDescriptorUpdateAfterBindUniformBuffers = default,
		uint maxPerStageDescriptorUpdateAfterBindStorageBuffers = default,
		uint maxPerStageDescriptorUpdateAfterBindSampledImages = default,
		uint maxPerStageDescriptorUpdateAfterBindStorageImages = default,
		uint maxPerStageDescriptorUpdateAfterBindInputAttachments = default,
		uint maxPerStageUpdateAfterBindResources = default,
		uint maxDescriptorSetUpdateAfterBindSamplers = default,
		uint maxDescriptorSetUpdateAfterBindUniformBuffers = default,
		uint maxDescriptorSetUpdateAfterBindUniformBuffersDynamic = default,
		uint maxDescriptorSetUpdateAfterBindStorageBuffers = default,
		uint maxDescriptorSetUpdateAfterBindStorageBuffersDynamic = default,
		uint maxDescriptorSetUpdateAfterBindSampledImages = default,
		uint maxDescriptorSetUpdateAfterBindStorageImages = default,
		uint maxDescriptorSetUpdateAfterBindInputAttachments = default
	) {
		sType = TYPE;
		pNext = null;
		MaxUpdateAfterBindDescriptorsInAllPools = maxUpdateAfterBindDescriptorsInAllPools;
		ShaderUniformBufferArrayNonUniformIndexingNative = shaderUniformBufferArrayNonUniformIndexingNative;
		ShaderSampledImageArrayNonUniformIndexingNative = shaderSampledImageArrayNonUniformIndexingNative;
		ShaderStorageBufferArrayNonUniformIndexingNative = shaderStorageBufferArrayNonUniformIndexingNative;
		ShaderStorageImageArrayNonUniformIndexingNative = shaderStorageImageArrayNonUniformIndexingNative;
		ShaderInputAttachmentArrayNonUniformIndexingNative = shaderInputAttachmentArrayNonUniformIndexingNative;
		RobustBufferAccessUpdateAfterBind = robustBufferAccessUpdateAfterBind;
		QuadDivergentImplicitLod = quadDivergentImplicitLod;
		MaxPerStageDescriptorUpdateAfterBindSamplers = maxPerStageDescriptorUpdateAfterBindSamplers;
		MaxPerStageDescriptorUpdateAfterBindUniformBuffers = maxPerStageDescriptorUpdateAfterBindUniformBuffers;
		MaxPerStageDescriptorUpdateAfterBindStorageBuffers = maxPerStageDescriptorUpdateAfterBindStorageBuffers;
		MaxPerStageDescriptorUpdateAfterBindSampledImages = maxPerStageDescriptorUpdateAfterBindSampledImages;
		MaxPerStageDescriptorUpdateAfterBindStorageImages = maxPerStageDescriptorUpdateAfterBindStorageImages;
		MaxPerStageDescriptorUpdateAfterBindInputAttachments = maxPerStageDescriptorUpdateAfterBindInputAttachments;
		MaxPerStageUpdateAfterBindResources = maxPerStageUpdateAfterBindResources;
		MaxDescriptorSetUpdateAfterBindSamplers = maxDescriptorSetUpdateAfterBindSamplers;
		MaxDescriptorSetUpdateAfterBindUniformBuffers = maxDescriptorSetUpdateAfterBindUniformBuffers;
		MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic = maxDescriptorSetUpdateAfterBindUniformBuffersDynamic;
		MaxDescriptorSetUpdateAfterBindStorageBuffers = maxDescriptorSetUpdateAfterBindStorageBuffers;
		MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic = maxDescriptorSetUpdateAfterBindStorageBuffersDynamic;
		MaxDescriptorSetUpdateAfterBindSampledImages = maxDescriptorSetUpdateAfterBindSampledImages;
		MaxDescriptorSetUpdateAfterBindStorageImages = maxDescriptorSetUpdateAfterBindStorageImages;
		MaxDescriptorSetUpdateAfterBindInputAttachments = maxDescriptorSetUpdateAfterBindInputAttachments;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceDescriptorIndexingProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceDescriptorIndexingProperties>.Equals(PhysicalDeviceDescriptorIndexingProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MaxUpdateAfterBindDescriptorsInAllPools.GetHashCode() ^ ShaderUniformBufferArrayNonUniformIndexingNative.GetHashCode()
			^ ShaderSampledImageArrayNonUniformIndexingNative.GetHashCode() ^ ShaderStorageBufferArrayNonUniformIndexingNative.GetHashCode() ^ ShaderStorageImageArrayNonUniformIndexingNative.GetHashCode() ^ ShaderInputAttachmentArrayNonUniformIndexingNative.GetHashCode()
			^ RobustBufferAccessUpdateAfterBind.GetHashCode() ^ QuadDivergentImplicitLod.GetHashCode() ^ MaxPerStageDescriptorUpdateAfterBindSamplers.GetHashCode() ^ MaxPerStageDescriptorUpdateAfterBindUniformBuffers.GetHashCode()
			^ MaxPerStageDescriptorUpdateAfterBindStorageBuffers.GetHashCode() ^ MaxPerStageDescriptorUpdateAfterBindSampledImages.GetHashCode() ^ MaxPerStageDescriptorUpdateAfterBindStorageImages.GetHashCode() ^ MaxPerStageDescriptorUpdateAfterBindInputAttachments.GetHashCode()
			^ MaxPerStageUpdateAfterBindResources.GetHashCode() ^ MaxDescriptorSetUpdateAfterBindSamplers.GetHashCode() ^ MaxDescriptorSetUpdateAfterBindUniformBuffers.GetHashCode() ^ MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic.GetHashCode()
			^ MaxDescriptorSetUpdateAfterBindStorageBuffers.GetHashCode() ^ MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic.GetHashCode() ^ MaxDescriptorSetUpdateAfterBindSampledImages.GetHashCode() ^ MaxDescriptorSetUpdateAfterBindStorageImages.GetHashCode()
			^ MaxDescriptorSetUpdateAfterBindInputAttachments.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceDescriptorIndexingProperties l, in PhysicalDeviceDescriptorIndexingProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MaxUpdateAfterBindDescriptorsInAllPools == r.MaxUpdateAfterBindDescriptorsInAllPools) && (l.ShaderUniformBufferArrayNonUniformIndexingNative == r.ShaderUniformBufferArrayNonUniformIndexingNative)
			&& (l.ShaderSampledImageArrayNonUniformIndexingNative == r.ShaderSampledImageArrayNonUniformIndexingNative) && (l.ShaderStorageBufferArrayNonUniformIndexingNative == r.ShaderStorageBufferArrayNonUniformIndexingNative) && (l.ShaderStorageImageArrayNonUniformIndexingNative == r.ShaderStorageImageArrayNonUniformIndexingNative) && (l.ShaderInputAttachmentArrayNonUniformIndexingNative == r.ShaderInputAttachmentArrayNonUniformIndexingNative)
			&& (l.RobustBufferAccessUpdateAfterBind == r.RobustBufferAccessUpdateAfterBind) && (l.QuadDivergentImplicitLod == r.QuadDivergentImplicitLod) && (l.MaxPerStageDescriptorUpdateAfterBindSamplers == r.MaxPerStageDescriptorUpdateAfterBindSamplers) && (l.MaxPerStageDescriptorUpdateAfterBindUniformBuffers == r.MaxPerStageDescriptorUpdateAfterBindUniformBuffers)
			&& (l.MaxPerStageDescriptorUpdateAfterBindStorageBuffers == r.MaxPerStageDescriptorUpdateAfterBindStorageBuffers) && (l.MaxPerStageDescriptorUpdateAfterBindSampledImages == r.MaxPerStageDescriptorUpdateAfterBindSampledImages) && (l.MaxPerStageDescriptorUpdateAfterBindStorageImages == r.MaxPerStageDescriptorUpdateAfterBindStorageImages) && (l.MaxPerStageDescriptorUpdateAfterBindInputAttachments == r.MaxPerStageDescriptorUpdateAfterBindInputAttachments)
			&& (l.MaxPerStageUpdateAfterBindResources == r.MaxPerStageUpdateAfterBindResources) && (l.MaxDescriptorSetUpdateAfterBindSamplers == r.MaxDescriptorSetUpdateAfterBindSamplers) && (l.MaxDescriptorSetUpdateAfterBindUniformBuffers == r.MaxDescriptorSetUpdateAfterBindUniformBuffers) && (l.MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic == r.MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic)
			&& (l.MaxDescriptorSetUpdateAfterBindStorageBuffers == r.MaxDescriptorSetUpdateAfterBindStorageBuffers) && (l.MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic == r.MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic) && (l.MaxDescriptorSetUpdateAfterBindSampledImages == r.MaxDescriptorSetUpdateAfterBindSampledImages) && (l.MaxDescriptorSetUpdateAfterBindStorageImages == r.MaxDescriptorSetUpdateAfterBindStorageImages)
			&& (l.MaxDescriptorSetUpdateAfterBindInputAttachments == r.MaxDescriptorSetUpdateAfterBindInputAttachments)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceDescriptorIndexingProperties l, in PhysicalDeviceDescriptorIndexingProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MaxUpdateAfterBindDescriptorsInAllPools != r.MaxUpdateAfterBindDescriptorsInAllPools) || (l.ShaderUniformBufferArrayNonUniformIndexingNative != r.ShaderUniformBufferArrayNonUniformIndexingNative)
			|| (l.ShaderSampledImageArrayNonUniformIndexingNative != r.ShaderSampledImageArrayNonUniformIndexingNative) || (l.ShaderStorageBufferArrayNonUniformIndexingNative != r.ShaderStorageBufferArrayNonUniformIndexingNative) || (l.ShaderStorageImageArrayNonUniformIndexingNative != r.ShaderStorageImageArrayNonUniformIndexingNative) || (l.ShaderInputAttachmentArrayNonUniformIndexingNative != r.ShaderInputAttachmentArrayNonUniformIndexingNative)
			|| (l.RobustBufferAccessUpdateAfterBind != r.RobustBufferAccessUpdateAfterBind) || (l.QuadDivergentImplicitLod != r.QuadDivergentImplicitLod) || (l.MaxPerStageDescriptorUpdateAfterBindSamplers != r.MaxPerStageDescriptorUpdateAfterBindSamplers) || (l.MaxPerStageDescriptorUpdateAfterBindUniformBuffers != r.MaxPerStageDescriptorUpdateAfterBindUniformBuffers)
			|| (l.MaxPerStageDescriptorUpdateAfterBindStorageBuffers != r.MaxPerStageDescriptorUpdateAfterBindStorageBuffers) || (l.MaxPerStageDescriptorUpdateAfterBindSampledImages != r.MaxPerStageDescriptorUpdateAfterBindSampledImages) || (l.MaxPerStageDescriptorUpdateAfterBindStorageImages != r.MaxPerStageDescriptorUpdateAfterBindStorageImages) || (l.MaxPerStageDescriptorUpdateAfterBindInputAttachments != r.MaxPerStageDescriptorUpdateAfterBindInputAttachments)
			|| (l.MaxPerStageUpdateAfterBindResources != r.MaxPerStageUpdateAfterBindResources) || (l.MaxDescriptorSetUpdateAfterBindSamplers != r.MaxDescriptorSetUpdateAfterBindSamplers) || (l.MaxDescriptorSetUpdateAfterBindUniformBuffers != r.MaxDescriptorSetUpdateAfterBindUniformBuffers) || (l.MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic != r.MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic)
			|| (l.MaxDescriptorSetUpdateAfterBindStorageBuffers != r.MaxDescriptorSetUpdateAfterBindStorageBuffers) || (l.MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic != r.MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic) || (l.MaxDescriptorSetUpdateAfterBindSampledImages != r.MaxDescriptorSetUpdateAfterBindSampledImages) || (l.MaxDescriptorSetUpdateAfterBindStorageImages != r.MaxDescriptorSetUpdateAfterBindStorageImages)
			|| (l.MaxDescriptorSetUpdateAfterBindInputAttachments != r.MaxDescriptorSetUpdateAfterBindInputAttachments)
			;
	}


	/// <summary>Creates a new PhysicalDeviceDescriptorIndexingProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceDescriptorIndexingProperties value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DescriptorSetLayoutBindingFlagsCreateInfo : IEquatable<DescriptorSetLayoutBindingFlagsCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DescriptorSetLayoutBindingFlagsCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public uint BindingCount;
	public Vk.DescriptorBindingFlags* BindingFlags;
	public DescriptorSetLayoutBindingFlagsCreateInfo(
		uint bindingCount = default,
		in Vk.DescriptorBindingFlags* bindingFlags = default
	) {
		sType = TYPE;
		pNext = null;
		BindingCount = bindingCount;
		BindingFlags = bindingFlags;
	}


	public readonly override bool Equals(object? obj) => (obj is DescriptorSetLayoutBindingFlagsCreateInfo o) && (this == o);
	readonly bool IEquatable<DescriptorSetLayoutBindingFlagsCreateInfo>.Equals(DescriptorSetLayoutBindingFlagsCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ BindingCount.GetHashCode() ^ ((ulong)BindingFlags).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DescriptorSetLayoutBindingFlagsCreateInfo l, in DescriptorSetLayoutBindingFlagsCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.BindingCount == r.BindingCount) && (l.BindingFlags == r.BindingFlags)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DescriptorSetLayoutBindingFlagsCreateInfo l, in DescriptorSetLayoutBindingFlagsCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.BindingCount != r.BindingCount) || (l.BindingFlags != r.BindingFlags)
			;
	}


	/// <summary>Creates a new DescriptorSetLayoutBindingFlagsCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DescriptorSetLayoutBindingFlagsCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DescriptorSetVariableDescriptorCountAllocateInfo : IEquatable<DescriptorSetVariableDescriptorCountAllocateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DescriptorSetVariableDescriptorCountAllocateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public uint DescriptorSetCount;
	public uint* DescriptorCounts;
	public DescriptorSetVariableDescriptorCountAllocateInfo(
		uint descriptorSetCount = default,
		uint* descriptorCounts = default
	) {
		sType = TYPE;
		pNext = null;
		DescriptorSetCount = descriptorSetCount;
		DescriptorCounts = descriptorCounts;
	}


	public readonly override bool Equals(object? obj) => (obj is DescriptorSetVariableDescriptorCountAllocateInfo o) && (this == o);
	readonly bool IEquatable<DescriptorSetVariableDescriptorCountAllocateInfo>.Equals(DescriptorSetVariableDescriptorCountAllocateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DescriptorSetCount.GetHashCode() ^ ((ulong)DescriptorCounts).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DescriptorSetVariableDescriptorCountAllocateInfo l, in DescriptorSetVariableDescriptorCountAllocateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DescriptorSetCount == r.DescriptorSetCount) && (l.DescriptorCounts == r.DescriptorCounts)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DescriptorSetVariableDescriptorCountAllocateInfo l, in DescriptorSetVariableDescriptorCountAllocateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DescriptorSetCount != r.DescriptorSetCount) || (l.DescriptorCounts != r.DescriptorCounts)
			;
	}


	/// <summary>Creates a new DescriptorSetVariableDescriptorCountAllocateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DescriptorSetVariableDescriptorCountAllocateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DescriptorSetVariableDescriptorCountLayoutSupport : IEquatable<DescriptorSetVariableDescriptorCountLayoutSupport>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DescriptorSetVariableDescriptorCountLayoutSupport;

	public Vk.StructureType sType;
	public void* pNext;
	public uint MaxVariableDescriptorCount;
	public DescriptorSetVariableDescriptorCountLayoutSupport(
		uint maxVariableDescriptorCount = default
	) {
		sType = TYPE;
		pNext = null;
		MaxVariableDescriptorCount = maxVariableDescriptorCount;
	}


	public readonly override bool Equals(object? obj) => (obj is DescriptorSetVariableDescriptorCountLayoutSupport o) && (this == o);
	readonly bool IEquatable<DescriptorSetVariableDescriptorCountLayoutSupport>.Equals(DescriptorSetVariableDescriptorCountLayoutSupport obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MaxVariableDescriptorCount.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DescriptorSetVariableDescriptorCountLayoutSupport l, in DescriptorSetVariableDescriptorCountLayoutSupport r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MaxVariableDescriptorCount == r.MaxVariableDescriptorCount)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DescriptorSetVariableDescriptorCountLayoutSupport l, in DescriptorSetVariableDescriptorCountLayoutSupport r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MaxVariableDescriptorCount != r.MaxVariableDescriptorCount)
			;
	}


	/// <summary>Creates a new DescriptorSetVariableDescriptorCountLayoutSupport value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DescriptorSetVariableDescriptorCountLayoutSupport value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VertexInputBindingDivisorDescription : IEquatable<VertexInputBindingDivisorDescription>
{
	public uint Binding;
	public uint Divisor;
	public VertexInputBindingDivisorDescription(
		uint binding = default,
		uint divisor = default
	) {
		Binding = binding;
		Divisor = divisor;
	}


	public readonly override bool Equals(object? obj) => (obj is VertexInputBindingDivisorDescription o) && (this == o);
	readonly bool IEquatable<VertexInputBindingDivisorDescription>.Equals(VertexInputBindingDivisorDescription obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Binding.GetHashCode() ^ Divisor.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VertexInputBindingDivisorDescription l, in VertexInputBindingDivisorDescription r)
	{
		return
			(l.Binding == r.Binding) && (l.Divisor == r.Divisor)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VertexInputBindingDivisorDescription l, in VertexInputBindingDivisorDescription r)
	{
		return
			(l.Binding != r.Binding) || (l.Divisor != r.Divisor)
			;
	}


	/// <summary>Creates a new VertexInputBindingDivisorDescription value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VertexInputBindingDivisorDescription value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PipelineVertexInputDivisorStateCreateInfo : IEquatable<PipelineVertexInputDivisorStateCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PipelineVertexInputDivisorStateCreateInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public uint VertexBindingDivisorCount;
	public Vk.EXT.VertexInputBindingDivisorDescription* VertexBindingDivisors;
	public PipelineVertexInputDivisorStateCreateInfo(
		uint vertexBindingDivisorCount = default,
		in Vk.EXT.VertexInputBindingDivisorDescription* vertexBindingDivisors = default
	) {
		sType = TYPE;
		pNext = null;
		VertexBindingDivisorCount = vertexBindingDivisorCount;
		VertexBindingDivisors = vertexBindingDivisors;
	}


	public readonly override bool Equals(object? obj) => (obj is PipelineVertexInputDivisorStateCreateInfo o) && (this == o);
	readonly bool IEquatable<PipelineVertexInputDivisorStateCreateInfo>.Equals(PipelineVertexInputDivisorStateCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ VertexBindingDivisorCount.GetHashCode() ^ ((ulong)VertexBindingDivisors).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PipelineVertexInputDivisorStateCreateInfo l, in PipelineVertexInputDivisorStateCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.VertexBindingDivisorCount == r.VertexBindingDivisorCount) && (l.VertexBindingDivisors == r.VertexBindingDivisors)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PipelineVertexInputDivisorStateCreateInfo l, in PipelineVertexInputDivisorStateCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.VertexBindingDivisorCount != r.VertexBindingDivisorCount) || (l.VertexBindingDivisors != r.VertexBindingDivisors)
			;
	}


	/// <summary>Creates a new PipelineVertexInputDivisorStateCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PipelineVertexInputDivisorStateCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceVertexAttributeDivisorProperties : IEquatable<PhysicalDeviceVertexAttributeDivisorProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceVertexAttributeDivisorPropertiesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public uint MaxVertexAttribDivisor;
	public PhysicalDeviceVertexAttributeDivisorProperties(
		uint maxVertexAttribDivisor = default
	) {
		sType = TYPE;
		pNext = null;
		MaxVertexAttribDivisor = maxVertexAttribDivisor;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceVertexAttributeDivisorProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceVertexAttributeDivisorProperties>.Equals(PhysicalDeviceVertexAttributeDivisorProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MaxVertexAttribDivisor.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceVertexAttributeDivisorProperties l, in PhysicalDeviceVertexAttributeDivisorProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MaxVertexAttribDivisor == r.MaxVertexAttribDivisor)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceVertexAttributeDivisorProperties l, in PhysicalDeviceVertexAttributeDivisorProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MaxVertexAttribDivisor != r.MaxVertexAttribDivisor)
			;
	}


	/// <summary>Creates a new PhysicalDeviceVertexAttributeDivisorProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceVertexAttributeDivisorProperties value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDevicePCIBusInfoProperties : IEquatable<PhysicalDevicePCIBusInfoProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDevicePciBusInfoPropertiesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public uint PciDomain;
	public uint PciBus;
	public uint PciDevice;
	public uint PciFunction;
	public PhysicalDevicePCIBusInfoProperties(
		uint pciDomain = default,
		uint pciBus = default,
		uint pciDevice = default,
		uint pciFunction = default
	) {
		sType = TYPE;
		pNext = null;
		PciDomain = pciDomain;
		PciBus = pciBus;
		PciDevice = pciDevice;
		PciFunction = pciFunction;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDevicePCIBusInfoProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDevicePCIBusInfoProperties>.Equals(PhysicalDevicePCIBusInfoProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ PciDomain.GetHashCode() ^ PciBus.GetHashCode()
			^ PciDevice.GetHashCode() ^ PciFunction.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDevicePCIBusInfoProperties l, in PhysicalDevicePCIBusInfoProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.PciDomain == r.PciDomain) && (l.PciBus == r.PciBus)
			&& (l.PciDevice == r.PciDevice) && (l.PciFunction == r.PciFunction)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDevicePCIBusInfoProperties l, in PhysicalDevicePCIBusInfoProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.PciDomain != r.PciDomain) || (l.PciBus != r.PciBus)
			|| (l.PciDevice != r.PciDevice) || (l.PciFunction != r.PciFunction)
			;
	}


	/// <summary>Creates a new PhysicalDevicePCIBusInfoProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDevicePCIBusInfoProperties value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct CommandBufferInheritanceConditionalRenderingInfo : IEquatable<CommandBufferInheritanceConditionalRenderingInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.CommandBufferInheritanceConditionalRenderingInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 ConditionalRenderingEnable;
	public CommandBufferInheritanceConditionalRenderingInfo(
		in Vk.Bool32 conditionalRenderingEnable = default
	) {
		sType = TYPE;
		pNext = null;
		ConditionalRenderingEnable = conditionalRenderingEnable;
	}


	public readonly override bool Equals(object? obj) => (obj is CommandBufferInheritanceConditionalRenderingInfo o) && (this == o);
	readonly bool IEquatable<CommandBufferInheritanceConditionalRenderingInfo>.Equals(CommandBufferInheritanceConditionalRenderingInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ConditionalRenderingEnable.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in CommandBufferInheritanceConditionalRenderingInfo l, in CommandBufferInheritanceConditionalRenderingInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ConditionalRenderingEnable == r.ConditionalRenderingEnable)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in CommandBufferInheritanceConditionalRenderingInfo l, in CommandBufferInheritanceConditionalRenderingInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ConditionalRenderingEnable != r.ConditionalRenderingEnable)
			;
	}


	/// <summary>Creates a new CommandBufferInheritanceConditionalRenderingInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out CommandBufferInheritanceConditionalRenderingInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceConditionalRenderingFeatures : IEquatable<PhysicalDeviceConditionalRenderingFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceConditionalRenderingFeaturesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 ConditionalRendering;
	public Vk.Bool32 InheritedConditionalRendering;
	public PhysicalDeviceConditionalRenderingFeatures(
		in Vk.Bool32 conditionalRendering = default,
		in Vk.Bool32 inheritedConditionalRendering = default
	) {
		sType = TYPE;
		pNext = null;
		ConditionalRendering = conditionalRendering;
		InheritedConditionalRendering = inheritedConditionalRendering;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceConditionalRenderingFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceConditionalRenderingFeatures>.Equals(PhysicalDeviceConditionalRenderingFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ConditionalRendering.GetHashCode() ^ InheritedConditionalRendering.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceConditionalRenderingFeatures l, in PhysicalDeviceConditionalRenderingFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ConditionalRendering == r.ConditionalRendering) && (l.InheritedConditionalRendering == r.InheritedConditionalRendering)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceConditionalRenderingFeatures l, in PhysicalDeviceConditionalRenderingFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ConditionalRendering != r.ConditionalRendering) || (l.InheritedConditionalRendering != r.InheritedConditionalRendering)
			;
	}


	/// <summary>Creates a new PhysicalDeviceConditionalRenderingFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceConditionalRenderingFeatures value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceShaderAtomicFloatFeatures : IEquatable<PhysicalDeviceShaderAtomicFloatFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceShaderAtomicFloatFeaturesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 ShaderBufferFloat32Atomics;
	public Vk.Bool32 ShaderBufferFloat32AtomicAdd;
	public Vk.Bool32 ShaderBufferFloat64Atomics;
	public Vk.Bool32 ShaderBufferFloat64AtomicAdd;
	public Vk.Bool32 ShaderSharedFloat32Atomics;
	public Vk.Bool32 ShaderSharedFloat32AtomicAdd;
	public Vk.Bool32 ShaderSharedFloat64Atomics;
	public Vk.Bool32 ShaderSharedFloat64AtomicAdd;
	public Vk.Bool32 ShaderImageFloat32Atomics;
	public Vk.Bool32 ShaderImageFloat32AtomicAdd;
	public Vk.Bool32 SparseImageFloat32Atomics;
	public Vk.Bool32 SparseImageFloat32AtomicAdd;
	public PhysicalDeviceShaderAtomicFloatFeatures(
		in Vk.Bool32 shaderBufferFloat32Atomics = default,
		in Vk.Bool32 shaderBufferFloat32AtomicAdd = default,
		in Vk.Bool32 shaderBufferFloat64Atomics = default,
		in Vk.Bool32 shaderBufferFloat64AtomicAdd = default,
		in Vk.Bool32 shaderSharedFloat32Atomics = default,
		in Vk.Bool32 shaderSharedFloat32AtomicAdd = default,
		in Vk.Bool32 shaderSharedFloat64Atomics = default,
		in Vk.Bool32 shaderSharedFloat64AtomicAdd = default,
		in Vk.Bool32 shaderImageFloat32Atomics = default,
		in Vk.Bool32 shaderImageFloat32AtomicAdd = default,
		in Vk.Bool32 sparseImageFloat32Atomics = default,
		in Vk.Bool32 sparseImageFloat32AtomicAdd = default
	) {
		sType = TYPE;
		pNext = null;
		ShaderBufferFloat32Atomics = shaderBufferFloat32Atomics;
		ShaderBufferFloat32AtomicAdd = shaderBufferFloat32AtomicAdd;
		ShaderBufferFloat64Atomics = shaderBufferFloat64Atomics;
		ShaderBufferFloat64AtomicAdd = shaderBufferFloat64AtomicAdd;
		ShaderSharedFloat32Atomics = shaderSharedFloat32Atomics;
		ShaderSharedFloat32AtomicAdd = shaderSharedFloat32AtomicAdd;
		ShaderSharedFloat64Atomics = shaderSharedFloat64Atomics;
		ShaderSharedFloat64AtomicAdd = shaderSharedFloat64AtomicAdd;
		ShaderImageFloat32Atomics = shaderImageFloat32Atomics;
		ShaderImageFloat32AtomicAdd = shaderImageFloat32AtomicAdd;
		SparseImageFloat32Atomics = sparseImageFloat32Atomics;
		SparseImageFloat32AtomicAdd = sparseImageFloat32AtomicAdd;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceShaderAtomicFloatFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceShaderAtomicFloatFeatures>.Equals(PhysicalDeviceShaderAtomicFloatFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ShaderBufferFloat32Atomics.GetHashCode() ^ ShaderBufferFloat32AtomicAdd.GetHashCode()
			^ ShaderBufferFloat64Atomics.GetHashCode() ^ ShaderBufferFloat64AtomicAdd.GetHashCode() ^ ShaderSharedFloat32Atomics.GetHashCode() ^ ShaderSharedFloat32AtomicAdd.GetHashCode()
			^ ShaderSharedFloat64Atomics.GetHashCode() ^ ShaderSharedFloat64AtomicAdd.GetHashCode() ^ ShaderImageFloat32Atomics.GetHashCode() ^ ShaderImageFloat32AtomicAdd.GetHashCode()
			^ SparseImageFloat32Atomics.GetHashCode() ^ SparseImageFloat32AtomicAdd.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceShaderAtomicFloatFeatures l, in PhysicalDeviceShaderAtomicFloatFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ShaderBufferFloat32Atomics == r.ShaderBufferFloat32Atomics) && (l.ShaderBufferFloat32AtomicAdd == r.ShaderBufferFloat32AtomicAdd)
			&& (l.ShaderBufferFloat64Atomics == r.ShaderBufferFloat64Atomics) && (l.ShaderBufferFloat64AtomicAdd == r.ShaderBufferFloat64AtomicAdd) && (l.ShaderSharedFloat32Atomics == r.ShaderSharedFloat32Atomics) && (l.ShaderSharedFloat32AtomicAdd == r.ShaderSharedFloat32AtomicAdd)
			&& (l.ShaderSharedFloat64Atomics == r.ShaderSharedFloat64Atomics) && (l.ShaderSharedFloat64AtomicAdd == r.ShaderSharedFloat64AtomicAdd) && (l.ShaderImageFloat32Atomics == r.ShaderImageFloat32Atomics) && (l.ShaderImageFloat32AtomicAdd == r.ShaderImageFloat32AtomicAdd)
			&& (l.SparseImageFloat32Atomics == r.SparseImageFloat32Atomics) && (l.SparseImageFloat32AtomicAdd == r.SparseImageFloat32AtomicAdd)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceShaderAtomicFloatFeatures l, in PhysicalDeviceShaderAtomicFloatFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ShaderBufferFloat32Atomics != r.ShaderBufferFloat32Atomics) || (l.ShaderBufferFloat32AtomicAdd != r.ShaderBufferFloat32AtomicAdd)
			|| (l.ShaderBufferFloat64Atomics != r.ShaderBufferFloat64Atomics) || (l.ShaderBufferFloat64AtomicAdd != r.ShaderBufferFloat64AtomicAdd) || (l.ShaderSharedFloat32Atomics != r.ShaderSharedFloat32Atomics) || (l.ShaderSharedFloat32AtomicAdd != r.ShaderSharedFloat32AtomicAdd)
			|| (l.ShaderSharedFloat64Atomics != r.ShaderSharedFloat64Atomics) || (l.ShaderSharedFloat64AtomicAdd != r.ShaderSharedFloat64AtomicAdd) || (l.ShaderImageFloat32Atomics != r.ShaderImageFloat32Atomics) || (l.ShaderImageFloat32AtomicAdd != r.ShaderImageFloat32AtomicAdd)
			|| (l.SparseImageFloat32Atomics != r.SparseImageFloat32Atomics) || (l.SparseImageFloat32AtomicAdd != r.SparseImageFloat32AtomicAdd)
			;
	}


	/// <summary>Creates a new PhysicalDeviceShaderAtomicFloatFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceShaderAtomicFloatFeatures value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceVertexAttributeDivisorFeatures : IEquatable<PhysicalDeviceVertexAttributeDivisorFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceVertexAttributeDivisorFeaturesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 VertexAttributeInstanceRateDivisor;
	public Vk.Bool32 VertexAttributeInstanceRateZeroDivisor;
	public PhysicalDeviceVertexAttributeDivisorFeatures(
		in Vk.Bool32 vertexAttributeInstanceRateDivisor = default,
		in Vk.Bool32 vertexAttributeInstanceRateZeroDivisor = default
	) {
		sType = TYPE;
		pNext = null;
		VertexAttributeInstanceRateDivisor = vertexAttributeInstanceRateDivisor;
		VertexAttributeInstanceRateZeroDivisor = vertexAttributeInstanceRateZeroDivisor;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceVertexAttributeDivisorFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceVertexAttributeDivisorFeatures>.Equals(PhysicalDeviceVertexAttributeDivisorFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ VertexAttributeInstanceRateDivisor.GetHashCode() ^ VertexAttributeInstanceRateZeroDivisor.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceVertexAttributeDivisorFeatures l, in PhysicalDeviceVertexAttributeDivisorFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.VertexAttributeInstanceRateDivisor == r.VertexAttributeInstanceRateDivisor) && (l.VertexAttributeInstanceRateZeroDivisor == r.VertexAttributeInstanceRateZeroDivisor)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceVertexAttributeDivisorFeatures l, in PhysicalDeviceVertexAttributeDivisorFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.VertexAttributeInstanceRateDivisor != r.VertexAttributeInstanceRateDivisor) || (l.VertexAttributeInstanceRateZeroDivisor != r.VertexAttributeInstanceRateZeroDivisor)
			;
	}


	/// <summary>Creates a new PhysicalDeviceVertexAttributeDivisorFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceVertexAttributeDivisorFeatures value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ImageViewASTCDecodeMode : IEquatable<ImageViewASTCDecodeMode>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ImageViewAstcDecodeModeEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Format DecodeMode;
	public ImageViewASTCDecodeMode(
		in Vk.Format decodeMode = default
	) {
		sType = TYPE;
		pNext = null;
		DecodeMode = decodeMode;
	}


	public readonly override bool Equals(object? obj) => (obj is ImageViewASTCDecodeMode o) && (this == o);
	readonly bool IEquatable<ImageViewASTCDecodeMode>.Equals(ImageViewASTCDecodeMode obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DecodeMode.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ImageViewASTCDecodeMode l, in ImageViewASTCDecodeMode r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DecodeMode == r.DecodeMode)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ImageViewASTCDecodeMode l, in ImageViewASTCDecodeMode r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DecodeMode != r.DecodeMode)
			;
	}


	/// <summary>Creates a new ImageViewASTCDecodeMode value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ImageViewASTCDecodeMode value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceASTCDecodeFeatures : IEquatable<PhysicalDeviceASTCDecodeFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceAstcDecodeFeaturesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 DecodeModeSharedExponent;
	public PhysicalDeviceASTCDecodeFeatures(
		in Vk.Bool32 decodeModeSharedExponent = default
	) {
		sType = TYPE;
		pNext = null;
		DecodeModeSharedExponent = decodeModeSharedExponent;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceASTCDecodeFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceASTCDecodeFeatures>.Equals(PhysicalDeviceASTCDecodeFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DecodeModeSharedExponent.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceASTCDecodeFeatures l, in PhysicalDeviceASTCDecodeFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DecodeModeSharedExponent == r.DecodeModeSharedExponent)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceASTCDecodeFeatures l, in PhysicalDeviceASTCDecodeFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DecodeModeSharedExponent != r.DecodeModeSharedExponent)
			;
	}


	/// <summary>Creates a new PhysicalDeviceASTCDecodeFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceASTCDecodeFeatures value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceTransformFeedbackFeatures : IEquatable<PhysicalDeviceTransformFeedbackFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceTransformFeedbackFeaturesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 TransformFeedback;
	public Vk.Bool32 GeometryStreams;
	public PhysicalDeviceTransformFeedbackFeatures(
		in Vk.Bool32 transformFeedback = default,
		in Vk.Bool32 geometryStreams = default
	) {
		sType = TYPE;
		pNext = null;
		TransformFeedback = transformFeedback;
		GeometryStreams = geometryStreams;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceTransformFeedbackFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceTransformFeedbackFeatures>.Equals(PhysicalDeviceTransformFeedbackFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ TransformFeedback.GetHashCode() ^ GeometryStreams.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceTransformFeedbackFeatures l, in PhysicalDeviceTransformFeedbackFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.TransformFeedback == r.TransformFeedback) && (l.GeometryStreams == r.GeometryStreams)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceTransformFeedbackFeatures l, in PhysicalDeviceTransformFeedbackFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.TransformFeedback != r.TransformFeedback) || (l.GeometryStreams != r.GeometryStreams)
			;
	}


	/// <summary>Creates a new PhysicalDeviceTransformFeedbackFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceTransformFeedbackFeatures value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceTransformFeedbackProperties : IEquatable<PhysicalDeviceTransformFeedbackProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceTransformFeedbackPropertiesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public uint MaxTransformFeedbackStreams;
	public uint MaxTransformFeedbackBuffers;
	public Vk.DeviceSize MaxTransformFeedbackBufferSize;
	public uint MaxTransformFeedbackStreamDataSize;
	public uint MaxTransformFeedbackBufferDataSize;
	public uint MaxTransformFeedbackBufferDataStride;
	public Vk.Bool32 TransformFeedbackQueries;
	public Vk.Bool32 TransformFeedbackStreamsLinesTriangles;
	public Vk.Bool32 TransformFeedbackRasterizationStreamSelect;
	public Vk.Bool32 TransformFeedbackDraw;
	public PhysicalDeviceTransformFeedbackProperties(
		uint maxTransformFeedbackStreams = default,
		uint maxTransformFeedbackBuffers = default,
		in Vk.DeviceSize maxTransformFeedbackBufferSize = default,
		uint maxTransformFeedbackStreamDataSize = default,
		uint maxTransformFeedbackBufferDataSize = default,
		uint maxTransformFeedbackBufferDataStride = default,
		in Vk.Bool32 transformFeedbackQueries = default,
		in Vk.Bool32 transformFeedbackStreamsLinesTriangles = default,
		in Vk.Bool32 transformFeedbackRasterizationStreamSelect = default,
		in Vk.Bool32 transformFeedbackDraw = default
	) {
		sType = TYPE;
		pNext = null;
		MaxTransformFeedbackStreams = maxTransformFeedbackStreams;
		MaxTransformFeedbackBuffers = maxTransformFeedbackBuffers;
		MaxTransformFeedbackBufferSize = maxTransformFeedbackBufferSize;
		MaxTransformFeedbackStreamDataSize = maxTransformFeedbackStreamDataSize;
		MaxTransformFeedbackBufferDataSize = maxTransformFeedbackBufferDataSize;
		MaxTransformFeedbackBufferDataStride = maxTransformFeedbackBufferDataStride;
		TransformFeedbackQueries = transformFeedbackQueries;
		TransformFeedbackStreamsLinesTriangles = transformFeedbackStreamsLinesTriangles;
		TransformFeedbackRasterizationStreamSelect = transformFeedbackRasterizationStreamSelect;
		TransformFeedbackDraw = transformFeedbackDraw;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceTransformFeedbackProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceTransformFeedbackProperties>.Equals(PhysicalDeviceTransformFeedbackProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MaxTransformFeedbackStreams.GetHashCode() ^ MaxTransformFeedbackBuffers.GetHashCode()
			^ MaxTransformFeedbackBufferSize.GetHashCode() ^ MaxTransformFeedbackStreamDataSize.GetHashCode() ^ MaxTransformFeedbackBufferDataSize.GetHashCode() ^ MaxTransformFeedbackBufferDataStride.GetHashCode()
			^ TransformFeedbackQueries.GetHashCode() ^ TransformFeedbackStreamsLinesTriangles.GetHashCode() ^ TransformFeedbackRasterizationStreamSelect.GetHashCode() ^ TransformFeedbackDraw.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceTransformFeedbackProperties l, in PhysicalDeviceTransformFeedbackProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MaxTransformFeedbackStreams == r.MaxTransformFeedbackStreams) && (l.MaxTransformFeedbackBuffers == r.MaxTransformFeedbackBuffers)
			&& (l.MaxTransformFeedbackBufferSize == r.MaxTransformFeedbackBufferSize) && (l.MaxTransformFeedbackStreamDataSize == r.MaxTransformFeedbackStreamDataSize) && (l.MaxTransformFeedbackBufferDataSize == r.MaxTransformFeedbackBufferDataSize) && (l.MaxTransformFeedbackBufferDataStride == r.MaxTransformFeedbackBufferDataStride)
			&& (l.TransformFeedbackQueries == r.TransformFeedbackQueries) && (l.TransformFeedbackStreamsLinesTriangles == r.TransformFeedbackStreamsLinesTriangles) && (l.TransformFeedbackRasterizationStreamSelect == r.TransformFeedbackRasterizationStreamSelect) && (l.TransformFeedbackDraw == r.TransformFeedbackDraw)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceTransformFeedbackProperties l, in PhysicalDeviceTransformFeedbackProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MaxTransformFeedbackStreams != r.MaxTransformFeedbackStreams) || (l.MaxTransformFeedbackBuffers != r.MaxTransformFeedbackBuffers)
			|| (l.MaxTransformFeedbackBufferSize != r.MaxTransformFeedbackBufferSize) || (l.MaxTransformFeedbackStreamDataSize != r.MaxTransformFeedbackStreamDataSize) || (l.MaxTransformFeedbackBufferDataSize != r.MaxTransformFeedbackBufferDataSize) || (l.MaxTransformFeedbackBufferDataStride != r.MaxTransformFeedbackBufferDataStride)
			|| (l.TransformFeedbackQueries != r.TransformFeedbackQueries) || (l.TransformFeedbackStreamsLinesTriangles != r.TransformFeedbackStreamsLinesTriangles) || (l.TransformFeedbackRasterizationStreamSelect != r.TransformFeedbackRasterizationStreamSelect) || (l.TransformFeedbackDraw != r.TransformFeedbackDraw)
			;
	}


	/// <summary>Creates a new PhysicalDeviceTransformFeedbackProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceTransformFeedbackProperties value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PipelineRasterizationStateStreamCreateInfo : IEquatable<PipelineRasterizationStateStreamCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PipelineRasterizationStateStreamCreateInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.EXT.PipelineRasterizationStateStreamCreateFlags Flags;
	public uint RasterizationStream;
	public PipelineRasterizationStateStreamCreateInfo(
		in Vk.EXT.PipelineRasterizationStateStreamCreateFlags flags = default,
		uint rasterizationStream = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		RasterizationStream = rasterizationStream;
	}


	public readonly override bool Equals(object? obj) => (obj is PipelineRasterizationStateStreamCreateInfo o) && (this == o);
	readonly bool IEquatable<PipelineRasterizationStateStreamCreateInfo>.Equals(PipelineRasterizationStateStreamCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ RasterizationStream.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PipelineRasterizationStateStreamCreateInfo l, in PipelineRasterizationStateStreamCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.RasterizationStream == r.RasterizationStream)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PipelineRasterizationStateStreamCreateInfo l, in PipelineRasterizationStateStreamCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.RasterizationStream != r.RasterizationStream)
			;
	}


	/// <summary>Creates a new PipelineRasterizationStateStreamCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PipelineRasterizationStateStreamCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DrmFormatModifierPropertiesList : IEquatable<DrmFormatModifierPropertiesList>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DrmFormatModifierPropertiesListEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public uint DrmFormatModifierCount;
	public Vk.EXT.DrmFormatModifierProperties* DrmFormatModifierProperties;
	public DrmFormatModifierPropertiesList(
		uint drmFormatModifierCount = default,
		in Vk.EXT.DrmFormatModifierProperties* drmFormatModifierProperties = default
	) {
		sType = TYPE;
		pNext = null;
		DrmFormatModifierCount = drmFormatModifierCount;
		DrmFormatModifierProperties = drmFormatModifierProperties;
	}


	public readonly override bool Equals(object? obj) => (obj is DrmFormatModifierPropertiesList o) && (this == o);
	readonly bool IEquatable<DrmFormatModifierPropertiesList>.Equals(DrmFormatModifierPropertiesList obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DrmFormatModifierCount.GetHashCode() ^ ((ulong)DrmFormatModifierProperties).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DrmFormatModifierPropertiesList l, in DrmFormatModifierPropertiesList r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DrmFormatModifierCount == r.DrmFormatModifierCount) && (l.DrmFormatModifierProperties == r.DrmFormatModifierProperties)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DrmFormatModifierPropertiesList l, in DrmFormatModifierPropertiesList r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DrmFormatModifierCount != r.DrmFormatModifierCount) || (l.DrmFormatModifierProperties != r.DrmFormatModifierProperties)
			;
	}


	/// <summary>Creates a new DrmFormatModifierPropertiesList value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DrmFormatModifierPropertiesList value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DrmFormatModifierProperties : IEquatable<DrmFormatModifierProperties>
{
	public ulong DrmFormatModifier;
	public uint DrmFormatModifierPlaneCount;
	public Vk.FormatFeatureFlags DrmFormatModifierTilingFeatures;
	public DrmFormatModifierProperties(
		ulong drmFormatModifier = default,
		uint drmFormatModifierPlaneCount = default,
		in Vk.FormatFeatureFlags drmFormatModifierTilingFeatures = default
	) {
		DrmFormatModifier = drmFormatModifier;
		DrmFormatModifierPlaneCount = drmFormatModifierPlaneCount;
		DrmFormatModifierTilingFeatures = drmFormatModifierTilingFeatures;
	}


	public readonly override bool Equals(object? obj) => (obj is DrmFormatModifierProperties o) && (this == o);
	readonly bool IEquatable<DrmFormatModifierProperties>.Equals(DrmFormatModifierProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			DrmFormatModifier.GetHashCode() ^ DrmFormatModifierPlaneCount.GetHashCode() ^ DrmFormatModifierTilingFeatures.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DrmFormatModifierProperties l, in DrmFormatModifierProperties r)
	{
		return
			(l.DrmFormatModifier == r.DrmFormatModifier) && (l.DrmFormatModifierPlaneCount == r.DrmFormatModifierPlaneCount) && (l.DrmFormatModifierTilingFeatures == r.DrmFormatModifierTilingFeatures)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DrmFormatModifierProperties l, in DrmFormatModifierProperties r)
	{
		return
			(l.DrmFormatModifier != r.DrmFormatModifier) || (l.DrmFormatModifierPlaneCount != r.DrmFormatModifierPlaneCount) || (l.DrmFormatModifierTilingFeatures != r.DrmFormatModifierTilingFeatures)
			;
	}


	/// <summary>Creates a new DrmFormatModifierProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DrmFormatModifierProperties value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceImageDrmFormatModifierInfo : IEquatable<PhysicalDeviceImageDrmFormatModifierInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceImageDrmFormatModifierInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public ulong DrmFormatModifier;
	public Vk.SharingMode SharingMode;
	public uint QueueFamilyIndexCount;
	public uint* QueueFamilyIndices;
	public PhysicalDeviceImageDrmFormatModifierInfo(
		ulong drmFormatModifier = default,
		in Vk.SharingMode sharingMode = default,
		uint queueFamilyIndexCount = default,
		uint* queueFamilyIndices = default
	) {
		sType = TYPE;
		pNext = null;
		DrmFormatModifier = drmFormatModifier;
		SharingMode = sharingMode;
		QueueFamilyIndexCount = queueFamilyIndexCount;
		QueueFamilyIndices = queueFamilyIndices;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceImageDrmFormatModifierInfo o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceImageDrmFormatModifierInfo>.Equals(PhysicalDeviceImageDrmFormatModifierInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DrmFormatModifier.GetHashCode() ^ SharingMode.GetHashCode()
			^ QueueFamilyIndexCount.GetHashCode() ^ ((ulong)QueueFamilyIndices).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceImageDrmFormatModifierInfo l, in PhysicalDeviceImageDrmFormatModifierInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DrmFormatModifier == r.DrmFormatModifier) && (l.SharingMode == r.SharingMode)
			&& (l.QueueFamilyIndexCount == r.QueueFamilyIndexCount) && (l.QueueFamilyIndices == r.QueueFamilyIndices)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceImageDrmFormatModifierInfo l, in PhysicalDeviceImageDrmFormatModifierInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DrmFormatModifier != r.DrmFormatModifier) || (l.SharingMode != r.SharingMode)
			|| (l.QueueFamilyIndexCount != r.QueueFamilyIndexCount) || (l.QueueFamilyIndices != r.QueueFamilyIndices)
			;
	}


	/// <summary>Creates a new PhysicalDeviceImageDrmFormatModifierInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceImageDrmFormatModifierInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ImageDrmFormatModifierListCreateInfo : IEquatable<ImageDrmFormatModifierListCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ImageDrmFormatModifierListCreateInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public uint DrmFormatModifierCount;
	public ulong* DrmFormatModifiers;
	public ImageDrmFormatModifierListCreateInfo(
		uint drmFormatModifierCount = default,
		ulong* drmFormatModifiers = default
	) {
		sType = TYPE;
		pNext = null;
		DrmFormatModifierCount = drmFormatModifierCount;
		DrmFormatModifiers = drmFormatModifiers;
	}


	public readonly override bool Equals(object? obj) => (obj is ImageDrmFormatModifierListCreateInfo o) && (this == o);
	readonly bool IEquatable<ImageDrmFormatModifierListCreateInfo>.Equals(ImageDrmFormatModifierListCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DrmFormatModifierCount.GetHashCode() ^ ((ulong)DrmFormatModifiers).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ImageDrmFormatModifierListCreateInfo l, in ImageDrmFormatModifierListCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DrmFormatModifierCount == r.DrmFormatModifierCount) && (l.DrmFormatModifiers == r.DrmFormatModifiers)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ImageDrmFormatModifierListCreateInfo l, in ImageDrmFormatModifierListCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DrmFormatModifierCount != r.DrmFormatModifierCount) || (l.DrmFormatModifiers != r.DrmFormatModifiers)
			;
	}


	/// <summary>Creates a new ImageDrmFormatModifierListCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ImageDrmFormatModifierListCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ImageDrmFormatModifierExplicitCreateInfo : IEquatable<ImageDrmFormatModifierExplicitCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ImageDrmFormatModifierExplicitCreateInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public ulong DrmFormatModifier;
	public uint DrmFormatModifierPlaneCount;
	public Vk.SubresourceLayout* PlaneLayouts;
	public ImageDrmFormatModifierExplicitCreateInfo(
		ulong drmFormatModifier = default,
		uint drmFormatModifierPlaneCount = default,
		in Vk.SubresourceLayout* planeLayouts = default
	) {
		sType = TYPE;
		pNext = null;
		DrmFormatModifier = drmFormatModifier;
		DrmFormatModifierPlaneCount = drmFormatModifierPlaneCount;
		PlaneLayouts = planeLayouts;
	}


	public readonly override bool Equals(object? obj) => (obj is ImageDrmFormatModifierExplicitCreateInfo o) && (this == o);
	readonly bool IEquatable<ImageDrmFormatModifierExplicitCreateInfo>.Equals(ImageDrmFormatModifierExplicitCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DrmFormatModifier.GetHashCode() ^ DrmFormatModifierPlaneCount.GetHashCode()
			^ ((ulong)PlaneLayouts).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ImageDrmFormatModifierExplicitCreateInfo l, in ImageDrmFormatModifierExplicitCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DrmFormatModifier == r.DrmFormatModifier) && (l.DrmFormatModifierPlaneCount == r.DrmFormatModifierPlaneCount)
			&& (l.PlaneLayouts == r.PlaneLayouts)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ImageDrmFormatModifierExplicitCreateInfo l, in ImageDrmFormatModifierExplicitCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DrmFormatModifier != r.DrmFormatModifier) || (l.DrmFormatModifierPlaneCount != r.DrmFormatModifierPlaneCount)
			|| (l.PlaneLayouts != r.PlaneLayouts)
			;
	}


	/// <summary>Creates a new ImageDrmFormatModifierExplicitCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ImageDrmFormatModifierExplicitCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ImageDrmFormatModifierProperties : IEquatable<ImageDrmFormatModifierProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ImageDrmFormatModifierPropertiesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public ulong DrmFormatModifier;
	public ImageDrmFormatModifierProperties(
		ulong drmFormatModifier = default
	) {
		sType = TYPE;
		pNext = null;
		DrmFormatModifier = drmFormatModifier;
	}


	public readonly override bool Equals(object? obj) => (obj is ImageDrmFormatModifierProperties o) && (this == o);
	readonly bool IEquatable<ImageDrmFormatModifierProperties>.Equals(ImageDrmFormatModifierProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DrmFormatModifier.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ImageDrmFormatModifierProperties l, in ImageDrmFormatModifierProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DrmFormatModifier == r.DrmFormatModifier)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ImageDrmFormatModifierProperties l, in ImageDrmFormatModifierProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DrmFormatModifier != r.DrmFormatModifier)
			;
	}


	/// <summary>Creates a new ImageDrmFormatModifierProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ImageDrmFormatModifierProperties value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ImageStencilUsageCreateInfo : IEquatable<ImageStencilUsageCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.ImageStencilUsageCreateInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.ImageUsageFlags StencilUsage;
	public ImageStencilUsageCreateInfo(
		in Vk.ImageUsageFlags stencilUsage = default
	) {
		sType = TYPE;
		pNext = null;
		StencilUsage = stencilUsage;
	}


	public readonly override bool Equals(object? obj) => (obj is ImageStencilUsageCreateInfo o) && (this == o);
	readonly bool IEquatable<ImageStencilUsageCreateInfo>.Equals(ImageStencilUsageCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ StencilUsage.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ImageStencilUsageCreateInfo l, in ImageStencilUsageCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.StencilUsage == r.StencilUsage)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ImageStencilUsageCreateInfo l, in ImageStencilUsageCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.StencilUsage != r.StencilUsage)
			;
	}


	/// <summary>Creates a new ImageStencilUsageCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ImageStencilUsageCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceFragmentDensityMapFeatures : IEquatable<PhysicalDeviceFragmentDensityMapFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceFragmentDensityMapFeaturesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 FragmentDensityMap;
	public Vk.Bool32 FragmentDensityMapDynamic;
	public Vk.Bool32 FragmentDensityMapNonSubsampledImages;
	public PhysicalDeviceFragmentDensityMapFeatures(
		in Vk.Bool32 fragmentDensityMap = default,
		in Vk.Bool32 fragmentDensityMapDynamic = default,
		in Vk.Bool32 fragmentDensityMapNonSubsampledImages = default
	) {
		sType = TYPE;
		pNext = null;
		FragmentDensityMap = fragmentDensityMap;
		FragmentDensityMapDynamic = fragmentDensityMapDynamic;
		FragmentDensityMapNonSubsampledImages = fragmentDensityMapNonSubsampledImages;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceFragmentDensityMapFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceFragmentDensityMapFeatures>.Equals(PhysicalDeviceFragmentDensityMapFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ FragmentDensityMap.GetHashCode() ^ FragmentDensityMapDynamic.GetHashCode()
			^ FragmentDensityMapNonSubsampledImages.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceFragmentDensityMapFeatures l, in PhysicalDeviceFragmentDensityMapFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.FragmentDensityMap == r.FragmentDensityMap) && (l.FragmentDensityMapDynamic == r.FragmentDensityMapDynamic)
			&& (l.FragmentDensityMapNonSubsampledImages == r.FragmentDensityMapNonSubsampledImages)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceFragmentDensityMapFeatures l, in PhysicalDeviceFragmentDensityMapFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.FragmentDensityMap != r.FragmentDensityMap) || (l.FragmentDensityMapDynamic != r.FragmentDensityMapDynamic)
			|| (l.FragmentDensityMapNonSubsampledImages != r.FragmentDensityMapNonSubsampledImages)
			;
	}


	/// <summary>Creates a new PhysicalDeviceFragmentDensityMapFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceFragmentDensityMapFeatures value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceFragmentDensityMap2Features : IEquatable<PhysicalDeviceFragmentDensityMap2Features>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceFragmentDensityMap2FeaturesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 FragmentDensityMapDeferred;
	public PhysicalDeviceFragmentDensityMap2Features(
		in Vk.Bool32 fragmentDensityMapDeferred = default
	) {
		sType = TYPE;
		pNext = null;
		FragmentDensityMapDeferred = fragmentDensityMapDeferred;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceFragmentDensityMap2Features o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceFragmentDensityMap2Features>.Equals(PhysicalDeviceFragmentDensityMap2Features obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ FragmentDensityMapDeferred.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceFragmentDensityMap2Features l, in PhysicalDeviceFragmentDensityMap2Features r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.FragmentDensityMapDeferred == r.FragmentDensityMapDeferred)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceFragmentDensityMap2Features l, in PhysicalDeviceFragmentDensityMap2Features r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.FragmentDensityMapDeferred != r.FragmentDensityMapDeferred)
			;
	}


	/// <summary>Creates a new PhysicalDeviceFragmentDensityMap2Features value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceFragmentDensityMap2Features value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceFragmentDensityMapProperties : IEquatable<PhysicalDeviceFragmentDensityMapProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceFragmentDensityMapPropertiesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Extent2D MinFragmentDensityTexelSize;
	public Vk.Extent2D MaxFragmentDensityTexelSize;
	public Vk.Bool32 FragmentDensityInvocations;
	public PhysicalDeviceFragmentDensityMapProperties(
		in Vk.Extent2D minFragmentDensityTexelSize = default,
		in Vk.Extent2D maxFragmentDensityTexelSize = default,
		in Vk.Bool32 fragmentDensityInvocations = default
	) {
		sType = TYPE;
		pNext = null;
		MinFragmentDensityTexelSize = minFragmentDensityTexelSize;
		MaxFragmentDensityTexelSize = maxFragmentDensityTexelSize;
		FragmentDensityInvocations = fragmentDensityInvocations;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceFragmentDensityMapProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceFragmentDensityMapProperties>.Equals(PhysicalDeviceFragmentDensityMapProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MinFragmentDensityTexelSize.GetHashCode() ^ MaxFragmentDensityTexelSize.GetHashCode()
			^ FragmentDensityInvocations.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceFragmentDensityMapProperties l, in PhysicalDeviceFragmentDensityMapProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MinFragmentDensityTexelSize == r.MinFragmentDensityTexelSize) && (l.MaxFragmentDensityTexelSize == r.MaxFragmentDensityTexelSize)
			&& (l.FragmentDensityInvocations == r.FragmentDensityInvocations)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceFragmentDensityMapProperties l, in PhysicalDeviceFragmentDensityMapProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MinFragmentDensityTexelSize != r.MinFragmentDensityTexelSize) || (l.MaxFragmentDensityTexelSize != r.MaxFragmentDensityTexelSize)
			|| (l.FragmentDensityInvocations != r.FragmentDensityInvocations)
			;
	}


	/// <summary>Creates a new PhysicalDeviceFragmentDensityMapProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceFragmentDensityMapProperties value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceFragmentDensityMap2Properties : IEquatable<PhysicalDeviceFragmentDensityMap2Properties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceFragmentDensityMap2PropertiesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 SubsampledLoads;
	public Vk.Bool32 SubsampledCoarseReconstructionEarlyAccess;
	public uint MaxSubsampledArrayLayers;
	public uint MaxDescriptorSetSubsampledSamplers;
	public PhysicalDeviceFragmentDensityMap2Properties(
		in Vk.Bool32 subsampledLoads = default,
		in Vk.Bool32 subsampledCoarseReconstructionEarlyAccess = default,
		uint maxSubsampledArrayLayers = default,
		uint maxDescriptorSetSubsampledSamplers = default
	) {
		sType = TYPE;
		pNext = null;
		SubsampledLoads = subsampledLoads;
		SubsampledCoarseReconstructionEarlyAccess = subsampledCoarseReconstructionEarlyAccess;
		MaxSubsampledArrayLayers = maxSubsampledArrayLayers;
		MaxDescriptorSetSubsampledSamplers = maxDescriptorSetSubsampledSamplers;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceFragmentDensityMap2Properties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceFragmentDensityMap2Properties>.Equals(PhysicalDeviceFragmentDensityMap2Properties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SubsampledLoads.GetHashCode() ^ SubsampledCoarseReconstructionEarlyAccess.GetHashCode()
			^ MaxSubsampledArrayLayers.GetHashCode() ^ MaxDescriptorSetSubsampledSamplers.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceFragmentDensityMap2Properties l, in PhysicalDeviceFragmentDensityMap2Properties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SubsampledLoads == r.SubsampledLoads) && (l.SubsampledCoarseReconstructionEarlyAccess == r.SubsampledCoarseReconstructionEarlyAccess)
			&& (l.MaxSubsampledArrayLayers == r.MaxSubsampledArrayLayers) && (l.MaxDescriptorSetSubsampledSamplers == r.MaxDescriptorSetSubsampledSamplers)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceFragmentDensityMap2Properties l, in PhysicalDeviceFragmentDensityMap2Properties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SubsampledLoads != r.SubsampledLoads) || (l.SubsampledCoarseReconstructionEarlyAccess != r.SubsampledCoarseReconstructionEarlyAccess)
			|| (l.MaxSubsampledArrayLayers != r.MaxSubsampledArrayLayers) || (l.MaxDescriptorSetSubsampledSamplers != r.MaxDescriptorSetSubsampledSamplers)
			;
	}


	/// <summary>Creates a new PhysicalDeviceFragmentDensityMap2Properties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceFragmentDensityMap2Properties value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct RenderPassFragmentDensityMapCreateInfo : IEquatable<RenderPassFragmentDensityMapCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.RenderPassFragmentDensityMapCreateInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.AttachmentReference FragmentDensityMapAttachment;
	public RenderPassFragmentDensityMapCreateInfo(
		in Vk.AttachmentReference fragmentDensityMapAttachment = default
	) {
		sType = TYPE;
		pNext = null;
		FragmentDensityMapAttachment = fragmentDensityMapAttachment;
	}


	public readonly override bool Equals(object? obj) => (obj is RenderPassFragmentDensityMapCreateInfo o) && (this == o);
	readonly bool IEquatable<RenderPassFragmentDensityMapCreateInfo>.Equals(RenderPassFragmentDensityMapCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ FragmentDensityMapAttachment.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in RenderPassFragmentDensityMapCreateInfo l, in RenderPassFragmentDensityMapCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.FragmentDensityMapAttachment == r.FragmentDensityMapAttachment)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in RenderPassFragmentDensityMapCreateInfo l, in RenderPassFragmentDensityMapCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.FragmentDensityMapAttachment != r.FragmentDensityMapAttachment)
			;
	}


	/// <summary>Creates a new RenderPassFragmentDensityMapCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out RenderPassFragmentDensityMapCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceScalarBlockLayoutFeatures : IEquatable<PhysicalDeviceScalarBlockLayoutFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceScalarBlockLayoutFeatures;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 ScalarBlockLayout;
	public PhysicalDeviceScalarBlockLayoutFeatures(
		in Vk.Bool32 scalarBlockLayout = default
	) {
		sType = TYPE;
		pNext = null;
		ScalarBlockLayout = scalarBlockLayout;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceScalarBlockLayoutFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceScalarBlockLayoutFeatures>.Equals(PhysicalDeviceScalarBlockLayoutFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ScalarBlockLayout.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceScalarBlockLayoutFeatures l, in PhysicalDeviceScalarBlockLayoutFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ScalarBlockLayout == r.ScalarBlockLayout)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceScalarBlockLayoutFeatures l, in PhysicalDeviceScalarBlockLayoutFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ScalarBlockLayout != r.ScalarBlockLayout)
			;
	}


	/// <summary>Creates a new PhysicalDeviceScalarBlockLayoutFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceScalarBlockLayoutFeatures value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceDepthClipEnableFeatures : IEquatable<PhysicalDeviceDepthClipEnableFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceDepthClipEnableFeaturesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 DepthClipEnable;
	public PhysicalDeviceDepthClipEnableFeatures(
		in Vk.Bool32 depthClipEnable = default
	) {
		sType = TYPE;
		pNext = null;
		DepthClipEnable = depthClipEnable;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceDepthClipEnableFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceDepthClipEnableFeatures>.Equals(PhysicalDeviceDepthClipEnableFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DepthClipEnable.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceDepthClipEnableFeatures l, in PhysicalDeviceDepthClipEnableFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DepthClipEnable == r.DepthClipEnable)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceDepthClipEnableFeatures l, in PhysicalDeviceDepthClipEnableFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DepthClipEnable != r.DepthClipEnable)
			;
	}


	/// <summary>Creates a new PhysicalDeviceDepthClipEnableFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceDepthClipEnableFeatures value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PipelineRasterizationDepthClipStateCreateInfo : IEquatable<PipelineRasterizationDepthClipStateCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PipelineRasterizationDepthClipStateCreateInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.EXT.PipelineRasterizationDepthClipStateCreateFlags Flags;
	public Vk.Bool32 DepthClipEnable;
	public PipelineRasterizationDepthClipStateCreateInfo(
		in Vk.EXT.PipelineRasterizationDepthClipStateCreateFlags flags = default,
		in Vk.Bool32 depthClipEnable = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		DepthClipEnable = depthClipEnable;
	}


	public readonly override bool Equals(object? obj) => (obj is PipelineRasterizationDepthClipStateCreateInfo o) && (this == o);
	readonly bool IEquatable<PipelineRasterizationDepthClipStateCreateInfo>.Equals(PipelineRasterizationDepthClipStateCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ DepthClipEnable.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PipelineRasterizationDepthClipStateCreateInfo l, in PipelineRasterizationDepthClipStateCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.DepthClipEnable == r.DepthClipEnable)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PipelineRasterizationDepthClipStateCreateInfo l, in PipelineRasterizationDepthClipStateCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.DepthClipEnable != r.DepthClipEnable)
			;
	}


	/// <summary>Creates a new PipelineRasterizationDepthClipStateCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PipelineRasterizationDepthClipStateCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceMemoryBudgetProperties : IEquatable<PhysicalDeviceMemoryBudgetProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceMemoryBudgetPropertiesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.DeviceSize HeapBudget_0;
	public Vk.DeviceSize HeapBudget_1;
	public Vk.DeviceSize HeapBudget_2;
	public Vk.DeviceSize HeapBudget_3;
	public Vk.DeviceSize HeapBudget_4;
	public Vk.DeviceSize HeapBudget_5;
	public Vk.DeviceSize HeapBudget_6;
	public Vk.DeviceSize HeapBudget_7;
	public Vk.DeviceSize HeapBudget_8;
	public Vk.DeviceSize HeapBudget_9;
	public Vk.DeviceSize HeapBudget_10;
	public Vk.DeviceSize HeapBudget_11;
	public Vk.DeviceSize HeapBudget_12;
	public Vk.DeviceSize HeapBudget_13;
	public Vk.DeviceSize HeapBudget_14;
	public Vk.DeviceSize HeapBudget_15;
	public Vk.DeviceSize HeapUsage_0;
	public Vk.DeviceSize HeapUsage_1;
	public Vk.DeviceSize HeapUsage_2;
	public Vk.DeviceSize HeapUsage_3;
	public Vk.DeviceSize HeapUsage_4;
	public Vk.DeviceSize HeapUsage_5;
	public Vk.DeviceSize HeapUsage_6;
	public Vk.DeviceSize HeapUsage_7;
	public Vk.DeviceSize HeapUsage_8;
	public Vk.DeviceSize HeapUsage_9;
	public Vk.DeviceSize HeapUsage_10;
	public Vk.DeviceSize HeapUsage_11;
	public Vk.DeviceSize HeapUsage_12;
	public Vk.DeviceSize HeapUsage_13;
	public Vk.DeviceSize HeapUsage_14;
	public Vk.DeviceSize HeapUsage_15;
	public PhysicalDeviceMemoryBudgetProperties(
		in Vk.DeviceSize heapBudget0 = default,
		in Vk.DeviceSize heapBudget1 = default,
		in Vk.DeviceSize heapBudget2 = default,
		in Vk.DeviceSize heapBudget3 = default,
		in Vk.DeviceSize heapBudget4 = default,
		in Vk.DeviceSize heapBudget5 = default,
		in Vk.DeviceSize heapBudget6 = default,
		in Vk.DeviceSize heapBudget7 = default,
		in Vk.DeviceSize heapBudget8 = default,
		in Vk.DeviceSize heapBudget9 = default,
		in Vk.DeviceSize heapBudget10 = default,
		in Vk.DeviceSize heapBudget11 = default,
		in Vk.DeviceSize heapBudget12 = default,
		in Vk.DeviceSize heapBudget13 = default,
		in Vk.DeviceSize heapBudget14 = default,
		in Vk.DeviceSize heapBudget15 = default,
		in Vk.DeviceSize heapUsage0 = default,
		in Vk.DeviceSize heapUsage1 = default,
		in Vk.DeviceSize heapUsage2 = default,
		in Vk.DeviceSize heapUsage3 = default,
		in Vk.DeviceSize heapUsage4 = default,
		in Vk.DeviceSize heapUsage5 = default,
		in Vk.DeviceSize heapUsage6 = default,
		in Vk.DeviceSize heapUsage7 = default,
		in Vk.DeviceSize heapUsage8 = default,
		in Vk.DeviceSize heapUsage9 = default,
		in Vk.DeviceSize heapUsage10 = default,
		in Vk.DeviceSize heapUsage11 = default,
		in Vk.DeviceSize heapUsage12 = default,
		in Vk.DeviceSize heapUsage13 = default,
		in Vk.DeviceSize heapUsage14 = default,
		in Vk.DeviceSize heapUsage15 = default
	) {
		sType = TYPE;
		pNext = null;
		HeapBudget_0 = heapBudget0;
		HeapBudget_1 = heapBudget1;
		HeapBudget_2 = heapBudget2;
		HeapBudget_3 = heapBudget3;
		HeapBudget_4 = heapBudget4;
		HeapBudget_5 = heapBudget5;
		HeapBudget_6 = heapBudget6;
		HeapBudget_7 = heapBudget7;
		HeapBudget_8 = heapBudget8;
		HeapBudget_9 = heapBudget9;
		HeapBudget_10 = heapBudget10;
		HeapBudget_11 = heapBudget11;
		HeapBudget_12 = heapBudget12;
		HeapBudget_13 = heapBudget13;
		HeapBudget_14 = heapBudget14;
		HeapBudget_15 = heapBudget15;
		HeapUsage_0 = heapUsage0;
		HeapUsage_1 = heapUsage1;
		HeapUsage_2 = heapUsage2;
		HeapUsage_3 = heapUsage3;
		HeapUsage_4 = heapUsage4;
		HeapUsage_5 = heapUsage5;
		HeapUsage_6 = heapUsage6;
		HeapUsage_7 = heapUsage7;
		HeapUsage_8 = heapUsage8;
		HeapUsage_9 = heapUsage9;
		HeapUsage_10 = heapUsage10;
		HeapUsage_11 = heapUsage11;
		HeapUsage_12 = heapUsage12;
		HeapUsage_13 = heapUsage13;
		HeapUsage_14 = heapUsage14;
		HeapUsage_15 = heapUsage15;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceMemoryBudgetProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceMemoryBudgetProperties>.Equals(PhysicalDeviceMemoryBudgetProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ HeapBudget_0.GetHashCode() ^ HeapBudget_1.GetHashCode()
			^ HeapBudget_2.GetHashCode() ^ HeapBudget_3.GetHashCode() ^ HeapBudget_4.GetHashCode() ^ HeapBudget_5.GetHashCode()
			^ HeapBudget_6.GetHashCode() ^ HeapBudget_7.GetHashCode() ^ HeapBudget_8.GetHashCode() ^ HeapBudget_9.GetHashCode()
			^ HeapBudget_10.GetHashCode() ^ HeapBudget_11.GetHashCode() ^ HeapBudget_12.GetHashCode() ^ HeapBudget_13.GetHashCode()
			^ HeapBudget_14.GetHashCode() ^ HeapBudget_15.GetHashCode() ^ HeapUsage_0.GetHashCode() ^ HeapUsage_1.GetHashCode()
			^ HeapUsage_2.GetHashCode() ^ HeapUsage_3.GetHashCode() ^ HeapUsage_4.GetHashCode() ^ HeapUsage_5.GetHashCode()
			^ HeapUsage_6.GetHashCode() ^ HeapUsage_7.GetHashCode() ^ HeapUsage_8.GetHashCode() ^ HeapUsage_9.GetHashCode()
			^ HeapUsage_10.GetHashCode() ^ HeapUsage_11.GetHashCode() ^ HeapUsage_12.GetHashCode() ^ HeapUsage_13.GetHashCode()
			^ HeapUsage_14.GetHashCode() ^ HeapUsage_15.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceMemoryBudgetProperties l, in PhysicalDeviceMemoryBudgetProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.HeapBudget_0 == r.HeapBudget_0) && (l.HeapBudget_1 == r.HeapBudget_1)
			&& (l.HeapBudget_2 == r.HeapBudget_2) && (l.HeapBudget_3 == r.HeapBudget_3) && (l.HeapBudget_4 == r.HeapBudget_4) && (l.HeapBudget_5 == r.HeapBudget_5)
			&& (l.HeapBudget_6 == r.HeapBudget_6) && (l.HeapBudget_7 == r.HeapBudget_7) && (l.HeapBudget_8 == r.HeapBudget_8) && (l.HeapBudget_9 == r.HeapBudget_9)
			&& (l.HeapBudget_10 == r.HeapBudget_10) && (l.HeapBudget_11 == r.HeapBudget_11) && (l.HeapBudget_12 == r.HeapBudget_12) && (l.HeapBudget_13 == r.HeapBudget_13)
			&& (l.HeapBudget_14 == r.HeapBudget_14) && (l.HeapBudget_15 == r.HeapBudget_15) && (l.HeapUsage_0 == r.HeapUsage_0) && (l.HeapUsage_1 == r.HeapUsage_1)
			&& (l.HeapUsage_2 == r.HeapUsage_2) && (l.HeapUsage_3 == r.HeapUsage_3) && (l.HeapUsage_4 == r.HeapUsage_4) && (l.HeapUsage_5 == r.HeapUsage_5)
			&& (l.HeapUsage_6 == r.HeapUsage_6) && (l.HeapUsage_7 == r.HeapUsage_7) && (l.HeapUsage_8 == r.HeapUsage_8) && (l.HeapUsage_9 == r.HeapUsage_9)
			&& (l.HeapUsage_10 == r.HeapUsage_10) && (l.HeapUsage_11 == r.HeapUsage_11) && (l.HeapUsage_12 == r.HeapUsage_12) && (l.HeapUsage_13 == r.HeapUsage_13)
			&& (l.HeapUsage_14 == r.HeapUsage_14) && (l.HeapUsage_15 == r.HeapUsage_15)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceMemoryBudgetProperties l, in PhysicalDeviceMemoryBudgetProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.HeapBudget_0 != r.HeapBudget_0) || (l.HeapBudget_1 != r.HeapBudget_1)
			|| (l.HeapBudget_2 != r.HeapBudget_2) || (l.HeapBudget_3 != r.HeapBudget_3) || (l.HeapBudget_4 != r.HeapBudget_4) || (l.HeapBudget_5 != r.HeapBudget_5)
			|| (l.HeapBudget_6 != r.HeapBudget_6) || (l.HeapBudget_7 != r.HeapBudget_7) || (l.HeapBudget_8 != r.HeapBudget_8) || (l.HeapBudget_9 != r.HeapBudget_9)
			|| (l.HeapBudget_10 != r.HeapBudget_10) || (l.HeapBudget_11 != r.HeapBudget_11) || (l.HeapBudget_12 != r.HeapBudget_12) || (l.HeapBudget_13 != r.HeapBudget_13)
			|| (l.HeapBudget_14 != r.HeapBudget_14) || (l.HeapBudget_15 != r.HeapBudget_15) || (l.HeapUsage_0 != r.HeapUsage_0) || (l.HeapUsage_1 != r.HeapUsage_1)
			|| (l.HeapUsage_2 != r.HeapUsage_2) || (l.HeapUsage_3 != r.HeapUsage_3) || (l.HeapUsage_4 != r.HeapUsage_4) || (l.HeapUsage_5 != r.HeapUsage_5)
			|| (l.HeapUsage_6 != r.HeapUsage_6) || (l.HeapUsage_7 != r.HeapUsage_7) || (l.HeapUsage_8 != r.HeapUsage_8) || (l.HeapUsage_9 != r.HeapUsage_9)
			|| (l.HeapUsage_10 != r.HeapUsage_10) || (l.HeapUsage_11 != r.HeapUsage_11) || (l.HeapUsage_12 != r.HeapUsage_12) || (l.HeapUsage_13 != r.HeapUsage_13)
			|| (l.HeapUsage_14 != r.HeapUsage_14) || (l.HeapUsage_15 != r.HeapUsage_15)
			;
	}


	/// <summary>Creates a new PhysicalDeviceMemoryBudgetProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceMemoryBudgetProperties value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceMemoryPriorityFeatures : IEquatable<PhysicalDeviceMemoryPriorityFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceMemoryPriorityFeaturesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 MemoryPriority;
	public PhysicalDeviceMemoryPriorityFeatures(
		in Vk.Bool32 memoryPriority = default
	) {
		sType = TYPE;
		pNext = null;
		MemoryPriority = memoryPriority;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceMemoryPriorityFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceMemoryPriorityFeatures>.Equals(PhysicalDeviceMemoryPriorityFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MemoryPriority.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceMemoryPriorityFeatures l, in PhysicalDeviceMemoryPriorityFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MemoryPriority == r.MemoryPriority)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceMemoryPriorityFeatures l, in PhysicalDeviceMemoryPriorityFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MemoryPriority != r.MemoryPriority)
			;
	}


	/// <summary>Creates a new PhysicalDeviceMemoryPriorityFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceMemoryPriorityFeatures value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct MemoryPriorityAllocateInfo : IEquatable<MemoryPriorityAllocateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.MemoryPriorityAllocateInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public float Priority;
	public MemoryPriorityAllocateInfo(
		float priority = default
	) {
		sType = TYPE;
		pNext = null;
		Priority = priority;
	}


	public readonly override bool Equals(object? obj) => (obj is MemoryPriorityAllocateInfo o) && (this == o);
	readonly bool IEquatable<MemoryPriorityAllocateInfo>.Equals(MemoryPriorityAllocateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Priority.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in MemoryPriorityAllocateInfo l, in MemoryPriorityAllocateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Priority == r.Priority)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in MemoryPriorityAllocateInfo l, in MemoryPriorityAllocateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Priority != r.Priority)
			;
	}


	/// <summary>Creates a new MemoryPriorityAllocateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out MemoryPriorityAllocateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceBufferDeviceAddressFeatures : IEquatable<PhysicalDeviceBufferDeviceAddressFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceBufferDeviceAddressFeaturesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 BufferDeviceAddress;
	public Vk.Bool32 BufferDeviceAddressCaptureReplay;
	public Vk.Bool32 BufferDeviceAddressMultiDevice;
	public PhysicalDeviceBufferDeviceAddressFeatures(
		in Vk.Bool32 bufferDeviceAddress = default,
		in Vk.Bool32 bufferDeviceAddressCaptureReplay = default,
		in Vk.Bool32 bufferDeviceAddressMultiDevice = default
	) {
		sType = TYPE;
		pNext = null;
		BufferDeviceAddress = bufferDeviceAddress;
		BufferDeviceAddressCaptureReplay = bufferDeviceAddressCaptureReplay;
		BufferDeviceAddressMultiDevice = bufferDeviceAddressMultiDevice;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceBufferDeviceAddressFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceBufferDeviceAddressFeatures>.Equals(PhysicalDeviceBufferDeviceAddressFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ BufferDeviceAddress.GetHashCode() ^ BufferDeviceAddressCaptureReplay.GetHashCode()
			^ BufferDeviceAddressMultiDevice.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceBufferDeviceAddressFeatures l, in PhysicalDeviceBufferDeviceAddressFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.BufferDeviceAddress == r.BufferDeviceAddress) && (l.BufferDeviceAddressCaptureReplay == r.BufferDeviceAddressCaptureReplay)
			&& (l.BufferDeviceAddressMultiDevice == r.BufferDeviceAddressMultiDevice)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceBufferDeviceAddressFeatures l, in PhysicalDeviceBufferDeviceAddressFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.BufferDeviceAddress != r.BufferDeviceAddress) || (l.BufferDeviceAddressCaptureReplay != r.BufferDeviceAddressCaptureReplay)
			|| (l.BufferDeviceAddressMultiDevice != r.BufferDeviceAddressMultiDevice)
			;
	}


	/// <summary>Creates a new PhysicalDeviceBufferDeviceAddressFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceBufferDeviceAddressFeatures value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceBufferAddressFeatures : IEquatable<PhysicalDeviceBufferAddressFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceBufferDeviceAddressFeaturesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 BufferDeviceAddress;
	public Vk.Bool32 BufferDeviceAddressCaptureReplay;
	public Vk.Bool32 BufferDeviceAddressMultiDevice;
	public PhysicalDeviceBufferAddressFeatures(
		in Vk.Bool32 bufferDeviceAddress = default,
		in Vk.Bool32 bufferDeviceAddressCaptureReplay = default,
		in Vk.Bool32 bufferDeviceAddressMultiDevice = default
	) {
		sType = TYPE;
		pNext = null;
		BufferDeviceAddress = bufferDeviceAddress;
		BufferDeviceAddressCaptureReplay = bufferDeviceAddressCaptureReplay;
		BufferDeviceAddressMultiDevice = bufferDeviceAddressMultiDevice;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceBufferAddressFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceBufferAddressFeatures>.Equals(PhysicalDeviceBufferAddressFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ BufferDeviceAddress.GetHashCode() ^ BufferDeviceAddressCaptureReplay.GetHashCode()
			^ BufferDeviceAddressMultiDevice.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceBufferAddressFeatures l, in PhysicalDeviceBufferAddressFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.BufferDeviceAddress == r.BufferDeviceAddress) && (l.BufferDeviceAddressCaptureReplay == r.BufferDeviceAddressCaptureReplay)
			&& (l.BufferDeviceAddressMultiDevice == r.BufferDeviceAddressMultiDevice)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceBufferAddressFeatures l, in PhysicalDeviceBufferAddressFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.BufferDeviceAddress != r.BufferDeviceAddress) || (l.BufferDeviceAddressCaptureReplay != r.BufferDeviceAddressCaptureReplay)
			|| (l.BufferDeviceAddressMultiDevice != r.BufferDeviceAddressMultiDevice)
			;
	}


	/// <summary>Creates a new PhysicalDeviceBufferAddressFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceBufferAddressFeatures value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct BufferDeviceAddressInfo : IEquatable<BufferDeviceAddressInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.BufferDeviceAddressInfo;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Handle<Vk.Buffer> Buffer;
	public BufferDeviceAddressInfo(
		in Vk.Handle<Vk.Buffer> buffer = default
	) {
		sType = TYPE;
		pNext = null;
		Buffer = buffer;
	}


	public readonly override bool Equals(object? obj) => (obj is BufferDeviceAddressInfo o) && (this == o);
	readonly bool IEquatable<BufferDeviceAddressInfo>.Equals(BufferDeviceAddressInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Buffer.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in BufferDeviceAddressInfo l, in BufferDeviceAddressInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Buffer == r.Buffer)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in BufferDeviceAddressInfo l, in BufferDeviceAddressInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Buffer != r.Buffer)
			;
	}


	/// <summary>Creates a new BufferDeviceAddressInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out BufferDeviceAddressInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct BufferDeviceAddressCreateInfo : IEquatable<BufferDeviceAddressCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.BufferDeviceAddressCreateInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public ulong DeviceAddress;
	public BufferDeviceAddressCreateInfo(
		ulong deviceAddress = default
	) {
		sType = TYPE;
		pNext = null;
		DeviceAddress = deviceAddress;
	}


	public readonly override bool Equals(object? obj) => (obj is BufferDeviceAddressCreateInfo o) && (this == o);
	readonly bool IEquatable<BufferDeviceAddressCreateInfo>.Equals(BufferDeviceAddressCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DeviceAddress.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in BufferDeviceAddressCreateInfo l, in BufferDeviceAddressCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DeviceAddress == r.DeviceAddress)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in BufferDeviceAddressCreateInfo l, in BufferDeviceAddressCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DeviceAddress != r.DeviceAddress)
			;
	}


	/// <summary>Creates a new BufferDeviceAddressCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out BufferDeviceAddressCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceImageViewImageFormatInfo : IEquatable<PhysicalDeviceImageViewImageFormatInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceImageViewImageFormatInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.ImageViewType ImageViewType;
	public PhysicalDeviceImageViewImageFormatInfo(
		in Vk.ImageViewType imageViewType = default
	) {
		sType = TYPE;
		pNext = null;
		ImageViewType = imageViewType;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceImageViewImageFormatInfo o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceImageViewImageFormatInfo>.Equals(PhysicalDeviceImageViewImageFormatInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ImageViewType.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceImageViewImageFormatInfo l, in PhysicalDeviceImageViewImageFormatInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ImageViewType == r.ImageViewType)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceImageViewImageFormatInfo l, in PhysicalDeviceImageViewImageFormatInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ImageViewType != r.ImageViewType)
			;
	}


	/// <summary>Creates a new PhysicalDeviceImageViewImageFormatInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceImageViewImageFormatInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct FilterCubicImageViewImageFormatProperties : IEquatable<FilterCubicImageViewImageFormatProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.FilterCubicImageViewImageFormatPropertiesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 FilterCubic;
	public Vk.Bool32 FilterCubicMinmax;
	public FilterCubicImageViewImageFormatProperties(
		in Vk.Bool32 filterCubic = default,
		in Vk.Bool32 filterCubicMinmax = default
	) {
		sType = TYPE;
		pNext = null;
		FilterCubic = filterCubic;
		FilterCubicMinmax = filterCubicMinmax;
	}


	public readonly override bool Equals(object? obj) => (obj is FilterCubicImageViewImageFormatProperties o) && (this == o);
	readonly bool IEquatable<FilterCubicImageViewImageFormatProperties>.Equals(FilterCubicImageViewImageFormatProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ FilterCubic.GetHashCode() ^ FilterCubicMinmax.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in FilterCubicImageViewImageFormatProperties l, in FilterCubicImageViewImageFormatProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.FilterCubic == r.FilterCubic) && (l.FilterCubicMinmax == r.FilterCubicMinmax)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in FilterCubicImageViewImageFormatProperties l, in FilterCubicImageViewImageFormatProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.FilterCubic != r.FilterCubic) || (l.FilterCubicMinmax != r.FilterCubicMinmax)
			;
	}


	/// <summary>Creates a new FilterCubicImageViewImageFormatProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out FilterCubicImageViewImageFormatProperties value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceTextureCompressionASTCHDRFeatures : IEquatable<PhysicalDeviceTextureCompressionASTCHDRFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceTextureCompressionAstcHdrFeaturesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 TextureCompressionASTC_HDR;
	public PhysicalDeviceTextureCompressionASTCHDRFeatures(
		in Vk.Bool32 textureCompressionASTC_HDR = default
	) {
		sType = TYPE;
		pNext = null;
		TextureCompressionASTC_HDR = textureCompressionASTC_HDR;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceTextureCompressionASTCHDRFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceTextureCompressionASTCHDRFeatures>.Equals(PhysicalDeviceTextureCompressionASTCHDRFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ TextureCompressionASTC_HDR.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceTextureCompressionASTCHDRFeatures l, in PhysicalDeviceTextureCompressionASTCHDRFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.TextureCompressionASTC_HDR == r.TextureCompressionASTC_HDR)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceTextureCompressionASTCHDRFeatures l, in PhysicalDeviceTextureCompressionASTCHDRFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.TextureCompressionASTC_HDR != r.TextureCompressionASTC_HDR)
			;
	}


	/// <summary>Creates a new PhysicalDeviceTextureCompressionASTCHDRFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceTextureCompressionASTCHDRFeatures value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceYcbcrImageArraysFeatures : IEquatable<PhysicalDeviceYcbcrImageArraysFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceYcbcrImageArraysFeaturesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 YcbcrImageArrays;
	public PhysicalDeviceYcbcrImageArraysFeatures(
		in Vk.Bool32 ycbcrImageArrays = default
	) {
		sType = TYPE;
		pNext = null;
		YcbcrImageArrays = ycbcrImageArrays;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceYcbcrImageArraysFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceYcbcrImageArraysFeatures>.Equals(PhysicalDeviceYcbcrImageArraysFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ YcbcrImageArrays.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceYcbcrImageArraysFeatures l, in PhysicalDeviceYcbcrImageArraysFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.YcbcrImageArrays == r.YcbcrImageArrays)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceYcbcrImageArraysFeatures l, in PhysicalDeviceYcbcrImageArraysFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.YcbcrImageArrays != r.YcbcrImageArrays)
			;
	}


	/// <summary>Creates a new PhysicalDeviceYcbcrImageArraysFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceYcbcrImageArraysFeatures value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PipelineCreationFeedback : IEquatable<PipelineCreationFeedback>
{
	public Vk.EXT.PipelineCreationFeedbackFlags Flags;
	public ulong Duration;
	public PipelineCreationFeedback(
		in Vk.EXT.PipelineCreationFeedbackFlags flags = default,
		ulong duration = default
	) {
		Flags = flags;
		Duration = duration;
	}


	public readonly override bool Equals(object? obj) => (obj is PipelineCreationFeedback o) && (this == o);
	readonly bool IEquatable<PipelineCreationFeedback>.Equals(PipelineCreationFeedback obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Flags.GetHashCode() ^ Duration.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PipelineCreationFeedback l, in PipelineCreationFeedback r)
	{
		return
			(l.Flags == r.Flags) && (l.Duration == r.Duration)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PipelineCreationFeedback l, in PipelineCreationFeedback r)
	{
		return
			(l.Flags != r.Flags) || (l.Duration != r.Duration)
			;
	}


	/// <summary>Creates a new PipelineCreationFeedback value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PipelineCreationFeedback value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PipelineCreationFeedbackCreateInfo : IEquatable<PipelineCreationFeedbackCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PipelineCreationFeedbackCreateInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.EXT.PipelineCreationFeedback* PipelineCreationFeedback;
	public uint PipelineStageCreationFeedbackCount;
	public Vk.EXT.PipelineCreationFeedback** PipelineStageCreationFeedbacks;
	public PipelineCreationFeedbackCreateInfo(
		in Vk.EXT.PipelineCreationFeedback* pipelineCreationFeedback = default,
		uint pipelineStageCreationFeedbackCount = default,
		in Vk.EXT.PipelineCreationFeedback** pipelineStageCreationFeedbacks = default
	) {
		sType = TYPE;
		pNext = null;
		PipelineCreationFeedback = pipelineCreationFeedback;
		PipelineStageCreationFeedbackCount = pipelineStageCreationFeedbackCount;
		PipelineStageCreationFeedbacks = pipelineStageCreationFeedbacks;
	}


	public readonly override bool Equals(object? obj) => (obj is PipelineCreationFeedbackCreateInfo o) && (this == o);
	readonly bool IEquatable<PipelineCreationFeedbackCreateInfo>.Equals(PipelineCreationFeedbackCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ((ulong)PipelineCreationFeedback).GetHashCode() ^ PipelineStageCreationFeedbackCount.GetHashCode()
			^ ((ulong)PipelineStageCreationFeedbacks).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PipelineCreationFeedbackCreateInfo l, in PipelineCreationFeedbackCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.PipelineCreationFeedback == r.PipelineCreationFeedback) && (l.PipelineStageCreationFeedbackCount == r.PipelineStageCreationFeedbackCount)
			&& (l.PipelineStageCreationFeedbacks == r.PipelineStageCreationFeedbacks)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PipelineCreationFeedbackCreateInfo l, in PipelineCreationFeedbackCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.PipelineCreationFeedback != r.PipelineCreationFeedback) || (l.PipelineStageCreationFeedbackCount != r.PipelineStageCreationFeedbackCount)
			|| (l.PipelineStageCreationFeedbacks != r.PipelineStageCreationFeedbacks)
			;
	}


	/// <summary>Creates a new PipelineCreationFeedbackCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PipelineCreationFeedbackCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SurfaceFullScreenExclusiveInfo : IEquatable<SurfaceFullScreenExclusiveInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.SurfaceFullScreenExclusiveInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.EXT.FullScreenExclusive FullScreenExclusive;
	public SurfaceFullScreenExclusiveInfo(
		in Vk.EXT.FullScreenExclusive fullScreenExclusive = default
	) {
		sType = TYPE;
		pNext = null;
		FullScreenExclusive = fullScreenExclusive;
	}


	public readonly override bool Equals(object? obj) => (obj is SurfaceFullScreenExclusiveInfo o) && (this == o);
	readonly bool IEquatable<SurfaceFullScreenExclusiveInfo>.Equals(SurfaceFullScreenExclusiveInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ FullScreenExclusive.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SurfaceFullScreenExclusiveInfo l, in SurfaceFullScreenExclusiveInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.FullScreenExclusive == r.FullScreenExclusive)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SurfaceFullScreenExclusiveInfo l, in SurfaceFullScreenExclusiveInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.FullScreenExclusive != r.FullScreenExclusive)
			;
	}


	/// <summary>Creates a new SurfaceFullScreenExclusiveInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SurfaceFullScreenExclusiveInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SurfaceFullScreenExclusiveWin32Info : IEquatable<SurfaceFullScreenExclusiveWin32Info>
{
	public const Vk.StructureType TYPE = Vk.StructureType.SurfaceFullScreenExclusiveWin32InfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public void* Hmonitor;
	public SurfaceFullScreenExclusiveWin32Info(
		void* hmonitor = default
	) {
		sType = TYPE;
		pNext = null;
		Hmonitor = hmonitor;
	}


	public readonly override bool Equals(object? obj) => (obj is SurfaceFullScreenExclusiveWin32Info o) && (this == o);
	readonly bool IEquatable<SurfaceFullScreenExclusiveWin32Info>.Equals(SurfaceFullScreenExclusiveWin32Info obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ((ulong)Hmonitor).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SurfaceFullScreenExclusiveWin32Info l, in SurfaceFullScreenExclusiveWin32Info r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Hmonitor == r.Hmonitor)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SurfaceFullScreenExclusiveWin32Info l, in SurfaceFullScreenExclusiveWin32Info r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Hmonitor != r.Hmonitor)
			;
	}


	/// <summary>Creates a new SurfaceFullScreenExclusiveWin32Info value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SurfaceFullScreenExclusiveWin32Info value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SurfaceCapabilitiesFullScreenExclusive : IEquatable<SurfaceCapabilitiesFullScreenExclusive>
{
	public const Vk.StructureType TYPE = Vk.StructureType.SurfaceCapabilitiesFullScreenExclusiveEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 FullScreenExclusiveSupported;
	public SurfaceCapabilitiesFullScreenExclusive(
		in Vk.Bool32 fullScreenExclusiveSupported = default
	) {
		sType = TYPE;
		pNext = null;
		FullScreenExclusiveSupported = fullScreenExclusiveSupported;
	}


	public readonly override bool Equals(object? obj) => (obj is SurfaceCapabilitiesFullScreenExclusive o) && (this == o);
	readonly bool IEquatable<SurfaceCapabilitiesFullScreenExclusive>.Equals(SurfaceCapabilitiesFullScreenExclusive obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ FullScreenExclusiveSupported.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SurfaceCapabilitiesFullScreenExclusive l, in SurfaceCapabilitiesFullScreenExclusive r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.FullScreenExclusiveSupported == r.FullScreenExclusiveSupported)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SurfaceCapabilitiesFullScreenExclusive l, in SurfaceCapabilitiesFullScreenExclusive r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.FullScreenExclusiveSupported != r.FullScreenExclusiveSupported)
			;
	}


	/// <summary>Creates a new SurfaceCapabilitiesFullScreenExclusive value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SurfaceCapabilitiesFullScreenExclusive value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct HeadlessSurfaceCreateInfo : IEquatable<HeadlessSurfaceCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.HeadlessSurfaceCreateInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.EXT.HeadlessSurfaceCreateFlags Flags;
	public HeadlessSurfaceCreateInfo(
		in Vk.EXT.HeadlessSurfaceCreateFlags flags = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
	}


	public readonly override bool Equals(object? obj) => (obj is HeadlessSurfaceCreateInfo o) && (this == o);
	readonly bool IEquatable<HeadlessSurfaceCreateInfo>.Equals(HeadlessSurfaceCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in HeadlessSurfaceCreateInfo l, in HeadlessSurfaceCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in HeadlessSurfaceCreateInfo l, in HeadlessSurfaceCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags)
			;
	}


	/// <summary>Creates a new HeadlessSurfaceCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out HeadlessSurfaceCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceIndexTypeUint8Features : IEquatable<PhysicalDeviceIndexTypeUint8Features>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceIndexTypeUint8FeaturesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 IndexTypeUint8;
	public PhysicalDeviceIndexTypeUint8Features(
		in Vk.Bool32 indexTypeUint8 = default
	) {
		sType = TYPE;
		pNext = null;
		IndexTypeUint8 = indexTypeUint8;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceIndexTypeUint8Features o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceIndexTypeUint8Features>.Equals(PhysicalDeviceIndexTypeUint8Features obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ IndexTypeUint8.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceIndexTypeUint8Features l, in PhysicalDeviceIndexTypeUint8Features r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.IndexTypeUint8 == r.IndexTypeUint8)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceIndexTypeUint8Features l, in PhysicalDeviceIndexTypeUint8Features r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.IndexTypeUint8 != r.IndexTypeUint8)
			;
	}


	/// <summary>Creates a new PhysicalDeviceIndexTypeUint8Features value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceIndexTypeUint8Features value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceFragmentShaderInterlockFeatures : IEquatable<PhysicalDeviceFragmentShaderInterlockFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceFragmentShaderInterlockFeaturesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 FragmentShaderSampleInterlock;
	public Vk.Bool32 FragmentShaderPixelInterlock;
	public Vk.Bool32 FragmentShaderShadingRateInterlock;
	public PhysicalDeviceFragmentShaderInterlockFeatures(
		in Vk.Bool32 fragmentShaderSampleInterlock = default,
		in Vk.Bool32 fragmentShaderPixelInterlock = default,
		in Vk.Bool32 fragmentShaderShadingRateInterlock = default
	) {
		sType = TYPE;
		pNext = null;
		FragmentShaderSampleInterlock = fragmentShaderSampleInterlock;
		FragmentShaderPixelInterlock = fragmentShaderPixelInterlock;
		FragmentShaderShadingRateInterlock = fragmentShaderShadingRateInterlock;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceFragmentShaderInterlockFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceFragmentShaderInterlockFeatures>.Equals(PhysicalDeviceFragmentShaderInterlockFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ FragmentShaderSampleInterlock.GetHashCode() ^ FragmentShaderPixelInterlock.GetHashCode()
			^ FragmentShaderShadingRateInterlock.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceFragmentShaderInterlockFeatures l, in PhysicalDeviceFragmentShaderInterlockFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.FragmentShaderSampleInterlock == r.FragmentShaderSampleInterlock) && (l.FragmentShaderPixelInterlock == r.FragmentShaderPixelInterlock)
			&& (l.FragmentShaderShadingRateInterlock == r.FragmentShaderShadingRateInterlock)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceFragmentShaderInterlockFeatures l, in PhysicalDeviceFragmentShaderInterlockFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.FragmentShaderSampleInterlock != r.FragmentShaderSampleInterlock) || (l.FragmentShaderPixelInterlock != r.FragmentShaderPixelInterlock)
			|| (l.FragmentShaderShadingRateInterlock != r.FragmentShaderShadingRateInterlock)
			;
	}


	/// <summary>Creates a new PhysicalDeviceFragmentShaderInterlockFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceFragmentShaderInterlockFeatures value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceShaderDemoteToHelperInvocationFeatures : IEquatable<PhysicalDeviceShaderDemoteToHelperInvocationFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 ShaderDemoteToHelperInvocation;
	public PhysicalDeviceShaderDemoteToHelperInvocationFeatures(
		in Vk.Bool32 shaderDemoteToHelperInvocation = default
	) {
		sType = TYPE;
		pNext = null;
		ShaderDemoteToHelperInvocation = shaderDemoteToHelperInvocation;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceShaderDemoteToHelperInvocationFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceShaderDemoteToHelperInvocationFeatures>.Equals(PhysicalDeviceShaderDemoteToHelperInvocationFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ShaderDemoteToHelperInvocation.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceShaderDemoteToHelperInvocationFeatures l, in PhysicalDeviceShaderDemoteToHelperInvocationFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ShaderDemoteToHelperInvocation == r.ShaderDemoteToHelperInvocation)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceShaderDemoteToHelperInvocationFeatures l, in PhysicalDeviceShaderDemoteToHelperInvocationFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ShaderDemoteToHelperInvocation != r.ShaderDemoteToHelperInvocation)
			;
	}


	/// <summary>Creates a new PhysicalDeviceShaderDemoteToHelperInvocationFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceShaderDemoteToHelperInvocationFeatures value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceTexelBufferAlignmentFeatures : IEquatable<PhysicalDeviceTexelBufferAlignmentFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceTexelBufferAlignmentFeaturesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 TexelBufferAlignment;
	public PhysicalDeviceTexelBufferAlignmentFeatures(
		in Vk.Bool32 texelBufferAlignment = default
	) {
		sType = TYPE;
		pNext = null;
		TexelBufferAlignment = texelBufferAlignment;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceTexelBufferAlignmentFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceTexelBufferAlignmentFeatures>.Equals(PhysicalDeviceTexelBufferAlignmentFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ TexelBufferAlignment.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceTexelBufferAlignmentFeatures l, in PhysicalDeviceTexelBufferAlignmentFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.TexelBufferAlignment == r.TexelBufferAlignment)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceTexelBufferAlignmentFeatures l, in PhysicalDeviceTexelBufferAlignmentFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.TexelBufferAlignment != r.TexelBufferAlignment)
			;
	}


	/// <summary>Creates a new PhysicalDeviceTexelBufferAlignmentFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceTexelBufferAlignmentFeatures value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceTexelBufferAlignmentProperties : IEquatable<PhysicalDeviceTexelBufferAlignmentProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceTexelBufferAlignmentPropertiesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.DeviceSize StorageTexelBufferOffsetAlignmentBytes;
	public Vk.Bool32 StorageTexelBufferOffsetSingleTexelAlignment;
	public Vk.DeviceSize UniformTexelBufferOffsetAlignmentBytes;
	public Vk.Bool32 UniformTexelBufferOffsetSingleTexelAlignment;
	public PhysicalDeviceTexelBufferAlignmentProperties(
		in Vk.DeviceSize storageTexelBufferOffsetAlignmentBytes = default,
		in Vk.Bool32 storageTexelBufferOffsetSingleTexelAlignment = default,
		in Vk.DeviceSize uniformTexelBufferOffsetAlignmentBytes = default,
		in Vk.Bool32 uniformTexelBufferOffsetSingleTexelAlignment = default
	) {
		sType = TYPE;
		pNext = null;
		StorageTexelBufferOffsetAlignmentBytes = storageTexelBufferOffsetAlignmentBytes;
		StorageTexelBufferOffsetSingleTexelAlignment = storageTexelBufferOffsetSingleTexelAlignment;
		UniformTexelBufferOffsetAlignmentBytes = uniformTexelBufferOffsetAlignmentBytes;
		UniformTexelBufferOffsetSingleTexelAlignment = uniformTexelBufferOffsetSingleTexelAlignment;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceTexelBufferAlignmentProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceTexelBufferAlignmentProperties>.Equals(PhysicalDeviceTexelBufferAlignmentProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ StorageTexelBufferOffsetAlignmentBytes.GetHashCode() ^ StorageTexelBufferOffsetSingleTexelAlignment.GetHashCode()
			^ UniformTexelBufferOffsetAlignmentBytes.GetHashCode() ^ UniformTexelBufferOffsetSingleTexelAlignment.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceTexelBufferAlignmentProperties l, in PhysicalDeviceTexelBufferAlignmentProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.StorageTexelBufferOffsetAlignmentBytes == r.StorageTexelBufferOffsetAlignmentBytes) && (l.StorageTexelBufferOffsetSingleTexelAlignment == r.StorageTexelBufferOffsetSingleTexelAlignment)
			&& (l.UniformTexelBufferOffsetAlignmentBytes == r.UniformTexelBufferOffsetAlignmentBytes) && (l.UniformTexelBufferOffsetSingleTexelAlignment == r.UniformTexelBufferOffsetSingleTexelAlignment)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceTexelBufferAlignmentProperties l, in PhysicalDeviceTexelBufferAlignmentProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.StorageTexelBufferOffsetAlignmentBytes != r.StorageTexelBufferOffsetAlignmentBytes) || (l.StorageTexelBufferOffsetSingleTexelAlignment != r.StorageTexelBufferOffsetSingleTexelAlignment)
			|| (l.UniformTexelBufferOffsetAlignmentBytes != r.UniformTexelBufferOffsetAlignmentBytes) || (l.UniformTexelBufferOffsetSingleTexelAlignment != r.UniformTexelBufferOffsetSingleTexelAlignment)
			;
	}


	/// <summary>Creates a new PhysicalDeviceTexelBufferAlignmentProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceTexelBufferAlignmentProperties value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceSubgroupSizeControlFeatures : IEquatable<PhysicalDeviceSubgroupSizeControlFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceSubgroupSizeControlFeaturesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 SubgroupSizeControl;
	public Vk.Bool32 ComputeFullSubgroups;
	public PhysicalDeviceSubgroupSizeControlFeatures(
		in Vk.Bool32 subgroupSizeControl = default,
		in Vk.Bool32 computeFullSubgroups = default
	) {
		sType = TYPE;
		pNext = null;
		SubgroupSizeControl = subgroupSizeControl;
		ComputeFullSubgroups = computeFullSubgroups;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceSubgroupSizeControlFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceSubgroupSizeControlFeatures>.Equals(PhysicalDeviceSubgroupSizeControlFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SubgroupSizeControl.GetHashCode() ^ ComputeFullSubgroups.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceSubgroupSizeControlFeatures l, in PhysicalDeviceSubgroupSizeControlFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SubgroupSizeControl == r.SubgroupSizeControl) && (l.ComputeFullSubgroups == r.ComputeFullSubgroups)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceSubgroupSizeControlFeatures l, in PhysicalDeviceSubgroupSizeControlFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SubgroupSizeControl != r.SubgroupSizeControl) || (l.ComputeFullSubgroups != r.ComputeFullSubgroups)
			;
	}


	/// <summary>Creates a new PhysicalDeviceSubgroupSizeControlFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceSubgroupSizeControlFeatures value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceSubgroupSizeControlProperties : IEquatable<PhysicalDeviceSubgroupSizeControlProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceSubgroupSizeControlPropertiesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public uint MinSubgroupSize;
	public uint MaxSubgroupSize;
	public uint MaxComputeWorkgroupSubgroups;
	public Vk.ShaderStageFlags RequiredSubgroupSizeStages;
	public PhysicalDeviceSubgroupSizeControlProperties(
		uint minSubgroupSize = default,
		uint maxSubgroupSize = default,
		uint maxComputeWorkgroupSubgroups = default,
		in Vk.ShaderStageFlags requiredSubgroupSizeStages = default
	) {
		sType = TYPE;
		pNext = null;
		MinSubgroupSize = minSubgroupSize;
		MaxSubgroupSize = maxSubgroupSize;
		MaxComputeWorkgroupSubgroups = maxComputeWorkgroupSubgroups;
		RequiredSubgroupSizeStages = requiredSubgroupSizeStages;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceSubgroupSizeControlProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceSubgroupSizeControlProperties>.Equals(PhysicalDeviceSubgroupSizeControlProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MinSubgroupSize.GetHashCode() ^ MaxSubgroupSize.GetHashCode()
			^ MaxComputeWorkgroupSubgroups.GetHashCode() ^ RequiredSubgroupSizeStages.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceSubgroupSizeControlProperties l, in PhysicalDeviceSubgroupSizeControlProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MinSubgroupSize == r.MinSubgroupSize) && (l.MaxSubgroupSize == r.MaxSubgroupSize)
			&& (l.MaxComputeWorkgroupSubgroups == r.MaxComputeWorkgroupSubgroups) && (l.RequiredSubgroupSizeStages == r.RequiredSubgroupSizeStages)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceSubgroupSizeControlProperties l, in PhysicalDeviceSubgroupSizeControlProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MinSubgroupSize != r.MinSubgroupSize) || (l.MaxSubgroupSize != r.MaxSubgroupSize)
			|| (l.MaxComputeWorkgroupSubgroups != r.MaxComputeWorkgroupSubgroups) || (l.RequiredSubgroupSizeStages != r.RequiredSubgroupSizeStages)
			;
	}


	/// <summary>Creates a new PhysicalDeviceSubgroupSizeControlProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceSubgroupSizeControlProperties value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PipelineShaderStageRequiredSubgroupSizeCreateInfo : IEquatable<PipelineShaderStageRequiredSubgroupSizeCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PipelineShaderStageRequiredSubgroupSizeCreateInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public uint RequiredSubgroupSize;
	public PipelineShaderStageRequiredSubgroupSizeCreateInfo(
		uint requiredSubgroupSize = default
	) {
		sType = TYPE;
		pNext = null;
		RequiredSubgroupSize = requiredSubgroupSize;
	}


	public readonly override bool Equals(object? obj) => (obj is PipelineShaderStageRequiredSubgroupSizeCreateInfo o) && (this == o);
	readonly bool IEquatable<PipelineShaderStageRequiredSubgroupSizeCreateInfo>.Equals(PipelineShaderStageRequiredSubgroupSizeCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ RequiredSubgroupSize.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PipelineShaderStageRequiredSubgroupSizeCreateInfo l, in PipelineShaderStageRequiredSubgroupSizeCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.RequiredSubgroupSize == r.RequiredSubgroupSize)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PipelineShaderStageRequiredSubgroupSizeCreateInfo l, in PipelineShaderStageRequiredSubgroupSizeCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.RequiredSubgroupSize != r.RequiredSubgroupSize)
			;
	}


	/// <summary>Creates a new PipelineShaderStageRequiredSubgroupSizeCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PipelineShaderStageRequiredSubgroupSizeCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceLineRasterizationFeatures : IEquatable<PhysicalDeviceLineRasterizationFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceLineRasterizationFeaturesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 RectangularLines;
	public Vk.Bool32 BresenhamLines;
	public Vk.Bool32 SmoothLines;
	public Vk.Bool32 StippledRectangularLines;
	public Vk.Bool32 StippledBresenhamLines;
	public Vk.Bool32 StippledSmoothLines;
	public PhysicalDeviceLineRasterizationFeatures(
		in Vk.Bool32 rectangularLines = default,
		in Vk.Bool32 bresenhamLines = default,
		in Vk.Bool32 smoothLines = default,
		in Vk.Bool32 stippledRectangularLines = default,
		in Vk.Bool32 stippledBresenhamLines = default,
		in Vk.Bool32 stippledSmoothLines = default
	) {
		sType = TYPE;
		pNext = null;
		RectangularLines = rectangularLines;
		BresenhamLines = bresenhamLines;
		SmoothLines = smoothLines;
		StippledRectangularLines = stippledRectangularLines;
		StippledBresenhamLines = stippledBresenhamLines;
		StippledSmoothLines = stippledSmoothLines;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceLineRasterizationFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceLineRasterizationFeatures>.Equals(PhysicalDeviceLineRasterizationFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ RectangularLines.GetHashCode() ^ BresenhamLines.GetHashCode()
			^ SmoothLines.GetHashCode() ^ StippledRectangularLines.GetHashCode() ^ StippledBresenhamLines.GetHashCode() ^ StippledSmoothLines.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceLineRasterizationFeatures l, in PhysicalDeviceLineRasterizationFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.RectangularLines == r.RectangularLines) && (l.BresenhamLines == r.BresenhamLines)
			&& (l.SmoothLines == r.SmoothLines) && (l.StippledRectangularLines == r.StippledRectangularLines) && (l.StippledBresenhamLines == r.StippledBresenhamLines) && (l.StippledSmoothLines == r.StippledSmoothLines)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceLineRasterizationFeatures l, in PhysicalDeviceLineRasterizationFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.RectangularLines != r.RectangularLines) || (l.BresenhamLines != r.BresenhamLines)
			|| (l.SmoothLines != r.SmoothLines) || (l.StippledRectangularLines != r.StippledRectangularLines) || (l.StippledBresenhamLines != r.StippledBresenhamLines) || (l.StippledSmoothLines != r.StippledSmoothLines)
			;
	}


	/// <summary>Creates a new PhysicalDeviceLineRasterizationFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceLineRasterizationFeatures value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceLineRasterizationProperties : IEquatable<PhysicalDeviceLineRasterizationProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceLineRasterizationPropertiesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public uint LineSubPixelPrecisionBits;
	public PhysicalDeviceLineRasterizationProperties(
		uint lineSubPixelPrecisionBits = default
	) {
		sType = TYPE;
		pNext = null;
		LineSubPixelPrecisionBits = lineSubPixelPrecisionBits;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceLineRasterizationProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceLineRasterizationProperties>.Equals(PhysicalDeviceLineRasterizationProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ LineSubPixelPrecisionBits.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceLineRasterizationProperties l, in PhysicalDeviceLineRasterizationProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.LineSubPixelPrecisionBits == r.LineSubPixelPrecisionBits)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceLineRasterizationProperties l, in PhysicalDeviceLineRasterizationProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.LineSubPixelPrecisionBits != r.LineSubPixelPrecisionBits)
			;
	}


	/// <summary>Creates a new PhysicalDeviceLineRasterizationProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceLineRasterizationProperties value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PipelineRasterizationLineStateCreateInfo : IEquatable<PipelineRasterizationLineStateCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PipelineRasterizationLineStateCreateInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.EXT.LineRasterizationMode LineRasterizationMode;
	public Vk.Bool32 StippledLineEnable;
	public uint LineStippleFactor;
	public ushort LineStipplePattern;
	public PipelineRasterizationLineStateCreateInfo(
		in Vk.EXT.LineRasterizationMode lineRasterizationMode = default,
		in Vk.Bool32 stippledLineEnable = default,
		uint lineStippleFactor = default,
		ushort lineStipplePattern = default
	) {
		sType = TYPE;
		pNext = null;
		LineRasterizationMode = lineRasterizationMode;
		StippledLineEnable = stippledLineEnable;
		LineStippleFactor = lineStippleFactor;
		LineStipplePattern = lineStipplePattern;
	}


	public readonly override bool Equals(object? obj) => (obj is PipelineRasterizationLineStateCreateInfo o) && (this == o);
	readonly bool IEquatable<PipelineRasterizationLineStateCreateInfo>.Equals(PipelineRasterizationLineStateCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ LineRasterizationMode.GetHashCode() ^ StippledLineEnable.GetHashCode()
			^ LineStippleFactor.GetHashCode() ^ LineStipplePattern.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PipelineRasterizationLineStateCreateInfo l, in PipelineRasterizationLineStateCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.LineRasterizationMode == r.LineRasterizationMode) && (l.StippledLineEnable == r.StippledLineEnable)
			&& (l.LineStippleFactor == r.LineStippleFactor) && (l.LineStipplePattern == r.LineStipplePattern)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PipelineRasterizationLineStateCreateInfo l, in PipelineRasterizationLineStateCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.LineRasterizationMode != r.LineRasterizationMode) || (l.StippledLineEnable != r.StippledLineEnable)
			|| (l.LineStippleFactor != r.LineStippleFactor) || (l.LineStipplePattern != r.LineStipplePattern)
			;
	}


	/// <summary>Creates a new PipelineRasterizationLineStateCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PipelineRasterizationLineStateCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDevicePipelineCreationCacheControlFeatures : IEquatable<PhysicalDevicePipelineCreationCacheControlFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDevicePipelineCreationCacheControlFeaturesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 PipelineCreationCacheControl;
	public PhysicalDevicePipelineCreationCacheControlFeatures(
		in Vk.Bool32 pipelineCreationCacheControl = default
	) {
		sType = TYPE;
		pNext = null;
		PipelineCreationCacheControl = pipelineCreationCacheControl;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDevicePipelineCreationCacheControlFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDevicePipelineCreationCacheControlFeatures>.Equals(PhysicalDevicePipelineCreationCacheControlFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ PipelineCreationCacheControl.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDevicePipelineCreationCacheControlFeatures l, in PhysicalDevicePipelineCreationCacheControlFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.PipelineCreationCacheControl == r.PipelineCreationCacheControl)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDevicePipelineCreationCacheControlFeatures l, in PhysicalDevicePipelineCreationCacheControlFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.PipelineCreationCacheControl != r.PipelineCreationCacheControl)
			;
	}


	/// <summary>Creates a new PhysicalDevicePipelineCreationCacheControlFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDevicePipelineCreationCacheControlFeatures value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceToolProperties : IEquatable<PhysicalDeviceToolProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceToolPropertiesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.FixedString Name;
	public Vk.FixedString Version;
	public Vk.EXT.ToolPurposeFlags Purposes;
	public Vk.FixedString Description;
	public Vk.FixedString Layer;
	public PhysicalDeviceToolProperties(
		in Vk.FixedString name = default,
		in Vk.FixedString version = default,
		in Vk.EXT.ToolPurposeFlags purposes = default,
		in Vk.FixedString description = default,
		in Vk.FixedString layer = default
	) {
		sType = TYPE;
		pNext = null;
		Name = name;
		Version = version;
		Purposes = purposes;
		Description = description;
		Layer = layer;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceToolProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceToolProperties>.Equals(PhysicalDeviceToolProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Name.GetHashCode() ^ Version.GetHashCode()
			^ Purposes.GetHashCode() ^ Description.GetHashCode() ^ Layer.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceToolProperties l, in PhysicalDeviceToolProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Name == r.Name) && (l.Version == r.Version)
			&& (l.Purposes == r.Purposes) && (l.Description == r.Description) && (l.Layer == r.Layer)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceToolProperties l, in PhysicalDeviceToolProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Name != r.Name) || (l.Version != r.Version)
			|| (l.Purposes != r.Purposes) || (l.Description != r.Description) || (l.Layer != r.Layer)
			;
	}


	/// <summary>Creates a new PhysicalDeviceToolProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceToolProperties value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SamplerCustomBorderColorCreateInfo : IEquatable<SamplerCustomBorderColorCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.SamplerCustomBorderColorCreateInfoEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.ClearColorValue CustomBorderColor;
	public Vk.Format Format;
	public SamplerCustomBorderColorCreateInfo(
		in Vk.ClearColorValue customBorderColor = default,
		in Vk.Format format = default
	) {
		sType = TYPE;
		pNext = null;
		CustomBorderColor = customBorderColor;
		Format = format;
	}


	public readonly override bool Equals(object? obj) => (obj is SamplerCustomBorderColorCreateInfo o) && (this == o);
	readonly bool IEquatable<SamplerCustomBorderColorCreateInfo>.Equals(SamplerCustomBorderColorCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ CustomBorderColor.GetHashCode() ^ Format.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SamplerCustomBorderColorCreateInfo l, in SamplerCustomBorderColorCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.CustomBorderColor == r.CustomBorderColor) && (l.Format == r.Format)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SamplerCustomBorderColorCreateInfo l, in SamplerCustomBorderColorCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.CustomBorderColor != r.CustomBorderColor) || (l.Format != r.Format)
			;
	}


	/// <summary>Creates a new SamplerCustomBorderColorCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SamplerCustomBorderColorCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceCustomBorderColorProperties : IEquatable<PhysicalDeviceCustomBorderColorProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceCustomBorderColorPropertiesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public uint MaxCustomBorderColorSamplers;
	public PhysicalDeviceCustomBorderColorProperties(
		uint maxCustomBorderColorSamplers = default
	) {
		sType = TYPE;
		pNext = null;
		MaxCustomBorderColorSamplers = maxCustomBorderColorSamplers;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceCustomBorderColorProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceCustomBorderColorProperties>.Equals(PhysicalDeviceCustomBorderColorProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MaxCustomBorderColorSamplers.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceCustomBorderColorProperties l, in PhysicalDeviceCustomBorderColorProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MaxCustomBorderColorSamplers == r.MaxCustomBorderColorSamplers)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceCustomBorderColorProperties l, in PhysicalDeviceCustomBorderColorProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MaxCustomBorderColorSamplers != r.MaxCustomBorderColorSamplers)
			;
	}


	/// <summary>Creates a new PhysicalDeviceCustomBorderColorProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceCustomBorderColorProperties value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceCustomBorderColorFeatures : IEquatable<PhysicalDeviceCustomBorderColorFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceCustomBorderColorFeaturesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 CustomBorderColors;
	public Vk.Bool32 CustomBorderColorWithoutFormat;
	public PhysicalDeviceCustomBorderColorFeatures(
		in Vk.Bool32 customBorderColors = default,
		in Vk.Bool32 customBorderColorWithoutFormat = default
	) {
		sType = TYPE;
		pNext = null;
		CustomBorderColors = customBorderColors;
		CustomBorderColorWithoutFormat = customBorderColorWithoutFormat;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceCustomBorderColorFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceCustomBorderColorFeatures>.Equals(PhysicalDeviceCustomBorderColorFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ CustomBorderColors.GetHashCode() ^ CustomBorderColorWithoutFormat.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceCustomBorderColorFeatures l, in PhysicalDeviceCustomBorderColorFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.CustomBorderColors == r.CustomBorderColors) && (l.CustomBorderColorWithoutFormat == r.CustomBorderColorWithoutFormat)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceCustomBorderColorFeatures l, in PhysicalDeviceCustomBorderColorFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.CustomBorderColors != r.CustomBorderColors) || (l.CustomBorderColorWithoutFormat != r.CustomBorderColorWithoutFormat)
			;
	}


	/// <summary>Creates a new PhysicalDeviceCustomBorderColorFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceCustomBorderColorFeatures value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceExtendedDynamicStateFeatures : IEquatable<PhysicalDeviceExtendedDynamicStateFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceExtendedDynamicStateFeaturesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 ExtendedDynamicState;
	public PhysicalDeviceExtendedDynamicStateFeatures(
		in Vk.Bool32 extendedDynamicState = default
	) {
		sType = TYPE;
		pNext = null;
		ExtendedDynamicState = extendedDynamicState;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceExtendedDynamicStateFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceExtendedDynamicStateFeatures>.Equals(PhysicalDeviceExtendedDynamicStateFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ExtendedDynamicState.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceExtendedDynamicStateFeatures l, in PhysicalDeviceExtendedDynamicStateFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ExtendedDynamicState == r.ExtendedDynamicState)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceExtendedDynamicStateFeatures l, in PhysicalDeviceExtendedDynamicStateFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ExtendedDynamicState != r.ExtendedDynamicState)
			;
	}


	/// <summary>Creates a new PhysicalDeviceExtendedDynamicStateFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceExtendedDynamicStateFeatures value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceRobustness2Features : IEquatable<PhysicalDeviceRobustness2Features>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceRobustness2FeaturesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 RobustBufferAccess2;
	public Vk.Bool32 RobustImageAccess2;
	public Vk.Bool32 NullDescriptor;
	public PhysicalDeviceRobustness2Features(
		in Vk.Bool32 robustBufferAccess2 = default,
		in Vk.Bool32 robustImageAccess2 = default,
		in Vk.Bool32 nullDescriptor = default
	) {
		sType = TYPE;
		pNext = null;
		RobustBufferAccess2 = robustBufferAccess2;
		RobustImageAccess2 = robustImageAccess2;
		NullDescriptor = nullDescriptor;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceRobustness2Features o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceRobustness2Features>.Equals(PhysicalDeviceRobustness2Features obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ RobustBufferAccess2.GetHashCode() ^ RobustImageAccess2.GetHashCode()
			^ NullDescriptor.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceRobustness2Features l, in PhysicalDeviceRobustness2Features r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.RobustBufferAccess2 == r.RobustBufferAccess2) && (l.RobustImageAccess2 == r.RobustImageAccess2)
			&& (l.NullDescriptor == r.NullDescriptor)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceRobustness2Features l, in PhysicalDeviceRobustness2Features r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.RobustBufferAccess2 != r.RobustBufferAccess2) || (l.RobustImageAccess2 != r.RobustImageAccess2)
			|| (l.NullDescriptor != r.NullDescriptor)
			;
	}


	/// <summary>Creates a new PhysicalDeviceRobustness2Features value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceRobustness2Features value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceRobustness2Properties : IEquatable<PhysicalDeviceRobustness2Properties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceRobustness2PropertiesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.DeviceSize RobustStorageBufferAccessSizeAlignment;
	public Vk.DeviceSize RobustUniformBufferAccessSizeAlignment;
	public PhysicalDeviceRobustness2Properties(
		in Vk.DeviceSize robustStorageBufferAccessSizeAlignment = default,
		in Vk.DeviceSize robustUniformBufferAccessSizeAlignment = default
	) {
		sType = TYPE;
		pNext = null;
		RobustStorageBufferAccessSizeAlignment = robustStorageBufferAccessSizeAlignment;
		RobustUniformBufferAccessSizeAlignment = robustUniformBufferAccessSizeAlignment;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceRobustness2Properties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceRobustness2Properties>.Equals(PhysicalDeviceRobustness2Properties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ RobustStorageBufferAccessSizeAlignment.GetHashCode() ^ RobustUniformBufferAccessSizeAlignment.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceRobustness2Properties l, in PhysicalDeviceRobustness2Properties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.RobustStorageBufferAccessSizeAlignment == r.RobustStorageBufferAccessSizeAlignment) && (l.RobustUniformBufferAccessSizeAlignment == r.RobustUniformBufferAccessSizeAlignment)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceRobustness2Properties l, in PhysicalDeviceRobustness2Properties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.RobustStorageBufferAccessSizeAlignment != r.RobustStorageBufferAccessSizeAlignment) || (l.RobustUniformBufferAccessSizeAlignment != r.RobustUniformBufferAccessSizeAlignment)
			;
	}


	/// <summary>Creates a new PhysicalDeviceRobustness2Properties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceRobustness2Properties value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceImageRobustnessFeatures : IEquatable<PhysicalDeviceImageRobustnessFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceImageRobustnessFeaturesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 RobustImageAccess;
	public PhysicalDeviceImageRobustnessFeatures(
		in Vk.Bool32 robustImageAccess = default
	) {
		sType = TYPE;
		pNext = null;
		RobustImageAccess = robustImageAccess;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceImageRobustnessFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceImageRobustnessFeatures>.Equals(PhysicalDeviceImageRobustnessFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ RobustImageAccess.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceImageRobustnessFeatures l, in PhysicalDeviceImageRobustnessFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.RobustImageAccess == r.RobustImageAccess)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceImageRobustnessFeatures l, in PhysicalDeviceImageRobustnessFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.RobustImageAccess != r.RobustImageAccess)
			;
	}


	/// <summary>Creates a new PhysicalDeviceImageRobustnessFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceImageRobustnessFeatures value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDevice4444FormatsFeatures : IEquatable<PhysicalDevice4444FormatsFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDevice4444FormatsFeaturesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 FormatA4R4G4B4;
	public Vk.Bool32 FormatA4B4G4R4;
	public PhysicalDevice4444FormatsFeatures(
		in Vk.Bool32 formatA4R4G4B4 = default,
		in Vk.Bool32 formatA4B4G4R4 = default
	) {
		sType = TYPE;
		pNext = null;
		FormatA4R4G4B4 = formatA4R4G4B4;
		FormatA4B4G4R4 = formatA4B4G4R4;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDevice4444FormatsFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDevice4444FormatsFeatures>.Equals(PhysicalDevice4444FormatsFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ FormatA4R4G4B4.GetHashCode() ^ FormatA4B4G4R4.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDevice4444FormatsFeatures l, in PhysicalDevice4444FormatsFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.FormatA4R4G4B4 == r.FormatA4R4G4B4) && (l.FormatA4B4G4R4 == r.FormatA4B4G4R4)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDevice4444FormatsFeatures l, in PhysicalDevice4444FormatsFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.FormatA4R4G4B4 != r.FormatA4R4G4B4) || (l.FormatA4B4G4R4 != r.FormatA4B4G4R4)
			;
	}


	/// <summary>Creates a new PhysicalDevice4444FormatsFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDevice4444FormatsFeatures value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceShaderImageAtomicInt64Features : IEquatable<PhysicalDeviceShaderImageAtomicInt64Features>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceShaderImageAtomicInt64FeaturesEXT;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 ShaderImageInt64Atomics;
	public Vk.Bool32 SparseImageInt64Atomics;
	public PhysicalDeviceShaderImageAtomicInt64Features(
		in Vk.Bool32 shaderImageInt64Atomics = default,
		in Vk.Bool32 sparseImageInt64Atomics = default
	) {
		sType = TYPE;
		pNext = null;
		ShaderImageInt64Atomics = shaderImageInt64Atomics;
		SparseImageInt64Atomics = sparseImageInt64Atomics;
	}


	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceShaderImageAtomicInt64Features o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceShaderImageAtomicInt64Features>.Equals(PhysicalDeviceShaderImageAtomicInt64Features obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ShaderImageInt64Atomics.GetHashCode() ^ SparseImageInt64Atomics.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceShaderImageAtomicInt64Features l, in PhysicalDeviceShaderImageAtomicInt64Features r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ShaderImageInt64Atomics == r.ShaderImageInt64Atomics) && (l.SparseImageInt64Atomics == r.SparseImageInt64Atomics)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceShaderImageAtomicInt64Features l, in PhysicalDeviceShaderImageAtomicInt64Features r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ShaderImageInt64Atomics != r.ShaderImageInt64Atomics) || (l.SparseImageInt64Atomics != r.SparseImageInt64Atomics)
			;
	}


	/// <summary>Creates a new PhysicalDeviceShaderImageAtomicInt64Features value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceShaderImageAtomicInt64Features value) => value = new() { sType = TYPE };
}

} // namespace Vk.EXT
