/*
 * MIT License - Copyright(c) 2020 Sean Moss
 * This file is subject to the terms and conditions of the MIT License, the text of which can be found in the 'LICENSE'
 * file at the root of this repository, or online at<https://opensource.org/licenses/MIT>.
 */

/// This file was generated by VVKGen. Edits to this file will be lost on next generation.

using System;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;


namespace Vk.EXT
{

public unsafe partial class ValidationCache : IHandleType<ValidationCache>
{
	public static readonly ValidationCache Null = new(Device.Null, Vk.Handle<ValidationCache>.Null);

	public readonly Vk.Device Parent;
	public readonly Vk.DeviceFunctionTable Functions;
	public readonly Vk.Instance Instance;
	public readonly Vk.Device Device;
	public readonly Handle<ValidationCache> Handle;
	public bool IsValid => Handle.IsValid;

	public ValidationCache(in Vk.Device parent, Vk.Handle<ValidationCache> handle)
	{
		Parent = parent;
		Functions = parent.Functions;
		Instance = parent.Instance;
		Device = parent;
		Handle = handle;
	}

	public override int GetHashCode() => Handle.GetHashCode();
	public override string? ToString() => $"[ValidationCache 0x{(ulong)Handle:X16}]";
	public override bool Equals(object? o) => (o is ValidationCache t) && (t.Handle == Handle);
	bool IEquatable<ValidationCache>.Equals(ValidationCache? other) => (other?.Handle ?? new()) == Handle;

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static implicit operator Vk.Handle<ValidationCache> (ValidationCache? handle) => handle?.Handle ?? new();
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (ValidationCache? l, ValidationCache? r) => (l?.Handle ?? new()) == (r?.Handle ?? new());
	public static bool operator != (ValidationCache? l, ValidationCache? r) => (l?.Handle ?? new()) == (r?.Handle ?? new());
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static implicit operator bool (ValidationCache? handle) => handle?.Handle.IsValid ?? false;

	/// <summary>vkDestroyValidationCacheEXT</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void DestroyValidationCacheEXT(Vk.AllocationCallbacks* pAllocator)
	{
		if (Functions.vkDestroyValidationCacheEXT == null) throw new Vk.Extras.FunctionNotLoadedException("vkDestroyValidationCacheEXT");
		Functions.vkDestroyValidationCacheEXT(Device.Handle, Handle, pAllocator);
	}

	/// <summary>vkDestroyValidationCacheEXT</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void DestroyValidationCacheEXT(in Vk.AllocationCallbacks allocator)
	{
		if (Functions.vkDestroyValidationCacheEXT == null) throw new Vk.Extras.FunctionNotLoadedException("vkDestroyValidationCacheEXT");
		Functions.DestroyValidationCacheEXT(Device.Handle, Handle, allocator);
	}

	/// <summary>vkGetValidationCacheDataEXT</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Vk.Result GetValidationCacheDataEXT(ulong* pDataSize, void* pData)
	{
		if (Functions.vkGetValidationCacheDataEXT == null) throw new Vk.Extras.FunctionNotLoadedException("vkGetValidationCacheDataEXT");
		return Functions.vkGetValidationCacheDataEXT(Device.Handle, Handle, pDataSize, pData);
	}

	/// <summary>vkGetValidationCacheDataEXT</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Vk.Result GetValidationCacheDataEXT(out ulong dataSize, void* pData)
	{
		if (Functions.vkGetValidationCacheDataEXT == null) throw new Vk.Extras.FunctionNotLoadedException("vkGetValidationCacheDataEXT");
		return Functions.GetValidationCacheDataEXT(Device.Handle, Handle, out dataSize, pData);
	}

	/// <summary>vkMergeValidationCachesEXT</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Vk.Result MergeValidationCachesEXT(uint srcCacheCount, Vk.Handle<Vk.EXT.ValidationCache>* pSrcCaches)
	{
		if (Functions.vkMergeValidationCachesEXT == null) throw new Vk.Extras.FunctionNotLoadedException("vkMergeValidationCachesEXT");
		return Functions.vkMergeValidationCachesEXT(Device.Handle, Handle, srcCacheCount, pSrcCaches);
	}

	/// <summary>vkMergeValidationCachesEXT</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Vk.Result MergeValidationCachesEXT(in ReadOnlySpan<Vk.Handle<Vk.EXT.ValidationCache>> srcCaches)
	{
		if (Functions.vkMergeValidationCachesEXT == null) throw new Vk.Extras.FunctionNotLoadedException("vkMergeValidationCachesEXT");
		return Functions.MergeValidationCachesEXT(Device.Handle, Handle, srcCaches);
	}

}

public unsafe partial class PrivateDataSlot : IHandleType<PrivateDataSlot>
{
	public static readonly PrivateDataSlot Null = new(Device.Null, Vk.Handle<PrivateDataSlot>.Null);

	public readonly Vk.Device Parent;
	public readonly Vk.DeviceFunctionTable Functions;
	public readonly Vk.Instance Instance;
	public readonly Vk.Device Device;
	public readonly Handle<PrivateDataSlot> Handle;
	public bool IsValid => Handle.IsValid;

	public PrivateDataSlot(in Vk.Device parent, Vk.Handle<PrivateDataSlot> handle)
	{
		Parent = parent;
		Functions = parent.Functions;
		Instance = parent.Instance;
		Device = parent;
		Handle = handle;
	}

	public override int GetHashCode() => Handle.GetHashCode();
	public override string? ToString() => $"[PrivateDataSlot 0x{(ulong)Handle:X16}]";
	public override bool Equals(object? o) => (o is PrivateDataSlot t) && (t.Handle == Handle);
	bool IEquatable<PrivateDataSlot>.Equals(PrivateDataSlot? other) => (other?.Handle ?? new()) == Handle;

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static implicit operator Vk.Handle<PrivateDataSlot> (PrivateDataSlot? handle) => handle?.Handle ?? new();
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (PrivateDataSlot? l, PrivateDataSlot? r) => (l?.Handle ?? new()) == (r?.Handle ?? new());
	public static bool operator != (PrivateDataSlot? l, PrivateDataSlot? r) => (l?.Handle ?? new()) == (r?.Handle ?? new());
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static implicit operator bool (PrivateDataSlot? handle) => handle?.Handle.IsValid ?? false;

	/// <summary>vkDestroyPrivateDataSlotEXT</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void DestroyPrivateDataSlotEXT(Vk.AllocationCallbacks* pAllocator)
	{
		if (Functions.vkDestroyPrivateDataSlotEXT == null) throw new Vk.Extras.FunctionNotLoadedException("vkDestroyPrivateDataSlotEXT");
		Functions.vkDestroyPrivateDataSlotEXT(Device.Handle, Handle, pAllocator);
	}

	/// <summary>vkDestroyPrivateDataSlotEXT</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void DestroyPrivateDataSlotEXT(in Vk.AllocationCallbacks allocator)
	{
		if (Functions.vkDestroyPrivateDataSlotEXT == null) throw new Vk.Extras.FunctionNotLoadedException("vkDestroyPrivateDataSlotEXT");
		Functions.DestroyPrivateDataSlotEXT(Device.Handle, Handle, allocator);
	}

}

public unsafe partial class DebugReportCallback : IHandleType<DebugReportCallback>
{
	public static readonly DebugReportCallback Null = new(Instance.Null, Vk.Handle<DebugReportCallback>.Null);

	public readonly Vk.Instance Parent;
	public readonly Vk.InstanceFunctionTable Functions;
	public readonly Vk.Instance Instance;
	public readonly Handle<DebugReportCallback> Handle;
	public bool IsValid => Handle.IsValid;

	public DebugReportCallback(in Vk.Instance parent, Vk.Handle<DebugReportCallback> handle)
	{
		Parent = parent;
		Functions = parent.Functions;
		Instance = parent;
		Handle = handle;
	}

	public override int GetHashCode() => Handle.GetHashCode();
	public override string? ToString() => $"[DebugReportCallback 0x{(ulong)Handle:X16}]";
	public override bool Equals(object? o) => (o is DebugReportCallback t) && (t.Handle == Handle);
	bool IEquatable<DebugReportCallback>.Equals(DebugReportCallback? other) => (other?.Handle ?? new()) == Handle;

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static implicit operator Vk.Handle<DebugReportCallback> (DebugReportCallback? handle) => handle?.Handle ?? new();
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (DebugReportCallback? l, DebugReportCallback? r) => (l?.Handle ?? new()) == (r?.Handle ?? new());
	public static bool operator != (DebugReportCallback? l, DebugReportCallback? r) => (l?.Handle ?? new()) == (r?.Handle ?? new());
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static implicit operator bool (DebugReportCallback? handle) => handle?.Handle.IsValid ?? false;

	/// <summary>vkDestroyDebugReportCallbackEXT</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void DestroyDebugReportCallbackEXT(Vk.AllocationCallbacks* pAllocator)
	{
		if (Functions.vkDestroyDebugReportCallbackEXT == null) throw new Vk.Extras.FunctionNotLoadedException("vkDestroyDebugReportCallbackEXT");
		Functions.vkDestroyDebugReportCallbackEXT(Instance.Handle, Handle, pAllocator);
	}

	/// <summary>vkDestroyDebugReportCallbackEXT</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void DestroyDebugReportCallbackEXT(in Vk.AllocationCallbacks allocator)
	{
		if (Functions.vkDestroyDebugReportCallbackEXT == null) throw new Vk.Extras.FunctionNotLoadedException("vkDestroyDebugReportCallbackEXT");
		Functions.DestroyDebugReportCallbackEXT(Instance.Handle, Handle, allocator);
	}

}

public unsafe partial class DebugUtilsMessenger : IHandleType<DebugUtilsMessenger>
{
	public static readonly DebugUtilsMessenger Null = new(Instance.Null, Vk.Handle<DebugUtilsMessenger>.Null);

	public readonly Vk.Instance Parent;
	public readonly Vk.InstanceFunctionTable Functions;
	public readonly Vk.Instance Instance;
	public readonly Handle<DebugUtilsMessenger> Handle;
	public bool IsValid => Handle.IsValid;

	public DebugUtilsMessenger(in Vk.Instance parent, Vk.Handle<DebugUtilsMessenger> handle)
	{
		Parent = parent;
		Functions = parent.Functions;
		Instance = parent;
		Handle = handle;
	}

	public override int GetHashCode() => Handle.GetHashCode();
	public override string? ToString() => $"[DebugUtilsMessenger 0x{(ulong)Handle:X16}]";
	public override bool Equals(object? o) => (o is DebugUtilsMessenger t) && (t.Handle == Handle);
	bool IEquatable<DebugUtilsMessenger>.Equals(DebugUtilsMessenger? other) => (other?.Handle ?? new()) == Handle;

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static implicit operator Vk.Handle<DebugUtilsMessenger> (DebugUtilsMessenger? handle) => handle?.Handle ?? new();
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (DebugUtilsMessenger? l, DebugUtilsMessenger? r) => (l?.Handle ?? new()) == (r?.Handle ?? new());
	public static bool operator != (DebugUtilsMessenger? l, DebugUtilsMessenger? r) => (l?.Handle ?? new()) == (r?.Handle ?? new());
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static implicit operator bool (DebugUtilsMessenger? handle) => handle?.Handle.IsValid ?? false;

	/// <summary>vkDestroyDebugUtilsMessengerEXT</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void DestroyDebugUtilsMessengerEXT(Vk.AllocationCallbacks* pAllocator)
	{
		if (Functions.vkDestroyDebugUtilsMessengerEXT == null) throw new Vk.Extras.FunctionNotLoadedException("vkDestroyDebugUtilsMessengerEXT");
		Functions.vkDestroyDebugUtilsMessengerEXT(Instance.Handle, Handle, pAllocator);
	}

	/// <summary>vkDestroyDebugUtilsMessengerEXT</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void DestroyDebugUtilsMessengerEXT(in Vk.AllocationCallbacks allocator)
	{
		if (Functions.vkDestroyDebugUtilsMessengerEXT == null) throw new Vk.Extras.FunctionNotLoadedException("vkDestroyDebugUtilsMessengerEXT");
		Functions.DestroyDebugUtilsMessengerEXT(Instance.Handle, Handle, allocator);
	}

}

} // namespace Vk.EXT
