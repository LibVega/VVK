/*
 * MIT License - Copyright(c) 2020 Sean Moss
 * This file is subject to the terms and conditions of the MIT License, the text of which can be found in the 'LICENSE'
 * file at the root of this repository, or online at<https://opensource.org/licenses/MIT>.
 */

/// This file was generated by VVKGen. Edits to this file will be lost on next generation.

using System;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;


namespace Vk.EXT
{

public unsafe partial struct ValidationCache : IHandleType<ValidationCache>
{
	public static readonly ValidationCache Null = new();

	private readonly Handle<ValidationCache> _handle;
	readonly Handle<ValidationCache> IHandleType<ValidationCache>.Handle => _handle;

	public override readonly int GetHashCode() => _handle.GetHashCode();
	public override readonly string? ToString() => $"[ValidationCache 0x{(ulong)_handle:X16}]";
	public override readonly bool Equals(object? o) => (o is ValidationCache t) && (t._handle == _handle);
	readonly bool IEquatable<ValidationCache>.Equals(ValidationCache other) => other._handle == _handle;

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static implicit operator Vk.Handle<ValidationCache> (in ValidationCache handle) => handle._handle;
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (ValidationCache l, ValidationCache r) => l._handle == r._handle;
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (ValidationCache l, ValidationCache r) => l._handle != r._handle;
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static implicit operator bool (ValidationCache handle) => handle._handle.IsValid;
}

public unsafe partial struct PrivateDataSlot : IHandleType<PrivateDataSlot>
{
	public static readonly PrivateDataSlot Null = new();

	private readonly Handle<PrivateDataSlot> _handle;
	readonly Handle<PrivateDataSlot> IHandleType<PrivateDataSlot>.Handle => _handle;

	public override readonly int GetHashCode() => _handle.GetHashCode();
	public override readonly string? ToString() => $"[PrivateDataSlot 0x{(ulong)_handle:X16}]";
	public override readonly bool Equals(object? o) => (o is PrivateDataSlot t) && (t._handle == _handle);
	readonly bool IEquatable<PrivateDataSlot>.Equals(PrivateDataSlot other) => other._handle == _handle;

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static implicit operator Vk.Handle<PrivateDataSlot> (in PrivateDataSlot handle) => handle._handle;
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (PrivateDataSlot l, PrivateDataSlot r) => l._handle == r._handle;
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (PrivateDataSlot l, PrivateDataSlot r) => l._handle != r._handle;
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static implicit operator bool (PrivateDataSlot handle) => handle._handle.IsValid;
}

public unsafe partial struct DebugReportCallback : IHandleType<DebugReportCallback>
{
	public static readonly DebugReportCallback Null = new();

	private readonly Handle<DebugReportCallback> _handle;
	readonly Handle<DebugReportCallback> IHandleType<DebugReportCallback>.Handle => _handle;

	public override readonly int GetHashCode() => _handle.GetHashCode();
	public override readonly string? ToString() => $"[DebugReportCallback 0x{(ulong)_handle:X16}]";
	public override readonly bool Equals(object? o) => (o is DebugReportCallback t) && (t._handle == _handle);
	readonly bool IEquatable<DebugReportCallback>.Equals(DebugReportCallback other) => other._handle == _handle;

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static implicit operator Vk.Handle<DebugReportCallback> (in DebugReportCallback handle) => handle._handle;
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (DebugReportCallback l, DebugReportCallback r) => l._handle == r._handle;
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (DebugReportCallback l, DebugReportCallback r) => l._handle != r._handle;
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static implicit operator bool (DebugReportCallback handle) => handle._handle.IsValid;
}

public unsafe partial struct DebugUtilsMessenger : IHandleType<DebugUtilsMessenger>
{
	public static readonly DebugUtilsMessenger Null = new();

	private readonly Handle<DebugUtilsMessenger> _handle;
	readonly Handle<DebugUtilsMessenger> IHandleType<DebugUtilsMessenger>.Handle => _handle;

	public override readonly int GetHashCode() => _handle.GetHashCode();
	public override readonly string? ToString() => $"[DebugUtilsMessenger 0x{(ulong)_handle:X16}]";
	public override readonly bool Equals(object? o) => (o is DebugUtilsMessenger t) && (t._handle == _handle);
	readonly bool IEquatable<DebugUtilsMessenger>.Equals(DebugUtilsMessenger other) => other._handle == _handle;

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static implicit operator Vk.Handle<DebugUtilsMessenger> (in DebugUtilsMessenger handle) => handle._handle;
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator == (DebugUtilsMessenger l, DebugUtilsMessenger r) => l._handle == r._handle;
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator != (DebugUtilsMessenger l, DebugUtilsMessenger r) => l._handle != r._handle;
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static implicit operator bool (DebugUtilsMessenger handle) => handle._handle.IsValid;
}

} // namespace Vk.EXT
