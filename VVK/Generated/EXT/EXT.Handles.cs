/*
 * MIT License - Copyright(c) 2020 Sean Moss
 * This file is subject to the terms and conditions of the MIT License, the text of which can be found in the 'LICENSE'
 * file at the root of this repository, or online at<https://opensource.org/licenses/MIT>.
 */

/// This file was generated by VVKGen. Edits to this file will be lost on next generation.

using System;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;


namespace Vk.EXT
{

[StructLayout(LayoutKind.Explicit, Size = 8)]
public unsafe partial struct ValidationCache : IEquatable<ValidationCache>
{
	public static readonly ValidationCache Null = new(0);

	[FieldOffset(0)] public readonly void* Handle;
	public readonly ulong LongHandle => (ulong)Handle;

	public ValidationCache(void* handle) => Handle = handle;
	public ValidationCache(ulong handle) => Handle = (void*)handle;
	public ValidationCache(IntPtr handle) => Handle = handle.ToPointer();

	readonly bool IEquatable<ValidationCache>.Equals(ValidationCache other) => other.Handle == Handle;
	public readonly override bool Equals(object? other) => (other is ValidationCache handle) && handle.Handle == Handle;
	public readonly override int GetHashCode() => (int)(LongHandle >> 32) ^ (int)(LongHandle & 0xFFFFFFFF);
	public readonly override string ToString() => $"[ValidationCache 0x{LongHandle:X16}]";

	public static bool operator == (ValidationCache l, ValidationCache r) => l.Handle == r.Handle;
	public static bool operator != (ValidationCache l, ValidationCache r) => l.Handle != r.Handle;
	public static implicit operator bool (ValidationCache handle) => handle.Handle != null;
}

[StructLayout(LayoutKind.Explicit, Size = 8)]
public unsafe partial struct PrivateDataSlot : IEquatable<PrivateDataSlot>
{
	public static readonly PrivateDataSlot Null = new(0);

	[FieldOffset(0)] public readonly void* Handle;
	public readonly ulong LongHandle => (ulong)Handle;

	public PrivateDataSlot(void* handle) => Handle = handle;
	public PrivateDataSlot(ulong handle) => Handle = (void*)handle;
	public PrivateDataSlot(IntPtr handle) => Handle = handle.ToPointer();

	readonly bool IEquatable<PrivateDataSlot>.Equals(PrivateDataSlot other) => other.Handle == Handle;
	public readonly override bool Equals(object? other) => (other is PrivateDataSlot handle) && handle.Handle == Handle;
	public readonly override int GetHashCode() => (int)(LongHandle >> 32) ^ (int)(LongHandle & 0xFFFFFFFF);
	public readonly override string ToString() => $"[PrivateDataSlot 0x{LongHandle:X16}]";

	public static bool operator == (PrivateDataSlot l, PrivateDataSlot r) => l.Handle == r.Handle;
	public static bool operator != (PrivateDataSlot l, PrivateDataSlot r) => l.Handle != r.Handle;
	public static implicit operator bool (PrivateDataSlot handle) => handle.Handle != null;
}

[StructLayout(LayoutKind.Explicit, Size = 8)]
public unsafe partial struct DebugReportCallback : IEquatable<DebugReportCallback>
{
	public static readonly DebugReportCallback Null = new(0);

	[FieldOffset(0)] public readonly void* Handle;
	public readonly ulong LongHandle => (ulong)Handle;

	public DebugReportCallback(void* handle) => Handle = handle;
	public DebugReportCallback(ulong handle) => Handle = (void*)handle;
	public DebugReportCallback(IntPtr handle) => Handle = handle.ToPointer();

	readonly bool IEquatable<DebugReportCallback>.Equals(DebugReportCallback other) => other.Handle == Handle;
	public readonly override bool Equals(object? other) => (other is DebugReportCallback handle) && handle.Handle == Handle;
	public readonly override int GetHashCode() => (int)(LongHandle >> 32) ^ (int)(LongHandle & 0xFFFFFFFF);
	public readonly override string ToString() => $"[DebugReportCallback 0x{LongHandle:X16}]";

	public static bool operator == (DebugReportCallback l, DebugReportCallback r) => l.Handle == r.Handle;
	public static bool operator != (DebugReportCallback l, DebugReportCallback r) => l.Handle != r.Handle;
	public static implicit operator bool (DebugReportCallback handle) => handle.Handle != null;
}

[StructLayout(LayoutKind.Explicit, Size = 8)]
public unsafe partial struct DebugUtilsMessenger : IEquatable<DebugUtilsMessenger>
{
	public static readonly DebugUtilsMessenger Null = new(0);

	[FieldOffset(0)] public readonly void* Handle;
	public readonly ulong LongHandle => (ulong)Handle;

	public DebugUtilsMessenger(void* handle) => Handle = handle;
	public DebugUtilsMessenger(ulong handle) => Handle = (void*)handle;
	public DebugUtilsMessenger(IntPtr handle) => Handle = handle.ToPointer();

	readonly bool IEquatable<DebugUtilsMessenger>.Equals(DebugUtilsMessenger other) => other.Handle == Handle;
	public readonly override bool Equals(object? other) => (other is DebugUtilsMessenger handle) && handle.Handle == Handle;
	public readonly override int GetHashCode() => (int)(LongHandle >> 32) ^ (int)(LongHandle & 0xFFFFFFFF);
	public readonly override string ToString() => $"[DebugUtilsMessenger 0x{LongHandle:X16}]";

	public static bool operator == (DebugUtilsMessenger l, DebugUtilsMessenger r) => l.Handle == r.Handle;
	public static bool operator != (DebugUtilsMessenger l, DebugUtilsMessenger r) => l.Handle != r.Handle;
	public static implicit operator bool (DebugUtilsMessenger handle) => handle.Handle != null;
}

} // namespace Vk.EXT
