/*
 * MIT License - Copyright(c) 2020 Sean Moss
 * This file is subject to the terms and conditions of the MIT License, the text of which can be found in the 'LICENSE'
 * file at the root of this repository, or online at <https://opensource.org/licenses/MIT>.
 */

/// This file was generated by VVKGen. Edits to this file will be lost on next generation.

using System;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;

namespace Vulkan
{

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDirectFBSurfaceCreateInfoEXT : IEquatable<VkDirectFBSurfaceCreateInfoEXT>
{
	public const VkStructureType TYPE = VkStructureType.DirectfbSurfaceCreateInfoExt;

	public VkStructureType sType;
	public void* pNext;
	public VkDirectFBSurfaceCreateFlagsEXT Flags;
	public void* Dfb;
	public void* Surface;

	public VkDirectFBSurfaceCreateInfoEXT(
		VkDirectFBSurfaceCreateFlagsEXT flags = default,
		void* dfb = default,
		void* surface = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		Dfb = dfb;
		Surface = surface;
	}

	public readonly override bool Equals(object? o) => (o is VkDirectFBSurfaceCreateInfoEXT s) && (this == s);
	readonly bool IEquatable<VkDirectFBSurfaceCreateInfoEXT>.Equals(VkDirectFBSurfaceCreateInfoEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ ((ulong)Dfb).GetHashCode()
			^ ((ulong)Surface).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDirectFBSurfaceCreateInfoEXT l, in VkDirectFBSurfaceCreateInfoEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.Dfb == r.Dfb)
			&& (l.Surface == r.Surface)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDirectFBSurfaceCreateInfoEXT l, in VkDirectFBSurfaceCreateInfoEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.Dfb != r.Dfb)
			|| (l.Surface != r.Surface)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDirectFBSurfaceCreateInfoEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDebugReportCallbackCreateInfoEXT : IEquatable<VkDebugReportCallbackCreateInfoEXT>
{
	public const VkStructureType TYPE = VkStructureType.DebugReportCallbackCreateInfoExt;

	public VkStructureType sType;
	public void* pNext;
	public VkDebugReportFlagsEXT Flags;
	public delegate* managed<VkDebugReportFlagsEXT, VkDebugReportObjectTypeEXT, ulong, ulong, int, byte*, byte*, void*, VkBool32> Callback;
	public void* UserData;

	public VkDebugReportCallbackCreateInfoEXT(
		VkDebugReportFlagsEXT flags = default,
		delegate* managed<VkDebugReportFlagsEXT, VkDebugReportObjectTypeEXT, ulong, ulong, int, byte*, byte*, void*, VkBool32> callback = default,
		void* userData = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		Callback = callback;
		UserData = userData;
	}

	public readonly override bool Equals(object? o) => (o is VkDebugReportCallbackCreateInfoEXT s) && (this == s);
	readonly bool IEquatable<VkDebugReportCallbackCreateInfoEXT>.Equals(VkDebugReportCallbackCreateInfoEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ ((ulong)Callback).GetHashCode()
			^ ((ulong)UserData).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDebugReportCallbackCreateInfoEXT l, in VkDebugReportCallbackCreateInfoEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.Callback == r.Callback)
			&& (l.UserData == r.UserData)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDebugReportCallbackCreateInfoEXT l, in VkDebugReportCallbackCreateInfoEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.Callback != r.Callback)
			|| (l.UserData != r.UserData)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDebugReportCallbackCreateInfoEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkValidationFlagsEXT : IEquatable<VkValidationFlagsEXT>
{
	public const VkStructureType TYPE = VkStructureType.ValidationFlagsExt;

	public VkStructureType sType;
	public void* pNext;
	public uint DisabledValidationCheckCount;
	public VkValidationCheckEXT* DisabledValidationChecks;

	public VkValidationFlagsEXT(
		uint disabledValidationCheckCount = default,
		VkValidationCheckEXT* disabledValidationChecks = default
	) {
		sType = TYPE;
		pNext = null;
		DisabledValidationCheckCount = disabledValidationCheckCount;
		DisabledValidationChecks = disabledValidationChecks;
	}

	public readonly override bool Equals(object? o) => (o is VkValidationFlagsEXT s) && (this == s);
	readonly bool IEquatable<VkValidationFlagsEXT>.Equals(VkValidationFlagsEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DisabledValidationCheckCount.GetHashCode() ^ ((ulong)DisabledValidationChecks).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkValidationFlagsEXT l, in VkValidationFlagsEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DisabledValidationCheckCount == r.DisabledValidationCheckCount) && (l.DisabledValidationChecks == r.DisabledValidationChecks)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkValidationFlagsEXT l, in VkValidationFlagsEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DisabledValidationCheckCount != r.DisabledValidationCheckCount) || (l.DisabledValidationChecks != r.DisabledValidationChecks)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkValidationFlagsEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkValidationFeaturesEXT : IEquatable<VkValidationFeaturesEXT>
{
	public const VkStructureType TYPE = VkStructureType.ValidationFeaturesExt;

	public VkStructureType sType;
	public void* pNext;
	public uint EnabledValidationFeatureCount;
	public VkValidationFeatureEnableEXT* EnabledValidationFeatures;
	public uint DisabledValidationFeatureCount;
	public VkValidationFeatureDisableEXT* DisabledValidationFeatures;

	public VkValidationFeaturesEXT(
		uint enabledValidationFeatureCount = default,
		VkValidationFeatureEnableEXT* enabledValidationFeatures = default,
		uint disabledValidationFeatureCount = default,
		VkValidationFeatureDisableEXT* disabledValidationFeatures = default
	) {
		sType = TYPE;
		pNext = null;
		EnabledValidationFeatureCount = enabledValidationFeatureCount;
		EnabledValidationFeatures = enabledValidationFeatures;
		DisabledValidationFeatureCount = disabledValidationFeatureCount;
		DisabledValidationFeatures = disabledValidationFeatures;
	}

	public readonly override bool Equals(object? o) => (o is VkValidationFeaturesEXT s) && (this == s);
	readonly bool IEquatable<VkValidationFeaturesEXT>.Equals(VkValidationFeaturesEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ EnabledValidationFeatureCount.GetHashCode() ^ ((ulong)EnabledValidationFeatures).GetHashCode()
			^ DisabledValidationFeatureCount.GetHashCode() ^ ((ulong)DisabledValidationFeatures).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkValidationFeaturesEXT l, in VkValidationFeaturesEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.EnabledValidationFeatureCount == r.EnabledValidationFeatureCount) && (l.EnabledValidationFeatures == r.EnabledValidationFeatures)
			&& (l.DisabledValidationFeatureCount == r.DisabledValidationFeatureCount) && (l.DisabledValidationFeatures == r.DisabledValidationFeatures)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkValidationFeaturesEXT l, in VkValidationFeaturesEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.EnabledValidationFeatureCount != r.EnabledValidationFeatureCount) || (l.EnabledValidationFeatures != r.EnabledValidationFeatures)
			|| (l.DisabledValidationFeatureCount != r.DisabledValidationFeatureCount) || (l.DisabledValidationFeatures != r.DisabledValidationFeatures)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkValidationFeaturesEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDebugMarkerObjectNameInfoEXT : IEquatable<VkDebugMarkerObjectNameInfoEXT>
{
	public const VkStructureType TYPE = VkStructureType.DebugMarkerObjectNameInfoExt;

	public VkStructureType sType;
	public void* pNext;
	public VkDebugReportObjectTypeEXT ObjectType;
	public ulong Object;
	public byte* ObjectName;

	public VkDebugMarkerObjectNameInfoEXT(
		VkDebugReportObjectTypeEXT objectType = default,
		ulong @object = default,
		byte* objectName = default
	) {
		sType = TYPE;
		pNext = null;
		ObjectType = objectType;
		Object = @object;
		ObjectName = objectName;
	}

	public readonly override bool Equals(object? o) => (o is VkDebugMarkerObjectNameInfoEXT s) && (this == s);
	readonly bool IEquatable<VkDebugMarkerObjectNameInfoEXT>.Equals(VkDebugMarkerObjectNameInfoEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ObjectType.GetHashCode() ^ Object.GetHashCode()
			^ ((ulong)ObjectName).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDebugMarkerObjectNameInfoEXT l, in VkDebugMarkerObjectNameInfoEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ObjectType == r.ObjectType) && (l.Object == r.Object)
			&& (l.ObjectName == r.ObjectName)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDebugMarkerObjectNameInfoEXT l, in VkDebugMarkerObjectNameInfoEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ObjectType != r.ObjectType) || (l.Object != r.Object)
			|| (l.ObjectName != r.ObjectName)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDebugMarkerObjectNameInfoEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDebugMarkerObjectTagInfoEXT : IEquatable<VkDebugMarkerObjectTagInfoEXT>
{
	public const VkStructureType TYPE = VkStructureType.DebugMarkerObjectTagInfoExt;

	public VkStructureType sType;
	public void* pNext;
	public VkDebugReportObjectTypeEXT ObjectType;
	public ulong Object;
	public ulong TagName;
	public ulong TagSize;
	public void* Tag;

	public VkDebugMarkerObjectTagInfoEXT(
		VkDebugReportObjectTypeEXT objectType = default,
		ulong @object = default,
		ulong tagName = default,
		ulong tagSize = default,
		void* tag = default
	) {
		sType = TYPE;
		pNext = null;
		ObjectType = objectType;
		Object = @object;
		TagName = tagName;
		TagSize = tagSize;
		Tag = tag;
	}

	public readonly override bool Equals(object? o) => (o is VkDebugMarkerObjectTagInfoEXT s) && (this == s);
	readonly bool IEquatable<VkDebugMarkerObjectTagInfoEXT>.Equals(VkDebugMarkerObjectTagInfoEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ObjectType.GetHashCode() ^ Object.GetHashCode()
			^ TagName.GetHashCode() ^ TagSize.GetHashCode() ^ ((ulong)Tag).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDebugMarkerObjectTagInfoEXT l, in VkDebugMarkerObjectTagInfoEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ObjectType == r.ObjectType) && (l.Object == r.Object)
			&& (l.TagName == r.TagName) && (l.TagSize == r.TagSize) && (l.Tag == r.Tag)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDebugMarkerObjectTagInfoEXT l, in VkDebugMarkerObjectTagInfoEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ObjectType != r.ObjectType) || (l.Object != r.Object)
			|| (l.TagName != r.TagName) || (l.TagSize != r.TagSize) || (l.Tag != r.Tag)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDebugMarkerObjectTagInfoEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDebugMarkerMarkerInfoEXT : IEquatable<VkDebugMarkerMarkerInfoEXT>
{
	public const VkStructureType TYPE = VkStructureType.DebugMarkerMarkerInfoExt;

	public VkStructureType sType;
	public void* pNext;
	public byte* MarkerName;
	public fixed float Color[4];

	public VkDebugMarkerMarkerInfoEXT(
		byte* markerName = default,
		float color_0 = default,
		float color_1 = default,
		float color_2 = default,
		float color_3 = default
	) {
		sType = TYPE;
		pNext = null;
		MarkerName = markerName;
		Color[0] = color_0;
		Color[1] = color_1;
		Color[2] = color_2;
		Color[3] = color_3;
	}

	public readonly override bool Equals(object? o) => (o is VkDebugMarkerMarkerInfoEXT s) && (this == s);
	readonly bool IEquatable<VkDebugMarkerMarkerInfoEXT>.Equals(VkDebugMarkerMarkerInfoEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ((ulong)MarkerName).GetHashCode() ^ Color[0].GetHashCode()
			^ Color[1].GetHashCode() ^ Color[2].GetHashCode() ^ Color[3].GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDebugMarkerMarkerInfoEXT l, in VkDebugMarkerMarkerInfoEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MarkerName == r.MarkerName) && (l.Color[0] == r.Color[0])
			&& (l.Color[1] == r.Color[1]) && (l.Color[2] == r.Color[2]) && (l.Color[3] == r.Color[3])
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDebugMarkerMarkerInfoEXT l, in VkDebugMarkerMarkerInfoEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MarkerName != r.MarkerName) || (l.Color[0] != r.Color[0])
			|| (l.Color[1] != r.Color[1]) || (l.Color[2] != r.Color[2]) || (l.Color[3] != r.Color[3])
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDebugMarkerMarkerInfoEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDevicePrivateDataCreateInfoEXT : IEquatable<VkDevicePrivateDataCreateInfoEXT>
{
	public const VkStructureType TYPE = VkStructureType.DevicePrivateDataCreateInfoExt;

	public VkStructureType sType;
	public void* pNext;
	public uint PrivateDataSlotRequestCount;

	public VkDevicePrivateDataCreateInfoEXT(
		uint privateDataSlotRequestCount = default
	) {
		sType = TYPE;
		pNext = null;
		PrivateDataSlotRequestCount = privateDataSlotRequestCount;
	}

	public readonly override bool Equals(object? o) => (o is VkDevicePrivateDataCreateInfoEXT s) && (this == s);
	readonly bool IEquatable<VkDevicePrivateDataCreateInfoEXT>.Equals(VkDevicePrivateDataCreateInfoEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ PrivateDataSlotRequestCount.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDevicePrivateDataCreateInfoEXT l, in VkDevicePrivateDataCreateInfoEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.PrivateDataSlotRequestCount == r.PrivateDataSlotRequestCount)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDevicePrivateDataCreateInfoEXT l, in VkDevicePrivateDataCreateInfoEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.PrivateDataSlotRequestCount != r.PrivateDataSlotRequestCount)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDevicePrivateDataCreateInfoEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPrivateDataSlotCreateInfoEXT : IEquatable<VkPrivateDataSlotCreateInfoEXT>
{
	public const VkStructureType TYPE = VkStructureType.PrivateDataSlotCreateInfoExt;

	public VkStructureType sType;
	public void* pNext;
	public VkPrivateDataSlotCreateFlagsEXT Flags;

	public VkPrivateDataSlotCreateInfoEXT(
		VkPrivateDataSlotCreateFlagsEXT flags = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
	}

	public readonly override bool Equals(object? o) => (o is VkPrivateDataSlotCreateInfoEXT s) && (this == s);
	readonly bool IEquatable<VkPrivateDataSlotCreateInfoEXT>.Equals(VkPrivateDataSlotCreateInfoEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPrivateDataSlotCreateInfoEXT l, in VkPrivateDataSlotCreateInfoEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPrivateDataSlotCreateInfoEXT l, in VkPrivateDataSlotCreateInfoEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPrivateDataSlotCreateInfoEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDevicePrivateDataFeaturesEXT : IEquatable<VkPhysicalDevicePrivateDataFeaturesEXT>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDevicePrivateDataFeaturesExt;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 PrivateData;

	public VkPhysicalDevicePrivateDataFeaturesEXT(
		VkBool32 privateData = default
	) {
		sType = TYPE;
		pNext = null;
		PrivateData = privateData;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDevicePrivateDataFeaturesEXT s) && (this == s);
	readonly bool IEquatable<VkPhysicalDevicePrivateDataFeaturesEXT>.Equals(VkPhysicalDevicePrivateDataFeaturesEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ PrivateData.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDevicePrivateDataFeaturesEXT l, in VkPhysicalDevicePrivateDataFeaturesEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.PrivateData == r.PrivateData)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDevicePrivateDataFeaturesEXT l, in VkPhysicalDevicePrivateDataFeaturesEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.PrivateData != r.PrivateData)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDevicePrivateDataFeaturesEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkSurfaceCapabilities2EXT : IEquatable<VkSurfaceCapabilities2EXT>
{
	public const VkStructureType TYPE = VkStructureType.SurfaceCapabilities2Ext;

	public VkStructureType sType;
	public void* pNext;
	public uint MinImageCount;
	public uint MaxImageCount;
	public VkExtent2D CurrentExtent;
	public VkExtent2D MinImageExtent;
	public VkExtent2D MaxImageExtent;
	public uint MaxImageArrayLayers;
	public VkSurfaceTransformFlagsKHR SupportedTransforms;
	public VkSurfaceTransformFlagsKHR CurrentTransform;
	public VkCompositeAlphaFlagsKHR SupportedCompositeAlpha;
	public VkImageUsageFlags SupportedUsageFlags;
	public VkSurfaceCounterFlagsEXT SupportedSurfaceCounters;

	public VkSurfaceCapabilities2EXT(
		uint minImageCount = default,
		uint maxImageCount = default,
		VkExtent2D currentExtent = default,
		VkExtent2D minImageExtent = default,
		VkExtent2D maxImageExtent = default,
		uint maxImageArrayLayers = default,
		VkSurfaceTransformFlagsKHR supportedTransforms = default,
		VkSurfaceTransformFlagsKHR currentTransform = default,
		VkCompositeAlphaFlagsKHR supportedCompositeAlpha = default,
		VkImageUsageFlags supportedUsageFlags = default,
		VkSurfaceCounterFlagsEXT supportedSurfaceCounters = default
	) {
		sType = TYPE;
		pNext = null;
		MinImageCount = minImageCount;
		MaxImageCount = maxImageCount;
		CurrentExtent = currentExtent;
		MinImageExtent = minImageExtent;
		MaxImageExtent = maxImageExtent;
		MaxImageArrayLayers = maxImageArrayLayers;
		SupportedTransforms = supportedTransforms;
		CurrentTransform = currentTransform;
		SupportedCompositeAlpha = supportedCompositeAlpha;
		SupportedUsageFlags = supportedUsageFlags;
		SupportedSurfaceCounters = supportedSurfaceCounters;
	}

	public readonly override bool Equals(object? o) => (o is VkSurfaceCapabilities2EXT s) && (this == s);
	readonly bool IEquatable<VkSurfaceCapabilities2EXT>.Equals(VkSurfaceCapabilities2EXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MinImageCount.GetHashCode() ^ MaxImageCount.GetHashCode()
			^ CurrentExtent.GetHashCode() ^ MinImageExtent.GetHashCode() ^ MaxImageExtent.GetHashCode() ^ MaxImageArrayLayers.GetHashCode()
			^ SupportedTransforms.GetHashCode() ^ CurrentTransform.GetHashCode() ^ SupportedCompositeAlpha.GetHashCode() ^ SupportedUsageFlags.GetHashCode()
			^ SupportedSurfaceCounters.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkSurfaceCapabilities2EXT l, in VkSurfaceCapabilities2EXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MinImageCount == r.MinImageCount) && (l.MaxImageCount == r.MaxImageCount)
			&& (l.CurrentExtent == r.CurrentExtent) && (l.MinImageExtent == r.MinImageExtent) && (l.MaxImageExtent == r.MaxImageExtent) && (l.MaxImageArrayLayers == r.MaxImageArrayLayers)
			&& (l.SupportedTransforms == r.SupportedTransforms) && (l.CurrentTransform == r.CurrentTransform) && (l.SupportedCompositeAlpha == r.SupportedCompositeAlpha) && (l.SupportedUsageFlags == r.SupportedUsageFlags)
			&& (l.SupportedSurfaceCounters == r.SupportedSurfaceCounters)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkSurfaceCapabilities2EXT l, in VkSurfaceCapabilities2EXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MinImageCount != r.MinImageCount) || (l.MaxImageCount != r.MaxImageCount)
			|| (l.CurrentExtent != r.CurrentExtent) || (l.MinImageExtent != r.MinImageExtent) || (l.MaxImageExtent != r.MaxImageExtent) || (l.MaxImageArrayLayers != r.MaxImageArrayLayers)
			|| (l.SupportedTransforms != r.SupportedTransforms) || (l.CurrentTransform != r.CurrentTransform) || (l.SupportedCompositeAlpha != r.SupportedCompositeAlpha) || (l.SupportedUsageFlags != r.SupportedUsageFlags)
			|| (l.SupportedSurfaceCounters != r.SupportedSurfaceCounters)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkSurfaceCapabilities2EXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDisplayPowerInfoEXT : IEquatable<VkDisplayPowerInfoEXT>
{
	public const VkStructureType TYPE = VkStructureType.DisplayPowerInfoExt;

	public VkStructureType sType;
	public void* pNext;
	public VkDisplayPowerStateEXT PowerState;

	public VkDisplayPowerInfoEXT(
		VkDisplayPowerStateEXT powerState = default
	) {
		sType = TYPE;
		pNext = null;
		PowerState = powerState;
	}

	public readonly override bool Equals(object? o) => (o is VkDisplayPowerInfoEXT s) && (this == s);
	readonly bool IEquatable<VkDisplayPowerInfoEXT>.Equals(VkDisplayPowerInfoEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ PowerState.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDisplayPowerInfoEXT l, in VkDisplayPowerInfoEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.PowerState == r.PowerState)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDisplayPowerInfoEXT l, in VkDisplayPowerInfoEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.PowerState != r.PowerState)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDisplayPowerInfoEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDeviceEventInfoEXT : IEquatable<VkDeviceEventInfoEXT>
{
	public const VkStructureType TYPE = VkStructureType.DeviceEventInfoExt;

	public VkStructureType sType;
	public void* pNext;
	public VkDeviceEventTypeEXT DeviceEvent;

	public VkDeviceEventInfoEXT(
		VkDeviceEventTypeEXT deviceEvent = default
	) {
		sType = TYPE;
		pNext = null;
		DeviceEvent = deviceEvent;
	}

	public readonly override bool Equals(object? o) => (o is VkDeviceEventInfoEXT s) && (this == s);
	readonly bool IEquatable<VkDeviceEventInfoEXT>.Equals(VkDeviceEventInfoEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DeviceEvent.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDeviceEventInfoEXT l, in VkDeviceEventInfoEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DeviceEvent == r.DeviceEvent)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDeviceEventInfoEXT l, in VkDeviceEventInfoEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DeviceEvent != r.DeviceEvent)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDeviceEventInfoEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDisplayEventInfoEXT : IEquatable<VkDisplayEventInfoEXT>
{
	public const VkStructureType TYPE = VkStructureType.DisplayEventInfoExt;

	public VkStructureType sType;
	public void* pNext;
	public VkDisplayEventTypeEXT DisplayEvent;

	public VkDisplayEventInfoEXT(
		VkDisplayEventTypeEXT displayEvent = default
	) {
		sType = TYPE;
		pNext = null;
		DisplayEvent = displayEvent;
	}

	public readonly override bool Equals(object? o) => (o is VkDisplayEventInfoEXT s) && (this == s);
	readonly bool IEquatable<VkDisplayEventInfoEXT>.Equals(VkDisplayEventInfoEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DisplayEvent.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDisplayEventInfoEXT l, in VkDisplayEventInfoEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DisplayEvent == r.DisplayEvent)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDisplayEventInfoEXT l, in VkDisplayEventInfoEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DisplayEvent != r.DisplayEvent)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDisplayEventInfoEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkSwapchainCounterCreateInfoEXT : IEquatable<VkSwapchainCounterCreateInfoEXT>
{
	public const VkStructureType TYPE = VkStructureType.SwapchainCounterCreateInfoExt;

	public VkStructureType sType;
	public void* pNext;
	public VkSurfaceCounterFlagsEXT SurfaceCounters;

	public VkSwapchainCounterCreateInfoEXT(
		VkSurfaceCounterFlagsEXT surfaceCounters = default
	) {
		sType = TYPE;
		pNext = null;
		SurfaceCounters = surfaceCounters;
	}

	public readonly override bool Equals(object? o) => (o is VkSwapchainCounterCreateInfoEXT s) && (this == s);
	readonly bool IEquatable<VkSwapchainCounterCreateInfoEXT>.Equals(VkSwapchainCounterCreateInfoEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SurfaceCounters.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkSwapchainCounterCreateInfoEXT l, in VkSwapchainCounterCreateInfoEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SurfaceCounters == r.SurfaceCounters)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkSwapchainCounterCreateInfoEXT l, in VkSwapchainCounterCreateInfoEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SurfaceCounters != r.SurfaceCounters)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkSwapchainCounterCreateInfoEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkXYColorEXT : IEquatable<VkXYColorEXT>
{
	public float X;
	public float Y;

	public VkXYColorEXT(
		float x = default,
		float y = default
	) {
		X = x;
		Y = y;
	}

	public readonly override bool Equals(object? o) => (o is VkXYColorEXT s) && (this == s);
	readonly bool IEquatable<VkXYColorEXT>.Equals(VkXYColorEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			X.GetHashCode() ^ Y.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkXYColorEXT l, in VkXYColorEXT r)
	{
		return
			(l.X == r.X) && (l.Y == r.Y)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkXYColorEXT l, in VkXYColorEXT r)
	{
		return
			(l.X != r.X) || (l.Y != r.Y)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkXYColorEXT s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkHdrMetadataEXT : IEquatable<VkHdrMetadataEXT>
{
	public const VkStructureType TYPE = VkStructureType.HdrMetadataExt;

	public VkStructureType sType;
	public void* pNext;
	public VkXYColorEXT DisplayPrimaryRed;
	public VkXYColorEXT DisplayPrimaryGreen;
	public VkXYColorEXT DisplayPrimaryBlue;
	public VkXYColorEXT WhitePoint;
	public float MaxLuminance;
	public float MinLuminance;
	public float MaxContentLightLevel;
	public float MaxFrameAverageLightLevel;

	public VkHdrMetadataEXT(
		VkXYColorEXT displayPrimaryRed = default,
		VkXYColorEXT displayPrimaryGreen = default,
		VkXYColorEXT displayPrimaryBlue = default,
		VkXYColorEXT whitePoint = default,
		float maxLuminance = default,
		float minLuminance = default,
		float maxContentLightLevel = default,
		float maxFrameAverageLightLevel = default
	) {
		sType = TYPE;
		pNext = null;
		DisplayPrimaryRed = displayPrimaryRed;
		DisplayPrimaryGreen = displayPrimaryGreen;
		DisplayPrimaryBlue = displayPrimaryBlue;
		WhitePoint = whitePoint;
		MaxLuminance = maxLuminance;
		MinLuminance = minLuminance;
		MaxContentLightLevel = maxContentLightLevel;
		MaxFrameAverageLightLevel = maxFrameAverageLightLevel;
	}

	public readonly override bool Equals(object? o) => (o is VkHdrMetadataEXT s) && (this == s);
	readonly bool IEquatable<VkHdrMetadataEXT>.Equals(VkHdrMetadataEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DisplayPrimaryRed.GetHashCode() ^ DisplayPrimaryGreen.GetHashCode()
			^ DisplayPrimaryBlue.GetHashCode() ^ WhitePoint.GetHashCode() ^ MaxLuminance.GetHashCode() ^ MinLuminance.GetHashCode()
			^ MaxContentLightLevel.GetHashCode() ^ MaxFrameAverageLightLevel.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkHdrMetadataEXT l, in VkHdrMetadataEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DisplayPrimaryRed == r.DisplayPrimaryRed) && (l.DisplayPrimaryGreen == r.DisplayPrimaryGreen)
			&& (l.DisplayPrimaryBlue == r.DisplayPrimaryBlue) && (l.WhitePoint == r.WhitePoint) && (l.MaxLuminance == r.MaxLuminance) && (l.MinLuminance == r.MinLuminance)
			&& (l.MaxContentLightLevel == r.MaxContentLightLevel) && (l.MaxFrameAverageLightLevel == r.MaxFrameAverageLightLevel)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkHdrMetadataEXT l, in VkHdrMetadataEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DisplayPrimaryRed != r.DisplayPrimaryRed) || (l.DisplayPrimaryGreen != r.DisplayPrimaryGreen)
			|| (l.DisplayPrimaryBlue != r.DisplayPrimaryBlue) || (l.WhitePoint != r.WhitePoint) || (l.MaxLuminance != r.MaxLuminance) || (l.MinLuminance != r.MinLuminance)
			|| (l.MaxContentLightLevel != r.MaxContentLightLevel) || (l.MaxFrameAverageLightLevel != r.MaxFrameAverageLightLevel)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkHdrMetadataEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkMetalSurfaceCreateInfoEXT : IEquatable<VkMetalSurfaceCreateInfoEXT>
{
	public const VkStructureType TYPE = VkStructureType.MetalSurfaceCreateInfoExt;

	public VkStructureType sType;
	public void* pNext;
	public VkMetalSurfaceCreateFlagsEXT Flags;
	public void* Layer;

	public VkMetalSurfaceCreateInfoEXT(
		VkMetalSurfaceCreateFlagsEXT flags = default,
		void* layer = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		Layer = layer;
	}

	public readonly override bool Equals(object? o) => (o is VkMetalSurfaceCreateInfoEXT s) && (this == s);
	readonly bool IEquatable<VkMetalSurfaceCreateInfoEXT>.Equals(VkMetalSurfaceCreateInfoEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ ((ulong)Layer).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkMetalSurfaceCreateInfoEXT l, in VkMetalSurfaceCreateInfoEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.Layer == r.Layer)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkMetalSurfaceCreateInfoEXT l, in VkMetalSurfaceCreateInfoEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.Layer != r.Layer)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkMetalSurfaceCreateInfoEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceDiscardRectanglePropertiesEXT : IEquatable<VkPhysicalDeviceDiscardRectanglePropertiesEXT>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceDiscardRectanglePropertiesExt;

	public VkStructureType sType;
	public void* pNext;
	public uint MaxDiscardRectangles;

	public VkPhysicalDeviceDiscardRectanglePropertiesEXT(
		uint maxDiscardRectangles = default
	) {
		sType = TYPE;
		pNext = null;
		MaxDiscardRectangles = maxDiscardRectangles;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceDiscardRectanglePropertiesEXT s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceDiscardRectanglePropertiesEXT>.Equals(VkPhysicalDeviceDiscardRectanglePropertiesEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MaxDiscardRectangles.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceDiscardRectanglePropertiesEXT l, in VkPhysicalDeviceDiscardRectanglePropertiesEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MaxDiscardRectangles == r.MaxDiscardRectangles)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceDiscardRectanglePropertiesEXT l, in VkPhysicalDeviceDiscardRectanglePropertiesEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MaxDiscardRectangles != r.MaxDiscardRectangles)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceDiscardRectanglePropertiesEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPipelineDiscardRectangleStateCreateInfoEXT : IEquatable<VkPipelineDiscardRectangleStateCreateInfoEXT>
{
	public const VkStructureType TYPE = VkStructureType.PipelineDiscardRectangleStateCreateInfoExt;

	public VkStructureType sType;
	public void* pNext;
	public VkPipelineDiscardRectangleStateCreateFlagsEXT Flags;
	public VkDiscardRectangleModeEXT DiscardRectangleMode;
	public uint DiscardRectangleCount;
	public VkRect2D* DiscardRectangles;

	public VkPipelineDiscardRectangleStateCreateInfoEXT(
		VkPipelineDiscardRectangleStateCreateFlagsEXT flags = default,
		VkDiscardRectangleModeEXT discardRectangleMode = default,
		uint discardRectangleCount = default,
		VkRect2D* discardRectangles = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		DiscardRectangleMode = discardRectangleMode;
		DiscardRectangleCount = discardRectangleCount;
		DiscardRectangles = discardRectangles;
	}

	public readonly override bool Equals(object? o) => (o is VkPipelineDiscardRectangleStateCreateInfoEXT s) && (this == s);
	readonly bool IEquatable<VkPipelineDiscardRectangleStateCreateInfoEXT>.Equals(VkPipelineDiscardRectangleStateCreateInfoEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ DiscardRectangleMode.GetHashCode()
			^ DiscardRectangleCount.GetHashCode() ^ ((ulong)DiscardRectangles).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPipelineDiscardRectangleStateCreateInfoEXT l, in VkPipelineDiscardRectangleStateCreateInfoEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.DiscardRectangleMode == r.DiscardRectangleMode)
			&& (l.DiscardRectangleCount == r.DiscardRectangleCount) && (l.DiscardRectangles == r.DiscardRectangles)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPipelineDiscardRectangleStateCreateInfoEXT l, in VkPipelineDiscardRectangleStateCreateInfoEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.DiscardRectangleMode != r.DiscardRectangleMode)
			|| (l.DiscardRectangleCount != r.DiscardRectangleCount) || (l.DiscardRectangles != r.DiscardRectangles)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPipelineDiscardRectangleStateCreateInfoEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkConditionalRenderingBeginInfoEXT : IEquatable<VkConditionalRenderingBeginInfoEXT>
{
	public const VkStructureType TYPE = VkStructureType.ConditionalRenderingBeginInfoExt;

	public VkStructureType sType;
	public void* pNext;
	public VulkanHandle<VkBuffer> Buffer;
	public ulong Offset;
	public VkConditionalRenderingFlagsEXT Flags;

	public VkConditionalRenderingBeginInfoEXT(
		VulkanHandle<VkBuffer> buffer = default,
		ulong offset = default,
		VkConditionalRenderingFlagsEXT flags = default
	) {
		sType = TYPE;
		pNext = null;
		Buffer = buffer;
		Offset = offset;
		Flags = flags;
	}

	public readonly override bool Equals(object? o) => (o is VkConditionalRenderingBeginInfoEXT s) && (this == s);
	readonly bool IEquatable<VkConditionalRenderingBeginInfoEXT>.Equals(VkConditionalRenderingBeginInfoEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Buffer.GetHashCode() ^ Offset.GetHashCode()
			^ Flags.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkConditionalRenderingBeginInfoEXT l, in VkConditionalRenderingBeginInfoEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Buffer == r.Buffer) && (l.Offset == r.Offset)
			&& (l.Flags == r.Flags)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkConditionalRenderingBeginInfoEXT l, in VkConditionalRenderingBeginInfoEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Buffer != r.Buffer) || (l.Offset != r.Offset)
			|| (l.Flags != r.Flags)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkConditionalRenderingBeginInfoEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT : IEquatable<VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceSamplerFilterMinmaxProperties;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 FilterMinmaxSingleComponentFormats;
	public VkBool32 FilterMinmaxImageComponentMapping;

	public VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT(
		VkBool32 filterMinmaxSingleComponentFormats = default,
		VkBool32 filterMinmaxImageComponentMapping = default
	) {
		sType = TYPE;
		pNext = null;
		FilterMinmaxSingleComponentFormats = filterMinmaxSingleComponentFormats;
		FilterMinmaxImageComponentMapping = filterMinmaxImageComponentMapping;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT>.Equals(VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ FilterMinmaxSingleComponentFormats.GetHashCode() ^ FilterMinmaxImageComponentMapping.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT l, in VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.FilterMinmaxSingleComponentFormats == r.FilterMinmaxSingleComponentFormats) && (l.FilterMinmaxImageComponentMapping == r.FilterMinmaxImageComponentMapping)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT l, in VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.FilterMinmaxSingleComponentFormats != r.FilterMinmaxSingleComponentFormats) || (l.FilterMinmaxImageComponentMapping != r.FilterMinmaxImageComponentMapping)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkSampleLocationEXT : IEquatable<VkSampleLocationEXT>
{
	public float X;
	public float Y;

	public VkSampleLocationEXT(
		float x = default,
		float y = default
	) {
		X = x;
		Y = y;
	}

	public readonly override bool Equals(object? o) => (o is VkSampleLocationEXT s) && (this == s);
	readonly bool IEquatable<VkSampleLocationEXT>.Equals(VkSampleLocationEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			X.GetHashCode() ^ Y.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkSampleLocationEXT l, in VkSampleLocationEXT r)
	{
		return
			(l.X == r.X) && (l.Y == r.Y)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkSampleLocationEXT l, in VkSampleLocationEXT r)
	{
		return
			(l.X != r.X) || (l.Y != r.Y)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkSampleLocationEXT s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkSampleLocationsInfoEXT : IEquatable<VkSampleLocationsInfoEXT>
{
	public const VkStructureType TYPE = VkStructureType.SampleLocationsInfoExt;

	public VkStructureType sType;
	public void* pNext;
	public VkSampleCountFlags SampleLocationsPerPixel;
	public VkExtent2D SampleLocationGridSize;
	public uint SampleLocationsCount;
	public VkSampleLocationEXT* SampleLocations;

	public VkSampleLocationsInfoEXT(
		VkSampleCountFlags sampleLocationsPerPixel = default,
		VkExtent2D sampleLocationGridSize = default,
		uint sampleLocationsCount = default,
		VkSampleLocationEXT* sampleLocations = default
	) {
		sType = TYPE;
		pNext = null;
		SampleLocationsPerPixel = sampleLocationsPerPixel;
		SampleLocationGridSize = sampleLocationGridSize;
		SampleLocationsCount = sampleLocationsCount;
		SampleLocations = sampleLocations;
	}

	public readonly override bool Equals(object? o) => (o is VkSampleLocationsInfoEXT s) && (this == s);
	readonly bool IEquatable<VkSampleLocationsInfoEXT>.Equals(VkSampleLocationsInfoEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SampleLocationsPerPixel.GetHashCode() ^ SampleLocationGridSize.GetHashCode()
			^ SampleLocationsCount.GetHashCode() ^ ((ulong)SampleLocations).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkSampleLocationsInfoEXT l, in VkSampleLocationsInfoEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SampleLocationsPerPixel == r.SampleLocationsPerPixel) && (l.SampleLocationGridSize == r.SampleLocationGridSize)
			&& (l.SampleLocationsCount == r.SampleLocationsCount) && (l.SampleLocations == r.SampleLocations)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkSampleLocationsInfoEXT l, in VkSampleLocationsInfoEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SampleLocationsPerPixel != r.SampleLocationsPerPixel) || (l.SampleLocationGridSize != r.SampleLocationGridSize)
			|| (l.SampleLocationsCount != r.SampleLocationsCount) || (l.SampleLocations != r.SampleLocations)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkSampleLocationsInfoEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkAttachmentSampleLocationsEXT : IEquatable<VkAttachmentSampleLocationsEXT>
{
	public uint AttachmentIndex;
	public VkSampleLocationsInfoEXT SampleLocationsInfo;

	public VkAttachmentSampleLocationsEXT(
		uint attachmentIndex = default,
		VkSampleLocationsInfoEXT sampleLocationsInfo = default
	) {
		AttachmentIndex = attachmentIndex;
		SampleLocationsInfo = sampleLocationsInfo;
	}

	public readonly override bool Equals(object? o) => (o is VkAttachmentSampleLocationsEXT s) && (this == s);
	readonly bool IEquatable<VkAttachmentSampleLocationsEXT>.Equals(VkAttachmentSampleLocationsEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			AttachmentIndex.GetHashCode() ^ SampleLocationsInfo.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkAttachmentSampleLocationsEXT l, in VkAttachmentSampleLocationsEXT r)
	{
		return
			(l.AttachmentIndex == r.AttachmentIndex) && (l.SampleLocationsInfo == r.SampleLocationsInfo)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkAttachmentSampleLocationsEXT l, in VkAttachmentSampleLocationsEXT r)
	{
		return
			(l.AttachmentIndex != r.AttachmentIndex) || (l.SampleLocationsInfo != r.SampleLocationsInfo)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkAttachmentSampleLocationsEXT s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkSubpassSampleLocationsEXT : IEquatable<VkSubpassSampleLocationsEXT>
{
	public uint SubpassIndex;
	public VkSampleLocationsInfoEXT SampleLocationsInfo;

	public VkSubpassSampleLocationsEXT(
		uint subpassIndex = default,
		VkSampleLocationsInfoEXT sampleLocationsInfo = default
	) {
		SubpassIndex = subpassIndex;
		SampleLocationsInfo = sampleLocationsInfo;
	}

	public readonly override bool Equals(object? o) => (o is VkSubpassSampleLocationsEXT s) && (this == s);
	readonly bool IEquatable<VkSubpassSampleLocationsEXT>.Equals(VkSubpassSampleLocationsEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			SubpassIndex.GetHashCode() ^ SampleLocationsInfo.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkSubpassSampleLocationsEXT l, in VkSubpassSampleLocationsEXT r)
	{
		return
			(l.SubpassIndex == r.SubpassIndex) && (l.SampleLocationsInfo == r.SampleLocationsInfo)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkSubpassSampleLocationsEXT l, in VkSubpassSampleLocationsEXT r)
	{
		return
			(l.SubpassIndex != r.SubpassIndex) || (l.SampleLocationsInfo != r.SampleLocationsInfo)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkSubpassSampleLocationsEXT s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkRenderPassSampleLocationsBeginInfoEXT : IEquatable<VkRenderPassSampleLocationsBeginInfoEXT>
{
	public const VkStructureType TYPE = VkStructureType.RenderPassSampleLocationsBeginInfoExt;

	public VkStructureType sType;
	public void* pNext;
	public uint AttachmentInitialSampleLocationsCount;
	public VkAttachmentSampleLocationsEXT* AttachmentInitialSampleLocations;
	public uint PostSubpassSampleLocationsCount;
	public VkSubpassSampleLocationsEXT* PostSubpassSampleLocations;

	public VkRenderPassSampleLocationsBeginInfoEXT(
		uint attachmentInitialSampleLocationsCount = default,
		VkAttachmentSampleLocationsEXT* attachmentInitialSampleLocations = default,
		uint postSubpassSampleLocationsCount = default,
		VkSubpassSampleLocationsEXT* postSubpassSampleLocations = default
	) {
		sType = TYPE;
		pNext = null;
		AttachmentInitialSampleLocationsCount = attachmentInitialSampleLocationsCount;
		AttachmentInitialSampleLocations = attachmentInitialSampleLocations;
		PostSubpassSampleLocationsCount = postSubpassSampleLocationsCount;
		PostSubpassSampleLocations = postSubpassSampleLocations;
	}

	public readonly override bool Equals(object? o) => (o is VkRenderPassSampleLocationsBeginInfoEXT s) && (this == s);
	readonly bool IEquatable<VkRenderPassSampleLocationsBeginInfoEXT>.Equals(VkRenderPassSampleLocationsBeginInfoEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ AttachmentInitialSampleLocationsCount.GetHashCode() ^ ((ulong)AttachmentInitialSampleLocations).GetHashCode()
			^ PostSubpassSampleLocationsCount.GetHashCode() ^ ((ulong)PostSubpassSampleLocations).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkRenderPassSampleLocationsBeginInfoEXT l, in VkRenderPassSampleLocationsBeginInfoEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.AttachmentInitialSampleLocationsCount == r.AttachmentInitialSampleLocationsCount) && (l.AttachmentInitialSampleLocations == r.AttachmentInitialSampleLocations)
			&& (l.PostSubpassSampleLocationsCount == r.PostSubpassSampleLocationsCount) && (l.PostSubpassSampleLocations == r.PostSubpassSampleLocations)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkRenderPassSampleLocationsBeginInfoEXT l, in VkRenderPassSampleLocationsBeginInfoEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.AttachmentInitialSampleLocationsCount != r.AttachmentInitialSampleLocationsCount) || (l.AttachmentInitialSampleLocations != r.AttachmentInitialSampleLocations)
			|| (l.PostSubpassSampleLocationsCount != r.PostSubpassSampleLocationsCount) || (l.PostSubpassSampleLocations != r.PostSubpassSampleLocations)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkRenderPassSampleLocationsBeginInfoEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPipelineSampleLocationsStateCreateInfoEXT : IEquatable<VkPipelineSampleLocationsStateCreateInfoEXT>
{
	public const VkStructureType TYPE = VkStructureType.PipelineSampleLocationsStateCreateInfoExt;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 SampleLocationsEnable;
	public VkSampleLocationsInfoEXT SampleLocationsInfo;

	public VkPipelineSampleLocationsStateCreateInfoEXT(
		VkBool32 sampleLocationsEnable = default,
		VkSampleLocationsInfoEXT sampleLocationsInfo = default
	) {
		sType = TYPE;
		pNext = null;
		SampleLocationsEnable = sampleLocationsEnable;
		SampleLocationsInfo = sampleLocationsInfo;
	}

	public readonly override bool Equals(object? o) => (o is VkPipelineSampleLocationsStateCreateInfoEXT s) && (this == s);
	readonly bool IEquatable<VkPipelineSampleLocationsStateCreateInfoEXT>.Equals(VkPipelineSampleLocationsStateCreateInfoEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SampleLocationsEnable.GetHashCode() ^ SampleLocationsInfo.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPipelineSampleLocationsStateCreateInfoEXT l, in VkPipelineSampleLocationsStateCreateInfoEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SampleLocationsEnable == r.SampleLocationsEnable) && (l.SampleLocationsInfo == r.SampleLocationsInfo)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPipelineSampleLocationsStateCreateInfoEXT l, in VkPipelineSampleLocationsStateCreateInfoEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SampleLocationsEnable != r.SampleLocationsEnable) || (l.SampleLocationsInfo != r.SampleLocationsInfo)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPipelineSampleLocationsStateCreateInfoEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceSampleLocationsPropertiesEXT : IEquatable<VkPhysicalDeviceSampleLocationsPropertiesEXT>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceSampleLocationsPropertiesExt;

	public VkStructureType sType;
	public void* pNext;
	public VkSampleCountFlags SampleLocationSampleCounts;
	public VkExtent2D MaxSampleLocationGridSize;
	public fixed float SampleLocationCoordinateRange[2];
	public uint SampleLocationSubPixelBits;
	public VkBool32 VariableSampleLocations;

	public VkPhysicalDeviceSampleLocationsPropertiesEXT(
		VkSampleCountFlags sampleLocationSampleCounts = default,
		VkExtent2D maxSampleLocationGridSize = default,
		float sampleLocationCoordinateRange_0 = default,
		float sampleLocationCoordinateRange_1 = default,
		uint sampleLocationSubPixelBits = default,
		VkBool32 variableSampleLocations = default
	) {
		sType = TYPE;
		pNext = null;
		SampleLocationSampleCounts = sampleLocationSampleCounts;
		MaxSampleLocationGridSize = maxSampleLocationGridSize;
		SampleLocationCoordinateRange[0] = sampleLocationCoordinateRange_0;
		SampleLocationCoordinateRange[1] = sampleLocationCoordinateRange_1;
		SampleLocationSubPixelBits = sampleLocationSubPixelBits;
		VariableSampleLocations = variableSampleLocations;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceSampleLocationsPropertiesEXT s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceSampleLocationsPropertiesEXT>.Equals(VkPhysicalDeviceSampleLocationsPropertiesEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SampleLocationSampleCounts.GetHashCode() ^ MaxSampleLocationGridSize.GetHashCode()
			^ SampleLocationCoordinateRange[0].GetHashCode() ^ SampleLocationCoordinateRange[1].GetHashCode() ^ SampleLocationSubPixelBits.GetHashCode() ^ VariableSampleLocations.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceSampleLocationsPropertiesEXT l, in VkPhysicalDeviceSampleLocationsPropertiesEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SampleLocationSampleCounts == r.SampleLocationSampleCounts) && (l.MaxSampleLocationGridSize == r.MaxSampleLocationGridSize)
			&& (l.SampleLocationCoordinateRange[0] == r.SampleLocationCoordinateRange[0]) && (l.SampleLocationCoordinateRange[1] == r.SampleLocationCoordinateRange[1]) && (l.SampleLocationSubPixelBits == r.SampleLocationSubPixelBits) && (l.VariableSampleLocations == r.VariableSampleLocations)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceSampleLocationsPropertiesEXT l, in VkPhysicalDeviceSampleLocationsPropertiesEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SampleLocationSampleCounts != r.SampleLocationSampleCounts) || (l.MaxSampleLocationGridSize != r.MaxSampleLocationGridSize)
			|| (l.SampleLocationCoordinateRange[0] != r.SampleLocationCoordinateRange[0]) || (l.SampleLocationCoordinateRange[1] != r.SampleLocationCoordinateRange[1]) || (l.SampleLocationSubPixelBits != r.SampleLocationSubPixelBits) || (l.VariableSampleLocations != r.VariableSampleLocations)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceSampleLocationsPropertiesEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkMultisamplePropertiesEXT : IEquatable<VkMultisamplePropertiesEXT>
{
	public const VkStructureType TYPE = VkStructureType.MultisamplePropertiesExt;

	public VkStructureType sType;
	public void* pNext;
	public VkExtent2D MaxSampleLocationGridSize;

	public VkMultisamplePropertiesEXT(
		VkExtent2D maxSampleLocationGridSize = default
	) {
		sType = TYPE;
		pNext = null;
		MaxSampleLocationGridSize = maxSampleLocationGridSize;
	}

	public readonly override bool Equals(object? o) => (o is VkMultisamplePropertiesEXT s) && (this == s);
	readonly bool IEquatable<VkMultisamplePropertiesEXT>.Equals(VkMultisamplePropertiesEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MaxSampleLocationGridSize.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkMultisamplePropertiesEXT l, in VkMultisamplePropertiesEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MaxSampleLocationGridSize == r.MaxSampleLocationGridSize)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkMultisamplePropertiesEXT l, in VkMultisamplePropertiesEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MaxSampleLocationGridSize != r.MaxSampleLocationGridSize)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkMultisamplePropertiesEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkSamplerReductionModeCreateInfoEXT : IEquatable<VkSamplerReductionModeCreateInfoEXT>
{
	public const VkStructureType TYPE = VkStructureType.SamplerReductionModeCreateInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkSamplerReductionMode ReductionMode;

	public VkSamplerReductionModeCreateInfoEXT(
		VkSamplerReductionMode reductionMode = default
	) {
		sType = TYPE;
		pNext = null;
		ReductionMode = reductionMode;
	}

	public readonly override bool Equals(object? o) => (o is VkSamplerReductionModeCreateInfoEXT s) && (this == s);
	readonly bool IEquatable<VkSamplerReductionModeCreateInfoEXT>.Equals(VkSamplerReductionModeCreateInfoEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ReductionMode.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkSamplerReductionModeCreateInfoEXT l, in VkSamplerReductionModeCreateInfoEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ReductionMode == r.ReductionMode)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkSamplerReductionModeCreateInfoEXT l, in VkSamplerReductionModeCreateInfoEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ReductionMode != r.ReductionMode)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkSamplerReductionModeCreateInfoEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT : IEquatable<VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceBlendOperationAdvancedFeaturesExt;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 AdvancedBlendCoherentOperations;

	public VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(
		VkBool32 advancedBlendCoherentOperations = default
	) {
		sType = TYPE;
		pNext = null;
		AdvancedBlendCoherentOperations = advancedBlendCoherentOperations;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT>.Equals(VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ AdvancedBlendCoherentOperations.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT l, in VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.AdvancedBlendCoherentOperations == r.AdvancedBlendCoherentOperations)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT l, in VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.AdvancedBlendCoherentOperations != r.AdvancedBlendCoherentOperations)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT : IEquatable<VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceBlendOperationAdvancedPropertiesExt;

	public VkStructureType sType;
	public void* pNext;
	public uint AdvancedBlendMaxColorAttachments;
	public VkBool32 AdvancedBlendIndependentBlend;
	public VkBool32 AdvancedBlendNonPremultipliedSrcColor;
	public VkBool32 AdvancedBlendNonPremultipliedDstColor;
	public VkBool32 AdvancedBlendCorrelatedOverlap;
	public VkBool32 AdvancedBlendAllOperations;

	public VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT(
		uint advancedBlendMaxColorAttachments = default,
		VkBool32 advancedBlendIndependentBlend = default,
		VkBool32 advancedBlendNonPremultipliedSrcColor = default,
		VkBool32 advancedBlendNonPremultipliedDstColor = default,
		VkBool32 advancedBlendCorrelatedOverlap = default,
		VkBool32 advancedBlendAllOperations = default
	) {
		sType = TYPE;
		pNext = null;
		AdvancedBlendMaxColorAttachments = advancedBlendMaxColorAttachments;
		AdvancedBlendIndependentBlend = advancedBlendIndependentBlend;
		AdvancedBlendNonPremultipliedSrcColor = advancedBlendNonPremultipliedSrcColor;
		AdvancedBlendNonPremultipliedDstColor = advancedBlendNonPremultipliedDstColor;
		AdvancedBlendCorrelatedOverlap = advancedBlendCorrelatedOverlap;
		AdvancedBlendAllOperations = advancedBlendAllOperations;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT>.Equals(VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ AdvancedBlendMaxColorAttachments.GetHashCode() ^ AdvancedBlendIndependentBlend.GetHashCode()
			^ AdvancedBlendNonPremultipliedSrcColor.GetHashCode() ^ AdvancedBlendNonPremultipliedDstColor.GetHashCode() ^ AdvancedBlendCorrelatedOverlap.GetHashCode() ^ AdvancedBlendAllOperations.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT l, in VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.AdvancedBlendMaxColorAttachments == r.AdvancedBlendMaxColorAttachments) && (l.AdvancedBlendIndependentBlend == r.AdvancedBlendIndependentBlend)
			&& (l.AdvancedBlendNonPremultipliedSrcColor == r.AdvancedBlendNonPremultipliedSrcColor) && (l.AdvancedBlendNonPremultipliedDstColor == r.AdvancedBlendNonPremultipliedDstColor) && (l.AdvancedBlendCorrelatedOverlap == r.AdvancedBlendCorrelatedOverlap) && (l.AdvancedBlendAllOperations == r.AdvancedBlendAllOperations)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT l, in VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.AdvancedBlendMaxColorAttachments != r.AdvancedBlendMaxColorAttachments) || (l.AdvancedBlendIndependentBlend != r.AdvancedBlendIndependentBlend)
			|| (l.AdvancedBlendNonPremultipliedSrcColor != r.AdvancedBlendNonPremultipliedSrcColor) || (l.AdvancedBlendNonPremultipliedDstColor != r.AdvancedBlendNonPremultipliedDstColor) || (l.AdvancedBlendCorrelatedOverlap != r.AdvancedBlendCorrelatedOverlap) || (l.AdvancedBlendAllOperations != r.AdvancedBlendAllOperations)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPipelineColorBlendAdvancedStateCreateInfoEXT : IEquatable<VkPipelineColorBlendAdvancedStateCreateInfoEXT>
{
	public const VkStructureType TYPE = VkStructureType.PipelineColorBlendAdvancedStateCreateInfoExt;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 SrcPremultiplied;
	public VkBool32 DstPremultiplied;
	public VkBlendOverlapEXT BlendOverlap;

	public VkPipelineColorBlendAdvancedStateCreateInfoEXT(
		VkBool32 srcPremultiplied = default,
		VkBool32 dstPremultiplied = default,
		VkBlendOverlapEXT blendOverlap = default
	) {
		sType = TYPE;
		pNext = null;
		SrcPremultiplied = srcPremultiplied;
		DstPremultiplied = dstPremultiplied;
		BlendOverlap = blendOverlap;
	}

	public readonly override bool Equals(object? o) => (o is VkPipelineColorBlendAdvancedStateCreateInfoEXT s) && (this == s);
	readonly bool IEquatable<VkPipelineColorBlendAdvancedStateCreateInfoEXT>.Equals(VkPipelineColorBlendAdvancedStateCreateInfoEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SrcPremultiplied.GetHashCode() ^ DstPremultiplied.GetHashCode()
			^ BlendOverlap.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPipelineColorBlendAdvancedStateCreateInfoEXT l, in VkPipelineColorBlendAdvancedStateCreateInfoEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SrcPremultiplied == r.SrcPremultiplied) && (l.DstPremultiplied == r.DstPremultiplied)
			&& (l.BlendOverlap == r.BlendOverlap)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPipelineColorBlendAdvancedStateCreateInfoEXT l, in VkPipelineColorBlendAdvancedStateCreateInfoEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SrcPremultiplied != r.SrcPremultiplied) || (l.DstPremultiplied != r.DstPremultiplied)
			|| (l.BlendOverlap != r.BlendOverlap)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPipelineColorBlendAdvancedStateCreateInfoEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceInlineUniformBlockFeaturesEXT : IEquatable<VkPhysicalDeviceInlineUniformBlockFeaturesEXT>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceInlineUniformBlockFeaturesExt;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 InlineUniformBlock;
	public VkBool32 DescriptorBindingInlineUniformBlockUpdateAfterBind;

	public VkPhysicalDeviceInlineUniformBlockFeaturesEXT(
		VkBool32 inlineUniformBlock = default,
		VkBool32 descriptorBindingInlineUniformBlockUpdateAfterBind = default
	) {
		sType = TYPE;
		pNext = null;
		InlineUniformBlock = inlineUniformBlock;
		DescriptorBindingInlineUniformBlockUpdateAfterBind = descriptorBindingInlineUniformBlockUpdateAfterBind;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceInlineUniformBlockFeaturesEXT s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceInlineUniformBlockFeaturesEXT>.Equals(VkPhysicalDeviceInlineUniformBlockFeaturesEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ InlineUniformBlock.GetHashCode() ^ DescriptorBindingInlineUniformBlockUpdateAfterBind.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceInlineUniformBlockFeaturesEXT l, in VkPhysicalDeviceInlineUniformBlockFeaturesEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.InlineUniformBlock == r.InlineUniformBlock) && (l.DescriptorBindingInlineUniformBlockUpdateAfterBind == r.DescriptorBindingInlineUniformBlockUpdateAfterBind)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceInlineUniformBlockFeaturesEXT l, in VkPhysicalDeviceInlineUniformBlockFeaturesEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.InlineUniformBlock != r.InlineUniformBlock) || (l.DescriptorBindingInlineUniformBlockUpdateAfterBind != r.DescriptorBindingInlineUniformBlockUpdateAfterBind)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceInlineUniformBlockFeaturesEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceInlineUniformBlockPropertiesEXT : IEquatable<VkPhysicalDeviceInlineUniformBlockPropertiesEXT>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceInlineUniformBlockPropertiesExt;

	public VkStructureType sType;
	public void* pNext;
	public uint MaxInlineUniformBlockSize;
	public uint MaxPerStageDescriptorInlineUniformBlocks;
	public uint MaxPerStageDescriptorUpdateAfterBindInlineUniformBlocks;
	public uint MaxDescriptorSetInlineUniformBlocks;
	public uint MaxDescriptorSetUpdateAfterBindInlineUniformBlocks;

	public VkPhysicalDeviceInlineUniformBlockPropertiesEXT(
		uint maxInlineUniformBlockSize = default,
		uint maxPerStageDescriptorInlineUniformBlocks = default,
		uint maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks = default,
		uint maxDescriptorSetInlineUniformBlocks = default,
		uint maxDescriptorSetUpdateAfterBindInlineUniformBlocks = default
	) {
		sType = TYPE;
		pNext = null;
		MaxInlineUniformBlockSize = maxInlineUniformBlockSize;
		MaxPerStageDescriptorInlineUniformBlocks = maxPerStageDescriptorInlineUniformBlocks;
		MaxPerStageDescriptorUpdateAfterBindInlineUniformBlocks = maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks;
		MaxDescriptorSetInlineUniformBlocks = maxDescriptorSetInlineUniformBlocks;
		MaxDescriptorSetUpdateAfterBindInlineUniformBlocks = maxDescriptorSetUpdateAfterBindInlineUniformBlocks;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceInlineUniformBlockPropertiesEXT s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceInlineUniformBlockPropertiesEXT>.Equals(VkPhysicalDeviceInlineUniformBlockPropertiesEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MaxInlineUniformBlockSize.GetHashCode() ^ MaxPerStageDescriptorInlineUniformBlocks.GetHashCode()
			^ MaxPerStageDescriptorUpdateAfterBindInlineUniformBlocks.GetHashCode() ^ MaxDescriptorSetInlineUniformBlocks.GetHashCode() ^ MaxDescriptorSetUpdateAfterBindInlineUniformBlocks.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceInlineUniformBlockPropertiesEXT l, in VkPhysicalDeviceInlineUniformBlockPropertiesEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MaxInlineUniformBlockSize == r.MaxInlineUniformBlockSize) && (l.MaxPerStageDescriptorInlineUniformBlocks == r.MaxPerStageDescriptorInlineUniformBlocks)
			&& (l.MaxPerStageDescriptorUpdateAfterBindInlineUniformBlocks == r.MaxPerStageDescriptorUpdateAfterBindInlineUniformBlocks) && (l.MaxDescriptorSetInlineUniformBlocks == r.MaxDescriptorSetInlineUniformBlocks) && (l.MaxDescriptorSetUpdateAfterBindInlineUniformBlocks == r.MaxDescriptorSetUpdateAfterBindInlineUniformBlocks)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceInlineUniformBlockPropertiesEXT l, in VkPhysicalDeviceInlineUniformBlockPropertiesEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MaxInlineUniformBlockSize != r.MaxInlineUniformBlockSize) || (l.MaxPerStageDescriptorInlineUniformBlocks != r.MaxPerStageDescriptorInlineUniformBlocks)
			|| (l.MaxPerStageDescriptorUpdateAfterBindInlineUniformBlocks != r.MaxPerStageDescriptorUpdateAfterBindInlineUniformBlocks) || (l.MaxDescriptorSetInlineUniformBlocks != r.MaxDescriptorSetInlineUniformBlocks) || (l.MaxDescriptorSetUpdateAfterBindInlineUniformBlocks != r.MaxDescriptorSetUpdateAfterBindInlineUniformBlocks)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceInlineUniformBlockPropertiesEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkWriteDescriptorSetInlineUniformBlockEXT : IEquatable<VkWriteDescriptorSetInlineUniformBlockEXT>
{
	public const VkStructureType TYPE = VkStructureType.WriteDescriptorSetInlineUniformBlockExt;

	public VkStructureType sType;
	public void* pNext;
	public uint DataSize;
	public void* Data;

	public VkWriteDescriptorSetInlineUniformBlockEXT(
		uint dataSize = default,
		void* data = default
	) {
		sType = TYPE;
		pNext = null;
		DataSize = dataSize;
		Data = data;
	}

	public readonly override bool Equals(object? o) => (o is VkWriteDescriptorSetInlineUniformBlockEXT s) && (this == s);
	readonly bool IEquatable<VkWriteDescriptorSetInlineUniformBlockEXT>.Equals(VkWriteDescriptorSetInlineUniformBlockEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DataSize.GetHashCode() ^ ((ulong)Data).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkWriteDescriptorSetInlineUniformBlockEXT l, in VkWriteDescriptorSetInlineUniformBlockEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DataSize == r.DataSize) && (l.Data == r.Data)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkWriteDescriptorSetInlineUniformBlockEXT l, in VkWriteDescriptorSetInlineUniformBlockEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DataSize != r.DataSize) || (l.Data != r.Data)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkWriteDescriptorSetInlineUniformBlockEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDescriptorPoolInlineUniformBlockCreateInfoEXT : IEquatable<VkDescriptorPoolInlineUniformBlockCreateInfoEXT>
{
	public const VkStructureType TYPE = VkStructureType.DescriptorPoolInlineUniformBlockCreateInfoExt;

	public VkStructureType sType;
	public void* pNext;
	public uint MaxInlineUniformBlockBindings;

	public VkDescriptorPoolInlineUniformBlockCreateInfoEXT(
		uint maxInlineUniformBlockBindings = default
	) {
		sType = TYPE;
		pNext = null;
		MaxInlineUniformBlockBindings = maxInlineUniformBlockBindings;
	}

	public readonly override bool Equals(object? o) => (o is VkDescriptorPoolInlineUniformBlockCreateInfoEXT s) && (this == s);
	readonly bool IEquatable<VkDescriptorPoolInlineUniformBlockCreateInfoEXT>.Equals(VkDescriptorPoolInlineUniformBlockCreateInfoEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MaxInlineUniformBlockBindings.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDescriptorPoolInlineUniformBlockCreateInfoEXT l, in VkDescriptorPoolInlineUniformBlockCreateInfoEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MaxInlineUniformBlockBindings == r.MaxInlineUniformBlockBindings)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDescriptorPoolInlineUniformBlockCreateInfoEXT l, in VkDescriptorPoolInlineUniformBlockCreateInfoEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MaxInlineUniformBlockBindings != r.MaxInlineUniformBlockBindings)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDescriptorPoolInlineUniformBlockCreateInfoEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkValidationCacheCreateInfoEXT : IEquatable<VkValidationCacheCreateInfoEXT>
{
	public const VkStructureType TYPE = VkStructureType.ValidationCacheCreateInfoExt;

	public VkStructureType sType;
	public void* pNext;
	public VkValidationCacheCreateFlagsEXT Flags;
	public ulong InitialDataSize;
	public void* InitialData;

	public VkValidationCacheCreateInfoEXT(
		VkValidationCacheCreateFlagsEXT flags = default,
		ulong initialDataSize = default,
		void* initialData = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		InitialDataSize = initialDataSize;
		InitialData = initialData;
	}

	public readonly override bool Equals(object? o) => (o is VkValidationCacheCreateInfoEXT s) && (this == s);
	readonly bool IEquatable<VkValidationCacheCreateInfoEXT>.Equals(VkValidationCacheCreateInfoEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ InitialDataSize.GetHashCode()
			^ ((ulong)InitialData).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkValidationCacheCreateInfoEXT l, in VkValidationCacheCreateInfoEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.InitialDataSize == r.InitialDataSize)
			&& (l.InitialData == r.InitialData)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkValidationCacheCreateInfoEXT l, in VkValidationCacheCreateInfoEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.InitialDataSize != r.InitialDataSize)
			|| (l.InitialData != r.InitialData)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkValidationCacheCreateInfoEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkShaderModuleValidationCacheCreateInfoEXT : IEquatable<VkShaderModuleValidationCacheCreateInfoEXT>
{
	public const VkStructureType TYPE = VkStructureType.ShaderModuleValidationCacheCreateInfoExt;

	public VkStructureType sType;
	public void* pNext;
	public VulkanHandle<VkValidationCacheEXT> ValidationCache;

	public VkShaderModuleValidationCacheCreateInfoEXT(
		VulkanHandle<VkValidationCacheEXT> validationCache = default
	) {
		sType = TYPE;
		pNext = null;
		ValidationCache = validationCache;
	}

	public readonly override bool Equals(object? o) => (o is VkShaderModuleValidationCacheCreateInfoEXT s) && (this == s);
	readonly bool IEquatable<VkShaderModuleValidationCacheCreateInfoEXT>.Equals(VkShaderModuleValidationCacheCreateInfoEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ValidationCache.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkShaderModuleValidationCacheCreateInfoEXT l, in VkShaderModuleValidationCacheCreateInfoEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ValidationCache == r.ValidationCache)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkShaderModuleValidationCacheCreateInfoEXT l, in VkShaderModuleValidationCacheCreateInfoEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ValidationCache != r.ValidationCache)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkShaderModuleValidationCacheCreateInfoEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceHostQueryResetFeaturesEXT : IEquatable<VkPhysicalDeviceHostQueryResetFeaturesEXT>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceHostQueryResetFeatures;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 HostQueryReset;

	public VkPhysicalDeviceHostQueryResetFeaturesEXT(
		VkBool32 hostQueryReset = default
	) {
		sType = TYPE;
		pNext = null;
		HostQueryReset = hostQueryReset;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceHostQueryResetFeaturesEXT s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceHostQueryResetFeaturesEXT>.Equals(VkPhysicalDeviceHostQueryResetFeaturesEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ HostQueryReset.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceHostQueryResetFeaturesEXT l, in VkPhysicalDeviceHostQueryResetFeaturesEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.HostQueryReset == r.HostQueryReset)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceHostQueryResetFeaturesEXT l, in VkPhysicalDeviceHostQueryResetFeaturesEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.HostQueryReset != r.HostQueryReset)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceHostQueryResetFeaturesEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDeviceQueueGlobalPriorityCreateInfoEXT : IEquatable<VkDeviceQueueGlobalPriorityCreateInfoEXT>
{
	public const VkStructureType TYPE = VkStructureType.DeviceQueueGlobalPriorityCreateInfoExt;

	public VkStructureType sType;
	public void* pNext;
	public VkQueueGlobalPriorityEXT GlobalPriority;

	public VkDeviceQueueGlobalPriorityCreateInfoEXT(
		VkQueueGlobalPriorityEXT globalPriority = default
	) {
		sType = TYPE;
		pNext = null;
		GlobalPriority = globalPriority;
	}

	public readonly override bool Equals(object? o) => (o is VkDeviceQueueGlobalPriorityCreateInfoEXT s) && (this == s);
	readonly bool IEquatable<VkDeviceQueueGlobalPriorityCreateInfoEXT>.Equals(VkDeviceQueueGlobalPriorityCreateInfoEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ GlobalPriority.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDeviceQueueGlobalPriorityCreateInfoEXT l, in VkDeviceQueueGlobalPriorityCreateInfoEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.GlobalPriority == r.GlobalPriority)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDeviceQueueGlobalPriorityCreateInfoEXT l, in VkDeviceQueueGlobalPriorityCreateInfoEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.GlobalPriority != r.GlobalPriority)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDeviceQueueGlobalPriorityCreateInfoEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDebugUtilsObjectNameInfoEXT : IEquatable<VkDebugUtilsObjectNameInfoEXT>
{
	public const VkStructureType TYPE = VkStructureType.DebugUtilsObjectNameInfoExt;

	public VkStructureType sType;
	public void* pNext;
	public VkObjectType ObjectType;
	public ulong ObjectHandle;
	public byte* ObjectName;

	public VkDebugUtilsObjectNameInfoEXT(
		VkObjectType objectType = default,
		ulong objectHandle = default,
		byte* objectName = default
	) {
		sType = TYPE;
		pNext = null;
		ObjectType = objectType;
		ObjectHandle = objectHandle;
		ObjectName = objectName;
	}

	public readonly override bool Equals(object? o) => (o is VkDebugUtilsObjectNameInfoEXT s) && (this == s);
	readonly bool IEquatable<VkDebugUtilsObjectNameInfoEXT>.Equals(VkDebugUtilsObjectNameInfoEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ObjectType.GetHashCode() ^ ObjectHandle.GetHashCode()
			^ ((ulong)ObjectName).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDebugUtilsObjectNameInfoEXT l, in VkDebugUtilsObjectNameInfoEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ObjectType == r.ObjectType) && (l.ObjectHandle == r.ObjectHandle)
			&& (l.ObjectName == r.ObjectName)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDebugUtilsObjectNameInfoEXT l, in VkDebugUtilsObjectNameInfoEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ObjectType != r.ObjectType) || (l.ObjectHandle != r.ObjectHandle)
			|| (l.ObjectName != r.ObjectName)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDebugUtilsObjectNameInfoEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDebugUtilsObjectTagInfoEXT : IEquatable<VkDebugUtilsObjectTagInfoEXT>
{
	public const VkStructureType TYPE = VkStructureType.DebugUtilsObjectTagInfoExt;

	public VkStructureType sType;
	public void* pNext;
	public VkObjectType ObjectType;
	public ulong ObjectHandle;
	public ulong TagName;
	public ulong TagSize;
	public void* Tag;

	public VkDebugUtilsObjectTagInfoEXT(
		VkObjectType objectType = default,
		ulong objectHandle = default,
		ulong tagName = default,
		ulong tagSize = default,
		void* tag = default
	) {
		sType = TYPE;
		pNext = null;
		ObjectType = objectType;
		ObjectHandle = objectHandle;
		TagName = tagName;
		TagSize = tagSize;
		Tag = tag;
	}

	public readonly override bool Equals(object? o) => (o is VkDebugUtilsObjectTagInfoEXT s) && (this == s);
	readonly bool IEquatable<VkDebugUtilsObjectTagInfoEXT>.Equals(VkDebugUtilsObjectTagInfoEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ObjectType.GetHashCode() ^ ObjectHandle.GetHashCode()
			^ TagName.GetHashCode() ^ TagSize.GetHashCode() ^ ((ulong)Tag).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDebugUtilsObjectTagInfoEXT l, in VkDebugUtilsObjectTagInfoEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ObjectType == r.ObjectType) && (l.ObjectHandle == r.ObjectHandle)
			&& (l.TagName == r.TagName) && (l.TagSize == r.TagSize) && (l.Tag == r.Tag)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDebugUtilsObjectTagInfoEXT l, in VkDebugUtilsObjectTagInfoEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ObjectType != r.ObjectType) || (l.ObjectHandle != r.ObjectHandle)
			|| (l.TagName != r.TagName) || (l.TagSize != r.TagSize) || (l.Tag != r.Tag)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDebugUtilsObjectTagInfoEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDebugUtilsLabelEXT : IEquatable<VkDebugUtilsLabelEXT>
{
	public const VkStructureType TYPE = VkStructureType.DebugUtilsLabelExt;

	public VkStructureType sType;
	public void* pNext;
	public byte* LabelName;
	public fixed float Color[4];

	public VkDebugUtilsLabelEXT(
		byte* labelName = default,
		float color_0 = default,
		float color_1 = default,
		float color_2 = default,
		float color_3 = default
	) {
		sType = TYPE;
		pNext = null;
		LabelName = labelName;
		Color[0] = color_0;
		Color[1] = color_1;
		Color[2] = color_2;
		Color[3] = color_3;
	}

	public readonly override bool Equals(object? o) => (o is VkDebugUtilsLabelEXT s) && (this == s);
	readonly bool IEquatable<VkDebugUtilsLabelEXT>.Equals(VkDebugUtilsLabelEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ((ulong)LabelName).GetHashCode() ^ Color[0].GetHashCode()
			^ Color[1].GetHashCode() ^ Color[2].GetHashCode() ^ Color[3].GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDebugUtilsLabelEXT l, in VkDebugUtilsLabelEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.LabelName == r.LabelName) && (l.Color[0] == r.Color[0])
			&& (l.Color[1] == r.Color[1]) && (l.Color[2] == r.Color[2]) && (l.Color[3] == r.Color[3])
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDebugUtilsLabelEXT l, in VkDebugUtilsLabelEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.LabelName != r.LabelName) || (l.Color[0] != r.Color[0])
			|| (l.Color[1] != r.Color[1]) || (l.Color[2] != r.Color[2]) || (l.Color[3] != r.Color[3])
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDebugUtilsLabelEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDebugUtilsMessengerCreateInfoEXT : IEquatable<VkDebugUtilsMessengerCreateInfoEXT>
{
	public const VkStructureType TYPE = VkStructureType.DebugUtilsMessengerCreateInfoExt;

	public VkStructureType sType;
	public void* pNext;
	public VkDebugUtilsMessengerCreateFlagsEXT Flags;
	public VkDebugUtilsMessageSeverityFlagsEXT MessageSeverity;
	public VkDebugUtilsMessageTypeFlagsEXT MessageType;
	public delegate* managed<VkDebugUtilsMessageSeverityFlagsEXT, VkDebugUtilsMessageTypeFlagsEXT, VkDebugUtilsMessengerCallbackDataEXT*, void*, VkBool32> UserCallback;
	public void* UserData;

	public VkDebugUtilsMessengerCreateInfoEXT(
		VkDebugUtilsMessengerCreateFlagsEXT flags = default,
		VkDebugUtilsMessageSeverityFlagsEXT messageSeverity = default,
		VkDebugUtilsMessageTypeFlagsEXT messageType = default,
		delegate* managed<VkDebugUtilsMessageSeverityFlagsEXT, VkDebugUtilsMessageTypeFlagsEXT, VkDebugUtilsMessengerCallbackDataEXT*, void*, VkBool32> userCallback = default,
		void* userData = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		MessageSeverity = messageSeverity;
		MessageType = messageType;
		UserCallback = userCallback;
		UserData = userData;
	}

	public readonly override bool Equals(object? o) => (o is VkDebugUtilsMessengerCreateInfoEXT s) && (this == s);
	readonly bool IEquatable<VkDebugUtilsMessengerCreateInfoEXT>.Equals(VkDebugUtilsMessengerCreateInfoEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ MessageSeverity.GetHashCode()
			^ MessageType.GetHashCode() ^ ((ulong)UserCallback).GetHashCode() ^ ((ulong)UserData).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDebugUtilsMessengerCreateInfoEXT l, in VkDebugUtilsMessengerCreateInfoEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.MessageSeverity == r.MessageSeverity)
			&& (l.MessageType == r.MessageType) && (l.UserCallback == r.UserCallback) && (l.UserData == r.UserData)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDebugUtilsMessengerCreateInfoEXT l, in VkDebugUtilsMessengerCreateInfoEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.MessageSeverity != r.MessageSeverity)
			|| (l.MessageType != r.MessageType) || (l.UserCallback != r.UserCallback) || (l.UserData != r.UserData)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDebugUtilsMessengerCreateInfoEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDebugUtilsMessengerCallbackDataEXT : IEquatable<VkDebugUtilsMessengerCallbackDataEXT>
{
	public const VkStructureType TYPE = VkStructureType.DebugUtilsMessengerCallbackDataExt;

	public VkStructureType sType;
	public void* pNext;
	public VkDebugUtilsMessengerCallbackDataFlagsEXT Flags;
	public byte* MessageIdName;
	public int MessageIdNumber;
	public byte* Message;
	public uint QueueLabelCount;
	public VkDebugUtilsLabelEXT* QueueLabels;
	public uint CmdBufLabelCount;
	public VkDebugUtilsLabelEXT* CmdBufLabels;
	public uint ObjectCount;
	public VkDebugUtilsObjectNameInfoEXT* Objects;

	public VkDebugUtilsMessengerCallbackDataEXT(
		VkDebugUtilsMessengerCallbackDataFlagsEXT flags = default,
		byte* messageIdName = default,
		int messageIdNumber = default,
		byte* message = default,
		uint queueLabelCount = default,
		VkDebugUtilsLabelEXT* queueLabels = default,
		uint cmdBufLabelCount = default,
		VkDebugUtilsLabelEXT* cmdBufLabels = default,
		uint objectCount = default,
		VkDebugUtilsObjectNameInfoEXT* objects = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		MessageIdName = messageIdName;
		MessageIdNumber = messageIdNumber;
		Message = message;
		QueueLabelCount = queueLabelCount;
		QueueLabels = queueLabels;
		CmdBufLabelCount = cmdBufLabelCount;
		CmdBufLabels = cmdBufLabels;
		ObjectCount = objectCount;
		Objects = objects;
	}

	public readonly override bool Equals(object? o) => (o is VkDebugUtilsMessengerCallbackDataEXT s) && (this == s);
	readonly bool IEquatable<VkDebugUtilsMessengerCallbackDataEXT>.Equals(VkDebugUtilsMessengerCallbackDataEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ ((ulong)MessageIdName).GetHashCode()
			^ MessageIdNumber.GetHashCode() ^ ((ulong)Message).GetHashCode() ^ QueueLabelCount.GetHashCode() ^ ((ulong)QueueLabels).GetHashCode()
			^ CmdBufLabelCount.GetHashCode() ^ ((ulong)CmdBufLabels).GetHashCode() ^ ObjectCount.GetHashCode() ^ ((ulong)Objects).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDebugUtilsMessengerCallbackDataEXT l, in VkDebugUtilsMessengerCallbackDataEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.MessageIdName == r.MessageIdName)
			&& (l.MessageIdNumber == r.MessageIdNumber) && (l.Message == r.Message) && (l.QueueLabelCount == r.QueueLabelCount) && (l.QueueLabels == r.QueueLabels)
			&& (l.CmdBufLabelCount == r.CmdBufLabelCount) && (l.CmdBufLabels == r.CmdBufLabels) && (l.ObjectCount == r.ObjectCount) && (l.Objects == r.Objects)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDebugUtilsMessengerCallbackDataEXT l, in VkDebugUtilsMessengerCallbackDataEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.MessageIdName != r.MessageIdName)
			|| (l.MessageIdNumber != r.MessageIdNumber) || (l.Message != r.Message) || (l.QueueLabelCount != r.QueueLabelCount) || (l.QueueLabels != r.QueueLabels)
			|| (l.CmdBufLabelCount != r.CmdBufLabelCount) || (l.CmdBufLabels != r.CmdBufLabels) || (l.ObjectCount != r.ObjectCount) || (l.Objects != r.Objects)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDebugUtilsMessengerCallbackDataEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceDeviceMemoryReportFeaturesEXT : IEquatable<VkPhysicalDeviceDeviceMemoryReportFeaturesEXT>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceDeviceMemoryReportFeaturesExt;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 DeviceMemoryReport;

	public VkPhysicalDeviceDeviceMemoryReportFeaturesEXT(
		VkBool32 deviceMemoryReport = default
	) {
		sType = TYPE;
		pNext = null;
		DeviceMemoryReport = deviceMemoryReport;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceDeviceMemoryReportFeaturesEXT s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceDeviceMemoryReportFeaturesEXT>.Equals(VkPhysicalDeviceDeviceMemoryReportFeaturesEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DeviceMemoryReport.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceDeviceMemoryReportFeaturesEXT l, in VkPhysicalDeviceDeviceMemoryReportFeaturesEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DeviceMemoryReport == r.DeviceMemoryReport)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceDeviceMemoryReportFeaturesEXT l, in VkPhysicalDeviceDeviceMemoryReportFeaturesEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DeviceMemoryReport != r.DeviceMemoryReport)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceDeviceMemoryReportFeaturesEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDeviceDeviceMemoryReportCreateInfoEXT : IEquatable<VkDeviceDeviceMemoryReportCreateInfoEXT>
{
	public const VkStructureType TYPE = VkStructureType.DeviceDeviceMemoryReportCreateInfoExt;

	public VkStructureType sType;
	public void* pNext;
	public VkDeviceMemoryReportFlagsEXT Flags;
	public delegate* managed<VkDeviceMemoryReportCallbackDataEXT*, void*, void> UserCallback;
	public void* UserData;

	public VkDeviceDeviceMemoryReportCreateInfoEXT(
		VkDeviceMemoryReportFlagsEXT flags = default,
		delegate* managed<VkDeviceMemoryReportCallbackDataEXT*, void*, void> userCallback = default,
		void* userData = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		UserCallback = userCallback;
		UserData = userData;
	}

	public readonly override bool Equals(object? o) => (o is VkDeviceDeviceMemoryReportCreateInfoEXT s) && (this == s);
	readonly bool IEquatable<VkDeviceDeviceMemoryReportCreateInfoEXT>.Equals(VkDeviceDeviceMemoryReportCreateInfoEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ ((ulong)UserCallback).GetHashCode()
			^ ((ulong)UserData).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDeviceDeviceMemoryReportCreateInfoEXT l, in VkDeviceDeviceMemoryReportCreateInfoEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.UserCallback == r.UserCallback)
			&& (l.UserData == r.UserData)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDeviceDeviceMemoryReportCreateInfoEXT l, in VkDeviceDeviceMemoryReportCreateInfoEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.UserCallback != r.UserCallback)
			|| (l.UserData != r.UserData)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDeviceDeviceMemoryReportCreateInfoEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDeviceMemoryReportCallbackDataEXT : IEquatable<VkDeviceMemoryReportCallbackDataEXT>
{
	public const VkStructureType TYPE = VkStructureType.DeviceMemoryReportCallbackDataExt;

	public VkStructureType sType;
	public void* pNext;
	public VkDeviceMemoryReportFlagsEXT Flags;
	public VkDeviceMemoryReportEventTypeEXT Type;
	public ulong MemoryObjectId;
	public ulong Size;
	public VkObjectType ObjectType;
	public ulong ObjectHandle;
	public uint HeapIndex;

	public VkDeviceMemoryReportCallbackDataEXT(
		VkDeviceMemoryReportFlagsEXT flags = default,
		VkDeviceMemoryReportEventTypeEXT type = default,
		ulong memoryObjectId = default,
		ulong size = default,
		VkObjectType objectType = default,
		ulong objectHandle = default,
		uint heapIndex = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		Type = type;
		MemoryObjectId = memoryObjectId;
		Size = size;
		ObjectType = objectType;
		ObjectHandle = objectHandle;
		HeapIndex = heapIndex;
	}

	public readonly override bool Equals(object? o) => (o is VkDeviceMemoryReportCallbackDataEXT s) && (this == s);
	readonly bool IEquatable<VkDeviceMemoryReportCallbackDataEXT>.Equals(VkDeviceMemoryReportCallbackDataEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ Type.GetHashCode()
			^ MemoryObjectId.GetHashCode() ^ Size.GetHashCode() ^ ObjectType.GetHashCode() ^ ObjectHandle.GetHashCode()
			^ HeapIndex.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDeviceMemoryReportCallbackDataEXT l, in VkDeviceMemoryReportCallbackDataEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.Type == r.Type)
			&& (l.MemoryObjectId == r.MemoryObjectId) && (l.Size == r.Size) && (l.ObjectType == r.ObjectType) && (l.ObjectHandle == r.ObjectHandle)
			&& (l.HeapIndex == r.HeapIndex)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDeviceMemoryReportCallbackDataEXT l, in VkDeviceMemoryReportCallbackDataEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.Type != r.Type)
			|| (l.MemoryObjectId != r.MemoryObjectId) || (l.Size != r.Size) || (l.ObjectType != r.ObjectType) || (l.ObjectHandle != r.ObjectHandle)
			|| (l.HeapIndex != r.HeapIndex)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDeviceMemoryReportCallbackDataEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkImportMemoryHostPointerInfoEXT : IEquatable<VkImportMemoryHostPointerInfoEXT>
{
	public const VkStructureType TYPE = VkStructureType.ImportMemoryHostPointerInfoExt;

	public VkStructureType sType;
	public void* pNext;
	public VkExternalMemoryHandleTypeFlags HandleType;
	public void* HostPointer;

	public VkImportMemoryHostPointerInfoEXT(
		VkExternalMemoryHandleTypeFlags handleType = default,
		void* hostPointer = default
	) {
		sType = TYPE;
		pNext = null;
		HandleType = handleType;
		HostPointer = hostPointer;
	}

	public readonly override bool Equals(object? o) => (o is VkImportMemoryHostPointerInfoEXT s) && (this == s);
	readonly bool IEquatable<VkImportMemoryHostPointerInfoEXT>.Equals(VkImportMemoryHostPointerInfoEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ HandleType.GetHashCode() ^ ((ulong)HostPointer).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkImportMemoryHostPointerInfoEXT l, in VkImportMemoryHostPointerInfoEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.HandleType == r.HandleType) && (l.HostPointer == r.HostPointer)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkImportMemoryHostPointerInfoEXT l, in VkImportMemoryHostPointerInfoEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.HandleType != r.HandleType) || (l.HostPointer != r.HostPointer)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkImportMemoryHostPointerInfoEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkMemoryHostPointerPropertiesEXT : IEquatable<VkMemoryHostPointerPropertiesEXT>
{
	public const VkStructureType TYPE = VkStructureType.MemoryHostPointerPropertiesExt;

	public VkStructureType sType;
	public void* pNext;
	public uint MemoryTypeBits;

	public VkMemoryHostPointerPropertiesEXT(
		uint memoryTypeBits = default
	) {
		sType = TYPE;
		pNext = null;
		MemoryTypeBits = memoryTypeBits;
	}

	public readonly override bool Equals(object? o) => (o is VkMemoryHostPointerPropertiesEXT s) && (this == s);
	readonly bool IEquatable<VkMemoryHostPointerPropertiesEXT>.Equals(VkMemoryHostPointerPropertiesEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MemoryTypeBits.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkMemoryHostPointerPropertiesEXT l, in VkMemoryHostPointerPropertiesEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MemoryTypeBits == r.MemoryTypeBits)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkMemoryHostPointerPropertiesEXT l, in VkMemoryHostPointerPropertiesEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MemoryTypeBits != r.MemoryTypeBits)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkMemoryHostPointerPropertiesEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceExternalMemoryHostPropertiesEXT : IEquatable<VkPhysicalDeviceExternalMemoryHostPropertiesEXT>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceExternalMemoryHostPropertiesExt;

	public VkStructureType sType;
	public void* pNext;
	public ulong MinImportedHostPointerAlignment;

	public VkPhysicalDeviceExternalMemoryHostPropertiesEXT(
		ulong minImportedHostPointerAlignment = default
	) {
		sType = TYPE;
		pNext = null;
		MinImportedHostPointerAlignment = minImportedHostPointerAlignment;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceExternalMemoryHostPropertiesEXT s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceExternalMemoryHostPropertiesEXT>.Equals(VkPhysicalDeviceExternalMemoryHostPropertiesEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MinImportedHostPointerAlignment.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceExternalMemoryHostPropertiesEXT l, in VkPhysicalDeviceExternalMemoryHostPropertiesEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MinImportedHostPointerAlignment == r.MinImportedHostPointerAlignment)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceExternalMemoryHostPropertiesEXT l, in VkPhysicalDeviceExternalMemoryHostPropertiesEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MinImportedHostPointerAlignment != r.MinImportedHostPointerAlignment)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceExternalMemoryHostPropertiesEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceConservativeRasterizationPropertiesEXT : IEquatable<VkPhysicalDeviceConservativeRasterizationPropertiesEXT>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceConservativeRasterizationPropertiesExt;

	public VkStructureType sType;
	public void* pNext;
	public float PrimitiveOverestimationSize;
	public float MaxExtraPrimitiveOverestimationSize;
	public float ExtraPrimitiveOverestimationSizeGranularity;
	public VkBool32 PrimitiveUnderestimation;
	public VkBool32 ConservativePointAndLineRasterization;
	public VkBool32 DegenerateTrianglesRasterized;
	public VkBool32 DegenerateLinesRasterized;
	public VkBool32 FullyCoveredFragmentShaderInputVariable;
	public VkBool32 ConservativeRasterizationPostDepthCoverage;

	public VkPhysicalDeviceConservativeRasterizationPropertiesEXT(
		float primitiveOverestimationSize = default,
		float maxExtraPrimitiveOverestimationSize = default,
		float extraPrimitiveOverestimationSizeGranularity = default,
		VkBool32 primitiveUnderestimation = default,
		VkBool32 conservativePointAndLineRasterization = default,
		VkBool32 degenerateTrianglesRasterized = default,
		VkBool32 degenerateLinesRasterized = default,
		VkBool32 fullyCoveredFragmentShaderInputVariable = default,
		VkBool32 conservativeRasterizationPostDepthCoverage = default
	) {
		sType = TYPE;
		pNext = null;
		PrimitiveOverestimationSize = primitiveOverestimationSize;
		MaxExtraPrimitiveOverestimationSize = maxExtraPrimitiveOverestimationSize;
		ExtraPrimitiveOverestimationSizeGranularity = extraPrimitiveOverestimationSizeGranularity;
		PrimitiveUnderestimation = primitiveUnderestimation;
		ConservativePointAndLineRasterization = conservativePointAndLineRasterization;
		DegenerateTrianglesRasterized = degenerateTrianglesRasterized;
		DegenerateLinesRasterized = degenerateLinesRasterized;
		FullyCoveredFragmentShaderInputVariable = fullyCoveredFragmentShaderInputVariable;
		ConservativeRasterizationPostDepthCoverage = conservativeRasterizationPostDepthCoverage;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceConservativeRasterizationPropertiesEXT s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceConservativeRasterizationPropertiesEXT>.Equals(VkPhysicalDeviceConservativeRasterizationPropertiesEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ PrimitiveOverestimationSize.GetHashCode() ^ MaxExtraPrimitiveOverestimationSize.GetHashCode()
			^ ExtraPrimitiveOverestimationSizeGranularity.GetHashCode() ^ PrimitiveUnderestimation.GetHashCode() ^ ConservativePointAndLineRasterization.GetHashCode() ^ DegenerateTrianglesRasterized.GetHashCode()
			^ DegenerateLinesRasterized.GetHashCode() ^ FullyCoveredFragmentShaderInputVariable.GetHashCode() ^ ConservativeRasterizationPostDepthCoverage.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceConservativeRasterizationPropertiesEXT l, in VkPhysicalDeviceConservativeRasterizationPropertiesEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.PrimitiveOverestimationSize == r.PrimitiveOverestimationSize) && (l.MaxExtraPrimitiveOverestimationSize == r.MaxExtraPrimitiveOverestimationSize)
			&& (l.ExtraPrimitiveOverestimationSizeGranularity == r.ExtraPrimitiveOverestimationSizeGranularity) && (l.PrimitiveUnderestimation == r.PrimitiveUnderestimation) && (l.ConservativePointAndLineRasterization == r.ConservativePointAndLineRasterization) && (l.DegenerateTrianglesRasterized == r.DegenerateTrianglesRasterized)
			&& (l.DegenerateLinesRasterized == r.DegenerateLinesRasterized) && (l.FullyCoveredFragmentShaderInputVariable == r.FullyCoveredFragmentShaderInputVariable) && (l.ConservativeRasterizationPostDepthCoverage == r.ConservativeRasterizationPostDepthCoverage)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceConservativeRasterizationPropertiesEXT l, in VkPhysicalDeviceConservativeRasterizationPropertiesEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.PrimitiveOverestimationSize != r.PrimitiveOverestimationSize) || (l.MaxExtraPrimitiveOverestimationSize != r.MaxExtraPrimitiveOverestimationSize)
			|| (l.ExtraPrimitiveOverestimationSizeGranularity != r.ExtraPrimitiveOverestimationSizeGranularity) || (l.PrimitiveUnderestimation != r.PrimitiveUnderestimation) || (l.ConservativePointAndLineRasterization != r.ConservativePointAndLineRasterization) || (l.DegenerateTrianglesRasterized != r.DegenerateTrianglesRasterized)
			|| (l.DegenerateLinesRasterized != r.DegenerateLinesRasterized) || (l.FullyCoveredFragmentShaderInputVariable != r.FullyCoveredFragmentShaderInputVariable) || (l.ConservativeRasterizationPostDepthCoverage != r.ConservativeRasterizationPostDepthCoverage)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceConservativeRasterizationPropertiesEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkCalibratedTimestampInfoEXT : IEquatable<VkCalibratedTimestampInfoEXT>
{
	public const VkStructureType TYPE = VkStructureType.CalibratedTimestampInfoExt;

	public VkStructureType sType;
	public void* pNext;
	public VkTimeDomainEXT TimeDomain;

	public VkCalibratedTimestampInfoEXT(
		VkTimeDomainEXT timeDomain = default
	) {
		sType = TYPE;
		pNext = null;
		TimeDomain = timeDomain;
	}

	public readonly override bool Equals(object? o) => (o is VkCalibratedTimestampInfoEXT s) && (this == s);
	readonly bool IEquatable<VkCalibratedTimestampInfoEXT>.Equals(VkCalibratedTimestampInfoEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ TimeDomain.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkCalibratedTimestampInfoEXT l, in VkCalibratedTimestampInfoEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.TimeDomain == r.TimeDomain)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkCalibratedTimestampInfoEXT l, in VkCalibratedTimestampInfoEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.TimeDomain != r.TimeDomain)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkCalibratedTimestampInfoEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPipelineRasterizationConservativeStateCreateInfoEXT : IEquatable<VkPipelineRasterizationConservativeStateCreateInfoEXT>
{
	public const VkStructureType TYPE = VkStructureType.PipelineRasterizationConservativeStateCreateInfoExt;

	public VkStructureType sType;
	public void* pNext;
	public VkPipelineRasterizationConservativeStateCreateFlagsEXT Flags;
	public VkConservativeRasterizationModeEXT ConservativeRasterizationMode;
	public float ExtraPrimitiveOverestimationSize;

	public VkPipelineRasterizationConservativeStateCreateInfoEXT(
		VkPipelineRasterizationConservativeStateCreateFlagsEXT flags = default,
		VkConservativeRasterizationModeEXT conservativeRasterizationMode = default,
		float extraPrimitiveOverestimationSize = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		ConservativeRasterizationMode = conservativeRasterizationMode;
		ExtraPrimitiveOverestimationSize = extraPrimitiveOverestimationSize;
	}

	public readonly override bool Equals(object? o) => (o is VkPipelineRasterizationConservativeStateCreateInfoEXT s) && (this == s);
	readonly bool IEquatable<VkPipelineRasterizationConservativeStateCreateInfoEXT>.Equals(VkPipelineRasterizationConservativeStateCreateInfoEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ ConservativeRasterizationMode.GetHashCode()
			^ ExtraPrimitiveOverestimationSize.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPipelineRasterizationConservativeStateCreateInfoEXT l, in VkPipelineRasterizationConservativeStateCreateInfoEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.ConservativeRasterizationMode == r.ConservativeRasterizationMode)
			&& (l.ExtraPrimitiveOverestimationSize == r.ExtraPrimitiveOverestimationSize)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPipelineRasterizationConservativeStateCreateInfoEXT l, in VkPipelineRasterizationConservativeStateCreateInfoEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.ConservativeRasterizationMode != r.ConservativeRasterizationMode)
			|| (l.ExtraPrimitiveOverestimationSize != r.ExtraPrimitiveOverestimationSize)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPipelineRasterizationConservativeStateCreateInfoEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceDescriptorIndexingFeaturesEXT : IEquatable<VkPhysicalDeviceDescriptorIndexingFeaturesEXT>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceDescriptorIndexingFeatures;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 ShaderInputAttachmentArrayDynamicIndexing;
	public VkBool32 ShaderUniformTexelBufferArrayDynamicIndexing;
	public VkBool32 ShaderStorageTexelBufferArrayDynamicIndexing;
	public VkBool32 ShaderUniformBufferArrayNonUniformIndexing;
	public VkBool32 ShaderSampledImageArrayNonUniformIndexing;
	public VkBool32 ShaderStorageBufferArrayNonUniformIndexing;
	public VkBool32 ShaderStorageImageArrayNonUniformIndexing;
	public VkBool32 ShaderInputAttachmentArrayNonUniformIndexing;
	public VkBool32 ShaderUniformTexelBufferArrayNonUniformIndexing;
	public VkBool32 ShaderStorageTexelBufferArrayNonUniformIndexing;
	public VkBool32 DescriptorBindingUniformBufferUpdateAfterBind;
	public VkBool32 DescriptorBindingSampledImageUpdateAfterBind;
	public VkBool32 DescriptorBindingStorageImageUpdateAfterBind;
	public VkBool32 DescriptorBindingStorageBufferUpdateAfterBind;
	public VkBool32 DescriptorBindingUniformTexelBufferUpdateAfterBind;
	public VkBool32 DescriptorBindingStorageTexelBufferUpdateAfterBind;
	public VkBool32 DescriptorBindingUpdateUnusedWhilePending;
	public VkBool32 DescriptorBindingPartiallyBound;
	public VkBool32 DescriptorBindingVariableDescriptorCount;
	public VkBool32 RuntimeDescriptorArray;

	public VkPhysicalDeviceDescriptorIndexingFeaturesEXT(
		VkBool32 shaderInputAttachmentArrayDynamicIndexing = default,
		VkBool32 shaderUniformTexelBufferArrayDynamicIndexing = default,
		VkBool32 shaderStorageTexelBufferArrayDynamicIndexing = default,
		VkBool32 shaderUniformBufferArrayNonUniformIndexing = default,
		VkBool32 shaderSampledImageArrayNonUniformIndexing = default,
		VkBool32 shaderStorageBufferArrayNonUniformIndexing = default,
		VkBool32 shaderStorageImageArrayNonUniformIndexing = default,
		VkBool32 shaderInputAttachmentArrayNonUniformIndexing = default,
		VkBool32 shaderUniformTexelBufferArrayNonUniformIndexing = default,
		VkBool32 shaderStorageTexelBufferArrayNonUniformIndexing = default,
		VkBool32 descriptorBindingUniformBufferUpdateAfterBind = default,
		VkBool32 descriptorBindingSampledImageUpdateAfterBind = default,
		VkBool32 descriptorBindingStorageImageUpdateAfterBind = default,
		VkBool32 descriptorBindingStorageBufferUpdateAfterBind = default,
		VkBool32 descriptorBindingUniformTexelBufferUpdateAfterBind = default,
		VkBool32 descriptorBindingStorageTexelBufferUpdateAfterBind = default,
		VkBool32 descriptorBindingUpdateUnusedWhilePending = default,
		VkBool32 descriptorBindingPartiallyBound = default,
		VkBool32 descriptorBindingVariableDescriptorCount = default,
		VkBool32 runtimeDescriptorArray = default
	) {
		sType = TYPE;
		pNext = null;
		ShaderInputAttachmentArrayDynamicIndexing = shaderInputAttachmentArrayDynamicIndexing;
		ShaderUniformTexelBufferArrayDynamicIndexing = shaderUniformTexelBufferArrayDynamicIndexing;
		ShaderStorageTexelBufferArrayDynamicIndexing = shaderStorageTexelBufferArrayDynamicIndexing;
		ShaderUniformBufferArrayNonUniformIndexing = shaderUniformBufferArrayNonUniformIndexing;
		ShaderSampledImageArrayNonUniformIndexing = shaderSampledImageArrayNonUniformIndexing;
		ShaderStorageBufferArrayNonUniformIndexing = shaderStorageBufferArrayNonUniformIndexing;
		ShaderStorageImageArrayNonUniformIndexing = shaderStorageImageArrayNonUniformIndexing;
		ShaderInputAttachmentArrayNonUniformIndexing = shaderInputAttachmentArrayNonUniformIndexing;
		ShaderUniformTexelBufferArrayNonUniformIndexing = shaderUniformTexelBufferArrayNonUniformIndexing;
		ShaderStorageTexelBufferArrayNonUniformIndexing = shaderStorageTexelBufferArrayNonUniformIndexing;
		DescriptorBindingUniformBufferUpdateAfterBind = descriptorBindingUniformBufferUpdateAfterBind;
		DescriptorBindingSampledImageUpdateAfterBind = descriptorBindingSampledImageUpdateAfterBind;
		DescriptorBindingStorageImageUpdateAfterBind = descriptorBindingStorageImageUpdateAfterBind;
		DescriptorBindingStorageBufferUpdateAfterBind = descriptorBindingStorageBufferUpdateAfterBind;
		DescriptorBindingUniformTexelBufferUpdateAfterBind = descriptorBindingUniformTexelBufferUpdateAfterBind;
		DescriptorBindingStorageTexelBufferUpdateAfterBind = descriptorBindingStorageTexelBufferUpdateAfterBind;
		DescriptorBindingUpdateUnusedWhilePending = descriptorBindingUpdateUnusedWhilePending;
		DescriptorBindingPartiallyBound = descriptorBindingPartiallyBound;
		DescriptorBindingVariableDescriptorCount = descriptorBindingVariableDescriptorCount;
		RuntimeDescriptorArray = runtimeDescriptorArray;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceDescriptorIndexingFeaturesEXT s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceDescriptorIndexingFeaturesEXT>.Equals(VkPhysicalDeviceDescriptorIndexingFeaturesEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ShaderInputAttachmentArrayDynamicIndexing.GetHashCode() ^ ShaderUniformTexelBufferArrayDynamicIndexing.GetHashCode()
			^ ShaderStorageTexelBufferArrayDynamicIndexing.GetHashCode() ^ ShaderUniformBufferArrayNonUniformIndexing.GetHashCode() ^ ShaderSampledImageArrayNonUniformIndexing.GetHashCode() ^ ShaderStorageBufferArrayNonUniformIndexing.GetHashCode()
			^ ShaderStorageImageArrayNonUniformIndexing.GetHashCode() ^ ShaderInputAttachmentArrayNonUniformIndexing.GetHashCode() ^ ShaderUniformTexelBufferArrayNonUniformIndexing.GetHashCode() ^ ShaderStorageTexelBufferArrayNonUniformIndexing.GetHashCode()
			^ DescriptorBindingUniformBufferUpdateAfterBind.GetHashCode() ^ DescriptorBindingSampledImageUpdateAfterBind.GetHashCode() ^ DescriptorBindingStorageImageUpdateAfterBind.GetHashCode() ^ DescriptorBindingStorageBufferUpdateAfterBind.GetHashCode()
			^ DescriptorBindingUniformTexelBufferUpdateAfterBind.GetHashCode() ^ DescriptorBindingStorageTexelBufferUpdateAfterBind.GetHashCode() ^ DescriptorBindingUpdateUnusedWhilePending.GetHashCode() ^ DescriptorBindingPartiallyBound.GetHashCode()
			^ DescriptorBindingVariableDescriptorCount.GetHashCode() ^ RuntimeDescriptorArray.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceDescriptorIndexingFeaturesEXT l, in VkPhysicalDeviceDescriptorIndexingFeaturesEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ShaderInputAttachmentArrayDynamicIndexing == r.ShaderInputAttachmentArrayDynamicIndexing) && (l.ShaderUniformTexelBufferArrayDynamicIndexing == r.ShaderUniformTexelBufferArrayDynamicIndexing)
			&& (l.ShaderStorageTexelBufferArrayDynamicIndexing == r.ShaderStorageTexelBufferArrayDynamicIndexing) && (l.ShaderUniformBufferArrayNonUniformIndexing == r.ShaderUniformBufferArrayNonUniformIndexing) && (l.ShaderSampledImageArrayNonUniformIndexing == r.ShaderSampledImageArrayNonUniformIndexing) && (l.ShaderStorageBufferArrayNonUniformIndexing == r.ShaderStorageBufferArrayNonUniformIndexing)
			&& (l.ShaderStorageImageArrayNonUniformIndexing == r.ShaderStorageImageArrayNonUniformIndexing) && (l.ShaderInputAttachmentArrayNonUniformIndexing == r.ShaderInputAttachmentArrayNonUniformIndexing) && (l.ShaderUniformTexelBufferArrayNonUniformIndexing == r.ShaderUniformTexelBufferArrayNonUniformIndexing) && (l.ShaderStorageTexelBufferArrayNonUniformIndexing == r.ShaderStorageTexelBufferArrayNonUniformIndexing)
			&& (l.DescriptorBindingUniformBufferUpdateAfterBind == r.DescriptorBindingUniformBufferUpdateAfterBind) && (l.DescriptorBindingSampledImageUpdateAfterBind == r.DescriptorBindingSampledImageUpdateAfterBind) && (l.DescriptorBindingStorageImageUpdateAfterBind == r.DescriptorBindingStorageImageUpdateAfterBind) && (l.DescriptorBindingStorageBufferUpdateAfterBind == r.DescriptorBindingStorageBufferUpdateAfterBind)
			&& (l.DescriptorBindingUniformTexelBufferUpdateAfterBind == r.DescriptorBindingUniformTexelBufferUpdateAfterBind) && (l.DescriptorBindingStorageTexelBufferUpdateAfterBind == r.DescriptorBindingStorageTexelBufferUpdateAfterBind) && (l.DescriptorBindingUpdateUnusedWhilePending == r.DescriptorBindingUpdateUnusedWhilePending) && (l.DescriptorBindingPartiallyBound == r.DescriptorBindingPartiallyBound)
			&& (l.DescriptorBindingVariableDescriptorCount == r.DescriptorBindingVariableDescriptorCount) && (l.RuntimeDescriptorArray == r.RuntimeDescriptorArray)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceDescriptorIndexingFeaturesEXT l, in VkPhysicalDeviceDescriptorIndexingFeaturesEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ShaderInputAttachmentArrayDynamicIndexing != r.ShaderInputAttachmentArrayDynamicIndexing) || (l.ShaderUniformTexelBufferArrayDynamicIndexing != r.ShaderUniformTexelBufferArrayDynamicIndexing)
			|| (l.ShaderStorageTexelBufferArrayDynamicIndexing != r.ShaderStorageTexelBufferArrayDynamicIndexing) || (l.ShaderUniformBufferArrayNonUniformIndexing != r.ShaderUniformBufferArrayNonUniformIndexing) || (l.ShaderSampledImageArrayNonUniformIndexing != r.ShaderSampledImageArrayNonUniformIndexing) || (l.ShaderStorageBufferArrayNonUniformIndexing != r.ShaderStorageBufferArrayNonUniformIndexing)
			|| (l.ShaderStorageImageArrayNonUniformIndexing != r.ShaderStorageImageArrayNonUniformIndexing) || (l.ShaderInputAttachmentArrayNonUniformIndexing != r.ShaderInputAttachmentArrayNonUniformIndexing) || (l.ShaderUniformTexelBufferArrayNonUniformIndexing != r.ShaderUniformTexelBufferArrayNonUniformIndexing) || (l.ShaderStorageTexelBufferArrayNonUniformIndexing != r.ShaderStorageTexelBufferArrayNonUniformIndexing)
			|| (l.DescriptorBindingUniformBufferUpdateAfterBind != r.DescriptorBindingUniformBufferUpdateAfterBind) || (l.DescriptorBindingSampledImageUpdateAfterBind != r.DescriptorBindingSampledImageUpdateAfterBind) || (l.DescriptorBindingStorageImageUpdateAfterBind != r.DescriptorBindingStorageImageUpdateAfterBind) || (l.DescriptorBindingStorageBufferUpdateAfterBind != r.DescriptorBindingStorageBufferUpdateAfterBind)
			|| (l.DescriptorBindingUniformTexelBufferUpdateAfterBind != r.DescriptorBindingUniformTexelBufferUpdateAfterBind) || (l.DescriptorBindingStorageTexelBufferUpdateAfterBind != r.DescriptorBindingStorageTexelBufferUpdateAfterBind) || (l.DescriptorBindingUpdateUnusedWhilePending != r.DescriptorBindingUpdateUnusedWhilePending) || (l.DescriptorBindingPartiallyBound != r.DescriptorBindingPartiallyBound)
			|| (l.DescriptorBindingVariableDescriptorCount != r.DescriptorBindingVariableDescriptorCount) || (l.RuntimeDescriptorArray != r.RuntimeDescriptorArray)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceDescriptorIndexingFeaturesEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceDescriptorIndexingPropertiesEXT : IEquatable<VkPhysicalDeviceDescriptorIndexingPropertiesEXT>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceDescriptorIndexingProperties;

	public VkStructureType sType;
	public void* pNext;
	public uint MaxUpdateAfterBindDescriptorsInAllPools;
	public VkBool32 ShaderUniformBufferArrayNonUniformIndexingNative;
	public VkBool32 ShaderSampledImageArrayNonUniformIndexingNative;
	public VkBool32 ShaderStorageBufferArrayNonUniformIndexingNative;
	public VkBool32 ShaderStorageImageArrayNonUniformIndexingNative;
	public VkBool32 ShaderInputAttachmentArrayNonUniformIndexingNative;
	public VkBool32 RobustBufferAccessUpdateAfterBind;
	public VkBool32 QuadDivergentImplicitLod;
	public uint MaxPerStageDescriptorUpdateAfterBindSamplers;
	public uint MaxPerStageDescriptorUpdateAfterBindUniformBuffers;
	public uint MaxPerStageDescriptorUpdateAfterBindStorageBuffers;
	public uint MaxPerStageDescriptorUpdateAfterBindSampledImages;
	public uint MaxPerStageDescriptorUpdateAfterBindStorageImages;
	public uint MaxPerStageDescriptorUpdateAfterBindInputAttachments;
	public uint MaxPerStageUpdateAfterBindResources;
	public uint MaxDescriptorSetUpdateAfterBindSamplers;
	public uint MaxDescriptorSetUpdateAfterBindUniformBuffers;
	public uint MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic;
	public uint MaxDescriptorSetUpdateAfterBindStorageBuffers;
	public uint MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic;
	public uint MaxDescriptorSetUpdateAfterBindSampledImages;
	public uint MaxDescriptorSetUpdateAfterBindStorageImages;
	public uint MaxDescriptorSetUpdateAfterBindInputAttachments;

	public VkPhysicalDeviceDescriptorIndexingPropertiesEXT(
		uint maxUpdateAfterBindDescriptorsInAllPools = default,
		VkBool32 shaderUniformBufferArrayNonUniformIndexingNative = default,
		VkBool32 shaderSampledImageArrayNonUniformIndexingNative = default,
		VkBool32 shaderStorageBufferArrayNonUniformIndexingNative = default,
		VkBool32 shaderStorageImageArrayNonUniformIndexingNative = default,
		VkBool32 shaderInputAttachmentArrayNonUniformIndexingNative = default,
		VkBool32 robustBufferAccessUpdateAfterBind = default,
		VkBool32 quadDivergentImplicitLod = default,
		uint maxPerStageDescriptorUpdateAfterBindSamplers = default,
		uint maxPerStageDescriptorUpdateAfterBindUniformBuffers = default,
		uint maxPerStageDescriptorUpdateAfterBindStorageBuffers = default,
		uint maxPerStageDescriptorUpdateAfterBindSampledImages = default,
		uint maxPerStageDescriptorUpdateAfterBindStorageImages = default,
		uint maxPerStageDescriptorUpdateAfterBindInputAttachments = default,
		uint maxPerStageUpdateAfterBindResources = default,
		uint maxDescriptorSetUpdateAfterBindSamplers = default,
		uint maxDescriptorSetUpdateAfterBindUniformBuffers = default,
		uint maxDescriptorSetUpdateAfterBindUniformBuffersDynamic = default,
		uint maxDescriptorSetUpdateAfterBindStorageBuffers = default,
		uint maxDescriptorSetUpdateAfterBindStorageBuffersDynamic = default,
		uint maxDescriptorSetUpdateAfterBindSampledImages = default,
		uint maxDescriptorSetUpdateAfterBindStorageImages = default,
		uint maxDescriptorSetUpdateAfterBindInputAttachments = default
	) {
		sType = TYPE;
		pNext = null;
		MaxUpdateAfterBindDescriptorsInAllPools = maxUpdateAfterBindDescriptorsInAllPools;
		ShaderUniformBufferArrayNonUniformIndexingNative = shaderUniformBufferArrayNonUniformIndexingNative;
		ShaderSampledImageArrayNonUniformIndexingNative = shaderSampledImageArrayNonUniformIndexingNative;
		ShaderStorageBufferArrayNonUniformIndexingNative = shaderStorageBufferArrayNonUniformIndexingNative;
		ShaderStorageImageArrayNonUniformIndexingNative = shaderStorageImageArrayNonUniformIndexingNative;
		ShaderInputAttachmentArrayNonUniformIndexingNative = shaderInputAttachmentArrayNonUniformIndexingNative;
		RobustBufferAccessUpdateAfterBind = robustBufferAccessUpdateAfterBind;
		QuadDivergentImplicitLod = quadDivergentImplicitLod;
		MaxPerStageDescriptorUpdateAfterBindSamplers = maxPerStageDescriptorUpdateAfterBindSamplers;
		MaxPerStageDescriptorUpdateAfterBindUniformBuffers = maxPerStageDescriptorUpdateAfterBindUniformBuffers;
		MaxPerStageDescriptorUpdateAfterBindStorageBuffers = maxPerStageDescriptorUpdateAfterBindStorageBuffers;
		MaxPerStageDescriptorUpdateAfterBindSampledImages = maxPerStageDescriptorUpdateAfterBindSampledImages;
		MaxPerStageDescriptorUpdateAfterBindStorageImages = maxPerStageDescriptorUpdateAfterBindStorageImages;
		MaxPerStageDescriptorUpdateAfterBindInputAttachments = maxPerStageDescriptorUpdateAfterBindInputAttachments;
		MaxPerStageUpdateAfterBindResources = maxPerStageUpdateAfterBindResources;
		MaxDescriptorSetUpdateAfterBindSamplers = maxDescriptorSetUpdateAfterBindSamplers;
		MaxDescriptorSetUpdateAfterBindUniformBuffers = maxDescriptorSetUpdateAfterBindUniformBuffers;
		MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic = maxDescriptorSetUpdateAfterBindUniformBuffersDynamic;
		MaxDescriptorSetUpdateAfterBindStorageBuffers = maxDescriptorSetUpdateAfterBindStorageBuffers;
		MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic = maxDescriptorSetUpdateAfterBindStorageBuffersDynamic;
		MaxDescriptorSetUpdateAfterBindSampledImages = maxDescriptorSetUpdateAfterBindSampledImages;
		MaxDescriptorSetUpdateAfterBindStorageImages = maxDescriptorSetUpdateAfterBindStorageImages;
		MaxDescriptorSetUpdateAfterBindInputAttachments = maxDescriptorSetUpdateAfterBindInputAttachments;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceDescriptorIndexingPropertiesEXT s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceDescriptorIndexingPropertiesEXT>.Equals(VkPhysicalDeviceDescriptorIndexingPropertiesEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MaxUpdateAfterBindDescriptorsInAllPools.GetHashCode() ^ ShaderUniformBufferArrayNonUniformIndexingNative.GetHashCode()
			^ ShaderSampledImageArrayNonUniformIndexingNative.GetHashCode() ^ ShaderStorageBufferArrayNonUniformIndexingNative.GetHashCode() ^ ShaderStorageImageArrayNonUniformIndexingNative.GetHashCode() ^ ShaderInputAttachmentArrayNonUniformIndexingNative.GetHashCode()
			^ RobustBufferAccessUpdateAfterBind.GetHashCode() ^ QuadDivergentImplicitLod.GetHashCode() ^ MaxPerStageDescriptorUpdateAfterBindSamplers.GetHashCode() ^ MaxPerStageDescriptorUpdateAfterBindUniformBuffers.GetHashCode()
			^ MaxPerStageDescriptorUpdateAfterBindStorageBuffers.GetHashCode() ^ MaxPerStageDescriptorUpdateAfterBindSampledImages.GetHashCode() ^ MaxPerStageDescriptorUpdateAfterBindStorageImages.GetHashCode() ^ MaxPerStageDescriptorUpdateAfterBindInputAttachments.GetHashCode()
			^ MaxPerStageUpdateAfterBindResources.GetHashCode() ^ MaxDescriptorSetUpdateAfterBindSamplers.GetHashCode() ^ MaxDescriptorSetUpdateAfterBindUniformBuffers.GetHashCode() ^ MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic.GetHashCode()
			^ MaxDescriptorSetUpdateAfterBindStorageBuffers.GetHashCode() ^ MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic.GetHashCode() ^ MaxDescriptorSetUpdateAfterBindSampledImages.GetHashCode() ^ MaxDescriptorSetUpdateAfterBindStorageImages.GetHashCode()
			^ MaxDescriptorSetUpdateAfterBindInputAttachments.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceDescriptorIndexingPropertiesEXT l, in VkPhysicalDeviceDescriptorIndexingPropertiesEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MaxUpdateAfterBindDescriptorsInAllPools == r.MaxUpdateAfterBindDescriptorsInAllPools) && (l.ShaderUniformBufferArrayNonUniformIndexingNative == r.ShaderUniformBufferArrayNonUniformIndexingNative)
			&& (l.ShaderSampledImageArrayNonUniformIndexingNative == r.ShaderSampledImageArrayNonUniformIndexingNative) && (l.ShaderStorageBufferArrayNonUniformIndexingNative == r.ShaderStorageBufferArrayNonUniformIndexingNative) && (l.ShaderStorageImageArrayNonUniformIndexingNative == r.ShaderStorageImageArrayNonUniformIndexingNative) && (l.ShaderInputAttachmentArrayNonUniformIndexingNative == r.ShaderInputAttachmentArrayNonUniformIndexingNative)
			&& (l.RobustBufferAccessUpdateAfterBind == r.RobustBufferAccessUpdateAfterBind) && (l.QuadDivergentImplicitLod == r.QuadDivergentImplicitLod) && (l.MaxPerStageDescriptorUpdateAfterBindSamplers == r.MaxPerStageDescriptorUpdateAfterBindSamplers) && (l.MaxPerStageDescriptorUpdateAfterBindUniformBuffers == r.MaxPerStageDescriptorUpdateAfterBindUniformBuffers)
			&& (l.MaxPerStageDescriptorUpdateAfterBindStorageBuffers == r.MaxPerStageDescriptorUpdateAfterBindStorageBuffers) && (l.MaxPerStageDescriptorUpdateAfterBindSampledImages == r.MaxPerStageDescriptorUpdateAfterBindSampledImages) && (l.MaxPerStageDescriptorUpdateAfterBindStorageImages == r.MaxPerStageDescriptorUpdateAfterBindStorageImages) && (l.MaxPerStageDescriptorUpdateAfterBindInputAttachments == r.MaxPerStageDescriptorUpdateAfterBindInputAttachments)
			&& (l.MaxPerStageUpdateAfterBindResources == r.MaxPerStageUpdateAfterBindResources) && (l.MaxDescriptorSetUpdateAfterBindSamplers == r.MaxDescriptorSetUpdateAfterBindSamplers) && (l.MaxDescriptorSetUpdateAfterBindUniformBuffers == r.MaxDescriptorSetUpdateAfterBindUniformBuffers) && (l.MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic == r.MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic)
			&& (l.MaxDescriptorSetUpdateAfterBindStorageBuffers == r.MaxDescriptorSetUpdateAfterBindStorageBuffers) && (l.MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic == r.MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic) && (l.MaxDescriptorSetUpdateAfterBindSampledImages == r.MaxDescriptorSetUpdateAfterBindSampledImages) && (l.MaxDescriptorSetUpdateAfterBindStorageImages == r.MaxDescriptorSetUpdateAfterBindStorageImages)
			&& (l.MaxDescriptorSetUpdateAfterBindInputAttachments == r.MaxDescriptorSetUpdateAfterBindInputAttachments)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceDescriptorIndexingPropertiesEXT l, in VkPhysicalDeviceDescriptorIndexingPropertiesEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MaxUpdateAfterBindDescriptorsInAllPools != r.MaxUpdateAfterBindDescriptorsInAllPools) || (l.ShaderUniformBufferArrayNonUniformIndexingNative != r.ShaderUniformBufferArrayNonUniformIndexingNative)
			|| (l.ShaderSampledImageArrayNonUniformIndexingNative != r.ShaderSampledImageArrayNonUniformIndexingNative) || (l.ShaderStorageBufferArrayNonUniformIndexingNative != r.ShaderStorageBufferArrayNonUniformIndexingNative) || (l.ShaderStorageImageArrayNonUniformIndexingNative != r.ShaderStorageImageArrayNonUniformIndexingNative) || (l.ShaderInputAttachmentArrayNonUniformIndexingNative != r.ShaderInputAttachmentArrayNonUniformIndexingNative)
			|| (l.RobustBufferAccessUpdateAfterBind != r.RobustBufferAccessUpdateAfterBind) || (l.QuadDivergentImplicitLod != r.QuadDivergentImplicitLod) || (l.MaxPerStageDescriptorUpdateAfterBindSamplers != r.MaxPerStageDescriptorUpdateAfterBindSamplers) || (l.MaxPerStageDescriptorUpdateAfterBindUniformBuffers != r.MaxPerStageDescriptorUpdateAfterBindUniformBuffers)
			|| (l.MaxPerStageDescriptorUpdateAfterBindStorageBuffers != r.MaxPerStageDescriptorUpdateAfterBindStorageBuffers) || (l.MaxPerStageDescriptorUpdateAfterBindSampledImages != r.MaxPerStageDescriptorUpdateAfterBindSampledImages) || (l.MaxPerStageDescriptorUpdateAfterBindStorageImages != r.MaxPerStageDescriptorUpdateAfterBindStorageImages) || (l.MaxPerStageDescriptorUpdateAfterBindInputAttachments != r.MaxPerStageDescriptorUpdateAfterBindInputAttachments)
			|| (l.MaxPerStageUpdateAfterBindResources != r.MaxPerStageUpdateAfterBindResources) || (l.MaxDescriptorSetUpdateAfterBindSamplers != r.MaxDescriptorSetUpdateAfterBindSamplers) || (l.MaxDescriptorSetUpdateAfterBindUniformBuffers != r.MaxDescriptorSetUpdateAfterBindUniformBuffers) || (l.MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic != r.MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic)
			|| (l.MaxDescriptorSetUpdateAfterBindStorageBuffers != r.MaxDescriptorSetUpdateAfterBindStorageBuffers) || (l.MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic != r.MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic) || (l.MaxDescriptorSetUpdateAfterBindSampledImages != r.MaxDescriptorSetUpdateAfterBindSampledImages) || (l.MaxDescriptorSetUpdateAfterBindStorageImages != r.MaxDescriptorSetUpdateAfterBindStorageImages)
			|| (l.MaxDescriptorSetUpdateAfterBindInputAttachments != r.MaxDescriptorSetUpdateAfterBindInputAttachments)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceDescriptorIndexingPropertiesEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDescriptorSetLayoutBindingFlagsCreateInfoEXT : IEquatable<VkDescriptorSetLayoutBindingFlagsCreateInfoEXT>
{
	public const VkStructureType TYPE = VkStructureType.DescriptorSetLayoutBindingFlagsCreateInfo;

	public VkStructureType sType;
	public void* pNext;
	public uint BindingCount;
	public VkDescriptorBindingFlags* BindingFlags;

	public VkDescriptorSetLayoutBindingFlagsCreateInfoEXT(
		uint bindingCount = default,
		VkDescriptorBindingFlags* bindingFlags = default
	) {
		sType = TYPE;
		pNext = null;
		BindingCount = bindingCount;
		BindingFlags = bindingFlags;
	}

	public readonly override bool Equals(object? o) => (o is VkDescriptorSetLayoutBindingFlagsCreateInfoEXT s) && (this == s);
	readonly bool IEquatable<VkDescriptorSetLayoutBindingFlagsCreateInfoEXT>.Equals(VkDescriptorSetLayoutBindingFlagsCreateInfoEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ BindingCount.GetHashCode() ^ ((ulong)BindingFlags).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDescriptorSetLayoutBindingFlagsCreateInfoEXT l, in VkDescriptorSetLayoutBindingFlagsCreateInfoEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.BindingCount == r.BindingCount) && (l.BindingFlags == r.BindingFlags)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDescriptorSetLayoutBindingFlagsCreateInfoEXT l, in VkDescriptorSetLayoutBindingFlagsCreateInfoEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.BindingCount != r.BindingCount) || (l.BindingFlags != r.BindingFlags)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDescriptorSetLayoutBindingFlagsCreateInfoEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDescriptorSetVariableDescriptorCountAllocateInfoEXT : IEquatable<VkDescriptorSetVariableDescriptorCountAllocateInfoEXT>
{
	public const VkStructureType TYPE = VkStructureType.DescriptorSetVariableDescriptorCountAllocateInfo;

	public VkStructureType sType;
	public void* pNext;
	public uint DescriptorSetCount;
	public uint* DescriptorCounts;

	public VkDescriptorSetVariableDescriptorCountAllocateInfoEXT(
		uint descriptorSetCount = default,
		uint* descriptorCounts = default
	) {
		sType = TYPE;
		pNext = null;
		DescriptorSetCount = descriptorSetCount;
		DescriptorCounts = descriptorCounts;
	}

	public readonly override bool Equals(object? o) => (o is VkDescriptorSetVariableDescriptorCountAllocateInfoEXT s) && (this == s);
	readonly bool IEquatable<VkDescriptorSetVariableDescriptorCountAllocateInfoEXT>.Equals(VkDescriptorSetVariableDescriptorCountAllocateInfoEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DescriptorSetCount.GetHashCode() ^ ((ulong)DescriptorCounts).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDescriptorSetVariableDescriptorCountAllocateInfoEXT l, in VkDescriptorSetVariableDescriptorCountAllocateInfoEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DescriptorSetCount == r.DescriptorSetCount) && (l.DescriptorCounts == r.DescriptorCounts)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDescriptorSetVariableDescriptorCountAllocateInfoEXT l, in VkDescriptorSetVariableDescriptorCountAllocateInfoEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DescriptorSetCount != r.DescriptorSetCount) || (l.DescriptorCounts != r.DescriptorCounts)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDescriptorSetVariableDescriptorCountAllocateInfoEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDescriptorSetVariableDescriptorCountLayoutSupportEXT : IEquatable<VkDescriptorSetVariableDescriptorCountLayoutSupportEXT>
{
	public const VkStructureType TYPE = VkStructureType.DescriptorSetVariableDescriptorCountLayoutSupport;

	public VkStructureType sType;
	public void* pNext;
	public uint MaxVariableDescriptorCount;

	public VkDescriptorSetVariableDescriptorCountLayoutSupportEXT(
		uint maxVariableDescriptorCount = default
	) {
		sType = TYPE;
		pNext = null;
		MaxVariableDescriptorCount = maxVariableDescriptorCount;
	}

	public readonly override bool Equals(object? o) => (o is VkDescriptorSetVariableDescriptorCountLayoutSupportEXT s) && (this == s);
	readonly bool IEquatable<VkDescriptorSetVariableDescriptorCountLayoutSupportEXT>.Equals(VkDescriptorSetVariableDescriptorCountLayoutSupportEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MaxVariableDescriptorCount.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDescriptorSetVariableDescriptorCountLayoutSupportEXT l, in VkDescriptorSetVariableDescriptorCountLayoutSupportEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MaxVariableDescriptorCount == r.MaxVariableDescriptorCount)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDescriptorSetVariableDescriptorCountLayoutSupportEXT l, in VkDescriptorSetVariableDescriptorCountLayoutSupportEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MaxVariableDescriptorCount != r.MaxVariableDescriptorCount)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDescriptorSetVariableDescriptorCountLayoutSupportEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkVertexInputBindingDivisorDescriptionEXT : IEquatable<VkVertexInputBindingDivisorDescriptionEXT>
{
	public uint Binding;
	public uint Divisor;

	public VkVertexInputBindingDivisorDescriptionEXT(
		uint binding = default,
		uint divisor = default
	) {
		Binding = binding;
		Divisor = divisor;
	}

	public readonly override bool Equals(object? o) => (o is VkVertexInputBindingDivisorDescriptionEXT s) && (this == s);
	readonly bool IEquatable<VkVertexInputBindingDivisorDescriptionEXT>.Equals(VkVertexInputBindingDivisorDescriptionEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Binding.GetHashCode() ^ Divisor.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkVertexInputBindingDivisorDescriptionEXT l, in VkVertexInputBindingDivisorDescriptionEXT r)
	{
		return
			(l.Binding == r.Binding) && (l.Divisor == r.Divisor)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkVertexInputBindingDivisorDescriptionEXT l, in VkVertexInputBindingDivisorDescriptionEXT r)
	{
		return
			(l.Binding != r.Binding) || (l.Divisor != r.Divisor)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkVertexInputBindingDivisorDescriptionEXT s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPipelineVertexInputDivisorStateCreateInfoEXT : IEquatable<VkPipelineVertexInputDivisorStateCreateInfoEXT>
{
	public const VkStructureType TYPE = VkStructureType.PipelineVertexInputDivisorStateCreateInfoExt;

	public VkStructureType sType;
	public void* pNext;
	public uint VertexBindingDivisorCount;
	public VkVertexInputBindingDivisorDescriptionEXT* VertexBindingDivisors;

	public VkPipelineVertexInputDivisorStateCreateInfoEXT(
		uint vertexBindingDivisorCount = default,
		VkVertexInputBindingDivisorDescriptionEXT* vertexBindingDivisors = default
	) {
		sType = TYPE;
		pNext = null;
		VertexBindingDivisorCount = vertexBindingDivisorCount;
		VertexBindingDivisors = vertexBindingDivisors;
	}

	public readonly override bool Equals(object? o) => (o is VkPipelineVertexInputDivisorStateCreateInfoEXT s) && (this == s);
	readonly bool IEquatable<VkPipelineVertexInputDivisorStateCreateInfoEXT>.Equals(VkPipelineVertexInputDivisorStateCreateInfoEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ VertexBindingDivisorCount.GetHashCode() ^ ((ulong)VertexBindingDivisors).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPipelineVertexInputDivisorStateCreateInfoEXT l, in VkPipelineVertexInputDivisorStateCreateInfoEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.VertexBindingDivisorCount == r.VertexBindingDivisorCount) && (l.VertexBindingDivisors == r.VertexBindingDivisors)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPipelineVertexInputDivisorStateCreateInfoEXT l, in VkPipelineVertexInputDivisorStateCreateInfoEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.VertexBindingDivisorCount != r.VertexBindingDivisorCount) || (l.VertexBindingDivisors != r.VertexBindingDivisors)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPipelineVertexInputDivisorStateCreateInfoEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT : IEquatable<VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceVertexAttributeDivisorPropertiesExt;

	public VkStructureType sType;
	public void* pNext;
	public uint MaxVertexAttribDivisor;

	public VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(
		uint maxVertexAttribDivisor = default
	) {
		sType = TYPE;
		pNext = null;
		MaxVertexAttribDivisor = maxVertexAttribDivisor;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT>.Equals(VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MaxVertexAttribDivisor.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT l, in VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MaxVertexAttribDivisor == r.MaxVertexAttribDivisor)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT l, in VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MaxVertexAttribDivisor != r.MaxVertexAttribDivisor)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDevicePCIBusInfoPropertiesEXT : IEquatable<VkPhysicalDevicePCIBusInfoPropertiesEXT>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDevicePciBusInfoPropertiesExt;

	public VkStructureType sType;
	public void* pNext;
	public uint PciDomain;
	public uint PciBus;
	public uint PciDevice;
	public uint PciFunction;

	public VkPhysicalDevicePCIBusInfoPropertiesEXT(
		uint pciDomain = default,
		uint pciBus = default,
		uint pciDevice = default,
		uint pciFunction = default
	) {
		sType = TYPE;
		pNext = null;
		PciDomain = pciDomain;
		PciBus = pciBus;
		PciDevice = pciDevice;
		PciFunction = pciFunction;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDevicePCIBusInfoPropertiesEXT s) && (this == s);
	readonly bool IEquatable<VkPhysicalDevicePCIBusInfoPropertiesEXT>.Equals(VkPhysicalDevicePCIBusInfoPropertiesEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ PciDomain.GetHashCode() ^ PciBus.GetHashCode()
			^ PciDevice.GetHashCode() ^ PciFunction.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDevicePCIBusInfoPropertiesEXT l, in VkPhysicalDevicePCIBusInfoPropertiesEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.PciDomain == r.PciDomain) && (l.PciBus == r.PciBus)
			&& (l.PciDevice == r.PciDevice) && (l.PciFunction == r.PciFunction)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDevicePCIBusInfoPropertiesEXT l, in VkPhysicalDevicePCIBusInfoPropertiesEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.PciDomain != r.PciDomain) || (l.PciBus != r.PciBus)
			|| (l.PciDevice != r.PciDevice) || (l.PciFunction != r.PciFunction)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDevicePCIBusInfoPropertiesEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkCommandBufferInheritanceConditionalRenderingInfoEXT : IEquatable<VkCommandBufferInheritanceConditionalRenderingInfoEXT>
{
	public const VkStructureType TYPE = VkStructureType.CommandBufferInheritanceConditionalRenderingInfoExt;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 ConditionalRenderingEnable;

	public VkCommandBufferInheritanceConditionalRenderingInfoEXT(
		VkBool32 conditionalRenderingEnable = default
	) {
		sType = TYPE;
		pNext = null;
		ConditionalRenderingEnable = conditionalRenderingEnable;
	}

	public readonly override bool Equals(object? o) => (o is VkCommandBufferInheritanceConditionalRenderingInfoEXT s) && (this == s);
	readonly bool IEquatable<VkCommandBufferInheritanceConditionalRenderingInfoEXT>.Equals(VkCommandBufferInheritanceConditionalRenderingInfoEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ConditionalRenderingEnable.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkCommandBufferInheritanceConditionalRenderingInfoEXT l, in VkCommandBufferInheritanceConditionalRenderingInfoEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ConditionalRenderingEnable == r.ConditionalRenderingEnable)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkCommandBufferInheritanceConditionalRenderingInfoEXT l, in VkCommandBufferInheritanceConditionalRenderingInfoEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ConditionalRenderingEnable != r.ConditionalRenderingEnable)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkCommandBufferInheritanceConditionalRenderingInfoEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceConditionalRenderingFeaturesEXT : IEquatable<VkPhysicalDeviceConditionalRenderingFeaturesEXT>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceConditionalRenderingFeaturesExt;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 ConditionalRendering;
	public VkBool32 InheritedConditionalRendering;

	public VkPhysicalDeviceConditionalRenderingFeaturesEXT(
		VkBool32 conditionalRendering = default,
		VkBool32 inheritedConditionalRendering = default
	) {
		sType = TYPE;
		pNext = null;
		ConditionalRendering = conditionalRendering;
		InheritedConditionalRendering = inheritedConditionalRendering;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceConditionalRenderingFeaturesEXT s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceConditionalRenderingFeaturesEXT>.Equals(VkPhysicalDeviceConditionalRenderingFeaturesEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ConditionalRendering.GetHashCode() ^ InheritedConditionalRendering.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceConditionalRenderingFeaturesEXT l, in VkPhysicalDeviceConditionalRenderingFeaturesEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ConditionalRendering == r.ConditionalRendering) && (l.InheritedConditionalRendering == r.InheritedConditionalRendering)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceConditionalRenderingFeaturesEXT l, in VkPhysicalDeviceConditionalRenderingFeaturesEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ConditionalRendering != r.ConditionalRendering) || (l.InheritedConditionalRendering != r.InheritedConditionalRendering)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceConditionalRenderingFeaturesEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceShaderAtomicFloatFeaturesEXT : IEquatable<VkPhysicalDeviceShaderAtomicFloatFeaturesEXT>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceShaderAtomicFloatFeaturesExt;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 ShaderBufferFloat32Atomics;
	public VkBool32 ShaderBufferFloat32AtomicAdd;
	public VkBool32 ShaderBufferFloat64Atomics;
	public VkBool32 ShaderBufferFloat64AtomicAdd;
	public VkBool32 ShaderSharedFloat32Atomics;
	public VkBool32 ShaderSharedFloat32AtomicAdd;
	public VkBool32 ShaderSharedFloat64Atomics;
	public VkBool32 ShaderSharedFloat64AtomicAdd;
	public VkBool32 ShaderImageFloat32Atomics;
	public VkBool32 ShaderImageFloat32AtomicAdd;
	public VkBool32 SparseImageFloat32Atomics;
	public VkBool32 SparseImageFloat32AtomicAdd;

	public VkPhysicalDeviceShaderAtomicFloatFeaturesEXT(
		VkBool32 shaderBufferFloat32Atomics = default,
		VkBool32 shaderBufferFloat32AtomicAdd = default,
		VkBool32 shaderBufferFloat64Atomics = default,
		VkBool32 shaderBufferFloat64AtomicAdd = default,
		VkBool32 shaderSharedFloat32Atomics = default,
		VkBool32 shaderSharedFloat32AtomicAdd = default,
		VkBool32 shaderSharedFloat64Atomics = default,
		VkBool32 shaderSharedFloat64AtomicAdd = default,
		VkBool32 shaderImageFloat32Atomics = default,
		VkBool32 shaderImageFloat32AtomicAdd = default,
		VkBool32 sparseImageFloat32Atomics = default,
		VkBool32 sparseImageFloat32AtomicAdd = default
	) {
		sType = TYPE;
		pNext = null;
		ShaderBufferFloat32Atomics = shaderBufferFloat32Atomics;
		ShaderBufferFloat32AtomicAdd = shaderBufferFloat32AtomicAdd;
		ShaderBufferFloat64Atomics = shaderBufferFloat64Atomics;
		ShaderBufferFloat64AtomicAdd = shaderBufferFloat64AtomicAdd;
		ShaderSharedFloat32Atomics = shaderSharedFloat32Atomics;
		ShaderSharedFloat32AtomicAdd = shaderSharedFloat32AtomicAdd;
		ShaderSharedFloat64Atomics = shaderSharedFloat64Atomics;
		ShaderSharedFloat64AtomicAdd = shaderSharedFloat64AtomicAdd;
		ShaderImageFloat32Atomics = shaderImageFloat32Atomics;
		ShaderImageFloat32AtomicAdd = shaderImageFloat32AtomicAdd;
		SparseImageFloat32Atomics = sparseImageFloat32Atomics;
		SparseImageFloat32AtomicAdd = sparseImageFloat32AtomicAdd;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceShaderAtomicFloatFeaturesEXT s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceShaderAtomicFloatFeaturesEXT>.Equals(VkPhysicalDeviceShaderAtomicFloatFeaturesEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ShaderBufferFloat32Atomics.GetHashCode() ^ ShaderBufferFloat32AtomicAdd.GetHashCode()
			^ ShaderBufferFloat64Atomics.GetHashCode() ^ ShaderBufferFloat64AtomicAdd.GetHashCode() ^ ShaderSharedFloat32Atomics.GetHashCode() ^ ShaderSharedFloat32AtomicAdd.GetHashCode()
			^ ShaderSharedFloat64Atomics.GetHashCode() ^ ShaderSharedFloat64AtomicAdd.GetHashCode() ^ ShaderImageFloat32Atomics.GetHashCode() ^ ShaderImageFloat32AtomicAdd.GetHashCode()
			^ SparseImageFloat32Atomics.GetHashCode() ^ SparseImageFloat32AtomicAdd.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceShaderAtomicFloatFeaturesEXT l, in VkPhysicalDeviceShaderAtomicFloatFeaturesEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ShaderBufferFloat32Atomics == r.ShaderBufferFloat32Atomics) && (l.ShaderBufferFloat32AtomicAdd == r.ShaderBufferFloat32AtomicAdd)
			&& (l.ShaderBufferFloat64Atomics == r.ShaderBufferFloat64Atomics) && (l.ShaderBufferFloat64AtomicAdd == r.ShaderBufferFloat64AtomicAdd) && (l.ShaderSharedFloat32Atomics == r.ShaderSharedFloat32Atomics) && (l.ShaderSharedFloat32AtomicAdd == r.ShaderSharedFloat32AtomicAdd)
			&& (l.ShaderSharedFloat64Atomics == r.ShaderSharedFloat64Atomics) && (l.ShaderSharedFloat64AtomicAdd == r.ShaderSharedFloat64AtomicAdd) && (l.ShaderImageFloat32Atomics == r.ShaderImageFloat32Atomics) && (l.ShaderImageFloat32AtomicAdd == r.ShaderImageFloat32AtomicAdd)
			&& (l.SparseImageFloat32Atomics == r.SparseImageFloat32Atomics) && (l.SparseImageFloat32AtomicAdd == r.SparseImageFloat32AtomicAdd)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceShaderAtomicFloatFeaturesEXT l, in VkPhysicalDeviceShaderAtomicFloatFeaturesEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ShaderBufferFloat32Atomics != r.ShaderBufferFloat32Atomics) || (l.ShaderBufferFloat32AtomicAdd != r.ShaderBufferFloat32AtomicAdd)
			|| (l.ShaderBufferFloat64Atomics != r.ShaderBufferFloat64Atomics) || (l.ShaderBufferFloat64AtomicAdd != r.ShaderBufferFloat64AtomicAdd) || (l.ShaderSharedFloat32Atomics != r.ShaderSharedFloat32Atomics) || (l.ShaderSharedFloat32AtomicAdd != r.ShaderSharedFloat32AtomicAdd)
			|| (l.ShaderSharedFloat64Atomics != r.ShaderSharedFloat64Atomics) || (l.ShaderSharedFloat64AtomicAdd != r.ShaderSharedFloat64AtomicAdd) || (l.ShaderImageFloat32Atomics != r.ShaderImageFloat32Atomics) || (l.ShaderImageFloat32AtomicAdd != r.ShaderImageFloat32AtomicAdd)
			|| (l.SparseImageFloat32Atomics != r.SparseImageFloat32Atomics) || (l.SparseImageFloat32AtomicAdd != r.SparseImageFloat32AtomicAdd)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceShaderAtomicFloatFeaturesEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT : IEquatable<VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceVertexAttributeDivisorFeaturesExt;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 VertexAttributeInstanceRateDivisor;
	public VkBool32 VertexAttributeInstanceRateZeroDivisor;

	public VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT(
		VkBool32 vertexAttributeInstanceRateDivisor = default,
		VkBool32 vertexAttributeInstanceRateZeroDivisor = default
	) {
		sType = TYPE;
		pNext = null;
		VertexAttributeInstanceRateDivisor = vertexAttributeInstanceRateDivisor;
		VertexAttributeInstanceRateZeroDivisor = vertexAttributeInstanceRateZeroDivisor;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT>.Equals(VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ VertexAttributeInstanceRateDivisor.GetHashCode() ^ VertexAttributeInstanceRateZeroDivisor.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT l, in VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.VertexAttributeInstanceRateDivisor == r.VertexAttributeInstanceRateDivisor) && (l.VertexAttributeInstanceRateZeroDivisor == r.VertexAttributeInstanceRateZeroDivisor)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT l, in VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.VertexAttributeInstanceRateDivisor != r.VertexAttributeInstanceRateDivisor) || (l.VertexAttributeInstanceRateZeroDivisor != r.VertexAttributeInstanceRateZeroDivisor)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkImageViewASTCDecodeModeEXT : IEquatable<VkImageViewASTCDecodeModeEXT>
{
	public const VkStructureType TYPE = VkStructureType.ImageViewAstcDecodeModeExt;

	public VkStructureType sType;
	public void* pNext;
	public VkFormat DecodeMode;

	public VkImageViewASTCDecodeModeEXT(
		VkFormat decodeMode = default
	) {
		sType = TYPE;
		pNext = null;
		DecodeMode = decodeMode;
	}

	public readonly override bool Equals(object? o) => (o is VkImageViewASTCDecodeModeEXT s) && (this == s);
	readonly bool IEquatable<VkImageViewASTCDecodeModeEXT>.Equals(VkImageViewASTCDecodeModeEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DecodeMode.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkImageViewASTCDecodeModeEXT l, in VkImageViewASTCDecodeModeEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DecodeMode == r.DecodeMode)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkImageViewASTCDecodeModeEXT l, in VkImageViewASTCDecodeModeEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DecodeMode != r.DecodeMode)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkImageViewASTCDecodeModeEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceASTCDecodeFeaturesEXT : IEquatable<VkPhysicalDeviceASTCDecodeFeaturesEXT>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceAstcDecodeFeaturesExt;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 DecodeModeSharedExponent;

	public VkPhysicalDeviceASTCDecodeFeaturesEXT(
		VkBool32 decodeModeSharedExponent = default
	) {
		sType = TYPE;
		pNext = null;
		DecodeModeSharedExponent = decodeModeSharedExponent;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceASTCDecodeFeaturesEXT s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceASTCDecodeFeaturesEXT>.Equals(VkPhysicalDeviceASTCDecodeFeaturesEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DecodeModeSharedExponent.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceASTCDecodeFeaturesEXT l, in VkPhysicalDeviceASTCDecodeFeaturesEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DecodeModeSharedExponent == r.DecodeModeSharedExponent)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceASTCDecodeFeaturesEXT l, in VkPhysicalDeviceASTCDecodeFeaturesEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DecodeModeSharedExponent != r.DecodeModeSharedExponent)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceASTCDecodeFeaturesEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceTransformFeedbackFeaturesEXT : IEquatable<VkPhysicalDeviceTransformFeedbackFeaturesEXT>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceTransformFeedbackFeaturesExt;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 TransformFeedback;
	public VkBool32 GeometryStreams;

	public VkPhysicalDeviceTransformFeedbackFeaturesEXT(
		VkBool32 transformFeedback = default,
		VkBool32 geometryStreams = default
	) {
		sType = TYPE;
		pNext = null;
		TransformFeedback = transformFeedback;
		GeometryStreams = geometryStreams;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceTransformFeedbackFeaturesEXT s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceTransformFeedbackFeaturesEXT>.Equals(VkPhysicalDeviceTransformFeedbackFeaturesEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ TransformFeedback.GetHashCode() ^ GeometryStreams.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceTransformFeedbackFeaturesEXT l, in VkPhysicalDeviceTransformFeedbackFeaturesEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.TransformFeedback == r.TransformFeedback) && (l.GeometryStreams == r.GeometryStreams)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceTransformFeedbackFeaturesEXT l, in VkPhysicalDeviceTransformFeedbackFeaturesEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.TransformFeedback != r.TransformFeedback) || (l.GeometryStreams != r.GeometryStreams)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceTransformFeedbackFeaturesEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceTransformFeedbackPropertiesEXT : IEquatable<VkPhysicalDeviceTransformFeedbackPropertiesEXT>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceTransformFeedbackPropertiesExt;

	public VkStructureType sType;
	public void* pNext;
	public uint MaxTransformFeedbackStreams;
	public uint MaxTransformFeedbackBuffers;
	public ulong MaxTransformFeedbackBufferSize;
	public uint MaxTransformFeedbackStreamDataSize;
	public uint MaxTransformFeedbackBufferDataSize;
	public uint MaxTransformFeedbackBufferDataStride;
	public VkBool32 TransformFeedbackQueries;
	public VkBool32 TransformFeedbackStreamsLinesTriangles;
	public VkBool32 TransformFeedbackRasterizationStreamSelect;
	public VkBool32 TransformFeedbackDraw;

	public VkPhysicalDeviceTransformFeedbackPropertiesEXT(
		uint maxTransformFeedbackStreams = default,
		uint maxTransformFeedbackBuffers = default,
		ulong maxTransformFeedbackBufferSize = default,
		uint maxTransformFeedbackStreamDataSize = default,
		uint maxTransformFeedbackBufferDataSize = default,
		uint maxTransformFeedbackBufferDataStride = default,
		VkBool32 transformFeedbackQueries = default,
		VkBool32 transformFeedbackStreamsLinesTriangles = default,
		VkBool32 transformFeedbackRasterizationStreamSelect = default,
		VkBool32 transformFeedbackDraw = default
	) {
		sType = TYPE;
		pNext = null;
		MaxTransformFeedbackStreams = maxTransformFeedbackStreams;
		MaxTransformFeedbackBuffers = maxTransformFeedbackBuffers;
		MaxTransformFeedbackBufferSize = maxTransformFeedbackBufferSize;
		MaxTransformFeedbackStreamDataSize = maxTransformFeedbackStreamDataSize;
		MaxTransformFeedbackBufferDataSize = maxTransformFeedbackBufferDataSize;
		MaxTransformFeedbackBufferDataStride = maxTransformFeedbackBufferDataStride;
		TransformFeedbackQueries = transformFeedbackQueries;
		TransformFeedbackStreamsLinesTriangles = transformFeedbackStreamsLinesTriangles;
		TransformFeedbackRasterizationStreamSelect = transformFeedbackRasterizationStreamSelect;
		TransformFeedbackDraw = transformFeedbackDraw;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceTransformFeedbackPropertiesEXT s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceTransformFeedbackPropertiesEXT>.Equals(VkPhysicalDeviceTransformFeedbackPropertiesEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MaxTransformFeedbackStreams.GetHashCode() ^ MaxTransformFeedbackBuffers.GetHashCode()
			^ MaxTransformFeedbackBufferSize.GetHashCode() ^ MaxTransformFeedbackStreamDataSize.GetHashCode() ^ MaxTransformFeedbackBufferDataSize.GetHashCode() ^ MaxTransformFeedbackBufferDataStride.GetHashCode()
			^ TransformFeedbackQueries.GetHashCode() ^ TransformFeedbackStreamsLinesTriangles.GetHashCode() ^ TransformFeedbackRasterizationStreamSelect.GetHashCode() ^ TransformFeedbackDraw.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceTransformFeedbackPropertiesEXT l, in VkPhysicalDeviceTransformFeedbackPropertiesEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MaxTransformFeedbackStreams == r.MaxTransformFeedbackStreams) && (l.MaxTransformFeedbackBuffers == r.MaxTransformFeedbackBuffers)
			&& (l.MaxTransformFeedbackBufferSize == r.MaxTransformFeedbackBufferSize) && (l.MaxTransformFeedbackStreamDataSize == r.MaxTransformFeedbackStreamDataSize) && (l.MaxTransformFeedbackBufferDataSize == r.MaxTransformFeedbackBufferDataSize) && (l.MaxTransformFeedbackBufferDataStride == r.MaxTransformFeedbackBufferDataStride)
			&& (l.TransformFeedbackQueries == r.TransformFeedbackQueries) && (l.TransformFeedbackStreamsLinesTriangles == r.TransformFeedbackStreamsLinesTriangles) && (l.TransformFeedbackRasterizationStreamSelect == r.TransformFeedbackRasterizationStreamSelect) && (l.TransformFeedbackDraw == r.TransformFeedbackDraw)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceTransformFeedbackPropertiesEXT l, in VkPhysicalDeviceTransformFeedbackPropertiesEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MaxTransformFeedbackStreams != r.MaxTransformFeedbackStreams) || (l.MaxTransformFeedbackBuffers != r.MaxTransformFeedbackBuffers)
			|| (l.MaxTransformFeedbackBufferSize != r.MaxTransformFeedbackBufferSize) || (l.MaxTransformFeedbackStreamDataSize != r.MaxTransformFeedbackStreamDataSize) || (l.MaxTransformFeedbackBufferDataSize != r.MaxTransformFeedbackBufferDataSize) || (l.MaxTransformFeedbackBufferDataStride != r.MaxTransformFeedbackBufferDataStride)
			|| (l.TransformFeedbackQueries != r.TransformFeedbackQueries) || (l.TransformFeedbackStreamsLinesTriangles != r.TransformFeedbackStreamsLinesTriangles) || (l.TransformFeedbackRasterizationStreamSelect != r.TransformFeedbackRasterizationStreamSelect) || (l.TransformFeedbackDraw != r.TransformFeedbackDraw)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceTransformFeedbackPropertiesEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPipelineRasterizationStateStreamCreateInfoEXT : IEquatable<VkPipelineRasterizationStateStreamCreateInfoEXT>
{
	public const VkStructureType TYPE = VkStructureType.PipelineRasterizationStateStreamCreateInfoExt;

	public VkStructureType sType;
	public void* pNext;
	public VkPipelineRasterizationStateStreamCreateFlagsEXT Flags;
	public uint RasterizationStream;

	public VkPipelineRasterizationStateStreamCreateInfoEXT(
		VkPipelineRasterizationStateStreamCreateFlagsEXT flags = default,
		uint rasterizationStream = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		RasterizationStream = rasterizationStream;
	}

	public readonly override bool Equals(object? o) => (o is VkPipelineRasterizationStateStreamCreateInfoEXT s) && (this == s);
	readonly bool IEquatable<VkPipelineRasterizationStateStreamCreateInfoEXT>.Equals(VkPipelineRasterizationStateStreamCreateInfoEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ RasterizationStream.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPipelineRasterizationStateStreamCreateInfoEXT l, in VkPipelineRasterizationStateStreamCreateInfoEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.RasterizationStream == r.RasterizationStream)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPipelineRasterizationStateStreamCreateInfoEXT l, in VkPipelineRasterizationStateStreamCreateInfoEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.RasterizationStream != r.RasterizationStream)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPipelineRasterizationStateStreamCreateInfoEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDrmFormatModifierPropertiesListEXT : IEquatable<VkDrmFormatModifierPropertiesListEXT>
{
	public const VkStructureType TYPE = VkStructureType.DrmFormatModifierPropertiesListExt;

	public VkStructureType sType;
	public void* pNext;
	public uint DrmFormatModifierCount;
	public VkDrmFormatModifierPropertiesEXT* DrmFormatModifierProperties;

	public VkDrmFormatModifierPropertiesListEXT(
		uint drmFormatModifierCount = default,
		VkDrmFormatModifierPropertiesEXT* drmFormatModifierProperties = default
	) {
		sType = TYPE;
		pNext = null;
		DrmFormatModifierCount = drmFormatModifierCount;
		DrmFormatModifierProperties = drmFormatModifierProperties;
	}

	public readonly override bool Equals(object? o) => (o is VkDrmFormatModifierPropertiesListEXT s) && (this == s);
	readonly bool IEquatable<VkDrmFormatModifierPropertiesListEXT>.Equals(VkDrmFormatModifierPropertiesListEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DrmFormatModifierCount.GetHashCode() ^ ((ulong)DrmFormatModifierProperties).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDrmFormatModifierPropertiesListEXT l, in VkDrmFormatModifierPropertiesListEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DrmFormatModifierCount == r.DrmFormatModifierCount) && (l.DrmFormatModifierProperties == r.DrmFormatModifierProperties)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDrmFormatModifierPropertiesListEXT l, in VkDrmFormatModifierPropertiesListEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DrmFormatModifierCount != r.DrmFormatModifierCount) || (l.DrmFormatModifierProperties != r.DrmFormatModifierProperties)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDrmFormatModifierPropertiesListEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkDrmFormatModifierPropertiesEXT : IEquatable<VkDrmFormatModifierPropertiesEXT>
{
	public ulong DrmFormatModifier;
	public uint DrmFormatModifierPlaneCount;
	public VkFormatFeatureFlags DrmFormatModifierTilingFeatures;

	public VkDrmFormatModifierPropertiesEXT(
		ulong drmFormatModifier = default,
		uint drmFormatModifierPlaneCount = default,
		VkFormatFeatureFlags drmFormatModifierTilingFeatures = default
	) {
		DrmFormatModifier = drmFormatModifier;
		DrmFormatModifierPlaneCount = drmFormatModifierPlaneCount;
		DrmFormatModifierTilingFeatures = drmFormatModifierTilingFeatures;
	}

	public readonly override bool Equals(object? o) => (o is VkDrmFormatModifierPropertiesEXT s) && (this == s);
	readonly bool IEquatable<VkDrmFormatModifierPropertiesEXT>.Equals(VkDrmFormatModifierPropertiesEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			DrmFormatModifier.GetHashCode() ^ DrmFormatModifierPlaneCount.GetHashCode() ^ DrmFormatModifierTilingFeatures.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkDrmFormatModifierPropertiesEXT l, in VkDrmFormatModifierPropertiesEXT r)
	{
		return
			(l.DrmFormatModifier == r.DrmFormatModifier) && (l.DrmFormatModifierPlaneCount == r.DrmFormatModifierPlaneCount) && (l.DrmFormatModifierTilingFeatures == r.DrmFormatModifierTilingFeatures)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkDrmFormatModifierPropertiesEXT l, in VkDrmFormatModifierPropertiesEXT r)
	{
		return
			(l.DrmFormatModifier != r.DrmFormatModifier) || (l.DrmFormatModifierPlaneCount != r.DrmFormatModifierPlaneCount) || (l.DrmFormatModifierTilingFeatures != r.DrmFormatModifierTilingFeatures)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkDrmFormatModifierPropertiesEXT s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceImageDrmFormatModifierInfoEXT : IEquatable<VkPhysicalDeviceImageDrmFormatModifierInfoEXT>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceImageDrmFormatModifierInfoExt;

	public VkStructureType sType;
	public void* pNext;
	public ulong DrmFormatModifier;
	public VkSharingMode SharingMode;
	public uint QueueFamilyIndexCount;
	public uint* QueueFamilyIndices;

	public VkPhysicalDeviceImageDrmFormatModifierInfoEXT(
		ulong drmFormatModifier = default,
		VkSharingMode sharingMode = default,
		uint queueFamilyIndexCount = default,
		uint* queueFamilyIndices = default
	) {
		sType = TYPE;
		pNext = null;
		DrmFormatModifier = drmFormatModifier;
		SharingMode = sharingMode;
		QueueFamilyIndexCount = queueFamilyIndexCount;
		QueueFamilyIndices = queueFamilyIndices;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceImageDrmFormatModifierInfoEXT s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceImageDrmFormatModifierInfoEXT>.Equals(VkPhysicalDeviceImageDrmFormatModifierInfoEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DrmFormatModifier.GetHashCode() ^ SharingMode.GetHashCode()
			^ QueueFamilyIndexCount.GetHashCode() ^ ((ulong)QueueFamilyIndices).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceImageDrmFormatModifierInfoEXT l, in VkPhysicalDeviceImageDrmFormatModifierInfoEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DrmFormatModifier == r.DrmFormatModifier) && (l.SharingMode == r.SharingMode)
			&& (l.QueueFamilyIndexCount == r.QueueFamilyIndexCount) && (l.QueueFamilyIndices == r.QueueFamilyIndices)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceImageDrmFormatModifierInfoEXT l, in VkPhysicalDeviceImageDrmFormatModifierInfoEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DrmFormatModifier != r.DrmFormatModifier) || (l.SharingMode != r.SharingMode)
			|| (l.QueueFamilyIndexCount != r.QueueFamilyIndexCount) || (l.QueueFamilyIndices != r.QueueFamilyIndices)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceImageDrmFormatModifierInfoEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkImageDrmFormatModifierListCreateInfoEXT : IEquatable<VkImageDrmFormatModifierListCreateInfoEXT>
{
	public const VkStructureType TYPE = VkStructureType.ImageDrmFormatModifierListCreateInfoExt;

	public VkStructureType sType;
	public void* pNext;
	public uint DrmFormatModifierCount;
	public ulong* DrmFormatModifiers;

	public VkImageDrmFormatModifierListCreateInfoEXT(
		uint drmFormatModifierCount = default,
		ulong* drmFormatModifiers = default
	) {
		sType = TYPE;
		pNext = null;
		DrmFormatModifierCount = drmFormatModifierCount;
		DrmFormatModifiers = drmFormatModifiers;
	}

	public readonly override bool Equals(object? o) => (o is VkImageDrmFormatModifierListCreateInfoEXT s) && (this == s);
	readonly bool IEquatable<VkImageDrmFormatModifierListCreateInfoEXT>.Equals(VkImageDrmFormatModifierListCreateInfoEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DrmFormatModifierCount.GetHashCode() ^ ((ulong)DrmFormatModifiers).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkImageDrmFormatModifierListCreateInfoEXT l, in VkImageDrmFormatModifierListCreateInfoEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DrmFormatModifierCount == r.DrmFormatModifierCount) && (l.DrmFormatModifiers == r.DrmFormatModifiers)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkImageDrmFormatModifierListCreateInfoEXT l, in VkImageDrmFormatModifierListCreateInfoEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DrmFormatModifierCount != r.DrmFormatModifierCount) || (l.DrmFormatModifiers != r.DrmFormatModifiers)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkImageDrmFormatModifierListCreateInfoEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkImageDrmFormatModifierExplicitCreateInfoEXT : IEquatable<VkImageDrmFormatModifierExplicitCreateInfoEXT>
{
	public const VkStructureType TYPE = VkStructureType.ImageDrmFormatModifierExplicitCreateInfoExt;

	public VkStructureType sType;
	public void* pNext;
	public ulong DrmFormatModifier;
	public uint DrmFormatModifierPlaneCount;
	public VkSubresourceLayout* PlaneLayouts;

	public VkImageDrmFormatModifierExplicitCreateInfoEXT(
		ulong drmFormatModifier = default,
		uint drmFormatModifierPlaneCount = default,
		VkSubresourceLayout* planeLayouts = default
	) {
		sType = TYPE;
		pNext = null;
		DrmFormatModifier = drmFormatModifier;
		DrmFormatModifierPlaneCount = drmFormatModifierPlaneCount;
		PlaneLayouts = planeLayouts;
	}

	public readonly override bool Equals(object? o) => (o is VkImageDrmFormatModifierExplicitCreateInfoEXT s) && (this == s);
	readonly bool IEquatable<VkImageDrmFormatModifierExplicitCreateInfoEXT>.Equals(VkImageDrmFormatModifierExplicitCreateInfoEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DrmFormatModifier.GetHashCode() ^ DrmFormatModifierPlaneCount.GetHashCode()
			^ ((ulong)PlaneLayouts).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkImageDrmFormatModifierExplicitCreateInfoEXT l, in VkImageDrmFormatModifierExplicitCreateInfoEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DrmFormatModifier == r.DrmFormatModifier) && (l.DrmFormatModifierPlaneCount == r.DrmFormatModifierPlaneCount)
			&& (l.PlaneLayouts == r.PlaneLayouts)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkImageDrmFormatModifierExplicitCreateInfoEXT l, in VkImageDrmFormatModifierExplicitCreateInfoEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DrmFormatModifier != r.DrmFormatModifier) || (l.DrmFormatModifierPlaneCount != r.DrmFormatModifierPlaneCount)
			|| (l.PlaneLayouts != r.PlaneLayouts)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkImageDrmFormatModifierExplicitCreateInfoEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkImageDrmFormatModifierPropertiesEXT : IEquatable<VkImageDrmFormatModifierPropertiesEXT>
{
	public const VkStructureType TYPE = VkStructureType.ImageDrmFormatModifierPropertiesExt;

	public VkStructureType sType;
	public void* pNext;
	public ulong DrmFormatModifier;

	public VkImageDrmFormatModifierPropertiesEXT(
		ulong drmFormatModifier = default
	) {
		sType = TYPE;
		pNext = null;
		DrmFormatModifier = drmFormatModifier;
	}

	public readonly override bool Equals(object? o) => (o is VkImageDrmFormatModifierPropertiesEXT s) && (this == s);
	readonly bool IEquatable<VkImageDrmFormatModifierPropertiesEXT>.Equals(VkImageDrmFormatModifierPropertiesEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DrmFormatModifier.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkImageDrmFormatModifierPropertiesEXT l, in VkImageDrmFormatModifierPropertiesEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DrmFormatModifier == r.DrmFormatModifier)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkImageDrmFormatModifierPropertiesEXT l, in VkImageDrmFormatModifierPropertiesEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DrmFormatModifier != r.DrmFormatModifier)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkImageDrmFormatModifierPropertiesEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkImageStencilUsageCreateInfoEXT : IEquatable<VkImageStencilUsageCreateInfoEXT>
{
	public const VkStructureType TYPE = VkStructureType.ImageStencilUsageCreateInfo;

	public VkStructureType sType;
	public void* pNext;
	public VkImageUsageFlags StencilUsage;

	public VkImageStencilUsageCreateInfoEXT(
		VkImageUsageFlags stencilUsage = default
	) {
		sType = TYPE;
		pNext = null;
		StencilUsage = stencilUsage;
	}

	public readonly override bool Equals(object? o) => (o is VkImageStencilUsageCreateInfoEXT s) && (this == s);
	readonly bool IEquatable<VkImageStencilUsageCreateInfoEXT>.Equals(VkImageStencilUsageCreateInfoEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ StencilUsage.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkImageStencilUsageCreateInfoEXT l, in VkImageStencilUsageCreateInfoEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.StencilUsage == r.StencilUsage)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkImageStencilUsageCreateInfoEXT l, in VkImageStencilUsageCreateInfoEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.StencilUsage != r.StencilUsage)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkImageStencilUsageCreateInfoEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceFragmentDensityMapFeaturesEXT : IEquatable<VkPhysicalDeviceFragmentDensityMapFeaturesEXT>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceFragmentDensityMapFeaturesExt;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 FragmentDensityMap;
	public VkBool32 FragmentDensityMapDynamic;
	public VkBool32 FragmentDensityMapNonSubsampledImages;

	public VkPhysicalDeviceFragmentDensityMapFeaturesEXT(
		VkBool32 fragmentDensityMap = default,
		VkBool32 fragmentDensityMapDynamic = default,
		VkBool32 fragmentDensityMapNonSubsampledImages = default
	) {
		sType = TYPE;
		pNext = null;
		FragmentDensityMap = fragmentDensityMap;
		FragmentDensityMapDynamic = fragmentDensityMapDynamic;
		FragmentDensityMapNonSubsampledImages = fragmentDensityMapNonSubsampledImages;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceFragmentDensityMapFeaturesEXT s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceFragmentDensityMapFeaturesEXT>.Equals(VkPhysicalDeviceFragmentDensityMapFeaturesEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ FragmentDensityMap.GetHashCode() ^ FragmentDensityMapDynamic.GetHashCode()
			^ FragmentDensityMapNonSubsampledImages.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceFragmentDensityMapFeaturesEXT l, in VkPhysicalDeviceFragmentDensityMapFeaturesEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.FragmentDensityMap == r.FragmentDensityMap) && (l.FragmentDensityMapDynamic == r.FragmentDensityMapDynamic)
			&& (l.FragmentDensityMapNonSubsampledImages == r.FragmentDensityMapNonSubsampledImages)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceFragmentDensityMapFeaturesEXT l, in VkPhysicalDeviceFragmentDensityMapFeaturesEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.FragmentDensityMap != r.FragmentDensityMap) || (l.FragmentDensityMapDynamic != r.FragmentDensityMapDynamic)
			|| (l.FragmentDensityMapNonSubsampledImages != r.FragmentDensityMapNonSubsampledImages)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceFragmentDensityMapFeaturesEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceFragmentDensityMap2FeaturesEXT : IEquatable<VkPhysicalDeviceFragmentDensityMap2FeaturesEXT>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceFragmentDensityMap2FeaturesExt;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 FragmentDensityMapDeferred;

	public VkPhysicalDeviceFragmentDensityMap2FeaturesEXT(
		VkBool32 fragmentDensityMapDeferred = default
	) {
		sType = TYPE;
		pNext = null;
		FragmentDensityMapDeferred = fragmentDensityMapDeferred;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceFragmentDensityMap2FeaturesEXT s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceFragmentDensityMap2FeaturesEXT>.Equals(VkPhysicalDeviceFragmentDensityMap2FeaturesEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ FragmentDensityMapDeferred.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceFragmentDensityMap2FeaturesEXT l, in VkPhysicalDeviceFragmentDensityMap2FeaturesEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.FragmentDensityMapDeferred == r.FragmentDensityMapDeferred)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceFragmentDensityMap2FeaturesEXT l, in VkPhysicalDeviceFragmentDensityMap2FeaturesEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.FragmentDensityMapDeferred != r.FragmentDensityMapDeferred)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceFragmentDensityMap2FeaturesEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceFragmentDensityMapPropertiesEXT : IEquatable<VkPhysicalDeviceFragmentDensityMapPropertiesEXT>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceFragmentDensityMapPropertiesExt;

	public VkStructureType sType;
	public void* pNext;
	public VkExtent2D MinFragmentDensityTexelSize;
	public VkExtent2D MaxFragmentDensityTexelSize;
	public VkBool32 FragmentDensityInvocations;

	public VkPhysicalDeviceFragmentDensityMapPropertiesEXT(
		VkExtent2D minFragmentDensityTexelSize = default,
		VkExtent2D maxFragmentDensityTexelSize = default,
		VkBool32 fragmentDensityInvocations = default
	) {
		sType = TYPE;
		pNext = null;
		MinFragmentDensityTexelSize = minFragmentDensityTexelSize;
		MaxFragmentDensityTexelSize = maxFragmentDensityTexelSize;
		FragmentDensityInvocations = fragmentDensityInvocations;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceFragmentDensityMapPropertiesEXT s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceFragmentDensityMapPropertiesEXT>.Equals(VkPhysicalDeviceFragmentDensityMapPropertiesEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MinFragmentDensityTexelSize.GetHashCode() ^ MaxFragmentDensityTexelSize.GetHashCode()
			^ FragmentDensityInvocations.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceFragmentDensityMapPropertiesEXT l, in VkPhysicalDeviceFragmentDensityMapPropertiesEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MinFragmentDensityTexelSize == r.MinFragmentDensityTexelSize) && (l.MaxFragmentDensityTexelSize == r.MaxFragmentDensityTexelSize)
			&& (l.FragmentDensityInvocations == r.FragmentDensityInvocations)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceFragmentDensityMapPropertiesEXT l, in VkPhysicalDeviceFragmentDensityMapPropertiesEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MinFragmentDensityTexelSize != r.MinFragmentDensityTexelSize) || (l.MaxFragmentDensityTexelSize != r.MaxFragmentDensityTexelSize)
			|| (l.FragmentDensityInvocations != r.FragmentDensityInvocations)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceFragmentDensityMapPropertiesEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceFragmentDensityMap2PropertiesEXT : IEquatable<VkPhysicalDeviceFragmentDensityMap2PropertiesEXT>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceFragmentDensityMap2PropertiesExt;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 SubsampledLoads;
	public VkBool32 SubsampledCoarseReconstructionEarlyAccess;
	public uint MaxSubsampledArrayLayers;
	public uint MaxDescriptorSetSubsampledSamplers;

	public VkPhysicalDeviceFragmentDensityMap2PropertiesEXT(
		VkBool32 subsampledLoads = default,
		VkBool32 subsampledCoarseReconstructionEarlyAccess = default,
		uint maxSubsampledArrayLayers = default,
		uint maxDescriptorSetSubsampledSamplers = default
	) {
		sType = TYPE;
		pNext = null;
		SubsampledLoads = subsampledLoads;
		SubsampledCoarseReconstructionEarlyAccess = subsampledCoarseReconstructionEarlyAccess;
		MaxSubsampledArrayLayers = maxSubsampledArrayLayers;
		MaxDescriptorSetSubsampledSamplers = maxDescriptorSetSubsampledSamplers;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceFragmentDensityMap2PropertiesEXT s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceFragmentDensityMap2PropertiesEXT>.Equals(VkPhysicalDeviceFragmentDensityMap2PropertiesEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SubsampledLoads.GetHashCode() ^ SubsampledCoarseReconstructionEarlyAccess.GetHashCode()
			^ MaxSubsampledArrayLayers.GetHashCode() ^ MaxDescriptorSetSubsampledSamplers.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceFragmentDensityMap2PropertiesEXT l, in VkPhysicalDeviceFragmentDensityMap2PropertiesEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SubsampledLoads == r.SubsampledLoads) && (l.SubsampledCoarseReconstructionEarlyAccess == r.SubsampledCoarseReconstructionEarlyAccess)
			&& (l.MaxSubsampledArrayLayers == r.MaxSubsampledArrayLayers) && (l.MaxDescriptorSetSubsampledSamplers == r.MaxDescriptorSetSubsampledSamplers)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceFragmentDensityMap2PropertiesEXT l, in VkPhysicalDeviceFragmentDensityMap2PropertiesEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SubsampledLoads != r.SubsampledLoads) || (l.SubsampledCoarseReconstructionEarlyAccess != r.SubsampledCoarseReconstructionEarlyAccess)
			|| (l.MaxSubsampledArrayLayers != r.MaxSubsampledArrayLayers) || (l.MaxDescriptorSetSubsampledSamplers != r.MaxDescriptorSetSubsampledSamplers)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceFragmentDensityMap2PropertiesEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkRenderPassFragmentDensityMapCreateInfoEXT : IEquatable<VkRenderPassFragmentDensityMapCreateInfoEXT>
{
	public const VkStructureType TYPE = VkStructureType.RenderPassFragmentDensityMapCreateInfoExt;

	public VkStructureType sType;
	public void* pNext;
	public VkAttachmentReference FragmentDensityMapAttachment;

	public VkRenderPassFragmentDensityMapCreateInfoEXT(
		VkAttachmentReference fragmentDensityMapAttachment = default
	) {
		sType = TYPE;
		pNext = null;
		FragmentDensityMapAttachment = fragmentDensityMapAttachment;
	}

	public readonly override bool Equals(object? o) => (o is VkRenderPassFragmentDensityMapCreateInfoEXT s) && (this == s);
	readonly bool IEquatable<VkRenderPassFragmentDensityMapCreateInfoEXT>.Equals(VkRenderPassFragmentDensityMapCreateInfoEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ FragmentDensityMapAttachment.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkRenderPassFragmentDensityMapCreateInfoEXT l, in VkRenderPassFragmentDensityMapCreateInfoEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.FragmentDensityMapAttachment == r.FragmentDensityMapAttachment)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkRenderPassFragmentDensityMapCreateInfoEXT l, in VkRenderPassFragmentDensityMapCreateInfoEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.FragmentDensityMapAttachment != r.FragmentDensityMapAttachment)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkRenderPassFragmentDensityMapCreateInfoEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceScalarBlockLayoutFeaturesEXT : IEquatable<VkPhysicalDeviceScalarBlockLayoutFeaturesEXT>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceScalarBlockLayoutFeatures;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 ScalarBlockLayout;

	public VkPhysicalDeviceScalarBlockLayoutFeaturesEXT(
		VkBool32 scalarBlockLayout = default
	) {
		sType = TYPE;
		pNext = null;
		ScalarBlockLayout = scalarBlockLayout;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceScalarBlockLayoutFeaturesEXT s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceScalarBlockLayoutFeaturesEXT>.Equals(VkPhysicalDeviceScalarBlockLayoutFeaturesEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ScalarBlockLayout.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceScalarBlockLayoutFeaturesEXT l, in VkPhysicalDeviceScalarBlockLayoutFeaturesEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ScalarBlockLayout == r.ScalarBlockLayout)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceScalarBlockLayoutFeaturesEXT l, in VkPhysicalDeviceScalarBlockLayoutFeaturesEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ScalarBlockLayout != r.ScalarBlockLayout)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceScalarBlockLayoutFeaturesEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceDepthClipEnableFeaturesEXT : IEquatable<VkPhysicalDeviceDepthClipEnableFeaturesEXT>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceDepthClipEnableFeaturesExt;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 DepthClipEnable;

	public VkPhysicalDeviceDepthClipEnableFeaturesEXT(
		VkBool32 depthClipEnable = default
	) {
		sType = TYPE;
		pNext = null;
		DepthClipEnable = depthClipEnable;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceDepthClipEnableFeaturesEXT s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceDepthClipEnableFeaturesEXT>.Equals(VkPhysicalDeviceDepthClipEnableFeaturesEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DepthClipEnable.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceDepthClipEnableFeaturesEXT l, in VkPhysicalDeviceDepthClipEnableFeaturesEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DepthClipEnable == r.DepthClipEnable)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceDepthClipEnableFeaturesEXT l, in VkPhysicalDeviceDepthClipEnableFeaturesEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DepthClipEnable != r.DepthClipEnable)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceDepthClipEnableFeaturesEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPipelineRasterizationDepthClipStateCreateInfoEXT : IEquatable<VkPipelineRasterizationDepthClipStateCreateInfoEXT>
{
	public const VkStructureType TYPE = VkStructureType.PipelineRasterizationDepthClipStateCreateInfoExt;

	public VkStructureType sType;
	public void* pNext;
	public VkPipelineRasterizationDepthClipStateCreateFlagsEXT Flags;
	public VkBool32 DepthClipEnable;

	public VkPipelineRasterizationDepthClipStateCreateInfoEXT(
		VkPipelineRasterizationDepthClipStateCreateFlagsEXT flags = default,
		VkBool32 depthClipEnable = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
		DepthClipEnable = depthClipEnable;
	}

	public readonly override bool Equals(object? o) => (o is VkPipelineRasterizationDepthClipStateCreateInfoEXT s) && (this == s);
	readonly bool IEquatable<VkPipelineRasterizationDepthClipStateCreateInfoEXT>.Equals(VkPipelineRasterizationDepthClipStateCreateInfoEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode() ^ DepthClipEnable.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPipelineRasterizationDepthClipStateCreateInfoEXT l, in VkPipelineRasterizationDepthClipStateCreateInfoEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags) && (l.DepthClipEnable == r.DepthClipEnable)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPipelineRasterizationDepthClipStateCreateInfoEXT l, in VkPipelineRasterizationDepthClipStateCreateInfoEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags) || (l.DepthClipEnable != r.DepthClipEnable)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPipelineRasterizationDepthClipStateCreateInfoEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceMemoryBudgetPropertiesEXT : IEquatable<VkPhysicalDeviceMemoryBudgetPropertiesEXT>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceMemoryBudgetPropertiesExt;

	public VkStructureType sType;
	public void* pNext;
	public fixed ulong HeapBudget[16];
	public fixed ulong HeapUsage[16];

	public VkPhysicalDeviceMemoryBudgetPropertiesEXT(
		ulong heapBudget_0 = default,
		ulong heapBudget_1 = default,
		ulong heapBudget_2 = default,
		ulong heapBudget_3 = default,
		ulong heapBudget_4 = default,
		ulong heapBudget_5 = default,
		ulong heapBudget_6 = default,
		ulong heapBudget_7 = default,
		ulong heapBudget_8 = default,
		ulong heapBudget_9 = default,
		ulong heapBudget_10 = default,
		ulong heapBudget_11 = default,
		ulong heapBudget_12 = default,
		ulong heapBudget_13 = default,
		ulong heapBudget_14 = default,
		ulong heapBudget_15 = default,
		ulong heapUsage_0 = default,
		ulong heapUsage_1 = default,
		ulong heapUsage_2 = default,
		ulong heapUsage_3 = default,
		ulong heapUsage_4 = default,
		ulong heapUsage_5 = default,
		ulong heapUsage_6 = default,
		ulong heapUsage_7 = default,
		ulong heapUsage_8 = default,
		ulong heapUsage_9 = default,
		ulong heapUsage_10 = default,
		ulong heapUsage_11 = default,
		ulong heapUsage_12 = default,
		ulong heapUsage_13 = default,
		ulong heapUsage_14 = default,
		ulong heapUsage_15 = default
	) {
		sType = TYPE;
		pNext = null;
		HeapBudget[0] = heapBudget_0;
		HeapBudget[1] = heapBudget_1;
		HeapBudget[2] = heapBudget_2;
		HeapBudget[3] = heapBudget_3;
		HeapBudget[4] = heapBudget_4;
		HeapBudget[5] = heapBudget_5;
		HeapBudget[6] = heapBudget_6;
		HeapBudget[7] = heapBudget_7;
		HeapBudget[8] = heapBudget_8;
		HeapBudget[9] = heapBudget_9;
		HeapBudget[10] = heapBudget_10;
		HeapBudget[11] = heapBudget_11;
		HeapBudget[12] = heapBudget_12;
		HeapBudget[13] = heapBudget_13;
		HeapBudget[14] = heapBudget_14;
		HeapBudget[15] = heapBudget_15;
		HeapUsage[0] = heapUsage_0;
		HeapUsage[1] = heapUsage_1;
		HeapUsage[2] = heapUsage_2;
		HeapUsage[3] = heapUsage_3;
		HeapUsage[4] = heapUsage_4;
		HeapUsage[5] = heapUsage_5;
		HeapUsage[6] = heapUsage_6;
		HeapUsage[7] = heapUsage_7;
		HeapUsage[8] = heapUsage_8;
		HeapUsage[9] = heapUsage_9;
		HeapUsage[10] = heapUsage_10;
		HeapUsage[11] = heapUsage_11;
		HeapUsage[12] = heapUsage_12;
		HeapUsage[13] = heapUsage_13;
		HeapUsage[14] = heapUsage_14;
		HeapUsage[15] = heapUsage_15;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceMemoryBudgetPropertiesEXT s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceMemoryBudgetPropertiesEXT>.Equals(VkPhysicalDeviceMemoryBudgetPropertiesEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ HeapBudget[0].GetHashCode() ^ HeapBudget[1].GetHashCode()
			^ HeapBudget[2].GetHashCode() ^ HeapBudget[3].GetHashCode() ^ HeapBudget[4].GetHashCode() ^ HeapBudget[5].GetHashCode()
			^ HeapBudget[6].GetHashCode() ^ HeapBudget[7].GetHashCode() ^ HeapBudget[8].GetHashCode() ^ HeapBudget[9].GetHashCode()
			^ HeapBudget[10].GetHashCode() ^ HeapBudget[11].GetHashCode() ^ HeapBudget[12].GetHashCode() ^ HeapBudget[13].GetHashCode()
			^ HeapBudget[14].GetHashCode() ^ HeapBudget[15].GetHashCode() ^ HeapUsage[0].GetHashCode() ^ HeapUsage[1].GetHashCode()
			^ HeapUsage[2].GetHashCode() ^ HeapUsage[3].GetHashCode() ^ HeapUsage[4].GetHashCode() ^ HeapUsage[5].GetHashCode()
			^ HeapUsage[6].GetHashCode() ^ HeapUsage[7].GetHashCode() ^ HeapUsage[8].GetHashCode() ^ HeapUsage[9].GetHashCode()
			^ HeapUsage[10].GetHashCode() ^ HeapUsage[11].GetHashCode() ^ HeapUsage[12].GetHashCode() ^ HeapUsage[13].GetHashCode()
			^ HeapUsage[14].GetHashCode() ^ HeapUsage[15].GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceMemoryBudgetPropertiesEXT l, in VkPhysicalDeviceMemoryBudgetPropertiesEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.HeapBudget[0] == r.HeapBudget[0]) && (l.HeapBudget[1] == r.HeapBudget[1])
			&& (l.HeapBudget[2] == r.HeapBudget[2]) && (l.HeapBudget[3] == r.HeapBudget[3]) && (l.HeapBudget[4] == r.HeapBudget[4]) && (l.HeapBudget[5] == r.HeapBudget[5])
			&& (l.HeapBudget[6] == r.HeapBudget[6]) && (l.HeapBudget[7] == r.HeapBudget[7]) && (l.HeapBudget[8] == r.HeapBudget[8]) && (l.HeapBudget[9] == r.HeapBudget[9])
			&& (l.HeapBudget[10] == r.HeapBudget[10]) && (l.HeapBudget[11] == r.HeapBudget[11]) && (l.HeapBudget[12] == r.HeapBudget[12]) && (l.HeapBudget[13] == r.HeapBudget[13])
			&& (l.HeapBudget[14] == r.HeapBudget[14]) && (l.HeapBudget[15] == r.HeapBudget[15]) && (l.HeapUsage[0] == r.HeapUsage[0]) && (l.HeapUsage[1] == r.HeapUsage[1])
			&& (l.HeapUsage[2] == r.HeapUsage[2]) && (l.HeapUsage[3] == r.HeapUsage[3]) && (l.HeapUsage[4] == r.HeapUsage[4]) && (l.HeapUsage[5] == r.HeapUsage[5])
			&& (l.HeapUsage[6] == r.HeapUsage[6]) && (l.HeapUsage[7] == r.HeapUsage[7]) && (l.HeapUsage[8] == r.HeapUsage[8]) && (l.HeapUsage[9] == r.HeapUsage[9])
			&& (l.HeapUsage[10] == r.HeapUsage[10]) && (l.HeapUsage[11] == r.HeapUsage[11]) && (l.HeapUsage[12] == r.HeapUsage[12]) && (l.HeapUsage[13] == r.HeapUsage[13])
			&& (l.HeapUsage[14] == r.HeapUsage[14]) && (l.HeapUsage[15] == r.HeapUsage[15])
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceMemoryBudgetPropertiesEXT l, in VkPhysicalDeviceMemoryBudgetPropertiesEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.HeapBudget[0] != r.HeapBudget[0]) || (l.HeapBudget[1] != r.HeapBudget[1])
			|| (l.HeapBudget[2] != r.HeapBudget[2]) || (l.HeapBudget[3] != r.HeapBudget[3]) || (l.HeapBudget[4] != r.HeapBudget[4]) || (l.HeapBudget[5] != r.HeapBudget[5])
			|| (l.HeapBudget[6] != r.HeapBudget[6]) || (l.HeapBudget[7] != r.HeapBudget[7]) || (l.HeapBudget[8] != r.HeapBudget[8]) || (l.HeapBudget[9] != r.HeapBudget[9])
			|| (l.HeapBudget[10] != r.HeapBudget[10]) || (l.HeapBudget[11] != r.HeapBudget[11]) || (l.HeapBudget[12] != r.HeapBudget[12]) || (l.HeapBudget[13] != r.HeapBudget[13])
			|| (l.HeapBudget[14] != r.HeapBudget[14]) || (l.HeapBudget[15] != r.HeapBudget[15]) || (l.HeapUsage[0] != r.HeapUsage[0]) || (l.HeapUsage[1] != r.HeapUsage[1])
			|| (l.HeapUsage[2] != r.HeapUsage[2]) || (l.HeapUsage[3] != r.HeapUsage[3]) || (l.HeapUsage[4] != r.HeapUsage[4]) || (l.HeapUsage[5] != r.HeapUsage[5])
			|| (l.HeapUsage[6] != r.HeapUsage[6]) || (l.HeapUsage[7] != r.HeapUsage[7]) || (l.HeapUsage[8] != r.HeapUsage[8]) || (l.HeapUsage[9] != r.HeapUsage[9])
			|| (l.HeapUsage[10] != r.HeapUsage[10]) || (l.HeapUsage[11] != r.HeapUsage[11]) || (l.HeapUsage[12] != r.HeapUsage[12]) || (l.HeapUsage[13] != r.HeapUsage[13])
			|| (l.HeapUsage[14] != r.HeapUsage[14]) || (l.HeapUsage[15] != r.HeapUsage[15])
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceMemoryBudgetPropertiesEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceMemoryPriorityFeaturesEXT : IEquatable<VkPhysicalDeviceMemoryPriorityFeaturesEXT>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceMemoryPriorityFeaturesExt;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 MemoryPriority;

	public VkPhysicalDeviceMemoryPriorityFeaturesEXT(
		VkBool32 memoryPriority = default
	) {
		sType = TYPE;
		pNext = null;
		MemoryPriority = memoryPriority;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceMemoryPriorityFeaturesEXT s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceMemoryPriorityFeaturesEXT>.Equals(VkPhysicalDeviceMemoryPriorityFeaturesEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MemoryPriority.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceMemoryPriorityFeaturesEXT l, in VkPhysicalDeviceMemoryPriorityFeaturesEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MemoryPriority == r.MemoryPriority)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceMemoryPriorityFeaturesEXT l, in VkPhysicalDeviceMemoryPriorityFeaturesEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MemoryPriority != r.MemoryPriority)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceMemoryPriorityFeaturesEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkMemoryPriorityAllocateInfoEXT : IEquatable<VkMemoryPriorityAllocateInfoEXT>
{
	public const VkStructureType TYPE = VkStructureType.MemoryPriorityAllocateInfoExt;

	public VkStructureType sType;
	public void* pNext;
	public float Priority;

	public VkMemoryPriorityAllocateInfoEXT(
		float priority = default
	) {
		sType = TYPE;
		pNext = null;
		Priority = priority;
	}

	public readonly override bool Equals(object? o) => (o is VkMemoryPriorityAllocateInfoEXT s) && (this == s);
	readonly bool IEquatable<VkMemoryPriorityAllocateInfoEXT>.Equals(VkMemoryPriorityAllocateInfoEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Priority.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkMemoryPriorityAllocateInfoEXT l, in VkMemoryPriorityAllocateInfoEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Priority == r.Priority)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkMemoryPriorityAllocateInfoEXT l, in VkMemoryPriorityAllocateInfoEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Priority != r.Priority)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkMemoryPriorityAllocateInfoEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceBufferDeviceAddressFeaturesEXT : IEquatable<VkPhysicalDeviceBufferDeviceAddressFeaturesEXT>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceBufferDeviceAddressFeaturesExt;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 BufferDeviceAddress;
	public VkBool32 BufferDeviceAddressCaptureReplay;
	public VkBool32 BufferDeviceAddressMultiDevice;

	public VkPhysicalDeviceBufferDeviceAddressFeaturesEXT(
		VkBool32 bufferDeviceAddress = default,
		VkBool32 bufferDeviceAddressCaptureReplay = default,
		VkBool32 bufferDeviceAddressMultiDevice = default
	) {
		sType = TYPE;
		pNext = null;
		BufferDeviceAddress = bufferDeviceAddress;
		BufferDeviceAddressCaptureReplay = bufferDeviceAddressCaptureReplay;
		BufferDeviceAddressMultiDevice = bufferDeviceAddressMultiDevice;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceBufferDeviceAddressFeaturesEXT s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceBufferDeviceAddressFeaturesEXT>.Equals(VkPhysicalDeviceBufferDeviceAddressFeaturesEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ BufferDeviceAddress.GetHashCode() ^ BufferDeviceAddressCaptureReplay.GetHashCode()
			^ BufferDeviceAddressMultiDevice.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceBufferDeviceAddressFeaturesEXT l, in VkPhysicalDeviceBufferDeviceAddressFeaturesEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.BufferDeviceAddress == r.BufferDeviceAddress) && (l.BufferDeviceAddressCaptureReplay == r.BufferDeviceAddressCaptureReplay)
			&& (l.BufferDeviceAddressMultiDevice == r.BufferDeviceAddressMultiDevice)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceBufferDeviceAddressFeaturesEXT l, in VkPhysicalDeviceBufferDeviceAddressFeaturesEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.BufferDeviceAddress != r.BufferDeviceAddress) || (l.BufferDeviceAddressCaptureReplay != r.BufferDeviceAddressCaptureReplay)
			|| (l.BufferDeviceAddressMultiDevice != r.BufferDeviceAddressMultiDevice)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceBufferDeviceAddressFeaturesEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceBufferAddressFeaturesEXT : IEquatable<VkPhysicalDeviceBufferAddressFeaturesEXT>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceBufferDeviceAddressFeaturesExt;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 BufferDeviceAddress;
	public VkBool32 BufferDeviceAddressCaptureReplay;
	public VkBool32 BufferDeviceAddressMultiDevice;

	public VkPhysicalDeviceBufferAddressFeaturesEXT(
		VkBool32 bufferDeviceAddress = default,
		VkBool32 bufferDeviceAddressCaptureReplay = default,
		VkBool32 bufferDeviceAddressMultiDevice = default
	) {
		sType = TYPE;
		pNext = null;
		BufferDeviceAddress = bufferDeviceAddress;
		BufferDeviceAddressCaptureReplay = bufferDeviceAddressCaptureReplay;
		BufferDeviceAddressMultiDevice = bufferDeviceAddressMultiDevice;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceBufferAddressFeaturesEXT s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceBufferAddressFeaturesEXT>.Equals(VkPhysicalDeviceBufferAddressFeaturesEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ BufferDeviceAddress.GetHashCode() ^ BufferDeviceAddressCaptureReplay.GetHashCode()
			^ BufferDeviceAddressMultiDevice.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceBufferAddressFeaturesEXT l, in VkPhysicalDeviceBufferAddressFeaturesEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.BufferDeviceAddress == r.BufferDeviceAddress) && (l.BufferDeviceAddressCaptureReplay == r.BufferDeviceAddressCaptureReplay)
			&& (l.BufferDeviceAddressMultiDevice == r.BufferDeviceAddressMultiDevice)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceBufferAddressFeaturesEXT l, in VkPhysicalDeviceBufferAddressFeaturesEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.BufferDeviceAddress != r.BufferDeviceAddress) || (l.BufferDeviceAddressCaptureReplay != r.BufferDeviceAddressCaptureReplay)
			|| (l.BufferDeviceAddressMultiDevice != r.BufferDeviceAddressMultiDevice)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceBufferAddressFeaturesEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkBufferDeviceAddressInfoEXT : IEquatable<VkBufferDeviceAddressInfoEXT>
{
	public const VkStructureType TYPE = VkStructureType.BufferDeviceAddressInfo;

	public VkStructureType sType;
	public void* pNext;
	public VulkanHandle<VkBuffer> Buffer;

	public VkBufferDeviceAddressInfoEXT(
		VulkanHandle<VkBuffer> buffer = default
	) {
		sType = TYPE;
		pNext = null;
		Buffer = buffer;
	}

	public readonly override bool Equals(object? o) => (o is VkBufferDeviceAddressInfoEXT s) && (this == s);
	readonly bool IEquatable<VkBufferDeviceAddressInfoEXT>.Equals(VkBufferDeviceAddressInfoEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Buffer.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkBufferDeviceAddressInfoEXT l, in VkBufferDeviceAddressInfoEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Buffer == r.Buffer)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkBufferDeviceAddressInfoEXT l, in VkBufferDeviceAddressInfoEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Buffer != r.Buffer)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkBufferDeviceAddressInfoEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkBufferDeviceAddressCreateInfoEXT : IEquatable<VkBufferDeviceAddressCreateInfoEXT>
{
	public const VkStructureType TYPE = VkStructureType.BufferDeviceAddressCreateInfoExt;

	public VkStructureType sType;
	public void* pNext;
	public ulong DeviceAddress;

	public VkBufferDeviceAddressCreateInfoEXT(
		ulong deviceAddress = default
	) {
		sType = TYPE;
		pNext = null;
		DeviceAddress = deviceAddress;
	}

	public readonly override bool Equals(object? o) => (o is VkBufferDeviceAddressCreateInfoEXT s) && (this == s);
	readonly bool IEquatable<VkBufferDeviceAddressCreateInfoEXT>.Equals(VkBufferDeviceAddressCreateInfoEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DeviceAddress.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkBufferDeviceAddressCreateInfoEXT l, in VkBufferDeviceAddressCreateInfoEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DeviceAddress == r.DeviceAddress)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkBufferDeviceAddressCreateInfoEXT l, in VkBufferDeviceAddressCreateInfoEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DeviceAddress != r.DeviceAddress)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkBufferDeviceAddressCreateInfoEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceImageViewImageFormatInfoEXT : IEquatable<VkPhysicalDeviceImageViewImageFormatInfoEXT>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceImageViewImageFormatInfoExt;

	public VkStructureType sType;
	public void* pNext;
	public VkImageViewType ImageViewType;

	public VkPhysicalDeviceImageViewImageFormatInfoEXT(
		VkImageViewType imageViewType = default
	) {
		sType = TYPE;
		pNext = null;
		ImageViewType = imageViewType;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceImageViewImageFormatInfoEXT s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceImageViewImageFormatInfoEXT>.Equals(VkPhysicalDeviceImageViewImageFormatInfoEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ImageViewType.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceImageViewImageFormatInfoEXT l, in VkPhysicalDeviceImageViewImageFormatInfoEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ImageViewType == r.ImageViewType)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceImageViewImageFormatInfoEXT l, in VkPhysicalDeviceImageViewImageFormatInfoEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ImageViewType != r.ImageViewType)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceImageViewImageFormatInfoEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkFilterCubicImageViewImageFormatPropertiesEXT : IEquatable<VkFilterCubicImageViewImageFormatPropertiesEXT>
{
	public const VkStructureType TYPE = VkStructureType.FilterCubicImageViewImageFormatPropertiesExt;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 FilterCubic;
	public VkBool32 FilterCubicMinmax;

	public VkFilterCubicImageViewImageFormatPropertiesEXT(
		VkBool32 filterCubic = default,
		VkBool32 filterCubicMinmax = default
	) {
		sType = TYPE;
		pNext = null;
		FilterCubic = filterCubic;
		FilterCubicMinmax = filterCubicMinmax;
	}

	public readonly override bool Equals(object? o) => (o is VkFilterCubicImageViewImageFormatPropertiesEXT s) && (this == s);
	readonly bool IEquatable<VkFilterCubicImageViewImageFormatPropertiesEXT>.Equals(VkFilterCubicImageViewImageFormatPropertiesEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ FilterCubic.GetHashCode() ^ FilterCubicMinmax.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkFilterCubicImageViewImageFormatPropertiesEXT l, in VkFilterCubicImageViewImageFormatPropertiesEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.FilterCubic == r.FilterCubic) && (l.FilterCubicMinmax == r.FilterCubicMinmax)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkFilterCubicImageViewImageFormatPropertiesEXT l, in VkFilterCubicImageViewImageFormatPropertiesEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.FilterCubic != r.FilterCubic) || (l.FilterCubicMinmax != r.FilterCubicMinmax)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkFilterCubicImageViewImageFormatPropertiesEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT : IEquatable<VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceTextureCompressionAstcHdrFeaturesExt;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 TextureCompressionASTC_HDR;

	public VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT(
		VkBool32 textureCompressionASTC_HDR = default
	) {
		sType = TYPE;
		pNext = null;
		TextureCompressionASTC_HDR = textureCompressionASTC_HDR;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT>.Equals(VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ TextureCompressionASTC_HDR.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT l, in VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.TextureCompressionASTC_HDR == r.TextureCompressionASTC_HDR)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT l, in VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.TextureCompressionASTC_HDR != r.TextureCompressionASTC_HDR)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceYcbcrImageArraysFeaturesEXT : IEquatable<VkPhysicalDeviceYcbcrImageArraysFeaturesEXT>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceYcbcrImageArraysFeaturesExt;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 YcbcrImageArrays;

	public VkPhysicalDeviceYcbcrImageArraysFeaturesEXT(
		VkBool32 ycbcrImageArrays = default
	) {
		sType = TYPE;
		pNext = null;
		YcbcrImageArrays = ycbcrImageArrays;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceYcbcrImageArraysFeaturesEXT s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceYcbcrImageArraysFeaturesEXT>.Equals(VkPhysicalDeviceYcbcrImageArraysFeaturesEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ YcbcrImageArrays.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceYcbcrImageArraysFeaturesEXT l, in VkPhysicalDeviceYcbcrImageArraysFeaturesEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.YcbcrImageArrays == r.YcbcrImageArrays)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceYcbcrImageArraysFeaturesEXT l, in VkPhysicalDeviceYcbcrImageArraysFeaturesEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.YcbcrImageArrays != r.YcbcrImageArrays)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceYcbcrImageArraysFeaturesEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPipelineCreationFeedbackEXT : IEquatable<VkPipelineCreationFeedbackEXT>
{
	public VkPipelineCreationFeedbackFlagsEXT Flags;
	public ulong Duration;

	public VkPipelineCreationFeedbackEXT(
		VkPipelineCreationFeedbackFlagsEXT flags = default,
		ulong duration = default
	) {
		Flags = flags;
		Duration = duration;
	}

	public readonly override bool Equals(object? o) => (o is VkPipelineCreationFeedbackEXT s) && (this == s);
	readonly bool IEquatable<VkPipelineCreationFeedbackEXT>.Equals(VkPipelineCreationFeedbackEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			Flags.GetHashCode() ^ Duration.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPipelineCreationFeedbackEXT l, in VkPipelineCreationFeedbackEXT r)
	{
		return
			(l.Flags == r.Flags) && (l.Duration == r.Duration)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPipelineCreationFeedbackEXT l, in VkPipelineCreationFeedbackEXT r)
	{
		return
			(l.Flags != r.Flags) || (l.Duration != r.Duration)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPipelineCreationFeedbackEXT s) => s = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPipelineCreationFeedbackCreateInfoEXT : IEquatable<VkPipelineCreationFeedbackCreateInfoEXT>
{
	public const VkStructureType TYPE = VkStructureType.PipelineCreationFeedbackCreateInfoExt;

	public VkStructureType sType;
	public void* pNext;
	public VkPipelineCreationFeedbackEXT* PipelineCreationFeedback;
	public uint PipelineStageCreationFeedbackCount;
	public VkPipelineCreationFeedbackEXT** PipelineStageCreationFeedbacks;

	public VkPipelineCreationFeedbackCreateInfoEXT(
		VkPipelineCreationFeedbackEXT* pipelineCreationFeedback = default,
		uint pipelineStageCreationFeedbackCount = default,
		VkPipelineCreationFeedbackEXT** pipelineStageCreationFeedbacks = default
	) {
		sType = TYPE;
		pNext = null;
		PipelineCreationFeedback = pipelineCreationFeedback;
		PipelineStageCreationFeedbackCount = pipelineStageCreationFeedbackCount;
		PipelineStageCreationFeedbacks = pipelineStageCreationFeedbacks;
	}

	public readonly override bool Equals(object? o) => (o is VkPipelineCreationFeedbackCreateInfoEXT s) && (this == s);
	readonly bool IEquatable<VkPipelineCreationFeedbackCreateInfoEXT>.Equals(VkPipelineCreationFeedbackCreateInfoEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ((ulong)PipelineCreationFeedback).GetHashCode() ^ PipelineStageCreationFeedbackCount.GetHashCode()
			^ ((ulong)PipelineStageCreationFeedbacks).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPipelineCreationFeedbackCreateInfoEXT l, in VkPipelineCreationFeedbackCreateInfoEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.PipelineCreationFeedback == r.PipelineCreationFeedback) && (l.PipelineStageCreationFeedbackCount == r.PipelineStageCreationFeedbackCount)
			&& (l.PipelineStageCreationFeedbacks == r.PipelineStageCreationFeedbacks)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPipelineCreationFeedbackCreateInfoEXT l, in VkPipelineCreationFeedbackCreateInfoEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.PipelineCreationFeedback != r.PipelineCreationFeedback) || (l.PipelineStageCreationFeedbackCount != r.PipelineStageCreationFeedbackCount)
			|| (l.PipelineStageCreationFeedbacks != r.PipelineStageCreationFeedbacks)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPipelineCreationFeedbackCreateInfoEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkSurfaceFullScreenExclusiveInfoEXT : IEquatable<VkSurfaceFullScreenExclusiveInfoEXT>
{
	public const VkStructureType TYPE = VkStructureType.SurfaceFullScreenExclusiveInfoExt;

	public VkStructureType sType;
	public void* pNext;
	public VkFullScreenExclusiveEXT FullScreenExclusive;

	public VkSurfaceFullScreenExclusiveInfoEXT(
		VkFullScreenExclusiveEXT fullScreenExclusive = default
	) {
		sType = TYPE;
		pNext = null;
		FullScreenExclusive = fullScreenExclusive;
	}

	public readonly override bool Equals(object? o) => (o is VkSurfaceFullScreenExclusiveInfoEXT s) && (this == s);
	readonly bool IEquatable<VkSurfaceFullScreenExclusiveInfoEXT>.Equals(VkSurfaceFullScreenExclusiveInfoEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ FullScreenExclusive.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkSurfaceFullScreenExclusiveInfoEXT l, in VkSurfaceFullScreenExclusiveInfoEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.FullScreenExclusive == r.FullScreenExclusive)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkSurfaceFullScreenExclusiveInfoEXT l, in VkSurfaceFullScreenExclusiveInfoEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.FullScreenExclusive != r.FullScreenExclusive)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkSurfaceFullScreenExclusiveInfoEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkSurfaceFullScreenExclusiveWin32InfoEXT : IEquatable<VkSurfaceFullScreenExclusiveWin32InfoEXT>
{
	public const VkStructureType TYPE = VkStructureType.SurfaceFullScreenExclusiveWin32InfoExt;

	public VkStructureType sType;
	public void* pNext;
	public void* Hmonitor;

	public VkSurfaceFullScreenExclusiveWin32InfoEXT(
		void* hmonitor = default
	) {
		sType = TYPE;
		pNext = null;
		Hmonitor = hmonitor;
	}

	public readonly override bool Equals(object? o) => (o is VkSurfaceFullScreenExclusiveWin32InfoEXT s) && (this == s);
	readonly bool IEquatable<VkSurfaceFullScreenExclusiveWin32InfoEXT>.Equals(VkSurfaceFullScreenExclusiveWin32InfoEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ((ulong)Hmonitor).GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkSurfaceFullScreenExclusiveWin32InfoEXT l, in VkSurfaceFullScreenExclusiveWin32InfoEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Hmonitor == r.Hmonitor)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkSurfaceFullScreenExclusiveWin32InfoEXT l, in VkSurfaceFullScreenExclusiveWin32InfoEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Hmonitor != r.Hmonitor)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkSurfaceFullScreenExclusiveWin32InfoEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkSurfaceCapabilitiesFullScreenExclusiveEXT : IEquatable<VkSurfaceCapabilitiesFullScreenExclusiveEXT>
{
	public const VkStructureType TYPE = VkStructureType.SurfaceCapabilitiesFullScreenExclusiveExt;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 FullScreenExclusiveSupported;

	public VkSurfaceCapabilitiesFullScreenExclusiveEXT(
		VkBool32 fullScreenExclusiveSupported = default
	) {
		sType = TYPE;
		pNext = null;
		FullScreenExclusiveSupported = fullScreenExclusiveSupported;
	}

	public readonly override bool Equals(object? o) => (o is VkSurfaceCapabilitiesFullScreenExclusiveEXT s) && (this == s);
	readonly bool IEquatable<VkSurfaceCapabilitiesFullScreenExclusiveEXT>.Equals(VkSurfaceCapabilitiesFullScreenExclusiveEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ FullScreenExclusiveSupported.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkSurfaceCapabilitiesFullScreenExclusiveEXT l, in VkSurfaceCapabilitiesFullScreenExclusiveEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.FullScreenExclusiveSupported == r.FullScreenExclusiveSupported)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkSurfaceCapabilitiesFullScreenExclusiveEXT l, in VkSurfaceCapabilitiesFullScreenExclusiveEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.FullScreenExclusiveSupported != r.FullScreenExclusiveSupported)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkSurfaceCapabilitiesFullScreenExclusiveEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkHeadlessSurfaceCreateInfoEXT : IEquatable<VkHeadlessSurfaceCreateInfoEXT>
{
	public const VkStructureType TYPE = VkStructureType.HeadlessSurfaceCreateInfoExt;

	public VkStructureType sType;
	public void* pNext;
	public VkHeadlessSurfaceCreateFlagsEXT Flags;

	public VkHeadlessSurfaceCreateInfoEXT(
		VkHeadlessSurfaceCreateFlagsEXT flags = default
	) {
		sType = TYPE;
		pNext = null;
		Flags = flags;
	}

	public readonly override bool Equals(object? o) => (o is VkHeadlessSurfaceCreateInfoEXT s) && (this == s);
	readonly bool IEquatable<VkHeadlessSurfaceCreateInfoEXT>.Equals(VkHeadlessSurfaceCreateInfoEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Flags.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkHeadlessSurfaceCreateInfoEXT l, in VkHeadlessSurfaceCreateInfoEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Flags == r.Flags)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkHeadlessSurfaceCreateInfoEXT l, in VkHeadlessSurfaceCreateInfoEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Flags != r.Flags)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkHeadlessSurfaceCreateInfoEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceIndexTypeUint8FeaturesEXT : IEquatable<VkPhysicalDeviceIndexTypeUint8FeaturesEXT>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceIndexTypeUint8FeaturesExt;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 IndexTypeUint8;

	public VkPhysicalDeviceIndexTypeUint8FeaturesEXT(
		VkBool32 indexTypeUint8 = default
	) {
		sType = TYPE;
		pNext = null;
		IndexTypeUint8 = indexTypeUint8;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceIndexTypeUint8FeaturesEXT s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceIndexTypeUint8FeaturesEXT>.Equals(VkPhysicalDeviceIndexTypeUint8FeaturesEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ IndexTypeUint8.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceIndexTypeUint8FeaturesEXT l, in VkPhysicalDeviceIndexTypeUint8FeaturesEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.IndexTypeUint8 == r.IndexTypeUint8)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceIndexTypeUint8FeaturesEXT l, in VkPhysicalDeviceIndexTypeUint8FeaturesEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.IndexTypeUint8 != r.IndexTypeUint8)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceIndexTypeUint8FeaturesEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT : IEquatable<VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceFragmentShaderInterlockFeaturesExt;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 FragmentShaderSampleInterlock;
	public VkBool32 FragmentShaderPixelInterlock;
	public VkBool32 FragmentShaderShadingRateInterlock;

	public VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT(
		VkBool32 fragmentShaderSampleInterlock = default,
		VkBool32 fragmentShaderPixelInterlock = default,
		VkBool32 fragmentShaderShadingRateInterlock = default
	) {
		sType = TYPE;
		pNext = null;
		FragmentShaderSampleInterlock = fragmentShaderSampleInterlock;
		FragmentShaderPixelInterlock = fragmentShaderPixelInterlock;
		FragmentShaderShadingRateInterlock = fragmentShaderShadingRateInterlock;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT>.Equals(VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ FragmentShaderSampleInterlock.GetHashCode() ^ FragmentShaderPixelInterlock.GetHashCode()
			^ FragmentShaderShadingRateInterlock.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT l, in VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.FragmentShaderSampleInterlock == r.FragmentShaderSampleInterlock) && (l.FragmentShaderPixelInterlock == r.FragmentShaderPixelInterlock)
			&& (l.FragmentShaderShadingRateInterlock == r.FragmentShaderShadingRateInterlock)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT l, in VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.FragmentShaderSampleInterlock != r.FragmentShaderSampleInterlock) || (l.FragmentShaderPixelInterlock != r.FragmentShaderPixelInterlock)
			|| (l.FragmentShaderShadingRateInterlock != r.FragmentShaderShadingRateInterlock)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT : IEquatable<VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceShaderDemoteToHelperInvocationFeaturesExt;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 ShaderDemoteToHelperInvocation;

	public VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT(
		VkBool32 shaderDemoteToHelperInvocation = default
	) {
		sType = TYPE;
		pNext = null;
		ShaderDemoteToHelperInvocation = shaderDemoteToHelperInvocation;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT>.Equals(VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ShaderDemoteToHelperInvocation.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT l, in VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ShaderDemoteToHelperInvocation == r.ShaderDemoteToHelperInvocation)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT l, in VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ShaderDemoteToHelperInvocation != r.ShaderDemoteToHelperInvocation)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT : IEquatable<VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceTexelBufferAlignmentFeaturesExt;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 TexelBufferAlignment;

	public VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT(
		VkBool32 texelBufferAlignment = default
	) {
		sType = TYPE;
		pNext = null;
		TexelBufferAlignment = texelBufferAlignment;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT>.Equals(VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ TexelBufferAlignment.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT l, in VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.TexelBufferAlignment == r.TexelBufferAlignment)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT l, in VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.TexelBufferAlignment != r.TexelBufferAlignment)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT : IEquatable<VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceTexelBufferAlignmentPropertiesExt;

	public VkStructureType sType;
	public void* pNext;
	public ulong StorageTexelBufferOffsetAlignmentBytes;
	public VkBool32 StorageTexelBufferOffsetSingleTexelAlignment;
	public ulong UniformTexelBufferOffsetAlignmentBytes;
	public VkBool32 UniformTexelBufferOffsetSingleTexelAlignment;

	public VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT(
		ulong storageTexelBufferOffsetAlignmentBytes = default,
		VkBool32 storageTexelBufferOffsetSingleTexelAlignment = default,
		ulong uniformTexelBufferOffsetAlignmentBytes = default,
		VkBool32 uniformTexelBufferOffsetSingleTexelAlignment = default
	) {
		sType = TYPE;
		pNext = null;
		StorageTexelBufferOffsetAlignmentBytes = storageTexelBufferOffsetAlignmentBytes;
		StorageTexelBufferOffsetSingleTexelAlignment = storageTexelBufferOffsetSingleTexelAlignment;
		UniformTexelBufferOffsetAlignmentBytes = uniformTexelBufferOffsetAlignmentBytes;
		UniformTexelBufferOffsetSingleTexelAlignment = uniformTexelBufferOffsetSingleTexelAlignment;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT>.Equals(VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ StorageTexelBufferOffsetAlignmentBytes.GetHashCode() ^ StorageTexelBufferOffsetSingleTexelAlignment.GetHashCode()
			^ UniformTexelBufferOffsetAlignmentBytes.GetHashCode() ^ UniformTexelBufferOffsetSingleTexelAlignment.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT l, in VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.StorageTexelBufferOffsetAlignmentBytes == r.StorageTexelBufferOffsetAlignmentBytes) && (l.StorageTexelBufferOffsetSingleTexelAlignment == r.StorageTexelBufferOffsetSingleTexelAlignment)
			&& (l.UniformTexelBufferOffsetAlignmentBytes == r.UniformTexelBufferOffsetAlignmentBytes) && (l.UniformTexelBufferOffsetSingleTexelAlignment == r.UniformTexelBufferOffsetSingleTexelAlignment)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT l, in VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.StorageTexelBufferOffsetAlignmentBytes != r.StorageTexelBufferOffsetAlignmentBytes) || (l.StorageTexelBufferOffsetSingleTexelAlignment != r.StorageTexelBufferOffsetSingleTexelAlignment)
			|| (l.UniformTexelBufferOffsetAlignmentBytes != r.UniformTexelBufferOffsetAlignmentBytes) || (l.UniformTexelBufferOffsetSingleTexelAlignment != r.UniformTexelBufferOffsetSingleTexelAlignment)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceSubgroupSizeControlFeaturesEXT : IEquatable<VkPhysicalDeviceSubgroupSizeControlFeaturesEXT>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceSubgroupSizeControlFeaturesExt;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 SubgroupSizeControl;
	public VkBool32 ComputeFullSubgroups;

	public VkPhysicalDeviceSubgroupSizeControlFeaturesEXT(
		VkBool32 subgroupSizeControl = default,
		VkBool32 computeFullSubgroups = default
	) {
		sType = TYPE;
		pNext = null;
		SubgroupSizeControl = subgroupSizeControl;
		ComputeFullSubgroups = computeFullSubgroups;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceSubgroupSizeControlFeaturesEXT s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceSubgroupSizeControlFeaturesEXT>.Equals(VkPhysicalDeviceSubgroupSizeControlFeaturesEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SubgroupSizeControl.GetHashCode() ^ ComputeFullSubgroups.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceSubgroupSizeControlFeaturesEXT l, in VkPhysicalDeviceSubgroupSizeControlFeaturesEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SubgroupSizeControl == r.SubgroupSizeControl) && (l.ComputeFullSubgroups == r.ComputeFullSubgroups)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceSubgroupSizeControlFeaturesEXT l, in VkPhysicalDeviceSubgroupSizeControlFeaturesEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SubgroupSizeControl != r.SubgroupSizeControl) || (l.ComputeFullSubgroups != r.ComputeFullSubgroups)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceSubgroupSizeControlFeaturesEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceSubgroupSizeControlPropertiesEXT : IEquatable<VkPhysicalDeviceSubgroupSizeControlPropertiesEXT>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceSubgroupSizeControlPropertiesExt;

	public VkStructureType sType;
	public void* pNext;
	public uint MinSubgroupSize;
	public uint MaxSubgroupSize;
	public uint MaxComputeWorkgroupSubgroups;
	public VkShaderStageFlags RequiredSubgroupSizeStages;

	public VkPhysicalDeviceSubgroupSizeControlPropertiesEXT(
		uint minSubgroupSize = default,
		uint maxSubgroupSize = default,
		uint maxComputeWorkgroupSubgroups = default,
		VkShaderStageFlags requiredSubgroupSizeStages = default
	) {
		sType = TYPE;
		pNext = null;
		MinSubgroupSize = minSubgroupSize;
		MaxSubgroupSize = maxSubgroupSize;
		MaxComputeWorkgroupSubgroups = maxComputeWorkgroupSubgroups;
		RequiredSubgroupSizeStages = requiredSubgroupSizeStages;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceSubgroupSizeControlPropertiesEXT s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceSubgroupSizeControlPropertiesEXT>.Equals(VkPhysicalDeviceSubgroupSizeControlPropertiesEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MinSubgroupSize.GetHashCode() ^ MaxSubgroupSize.GetHashCode()
			^ MaxComputeWorkgroupSubgroups.GetHashCode() ^ RequiredSubgroupSizeStages.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceSubgroupSizeControlPropertiesEXT l, in VkPhysicalDeviceSubgroupSizeControlPropertiesEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MinSubgroupSize == r.MinSubgroupSize) && (l.MaxSubgroupSize == r.MaxSubgroupSize)
			&& (l.MaxComputeWorkgroupSubgroups == r.MaxComputeWorkgroupSubgroups) && (l.RequiredSubgroupSizeStages == r.RequiredSubgroupSizeStages)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceSubgroupSizeControlPropertiesEXT l, in VkPhysicalDeviceSubgroupSizeControlPropertiesEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MinSubgroupSize != r.MinSubgroupSize) || (l.MaxSubgroupSize != r.MaxSubgroupSize)
			|| (l.MaxComputeWorkgroupSubgroups != r.MaxComputeWorkgroupSubgroups) || (l.RequiredSubgroupSizeStages != r.RequiredSubgroupSizeStages)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceSubgroupSizeControlPropertiesEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT : IEquatable<VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT>
{
	public const VkStructureType TYPE = VkStructureType.PipelineShaderStageRequiredSubgroupSizeCreateInfoExt;

	public VkStructureType sType;
	public void* pNext;
	public uint RequiredSubgroupSize;

	public VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT(
		uint requiredSubgroupSize = default
	) {
		sType = TYPE;
		pNext = null;
		RequiredSubgroupSize = requiredSubgroupSize;
	}

	public readonly override bool Equals(object? o) => (o is VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT s) && (this == s);
	readonly bool IEquatable<VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT>.Equals(VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ RequiredSubgroupSize.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT l, in VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.RequiredSubgroupSize == r.RequiredSubgroupSize)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT l, in VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.RequiredSubgroupSize != r.RequiredSubgroupSize)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceLineRasterizationFeaturesEXT : IEquatable<VkPhysicalDeviceLineRasterizationFeaturesEXT>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceLineRasterizationFeaturesExt;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 RectangularLines;
	public VkBool32 BresenhamLines;
	public VkBool32 SmoothLines;
	public VkBool32 StippledRectangularLines;
	public VkBool32 StippledBresenhamLines;
	public VkBool32 StippledSmoothLines;

	public VkPhysicalDeviceLineRasterizationFeaturesEXT(
		VkBool32 rectangularLines = default,
		VkBool32 bresenhamLines = default,
		VkBool32 smoothLines = default,
		VkBool32 stippledRectangularLines = default,
		VkBool32 stippledBresenhamLines = default,
		VkBool32 stippledSmoothLines = default
	) {
		sType = TYPE;
		pNext = null;
		RectangularLines = rectangularLines;
		BresenhamLines = bresenhamLines;
		SmoothLines = smoothLines;
		StippledRectangularLines = stippledRectangularLines;
		StippledBresenhamLines = stippledBresenhamLines;
		StippledSmoothLines = stippledSmoothLines;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceLineRasterizationFeaturesEXT s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceLineRasterizationFeaturesEXT>.Equals(VkPhysicalDeviceLineRasterizationFeaturesEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ RectangularLines.GetHashCode() ^ BresenhamLines.GetHashCode()
			^ SmoothLines.GetHashCode() ^ StippledRectangularLines.GetHashCode() ^ StippledBresenhamLines.GetHashCode() ^ StippledSmoothLines.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceLineRasterizationFeaturesEXT l, in VkPhysicalDeviceLineRasterizationFeaturesEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.RectangularLines == r.RectangularLines) && (l.BresenhamLines == r.BresenhamLines)
			&& (l.SmoothLines == r.SmoothLines) && (l.StippledRectangularLines == r.StippledRectangularLines) && (l.StippledBresenhamLines == r.StippledBresenhamLines) && (l.StippledSmoothLines == r.StippledSmoothLines)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceLineRasterizationFeaturesEXT l, in VkPhysicalDeviceLineRasterizationFeaturesEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.RectangularLines != r.RectangularLines) || (l.BresenhamLines != r.BresenhamLines)
			|| (l.SmoothLines != r.SmoothLines) || (l.StippledRectangularLines != r.StippledRectangularLines) || (l.StippledBresenhamLines != r.StippledBresenhamLines) || (l.StippledSmoothLines != r.StippledSmoothLines)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceLineRasterizationFeaturesEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceLineRasterizationPropertiesEXT : IEquatable<VkPhysicalDeviceLineRasterizationPropertiesEXT>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceLineRasterizationPropertiesExt;

	public VkStructureType sType;
	public void* pNext;
	public uint LineSubPixelPrecisionBits;

	public VkPhysicalDeviceLineRasterizationPropertiesEXT(
		uint lineSubPixelPrecisionBits = default
	) {
		sType = TYPE;
		pNext = null;
		LineSubPixelPrecisionBits = lineSubPixelPrecisionBits;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceLineRasterizationPropertiesEXT s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceLineRasterizationPropertiesEXT>.Equals(VkPhysicalDeviceLineRasterizationPropertiesEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ LineSubPixelPrecisionBits.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceLineRasterizationPropertiesEXT l, in VkPhysicalDeviceLineRasterizationPropertiesEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.LineSubPixelPrecisionBits == r.LineSubPixelPrecisionBits)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceLineRasterizationPropertiesEXT l, in VkPhysicalDeviceLineRasterizationPropertiesEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.LineSubPixelPrecisionBits != r.LineSubPixelPrecisionBits)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceLineRasterizationPropertiesEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPipelineRasterizationLineStateCreateInfoEXT : IEquatable<VkPipelineRasterizationLineStateCreateInfoEXT>
{
	public const VkStructureType TYPE = VkStructureType.PipelineRasterizationLineStateCreateInfoExt;

	public VkStructureType sType;
	public void* pNext;
	public VkLineRasterizationModeEXT LineRasterizationMode;
	public VkBool32 StippledLineEnable;
	public uint LineStippleFactor;
	public ushort LineStipplePattern;

	public VkPipelineRasterizationLineStateCreateInfoEXT(
		VkLineRasterizationModeEXT lineRasterizationMode = default,
		VkBool32 stippledLineEnable = default,
		uint lineStippleFactor = default,
		ushort lineStipplePattern = default
	) {
		sType = TYPE;
		pNext = null;
		LineRasterizationMode = lineRasterizationMode;
		StippledLineEnable = stippledLineEnable;
		LineStippleFactor = lineStippleFactor;
		LineStipplePattern = lineStipplePattern;
	}

	public readonly override bool Equals(object? o) => (o is VkPipelineRasterizationLineStateCreateInfoEXT s) && (this == s);
	readonly bool IEquatable<VkPipelineRasterizationLineStateCreateInfoEXT>.Equals(VkPipelineRasterizationLineStateCreateInfoEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ LineRasterizationMode.GetHashCode() ^ StippledLineEnable.GetHashCode()
			^ LineStippleFactor.GetHashCode() ^ LineStipplePattern.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPipelineRasterizationLineStateCreateInfoEXT l, in VkPipelineRasterizationLineStateCreateInfoEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.LineRasterizationMode == r.LineRasterizationMode) && (l.StippledLineEnable == r.StippledLineEnable)
			&& (l.LineStippleFactor == r.LineStippleFactor) && (l.LineStipplePattern == r.LineStipplePattern)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPipelineRasterizationLineStateCreateInfoEXT l, in VkPipelineRasterizationLineStateCreateInfoEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.LineRasterizationMode != r.LineRasterizationMode) || (l.StippledLineEnable != r.StippledLineEnable)
			|| (l.LineStippleFactor != r.LineStippleFactor) || (l.LineStipplePattern != r.LineStipplePattern)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPipelineRasterizationLineStateCreateInfoEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT : IEquatable<VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDevicePipelineCreationCacheControlFeaturesExt;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 PipelineCreationCacheControl;

	public VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT(
		VkBool32 pipelineCreationCacheControl = default
	) {
		sType = TYPE;
		pNext = null;
		PipelineCreationCacheControl = pipelineCreationCacheControl;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT s) && (this == s);
	readonly bool IEquatable<VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT>.Equals(VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ PipelineCreationCacheControl.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT l, in VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.PipelineCreationCacheControl == r.PipelineCreationCacheControl)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT l, in VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.PipelineCreationCacheControl != r.PipelineCreationCacheControl)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceToolPropertiesEXT : IEquatable<VkPhysicalDeviceToolPropertiesEXT>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceToolPropertiesExt;

	public VkStructureType sType;
	public void* pNext;
	public VVK.ExtensionName Name;
	public VVK.ExtensionName Version;
	public VkToolPurposeFlagsEXT Purposes;
	public VVK.Description Description;
	public VVK.ExtensionName Layer;

	public VkPhysicalDeviceToolPropertiesEXT(
		VVK.ExtensionName name = default,
		VVK.ExtensionName version = default,
		VkToolPurposeFlagsEXT purposes = default,
		VVK.Description description = default,
		VVK.ExtensionName layer = default
	) {
		sType = TYPE;
		pNext = null;
		Name = name;
		Version = version;
		Purposes = purposes;
		Description = description;
		Layer = layer;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceToolPropertiesEXT s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceToolPropertiesEXT>.Equals(VkPhysicalDeviceToolPropertiesEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ Name.GetHashCode() ^ Version.GetHashCode()
			^ Purposes.GetHashCode() ^ Description.GetHashCode() ^ Layer.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceToolPropertiesEXT l, in VkPhysicalDeviceToolPropertiesEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.Name == r.Name) && (l.Version == r.Version)
			&& (l.Purposes == r.Purposes) && (l.Description == r.Description) && (l.Layer == r.Layer)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceToolPropertiesEXT l, in VkPhysicalDeviceToolPropertiesEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.Name != r.Name) || (l.Version != r.Version)
			|| (l.Purposes != r.Purposes) || (l.Description != r.Description) || (l.Layer != r.Layer)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceToolPropertiesEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkSamplerCustomBorderColorCreateInfoEXT : IEquatable<VkSamplerCustomBorderColorCreateInfoEXT>
{
	public const VkStructureType TYPE = VkStructureType.SamplerCustomBorderColorCreateInfoExt;

	public VkStructureType sType;
	public void* pNext;
	public VkClearColorValue CustomBorderColor;
	public VkFormat Format;

	public VkSamplerCustomBorderColorCreateInfoEXT(
		VkClearColorValue customBorderColor = default,
		VkFormat format = default
	) {
		sType = TYPE;
		pNext = null;
		CustomBorderColor = customBorderColor;
		Format = format;
	}

	public readonly override bool Equals(object? o) => (o is VkSamplerCustomBorderColorCreateInfoEXT s) && (this == s);
	readonly bool IEquatable<VkSamplerCustomBorderColorCreateInfoEXT>.Equals(VkSamplerCustomBorderColorCreateInfoEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ CustomBorderColor.GetHashCode() ^ Format.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkSamplerCustomBorderColorCreateInfoEXT l, in VkSamplerCustomBorderColorCreateInfoEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.CustomBorderColor == r.CustomBorderColor) && (l.Format == r.Format)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkSamplerCustomBorderColorCreateInfoEXT l, in VkSamplerCustomBorderColorCreateInfoEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.CustomBorderColor != r.CustomBorderColor) || (l.Format != r.Format)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkSamplerCustomBorderColorCreateInfoEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceCustomBorderColorPropertiesEXT : IEquatable<VkPhysicalDeviceCustomBorderColorPropertiesEXT>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceCustomBorderColorPropertiesExt;

	public VkStructureType sType;
	public void* pNext;
	public uint MaxCustomBorderColorSamplers;

	public VkPhysicalDeviceCustomBorderColorPropertiesEXT(
		uint maxCustomBorderColorSamplers = default
	) {
		sType = TYPE;
		pNext = null;
		MaxCustomBorderColorSamplers = maxCustomBorderColorSamplers;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceCustomBorderColorPropertiesEXT s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceCustomBorderColorPropertiesEXT>.Equals(VkPhysicalDeviceCustomBorderColorPropertiesEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ MaxCustomBorderColorSamplers.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceCustomBorderColorPropertiesEXT l, in VkPhysicalDeviceCustomBorderColorPropertiesEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.MaxCustomBorderColorSamplers == r.MaxCustomBorderColorSamplers)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceCustomBorderColorPropertiesEXT l, in VkPhysicalDeviceCustomBorderColorPropertiesEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.MaxCustomBorderColorSamplers != r.MaxCustomBorderColorSamplers)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceCustomBorderColorPropertiesEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceCustomBorderColorFeaturesEXT : IEquatable<VkPhysicalDeviceCustomBorderColorFeaturesEXT>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceCustomBorderColorFeaturesExt;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 CustomBorderColors;
	public VkBool32 CustomBorderColorWithoutFormat;

	public VkPhysicalDeviceCustomBorderColorFeaturesEXT(
		VkBool32 customBorderColors = default,
		VkBool32 customBorderColorWithoutFormat = default
	) {
		sType = TYPE;
		pNext = null;
		CustomBorderColors = customBorderColors;
		CustomBorderColorWithoutFormat = customBorderColorWithoutFormat;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceCustomBorderColorFeaturesEXT s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceCustomBorderColorFeaturesEXT>.Equals(VkPhysicalDeviceCustomBorderColorFeaturesEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ CustomBorderColors.GetHashCode() ^ CustomBorderColorWithoutFormat.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceCustomBorderColorFeaturesEXT l, in VkPhysicalDeviceCustomBorderColorFeaturesEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.CustomBorderColors == r.CustomBorderColors) && (l.CustomBorderColorWithoutFormat == r.CustomBorderColorWithoutFormat)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceCustomBorderColorFeaturesEXT l, in VkPhysicalDeviceCustomBorderColorFeaturesEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.CustomBorderColors != r.CustomBorderColors) || (l.CustomBorderColorWithoutFormat != r.CustomBorderColorWithoutFormat)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceCustomBorderColorFeaturesEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceExtendedDynamicStateFeaturesEXT : IEquatable<VkPhysicalDeviceExtendedDynamicStateFeaturesEXT>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceExtendedDynamicStateFeaturesExt;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 ExtendedDynamicState;

	public VkPhysicalDeviceExtendedDynamicStateFeaturesEXT(
		VkBool32 extendedDynamicState = default
	) {
		sType = TYPE;
		pNext = null;
		ExtendedDynamicState = extendedDynamicState;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceExtendedDynamicStateFeaturesEXT s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceExtendedDynamicStateFeaturesEXT>.Equals(VkPhysicalDeviceExtendedDynamicStateFeaturesEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ExtendedDynamicState.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceExtendedDynamicStateFeaturesEXT l, in VkPhysicalDeviceExtendedDynamicStateFeaturesEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ExtendedDynamicState == r.ExtendedDynamicState)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceExtendedDynamicStateFeaturesEXT l, in VkPhysicalDeviceExtendedDynamicStateFeaturesEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ExtendedDynamicState != r.ExtendedDynamicState)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceExtendedDynamicStateFeaturesEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceRobustness2FeaturesEXT : IEquatable<VkPhysicalDeviceRobustness2FeaturesEXT>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceRobustness2FeaturesExt;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 RobustBufferAccess2;
	public VkBool32 RobustImageAccess2;
	public VkBool32 NullDescriptor;

	public VkPhysicalDeviceRobustness2FeaturesEXT(
		VkBool32 robustBufferAccess2 = default,
		VkBool32 robustImageAccess2 = default,
		VkBool32 nullDescriptor = default
	) {
		sType = TYPE;
		pNext = null;
		RobustBufferAccess2 = robustBufferAccess2;
		RobustImageAccess2 = robustImageAccess2;
		NullDescriptor = nullDescriptor;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceRobustness2FeaturesEXT s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceRobustness2FeaturesEXT>.Equals(VkPhysicalDeviceRobustness2FeaturesEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ RobustBufferAccess2.GetHashCode() ^ RobustImageAccess2.GetHashCode()
			^ NullDescriptor.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceRobustness2FeaturesEXT l, in VkPhysicalDeviceRobustness2FeaturesEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.RobustBufferAccess2 == r.RobustBufferAccess2) && (l.RobustImageAccess2 == r.RobustImageAccess2)
			&& (l.NullDescriptor == r.NullDescriptor)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceRobustness2FeaturesEXT l, in VkPhysicalDeviceRobustness2FeaturesEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.RobustBufferAccess2 != r.RobustBufferAccess2) || (l.RobustImageAccess2 != r.RobustImageAccess2)
			|| (l.NullDescriptor != r.NullDescriptor)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceRobustness2FeaturesEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceRobustness2PropertiesEXT : IEquatable<VkPhysicalDeviceRobustness2PropertiesEXT>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceRobustness2PropertiesExt;

	public VkStructureType sType;
	public void* pNext;
	public ulong RobustStorageBufferAccessSizeAlignment;
	public ulong RobustUniformBufferAccessSizeAlignment;

	public VkPhysicalDeviceRobustness2PropertiesEXT(
		ulong robustStorageBufferAccessSizeAlignment = default,
		ulong robustUniformBufferAccessSizeAlignment = default
	) {
		sType = TYPE;
		pNext = null;
		RobustStorageBufferAccessSizeAlignment = robustStorageBufferAccessSizeAlignment;
		RobustUniformBufferAccessSizeAlignment = robustUniformBufferAccessSizeAlignment;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceRobustness2PropertiesEXT s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceRobustness2PropertiesEXT>.Equals(VkPhysicalDeviceRobustness2PropertiesEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ RobustStorageBufferAccessSizeAlignment.GetHashCode() ^ RobustUniformBufferAccessSizeAlignment.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceRobustness2PropertiesEXT l, in VkPhysicalDeviceRobustness2PropertiesEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.RobustStorageBufferAccessSizeAlignment == r.RobustStorageBufferAccessSizeAlignment) && (l.RobustUniformBufferAccessSizeAlignment == r.RobustUniformBufferAccessSizeAlignment)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceRobustness2PropertiesEXT l, in VkPhysicalDeviceRobustness2PropertiesEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.RobustStorageBufferAccessSizeAlignment != r.RobustStorageBufferAccessSizeAlignment) || (l.RobustUniformBufferAccessSizeAlignment != r.RobustUniformBufferAccessSizeAlignment)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceRobustness2PropertiesEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceImageRobustnessFeaturesEXT : IEquatable<VkPhysicalDeviceImageRobustnessFeaturesEXT>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceImageRobustnessFeaturesExt;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 RobustImageAccess;

	public VkPhysicalDeviceImageRobustnessFeaturesEXT(
		VkBool32 robustImageAccess = default
	) {
		sType = TYPE;
		pNext = null;
		RobustImageAccess = robustImageAccess;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceImageRobustnessFeaturesEXT s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceImageRobustnessFeaturesEXT>.Equals(VkPhysicalDeviceImageRobustnessFeaturesEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ RobustImageAccess.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceImageRobustnessFeaturesEXT l, in VkPhysicalDeviceImageRobustnessFeaturesEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.RobustImageAccess == r.RobustImageAccess)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceImageRobustnessFeaturesEXT l, in VkPhysicalDeviceImageRobustnessFeaturesEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.RobustImageAccess != r.RobustImageAccess)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceImageRobustnessFeaturesEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDevice4444FormatsFeaturesEXT : IEquatable<VkPhysicalDevice4444FormatsFeaturesEXT>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDevice4444FormatsFeaturesExt;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 FormatA4R4G4B4;
	public VkBool32 FormatA4B4G4R4;

	public VkPhysicalDevice4444FormatsFeaturesEXT(
		VkBool32 formatA4R4G4B4 = default,
		VkBool32 formatA4B4G4R4 = default
	) {
		sType = TYPE;
		pNext = null;
		FormatA4R4G4B4 = formatA4R4G4B4;
		FormatA4B4G4R4 = formatA4B4G4R4;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDevice4444FormatsFeaturesEXT s) && (this == s);
	readonly bool IEquatable<VkPhysicalDevice4444FormatsFeaturesEXT>.Equals(VkPhysicalDevice4444FormatsFeaturesEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ FormatA4R4G4B4.GetHashCode() ^ FormatA4B4G4R4.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDevice4444FormatsFeaturesEXT l, in VkPhysicalDevice4444FormatsFeaturesEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.FormatA4R4G4B4 == r.FormatA4R4G4B4) && (l.FormatA4B4G4R4 == r.FormatA4B4G4R4)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDevice4444FormatsFeaturesEXT l, in VkPhysicalDevice4444FormatsFeaturesEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.FormatA4R4G4B4 != r.FormatA4R4G4B4) || (l.FormatA4B4G4R4 != r.FormatA4B4G4R4)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDevice4444FormatsFeaturesEXT s) => s = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT : IEquatable<VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT>
{
	public const VkStructureType TYPE = VkStructureType.PhysicalDeviceShaderImageAtomicInt64FeaturesExt;

	public VkStructureType sType;
	public void* pNext;
	public VkBool32 ShaderImageInt64Atomics;
	public VkBool32 SparseImageInt64Atomics;

	public VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT(
		VkBool32 shaderImageInt64Atomics = default,
		VkBool32 sparseImageInt64Atomics = default
	) {
		sType = TYPE;
		pNext = null;
		ShaderImageInt64Atomics = shaderImageInt64Atomics;
		SparseImageInt64Atomics = sparseImageInt64Atomics;
	}

	public readonly override bool Equals(object? o) => (o is VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT s) && (this == s);
	readonly bool IEquatable<VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT>.Equals(VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT o) => o == this;

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ShaderImageInt64Atomics.GetHashCode() ^ SparseImageInt64Atomics.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT l, in VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ShaderImageInt64Atomics == r.ShaderImageInt64Atomics) && (l.SparseImageInt64Atomics == r.SparseImageInt64Atomics)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT l, in VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ShaderImageInt64Atomics != r.ShaderImageInt64Atomics) || (l.SparseImageInt64Atomics != r.SparseImageInt64Atomics)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT s) => s = new() { sType = TYPE };
}


} // namespace Vulkan

