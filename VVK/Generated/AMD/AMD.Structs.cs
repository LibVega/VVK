/*
 * MIT License - Copyright(c) 2020 Sean Moss
 * This file is subject to the terms and conditions of the MIT License, the text of which can be found in the 'LICENSE'
 * file at the root of this repository, or online at<https://opensource.org/licenses/MIT>.
 */

/// This file was generated by VVKGen. Edits to this file will be lost on next generation.

using System;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;


namespace Vk.AMD
{

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PipelineRasterizationStateRasterizationOrder : IEquatable<PipelineRasterizationStateRasterizationOrder>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PipelineRasterizationStateRasterizationOrderAMD;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.AMD.RasterizationOrder RasterizationOrder;

	public readonly override bool Equals(object? obj) => (obj is PipelineRasterizationStateRasterizationOrder o) && (this == o);
	readonly bool IEquatable<PipelineRasterizationStateRasterizationOrder>.Equals(PipelineRasterizationStateRasterizationOrder obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ RasterizationOrder.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PipelineRasterizationStateRasterizationOrder l, in PipelineRasterizationStateRasterizationOrder r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.RasterizationOrder == r.RasterizationOrder)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PipelineRasterizationStateRasterizationOrder l, in PipelineRasterizationStateRasterizationOrder r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.RasterizationOrder != r.RasterizationOrder)
			;
	}


	/// <summary>Creates a new PipelineRasterizationStateRasterizationOrder value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PipelineRasterizationStateRasterizationOrder value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DisplayNativeHdrSurfaceCapabilities : IEquatable<DisplayNativeHdrSurfaceCapabilities>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DisplayNativeHdrSurfaceCapabilitiesAMD;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 LocalDimmingSupport;

	public readonly override bool Equals(object? obj) => (obj is DisplayNativeHdrSurfaceCapabilities o) && (this == o);
	readonly bool IEquatable<DisplayNativeHdrSurfaceCapabilities>.Equals(DisplayNativeHdrSurfaceCapabilities obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ LocalDimmingSupport.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DisplayNativeHdrSurfaceCapabilities l, in DisplayNativeHdrSurfaceCapabilities r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.LocalDimmingSupport == r.LocalDimmingSupport)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DisplayNativeHdrSurfaceCapabilities l, in DisplayNativeHdrSurfaceCapabilities r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.LocalDimmingSupport != r.LocalDimmingSupport)
			;
	}


	/// <summary>Creates a new DisplayNativeHdrSurfaceCapabilities value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DisplayNativeHdrSurfaceCapabilities value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct SwapchainDisplayNativeHdrCreateInfo : IEquatable<SwapchainDisplayNativeHdrCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.SwapchainDisplayNativeHdrCreateInfoAMD;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 LocalDimmingEnable;

	public readonly override bool Equals(object? obj) => (obj is SwapchainDisplayNativeHdrCreateInfo o) && (this == o);
	readonly bool IEquatable<SwapchainDisplayNativeHdrCreateInfo>.Equals(SwapchainDisplayNativeHdrCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ LocalDimmingEnable.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in SwapchainDisplayNativeHdrCreateInfo l, in SwapchainDisplayNativeHdrCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.LocalDimmingEnable == r.LocalDimmingEnable)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in SwapchainDisplayNativeHdrCreateInfo l, in SwapchainDisplayNativeHdrCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.LocalDimmingEnable != r.LocalDimmingEnable)
			;
	}


	/// <summary>Creates a new SwapchainDisplayNativeHdrCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out SwapchainDisplayNativeHdrCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct TextureLODGatherFormatProperties : IEquatable<TextureLODGatherFormatProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.TextureLodGatherFormatPropertiesAMD;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 SupportsTextureGatherLODBiasAMD;

	public readonly override bool Equals(object? obj) => (obj is TextureLODGatherFormatProperties o) && (this == o);
	readonly bool IEquatable<TextureLODGatherFormatProperties>.Equals(TextureLODGatherFormatProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ SupportsTextureGatherLODBiasAMD.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in TextureLODGatherFormatProperties l, in TextureLODGatherFormatProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.SupportsTextureGatherLODBiasAMD == r.SupportsTextureGatherLODBiasAMD)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in TextureLODGatherFormatProperties l, in TextureLODGatherFormatProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.SupportsTextureGatherLODBiasAMD != r.SupportsTextureGatherLODBiasAMD)
			;
	}


	/// <summary>Creates a new TextureLODGatherFormatProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out TextureLODGatherFormatProperties value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ShaderResourceUsage : IEquatable<ShaderResourceUsage>
{
	public uint NumUsedVgprs;
	public uint NumUsedSgprs;
	public uint LdsSizePerLocalWorkGroup;
	public ulong LdsUsageSizeInBytes;
	public ulong ScratchMemUsageInBytes;

	public readonly override bool Equals(object? obj) => (obj is ShaderResourceUsage o) && (this == o);
	readonly bool IEquatable<ShaderResourceUsage>.Equals(ShaderResourceUsage obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			NumUsedVgprs.GetHashCode() ^ NumUsedSgprs.GetHashCode() ^ LdsSizePerLocalWorkGroup.GetHashCode() ^ LdsUsageSizeInBytes.GetHashCode()
			^ ScratchMemUsageInBytes.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ShaderResourceUsage l, in ShaderResourceUsage r)
	{
		return
			(l.NumUsedVgprs == r.NumUsedVgprs) && (l.NumUsedSgprs == r.NumUsedSgprs) && (l.LdsSizePerLocalWorkGroup == r.LdsSizePerLocalWorkGroup) && (l.LdsUsageSizeInBytes == r.LdsUsageSizeInBytes)
			&& (l.ScratchMemUsageInBytes == r.ScratchMemUsageInBytes)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ShaderResourceUsage l, in ShaderResourceUsage r)
	{
		return
			(l.NumUsedVgprs != r.NumUsedVgprs) || (l.NumUsedSgprs != r.NumUsedSgprs) || (l.LdsSizePerLocalWorkGroup != r.LdsSizePerLocalWorkGroup) || (l.LdsUsageSizeInBytes != r.LdsUsageSizeInBytes)
			|| (l.ScratchMemUsageInBytes != r.ScratchMemUsageInBytes)
			;
	}


	/// <summary>Creates a new ShaderResourceUsage value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ShaderResourceUsage value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct ShaderStatisticsInfo : IEquatable<ShaderStatisticsInfo>
{
	public Vk.ShaderStageFlags ShaderStageMask;
	public Vk.AMD.ShaderResourceUsage ResourceUsage;
	public uint NumPhysicalVgprs;
	public uint NumPhysicalSgprs;
	public uint NumAvailableVgprs;
	public uint NumAvailableSgprs;
	public fixed uint ComputeWorkGroupSize[3];

	public readonly override bool Equals(object? obj) => (obj is ShaderStatisticsInfo o) && (this == o);
	readonly bool IEquatable<ShaderStatisticsInfo>.Equals(ShaderStatisticsInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			ShaderStageMask.GetHashCode() ^ ResourceUsage.GetHashCode() ^ NumPhysicalVgprs.GetHashCode() ^ NumPhysicalSgprs.GetHashCode()
			^ NumAvailableVgprs.GetHashCode() ^ NumAvailableSgprs.GetHashCode() ^ ComputeWorkGroupSize[0].GetHashCode() ^ ComputeWorkGroupSize[1].GetHashCode()
			^ ComputeWorkGroupSize[2].GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in ShaderStatisticsInfo l, in ShaderStatisticsInfo r)
	{
		return
			(l.ShaderStageMask == r.ShaderStageMask) && (l.ResourceUsage == r.ResourceUsage) && (l.NumPhysicalVgprs == r.NumPhysicalVgprs) && (l.NumPhysicalSgprs == r.NumPhysicalSgprs)
			&& (l.NumAvailableVgprs == r.NumAvailableVgprs) && (l.NumAvailableSgprs == r.NumAvailableSgprs) && (l.ComputeWorkGroupSize[0] == r.ComputeWorkGroupSize[0]) && (l.ComputeWorkGroupSize[1] == r.ComputeWorkGroupSize[1])
			&& (l.ComputeWorkGroupSize[2] == r.ComputeWorkGroupSize[2])
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in ShaderStatisticsInfo l, in ShaderStatisticsInfo r)
	{
		return
			(l.ShaderStageMask != r.ShaderStageMask) || (l.ResourceUsage != r.ResourceUsage) || (l.NumPhysicalVgprs != r.NumPhysicalVgprs) || (l.NumPhysicalSgprs != r.NumPhysicalSgprs)
			|| (l.NumAvailableVgprs != r.NumAvailableVgprs) || (l.NumAvailableSgprs != r.NumAvailableSgprs) || (l.ComputeWorkGroupSize[0] != r.ComputeWorkGroupSize[0]) || (l.ComputeWorkGroupSize[1] != r.ComputeWorkGroupSize[1])
			|| (l.ComputeWorkGroupSize[2] != r.ComputeWorkGroupSize[2])
			;
	}


	/// <summary>Creates a new ShaderStatisticsInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out ShaderStatisticsInfo value) => value = new();
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceShaderCoreProperties : IEquatable<PhysicalDeviceShaderCoreProperties>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceShaderCorePropertiesAMD;

	public Vk.StructureType sType;
	public void* pNext;
	public uint ShaderEngineCount;
	public uint ShaderArraysPerEngineCount;
	public uint ComputeUnitsPerShaderArray;
	public uint SimdPerComputeUnit;
	public uint WavefrontsPerSimd;
	public uint WavefrontSize;
	public uint SgprsPerSimd;
	public uint MinSgprAllocation;
	public uint MaxSgprAllocation;
	public uint SgprAllocationGranularity;
	public uint VgprsPerSimd;
	public uint MinVgprAllocation;
	public uint MaxVgprAllocation;
	public uint VgprAllocationGranularity;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceShaderCoreProperties o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceShaderCoreProperties>.Equals(PhysicalDeviceShaderCoreProperties obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ShaderEngineCount.GetHashCode() ^ ShaderArraysPerEngineCount.GetHashCode()
			^ ComputeUnitsPerShaderArray.GetHashCode() ^ SimdPerComputeUnit.GetHashCode() ^ WavefrontsPerSimd.GetHashCode() ^ WavefrontSize.GetHashCode()
			^ SgprsPerSimd.GetHashCode() ^ MinSgprAllocation.GetHashCode() ^ MaxSgprAllocation.GetHashCode() ^ SgprAllocationGranularity.GetHashCode()
			^ VgprsPerSimd.GetHashCode() ^ MinVgprAllocation.GetHashCode() ^ MaxVgprAllocation.GetHashCode() ^ VgprAllocationGranularity.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceShaderCoreProperties l, in PhysicalDeviceShaderCoreProperties r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ShaderEngineCount == r.ShaderEngineCount) && (l.ShaderArraysPerEngineCount == r.ShaderArraysPerEngineCount)
			&& (l.ComputeUnitsPerShaderArray == r.ComputeUnitsPerShaderArray) && (l.SimdPerComputeUnit == r.SimdPerComputeUnit) && (l.WavefrontsPerSimd == r.WavefrontsPerSimd) && (l.WavefrontSize == r.WavefrontSize)
			&& (l.SgprsPerSimd == r.SgprsPerSimd) && (l.MinSgprAllocation == r.MinSgprAllocation) && (l.MaxSgprAllocation == r.MaxSgprAllocation) && (l.SgprAllocationGranularity == r.SgprAllocationGranularity)
			&& (l.VgprsPerSimd == r.VgprsPerSimd) && (l.MinVgprAllocation == r.MinVgprAllocation) && (l.MaxVgprAllocation == r.MaxVgprAllocation) && (l.VgprAllocationGranularity == r.VgprAllocationGranularity)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceShaderCoreProperties l, in PhysicalDeviceShaderCoreProperties r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ShaderEngineCount != r.ShaderEngineCount) || (l.ShaderArraysPerEngineCount != r.ShaderArraysPerEngineCount)
			|| (l.ComputeUnitsPerShaderArray != r.ComputeUnitsPerShaderArray) || (l.SimdPerComputeUnit != r.SimdPerComputeUnit) || (l.WavefrontsPerSimd != r.WavefrontsPerSimd) || (l.WavefrontSize != r.WavefrontSize)
			|| (l.SgprsPerSimd != r.SgprsPerSimd) || (l.MinSgprAllocation != r.MinSgprAllocation) || (l.MaxSgprAllocation != r.MaxSgprAllocation) || (l.SgprAllocationGranularity != r.SgprAllocationGranularity)
			|| (l.VgprsPerSimd != r.VgprsPerSimd) || (l.MinVgprAllocation != r.MinVgprAllocation) || (l.MaxVgprAllocation != r.MaxVgprAllocation) || (l.VgprAllocationGranularity != r.VgprAllocationGranularity)
			;
	}


	/// <summary>Creates a new PhysicalDeviceShaderCoreProperties value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceShaderCoreProperties value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceShaderCoreProperties2 : IEquatable<PhysicalDeviceShaderCoreProperties2>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceShaderCoreProperties2AMD;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.AMD.ShaderCorePropertiesFlags ShaderCoreFeatures;
	public uint ActiveComputeUnitCount;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceShaderCoreProperties2 o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceShaderCoreProperties2>.Equals(PhysicalDeviceShaderCoreProperties2 obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ ShaderCoreFeatures.GetHashCode() ^ ActiveComputeUnitCount.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceShaderCoreProperties2 l, in PhysicalDeviceShaderCoreProperties2 r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.ShaderCoreFeatures == r.ShaderCoreFeatures) && (l.ActiveComputeUnitCount == r.ActiveComputeUnitCount)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceShaderCoreProperties2 l, in PhysicalDeviceShaderCoreProperties2 r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.ShaderCoreFeatures != r.ShaderCoreFeatures) || (l.ActiveComputeUnitCount != r.ActiveComputeUnitCount)
			;
	}


	/// <summary>Creates a new PhysicalDeviceShaderCoreProperties2 value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceShaderCoreProperties2 value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct DeviceMemoryOverallocationCreateInfo : IEquatable<DeviceMemoryOverallocationCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.DeviceMemoryOverallocationCreateInfoAMD;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.AMD.MemoryOverallocationBehavior OverallocationBehavior;

	public readonly override bool Equals(object? obj) => (obj is DeviceMemoryOverallocationCreateInfo o) && (this == o);
	readonly bool IEquatable<DeviceMemoryOverallocationCreateInfo>.Equals(DeviceMemoryOverallocationCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ OverallocationBehavior.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in DeviceMemoryOverallocationCreateInfo l, in DeviceMemoryOverallocationCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.OverallocationBehavior == r.OverallocationBehavior)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in DeviceMemoryOverallocationCreateInfo l, in DeviceMemoryOverallocationCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.OverallocationBehavior != r.OverallocationBehavior)
			;
	}


	/// <summary>Creates a new DeviceMemoryOverallocationCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out DeviceMemoryOverallocationCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PipelineCompilerControlCreateInfo : IEquatable<PipelineCompilerControlCreateInfo>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PipelineCompilerControlCreateInfoAMD;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.AMD.PipelineCompilerControlFlags CompilerControlFlags;

	public readonly override bool Equals(object? obj) => (obj is PipelineCompilerControlCreateInfo o) && (this == o);
	readonly bool IEquatable<PipelineCompilerControlCreateInfo>.Equals(PipelineCompilerControlCreateInfo obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ CompilerControlFlags.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PipelineCompilerControlCreateInfo l, in PipelineCompilerControlCreateInfo r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.CompilerControlFlags == r.CompilerControlFlags)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PipelineCompilerControlCreateInfo l, in PipelineCompilerControlCreateInfo r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.CompilerControlFlags != r.CompilerControlFlags)
			;
	}


	/// <summary>Creates a new PipelineCompilerControlCreateInfo value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PipelineCompilerControlCreateInfo value) => value = new() { sType = TYPE };
}

[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct PhysicalDeviceCoherentMemoryFeatures : IEquatable<PhysicalDeviceCoherentMemoryFeatures>
{
	public const Vk.StructureType TYPE = Vk.StructureType.PhysicalDeviceCoherentMemoryFeaturesAMD;

	public Vk.StructureType sType;
	public void* pNext;
	public Vk.Bool32 DeviceCoherentMemory;

	public readonly override bool Equals(object? obj) => (obj is PhysicalDeviceCoherentMemoryFeatures o) && (this == o);
	readonly bool IEquatable<PhysicalDeviceCoherentMemoryFeatures>.Equals(PhysicalDeviceCoherentMemoryFeatures obj) => (this == obj);
	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public readonly override int GetHashCode()
	{
		return
			sType.GetHashCode() ^ ((ulong)pNext).GetHashCode() ^ DeviceCoherentMemory.GetHashCode()
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator == (in PhysicalDeviceCoherentMemoryFeatures l, in PhysicalDeviceCoherentMemoryFeatures r)
	{
		return
			(l.sType == r.sType) && (l.pNext == r.pNext) && (l.DeviceCoherentMemory == r.DeviceCoherentMemory)
			;
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static bool operator != (in PhysicalDeviceCoherentMemoryFeatures l, in PhysicalDeviceCoherentMemoryFeatures r)
	{
		return
			(l.sType != r.sType) || (l.pNext != r.pNext) || (l.DeviceCoherentMemory != r.DeviceCoherentMemory)
			;
	}


	/// <summary>Creates a new PhysicalDeviceCoherentMemoryFeatures value with the correct default fields.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void New(out PhysicalDeviceCoherentMemoryFeatures value) => value = new() { sType = TYPE };
}

} // namespace Vk.AMD
