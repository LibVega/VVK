/*
 * MIT License - Copyright (c) 2020 Sean Moss
 * This file is subject to the terms and conditions of the MIT License, the text of which can be found in the 'LICENSE'
 * file at the root of this repository, or online at <https://opensource.org/licenses/MIT>.
 */

using System;
using System.IO;
using System.Text;

namespace Gen
{
	// Represents the context and file handle for a C# source file being generated
	public sealed class SourceFile : IDisposable
	{
		#region Fields
		// The path of the file within the generated output directory
		public readonly string RelativePath;
		// The full path to the file, with the output directory
		public string FullPath => Path.Combine(ArgParse.OutputPath, RelativePath);

		// The file namespace
		public readonly string Namespace;

		// The current block depth
		public uint BlockDepth { get; private set; } = 0;
		private string _indentString = "";

		// The file handle
		private readonly StreamWriter _file;
		#endregion // Fields

		public SourceFile(string path, string @namespace)
		{
			RelativePath = path;
			Namespace = @namespace;
			_file = new StreamWriter(File.OpenWrite(FullPath), Encoding.UTF8, leaveOpen: false);

			_file.WriteLine(STANDARD_HEADER);
			_file.WriteLine($"namespace {@namespace}\n{{\n");
		}

		public void WriteLine(string line)
		{
			_file.Write(_indentString);
			_file.WriteLine(line);
		}

		public void WriteLine() => _file.WriteLine();

		// Only call when there are no active blocks
		public SourceBlock PushBlock(string? header)
		{
			if (BlockDepth != 0) {
				throw new InvalidOperationException("A block is already active in the source file");
			}

			if (header is not null) {
				_file.WriteLine(header);
			}
			_file.WriteLine("{");

			BlockDepth = 1;
			_indentString = "\t";
			return new(this);
		}

		// Only call this from SourceBlock
		public void PushBlock(uint depth)
		{
			if (depth != BlockDepth) {
				throw new InvalidOperationException("Cannot push a new source block at the current depth");
			}

			BlockDepth += 1;
			_indentString = new string('\t', (int)BlockDepth);
		}

		// Only call this from SourceBlock
		public void PopBlock(uint depth)
		{
			if (BlockDepth != depth) {
				throw new InvalidOperationException("Mismatch in block depth of popped block");
			}

			BlockDepth -= 1;
			_indentString = new string('\t', (int)BlockDepth);
			_file.WriteLine("}\n");
		}

		#region IDisposable
		public void Dispose()
		{
			if (BlockDepth != 0) {
				throw new InvalidOperationException("Disposed of file without disposing of source blocks");
			}

			_file.WriteLine($"}} // namespace {Namespace}");
			_file.Flush();
			_file.Close();
			_file.Dispose();
		}
		#endregion // IDisposable

		private static readonly string STANDARD_HEADER =
			"/*\n" +
			" * MIT License - Copyright(c) 2020 Sean Moss\n" +
			" * This file is subject to the terms and conditions of the MIT License, the text of which can be found in the 'LICENSE'\n" +
			" * file at the root of this repository, or online at<https://opensource.org/licenses/MIT>.\n" +
			" */\n" +
			"\n" +
			"/// This file was generated by VVKGen. Edits to this file will be lost on next generation.\n" +
			"\n" +
			"using System;\n" +
			"using System.Runtime.InteropServices;\n" +
			"\n";
	}
}
